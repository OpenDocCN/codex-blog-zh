<html>
<head>
<title>Algorithmic Trading with Relative Strength Index in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的相对强弱指数算法交易</h1>
<blockquote>原文：<a href="https://medium.com/codex/algorithmic-trading-with-relative-strength-index-in-python-d969cf22dd85?source=collection_archive---------0-----------------------#2021-05-13">https://medium.com/codex/algorithmic-trading-with-relative-strength-index-in-python-d969cf22dd85?source=collection_archive---------0-----------------------#2021-05-13</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/965a5d4197f4dc40044accd0e3e24d33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OPixX8ee2JSrsRVnz9R3DA.jpeg"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx translated"><a class="ae hv" href="https://wallpapercave.com/stock-exchange-wallpapers" rel="noopener ugc nofollow" target="_blank">来源</a></figcaption></figure><div class=""/><div class=""><h2 id="4c80" class="pw-subtitle-paragraph iv hx hy bd b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm dx translated">学习使用python中最流行的交易指标进行更好的交易</h2></div><p id="9690" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">虽然还有其他的动量振荡指标，比如随机振荡指标和超棒振荡指标，但是我们今天讨论的这个被认为是交易者中最受欢迎的，也是新手交易者的最佳选择。这就是相对强弱指数，简称RSI。在本文中，我们将建立一些关于RSI及其计算的基本直觉，然后，我们将从头开始创建这个指标，并在python中基于它建立一个交易策略。事不宜迟，让我们进入文章。</p><p id="a7a7" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">在继续之前，如果你想在没有任何代码的情况下回溯测试你的交易策略，有一个解决方案。这是<a class="ae hv" href="https://www.backtestzone.com/" rel="noopener ugc nofollow" target="_blank">回测区</a>。这是一个平台，可以免费对不同类型的可交易资产的任意数量的交易策略进行回溯测试，无需编码。点击这里的链接，你可以马上使用这个工具:【https://www.backtestzone.com/ T4】</p><h1 id="5332" class="kj kk hy bd kl km kn ko kp kq kr ks kt je ku jf kv jh kw ji kx jk ky jl kz la bi translated">相对强度指数</h1><p id="b231" class="pw-post-body-paragraph jn jo hy jp b jq lb iz js jt lc jc jv jw ld jy jz ka le kc kd ke lf kg kh ki hb bi translated">在继续之前，让我们先了解一下在股票交易领域，振荡指标意味着什么。振荡指标是一种技术工具，它构建了一个基于趋势的指标，其值介于高波段和低波段之间。交易者使用这些波段和构建的基于趋势的指标来识别市场状态，进行潜在的买卖交易。同样，振荡指标被广泛用于短期交易，但是在长期投资中没有限制。</p><p id="1680" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">由J. Welles Wilder于1978年创立和发展的相对强度指数是一种动量振荡器，交易者使用它来识别市场是处于超买还是超卖的状态。在继续之前，我们先来探讨一下什么是超买和超卖。当一种资产不断被交易者买入，推动其走向极度看涨的趋势，并注定要盘整时，市场被认为处于超买状态。类似地，当交易者不断卖出某项资产，将其推向熊市趋势并趋于反弹时，市场被视为处于超卖状态。</p><p id="47f1" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">作为一个振荡器，RSI的值在0到100之间。使用相对强度指数评估市场状态的传统方法是，RSI读数为70或以上表明超买状态，类似地，RSI读数为30或以下表示市场处于超卖状态。这些超买和超卖也可以根据你选择的股票或资产来调整。例如，一些资产可能具有80和20的恒定RSI读数。所以在这种情况下，你可以将超买和超卖水平分别设为80和20。RSI的标准设定是14作为回望期。</p><p id="4ead" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">就价值解释而言，RSI听起来可能更类似于随机振荡器，但它的计算方式却大不相同。RSI的计算包括三个步骤。</p><ul class=""><li id="9660" class="lg lh hy jp b jq jr jt ju jw li ka lj ke lk ki ll lm ln lo bi translated"><strong class="jp hz">计算资产损益的指数移动平均线(EMA):</strong>关于指数移动平均线的一句话。EMA是一种移动平均线(MA ),它自动为最近的数据点分配较大的权重(除了重要性之外),而为遥远过去的数据点分配较小的权重。在这一步，我们将首先计算资产的回报，并将收益与损失分开。使用这些分开的值，可以计算指定数量的期间的两个EMA。</li><li id="5085" class="lg lh hy jp b jq lp jt lq jw lr ka ls ke lt ki ll lm ln lo bi translated"><strong class="jp hz">计算资产的相对实力:</strong>资产的相对实力是通过将资产的收益的指数移动平均值除以资产的损失的指数移动平均值来确定的。它可以用数学方法表示如下:</li></ul><pre class="lu lv lw lx fd ly lz ma mb aw mc bi"><span id="bd29" class="md kk hy lz b fi me mf l mg mh"><strong class="lz hz">RS = GAIN EMA / LOSS EMA</strong></span><span id="01d9" class="md kk hy lz b fi mi mf l mg mh">where,<br/>RS = Relative Strength<br/>GAIN EMA = Exponential Moving Average of the gains<br/>LOSS EMA = Exponential Moving Average of the losses</span></pre><ul class=""><li id="da3c" class="lg lh hy jp b jq jr jt ju jw li ka lj ke lk ki ll lm ln lo bi translated"><strong class="jp hz">计算RSI值:</strong>在这一步，我们将利用上一步计算的相对强度值来计算RSI本身。要计算给定资产在指定时间段内的RSI值，我们需要遵循一个公式:</li></ul><pre class="lu lv lw lx fd ly lz ma mb aw mc bi"><span id="665c" class="md kk hy lz b fi me mf l mg mh"><strong class="lz hz">RSI = 100.0 - (100.0 / (1.0 + RS))</strong></span><span id="3c6f" class="md kk hy lz b fi mi mf l mg mh">where,<br/>RSI = Relative Strength Index<br/>RS = Relative Strength</span></pre><p id="a62a" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">现在我们对什么是相对实力指数以及它是如何计算的有了一些基本的了解。让我们对RSI交易策略建立一些直觉。</p><p id="d4e7" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><strong class="jp hz">关于我们的RSI交易策略:</strong>在本文中，我们将实施一个简单的交叉策略，传统设置30和70分别作为超卖和超买水平，14作为回望期。我们的策略是，只要前一个RSI值高于超卖水平，当前RSI值低于超卖水平，我们就发出买入信号。同样地，当先前的RSI值低于超卖水平，当前的RSI值高于超卖水平时，该策略会显示卖出信号。我们的交易策略可以表述如下:</p><pre class="lu lv lw lx fd ly lz ma mb aw mc bi"><span id="7274" class="md kk hy lz b fi me mf l mg mh">IF <strong class="lz hz">PREVIOUS RSI &gt; 30</strong> AND <strong class="lz hz">CURRENT RSI &lt; 30</strong> ==&gt; <strong class="lz hz">BUY SIGNAL</strong><br/>IF <strong class="lz hz">PREVIOUS RSI &lt; 70</strong> AND <strong class="lz hz">CURRENT RSI &gt; 70</strong> ==&gt; <strong class="lz hz">SELL SIGNAL</strong></span></pre><p id="89d3" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">这就结束了我们关于相对强弱指数和交易策略的理论部分。现在让我们用python编写交易策略代码，看看一些令人兴奋的结果。在继续之前，关于免责声明的一个注意事项:本文的唯一目的是教育人们，必须被视为一个信息，而不是投资建议等。</p><h1 id="7e12" class="kj kk hy bd kl km kn ko kp kq kr ks kt je ku jf kv jh kw ji kx jk ky jl kz la bi translated">用Python实现</h1><p id="62b0" class="pw-post-body-paragraph jn jo hy jp b jq lb iz js jt lc jc jv jw ld jy jz ka le kc kd ke lf kg kh ki hb bi translated">编码部分分为以下几个步骤:</p><pre class="lu lv lw lx fd ly lz ma mb aw mc bi"><span id="4970" class="md kk hy lz b fi me mf l mg mh"><strong class="lz hz">1. Importing Packages<br/>2. Extracting Data from Alpha Vantage<br/>3. RSI calculation<br/>4. RSI Plot<br/>5. Creating the Trading Strategy<br/>6. Plotting the Trading Lists<br/>7. Creating our Position<br/>8. Backtesting</strong></span></pre><p id="9f91" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">我们将按照上面列表中提到的顺序，系好安全带，跟随每一个即将到来的编码部分。</p><h2 id="2c22" class="md kk hy bd kl mj mk ml kp mm mn mo kt jw mp mq kv ka mr ms kx ke mt mu kz mv bi translated">步骤1:导入包</h2><p id="067a" class="pw-post-body-paragraph jn jo hy jp b jq lb iz js jt lc jc jv jw ld jy jz ka le kc kd ke lf kg kh ki hb bi translated">将所需的包导入python环境是一个不可跳过的步骤。主要的包是处理数据的Pandas，处理数组和复杂函数的NumPy，用于绘图的Matplotlib，以及进行API调用的请求。二级包是数学函数的Math和字体定制的Termcolor(可选)。</p><p id="65a2" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><strong class="jp hz"> Python实现:</strong></p><pre class="lu lv lw lx fd ly lz ma mb aw mc bi"><span id="5707" class="md kk hy lz b fi me mf l mg mh">import pandas as pd <br/>import matplotlib.pyplot as plt<br/>import requests<br/>import numpy as np<br/>from math import floor<br/>from termcolor import colored as cl <br/><br/>plt.style.use('fivethirtyeight')<br/>plt.rcParams['figure.figsize'] = (20, 10)</span></pre><p id="ecb1" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">既然我们已经将所有基本的包导入到python环境中。让我们继续用Alpha Vantage强大的股票API提取IBM的历史数据。</p><h2 id="30cf" class="md kk hy bd kl mj mk ml kp mm mn mo kt jw mp mq kv ka mr ms kx ke mt mu kz mv bi translated">步骤2:从Alpha Vantage中提取数据</h2><p id="0b91" class="pw-post-body-paragraph jn jo hy jp b jq lb iz js jt lc jc jv jw ld jy jz ka le kc kd ke lf kg kh ki hb bi translated">在这一步，我们将使用Alpha Vantage提供的API端点提取IBM的历史数据。在此之前，关于Alpha Vantage的一个说明:Alpha Vantage提供免费的股票API，用户可以通过这些API访问各种数据，如实时更新，以及股票、货币和加密货币的历史数据。确保你在Alpha Vantage上有一个帐户，只有这样，你才能访问你的秘密API密匙(使用API提取数据的一个关键元素)。</p><p id="f493" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><strong class="jp hz"> Python实现:</strong></p><pre class="lu lv lw lx fd ly lz ma mb aw mc bi"><span id="1970" class="md kk hy lz b fi me mf l mg mh">def get_historical_data(symbol, start_date = None):<br/>    api_key = open(r'api_key.txt')<br/>    api_url = f'https://www.alphavantage.co/query?function=TIME_SERIES_DAILY_ADJUSTED&amp;symbol={symbol}&amp;apikey={api_key}&amp;outputsize=full'<br/>    raw_df = requests.get(api_url).json()<br/>    df = pd.DataFrame(raw_df[f'Time Series (Daily)']).T<br/>    df = df.rename(columns = {'1. open': 'open', '2. high': 'high', '3. low': 'low', '4. close': 'close', '5. adjusted close': 'adj close', '6. volume': 'volume'})<br/>    for i in df.columns:<br/>        df[i] = df[i].astype(float)<br/>    df.index = pd.to_datetime(df.index)<br/>    df = df.iloc[::-1].drop(['7. dividend amount', '8. split coefficient'], axis = 1)<br/>    if start_date:<br/>        df = df[df.index &gt;= start_date]<br/>    return df<br/><br/>ibm = get_historical_data('IBM', '2020-01-01')<br/>ibm</span></pre><p id="4d4b" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><strong class="jp hz">输出:</strong></p><figure class="lu lv lw lx fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es mw"><img src="../Images/f16fca49a2ffa698e8515f1217b620d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cqXa4Sh-_1xCTk-pcJXxTQ.png"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">作者图片</figcaption></figure><p id="ccf7" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><strong class="jp hz">代码解释:</strong>我们做的第一件事是定义一个名为‘get _ historical _ data’的函数，该函数将股票的符号(‘symbol’)作为必需参数，将历史数据的开始日期(‘start _ date’)作为可选参数。在函数内部，我们定义了API键和URL，并将它们存储到各自的变量中。接下来，我们使用“get”函数提取JSON格式的历史数据，并将其存储到“raw_df”变量中。在对原始JSON数据进行清理和格式化之后，我们将以干净的Pandas数据帧的形式返回它。最后，我们调用创建的函数来提取ibm从2020年开始的历史数据，并将其存储到“IBM”变量中。</p><h2 id="0b24" class="md kk hy bd kl mj mk ml kp mm mn mo kt jw mp mq kv ka mr ms kx ke mt mu kz mv bi translated">步骤3: RSI计算</h2><p id="7560" class="pw-post-body-paragraph jn jo hy jp b jq lb iz js jt lc jc jv jw ld jy jz ka le kc kd ke lf kg kh ki hb bi translated">在这一步中，我们将使用之前讨论过的RSI公式计算14作为回望期的RSI值。</p><p id="578a" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><strong class="jp hz"> Python实现:</strong></p><pre class="lu lv lw lx fd ly lz ma mb aw mc bi"><span id="bd54" class="md kk hy lz b fi me mf l mg mh">def get_rsi(close, lookback):<br/>    ret = close.diff()<br/>    up = []<br/>    down = []<br/>    for i in range(len(ret)):<br/>        if ret[i] &lt; 0:<br/>            up.append(0)<br/>            down.append(ret[i])<br/>        else:<br/>            up.append(ret[i])<br/>            down.append(0)<br/>    up_series = pd.Series(up)<br/>    down_series = pd.Series(down).abs()<br/>    up_ewm = up_series.ewm(com = lookback - 1, adjust = False).mean()<br/>    down_ewm = down_series.ewm(com = lookback - 1, adjust = False).mean()<br/>    rs = up_ewm/down_ewm<br/>    rsi = 100 - (100 / (1 + rs))<br/>    rsi_df = pd.DataFrame(rsi).rename(columns = {0:'rsi'}).set_index(close.index)<br/>    rsi_df = rsi_df.dropna()<br/>    return rsi_df[3:]<br/><br/>ibm['rsi_14'] = get_rsi(ibm['close'], 14)<br/>ibm = ibm.dropna()<br/>ibm</span></pre><p id="36a2" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><strong class="jp hz">输出:</strong></p><figure class="lu lv lw lx fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es mx"><img src="../Images/5c4214ea0b2434b8463643fb044dc486.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XxfWtQqXnBnOO4ogk-iVZA.png"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">作者图片</figcaption></figure><p id="dd8f" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><strong class="jp hz">代码解释:</strong>首先，我们定义一个名为‘get _ RSI’的函数，它以股票的收盘价(‘close’)和回望期(‘lookback’)作为参数。在这个函数中，我们首先使用Pandas包提供的diff函数计算股票的回报率，并将其存储到ret变量中。这个函数基本上是从以前的值中减去当前的值。接下来，我们在“ret”变量上传递一个for循环，以区分收益和损失，并将这些值附加到相关变量(“up”或“down”)。</p><p id="792b" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">然后，我们使用Pandas软件包提供的“ewm”函数计算“上涨”和“下跌”的指数移动平均值，并将它们分别存储到“上涨_ewm”和“下跌_ewm”变量中。使用这些计算出的EMA，我们按照之前讨论的公式确定相对强度，并将其存储到“rs”变量中。</p><p id="ecc9" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">通过利用计算出的相对强度值，我们按照公式计算RSI值。在做了一些数据处理和操作后，我们以熊猫数据框的形式返回计算出的相对强度指数值。最后，我们调用创建的函数来存储IBM的RSI值，14作为回顾期。</p><h2 id="aafe" class="md kk hy bd kl mj mk ml kp mm mn mo kt jw mp mq kv ka mr ms kx ke mt mu kz mv bi translated">第4步:相对强弱图</h2><p id="95b3" class="pw-post-body-paragraph jn jo hy jp b jq lb iz js jt lc jc jv jw ld jy jz ka le kc kd ke lf kg kh ki hb bi translated">在这一步中，我们将绘制IBM的计算相对优势指数值，以便更好地理解它。这一部分的主要目的不是在编码部分，而是观察情节以获得对RSI的牢固理解。</p><p id="2091" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><strong class="jp hz"> Python实现:</strong></p><pre class="lu lv lw lx fd ly lz ma mb aw mc bi"><span id="1d95" class="md kk hy lz b fi me mf l mg mh">ax1 = plt.subplot2grid((10,1), (0,0), rowspan = 4, colspan = 1)<br/>ax2 = plt.subplot2grid((10,1), (5,0), rowspan = 4, colspan = 1)<br/>ax1.plot(ibm['close'], linewidth = 2.5)<br/>ax1.set_title('IBM CLOSE PRICE')<br/>ax2.plot(ibm['rsi_14'], color = 'orange', linewidth = 2.5)<br/>ax2.axhline(30, linestyle = '--', linewidth = 1.5, color = 'grey')<br/>ax2.axhline(70, linestyle = '--', linewidth = 1.5, color = 'grey')<br/>ax2.set_title('IBM RELATIVE STRENGTH INDEX')<br/>plt.show()</span></pre><p id="0984" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><strong class="jp hz">输出:</strong></p><figure class="lu lv lw lx fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es my"><img src="../Images/41f5624c0a11b5d116be8d826ff7472a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vQQRPvULnSlx2NYSskvMfQ.png"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">作者图片</figcaption></figure><p id="011c" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">上面的图表分为两个面板:上面的面板显示IBM的收盘价，下面的面板显示IBM计算的RSI 14值。在分析用RSI值绘制的面板时，可以看到计算值的趋势和移动与IBM的收盘价相同。所以，我们可以认为RSI是一个方向性指标。一些指标是非方向性的，这意味着它们的运动将与实际的股票运动成反比，这有时会使交易者困惑，也很难理解。</p><p id="8d84" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">在观察RSI图时，我们可以看到，RSI图甚至比市场更早地揭示了趋势反转。简单地说，RSI在实际市场出现之前显示下跌趋势或上涨趋势。这说明RSI是先行指标。领先指标只不过是一种考虑到数据序列的当前值来预测未来变化的指标。RSI作为领先指标有助于及时警告交易者潜在的趋势反转。领先指标的反义词叫做滞后指标。滞后指标是通过考虑数据序列的历史值来表示当前值的指标。</p><h2 id="9884" class="md kk hy bd kl mj mk ml kp mm mn mo kt jw mp mq kv ka mr ms kx ke mt mu kz mv bi translated">步骤5:创建交易策略</h2><p id="0b8c" class="pw-post-body-paragraph jn jo hy jp b jq lb iz js jt lc jc jv jw ld jy jz ka le kc kd ke lf kg kh ki hb bi translated">在这一步中，我们将在python中实现所讨论的相对强弱指数交易策略。</p><p id="b9d8" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><strong class="jp hz"> Python实现:</strong></p><pre class="lu lv lw lx fd ly lz ma mb aw mc bi"><span id="1961" class="md kk hy lz b fi me mf l mg mh">def implement_rsi_strategy(prices, rsi):    <br/>    buy_price = []<br/>    sell_price = []<br/>    rsi_signal = []<br/>    signal = 0<br/><br/>    for i in range(len(rsi)):<br/>        if rsi[i-1] &gt; 30 and rsi[i] &lt; 30:<br/>            if signal != 1:<br/>                buy_price.append(prices[i])<br/>                sell_price.append(np.nan)<br/>                signal = 1<br/>                rsi_signal.append(signal)<br/>            else:<br/>                buy_price.append(np.nan)<br/>                sell_price.append(np.nan)<br/>                rsi_signal.append(0)<br/>        elif rsi[i-1] &lt; 70 and rsi[i] &gt; 70:<br/>            if signal != -1:<br/>                buy_price.append(np.nan)<br/>                sell_price.append(prices[i])<br/>                signal = -1<br/>                rsi_signal.append(signal)<br/>            else:<br/>                buy_price.append(np.nan)<br/>                sell_price.append(np.nan)<br/>                rsi_signal.append(0)<br/>        else:<br/>            buy_price.append(np.nan)<br/>            sell_price.append(np.nan)<br/>            rsi_signal.append(0)<br/>            <br/>    return buy_price, sell_price, rsi_signal<br/>            <br/><br/>buy_price, sell_price, rsi_signal = implement_rsi_strategy(ibm['close'], ibm['rsi_14'])</span></pre><p id="9064" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><strong class="jp hz">代码解释:</strong>首先，我们定义一个名为‘implement _ rsi _ strategy’的函数，它将股票价格(‘prices’)和RSI值(‘RSI’)作为参数。</p><p id="98df" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">在这个函数中，我们创建了三个空列表(buy_price、sell_price和rsi_signal ),在创建交易策略时，这些值将被追加到这些列表中。</p><p id="4063" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">之后，我们通过for循环实施交易策略。在for循环内部，我们传递某些条件，如果条件得到满足，相应的值将被追加到空列表中。如果购买股票的条件得到满足，买入价将被追加到“buy_price”列表中，信号值将被追加为1，表示购买股票。类似地，如果卖出股票的条件得到满足，卖价将被追加到“sell_price”列表中，信号值将被追加为-1，表示卖出股票。</p><p id="5998" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">最后，我们返回附加了值的列表。然后，我们调用创建的函数并将值存储到各自的变量中。除非我们画出这些值，否则这个列表没有任何意义。所以，让我们画出创建的交易列表的值。</p><h2 id="7a85" class="md kk hy bd kl mj mk ml kp mm mn mo kt jw mp mq kv ka mr ms kx ke mt mu kz mv bi translated">步骤6:绘制交易信号</h2><p id="1911" class="pw-post-body-paragraph jn jo hy jp b jq lb iz js jt lc jc jv jw ld jy jz ka le kc kd ke lf kg kh ki hb bi translated">在这一步，我们将绘制已创建的交易列表，以使它们有意义。</p><p id="4d72" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><strong class="jp hz"> Python实现:</strong></p><pre class="lu lv lw lx fd ly lz ma mb aw mc bi"><span id="d525" class="md kk hy lz b fi me mf l mg mh">ax1 = plt.subplot2grid((10,1), (0,0), rowspan = 4, colspan = 1)<br/>ax2 = plt.subplot2grid((10,1), (5,0), rowspan = 4, colspan = 1)<br/>ax1.plot(ibm['close'], linewidth = 2.5, color = 'skyblue', label = 'IBM')<br/>ax1.plot(ibm.index, buy_price, marker = '^', markersize = 10, color = 'green', label = 'BUY SIGNAL')<br/>ax1.plot(ibm.index, sell_price, marker = 'v', markersize = 10, color = 'r', label = 'SELL SIGNAL')<br/>ax1.set_title('IBM RSI TRADE SIGNALS')<br/>ax2.plot(ibm['rsi_14'], color = 'orange', linewidth = 2.5)<br/>ax2.axhline(30, linestyle = '--', linewidth = 1.5, color = 'grey')<br/>ax2.axhline(70, linestyle = '--', linewidth = 1.5, color = 'grey')<br/>plt.show()</span></pre><p id="7e23" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><strong class="jp hz">输出:</strong></p><figure class="lu lv lw lx fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es my"><img src="../Images/4479162ef1fc6b9084a3d714c9502656.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NfrrbhgVdeQaOkZzUVDjhQ.png"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">作者图片</figcaption></figure><p id="50ef" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><strong class="jp hz">代码解释:</strong>我们正在绘制相对强弱指数值以及交易策略产生的买入和卖出信号。我们可以观察到，每当RSI线从上方穿越到下方波段或超卖水平下方时，图表中就会绘制出绿色的买入信号。类似地，RSI线从下方穿过上方波段或超买水平，在图表中绘制了红色的卖出信号。</p><h2 id="2349" class="md kk hy bd kl mj mk ml kp mm mn mo kt jw mp mq kv ka mr ms kx ke mt mu kz mv bi translated">步骤7:创建我们的职位</h2><p id="4326" class="pw-post-body-paragraph jn jo hy jp b jq lb iz js jt lc jc jv jw ld jy jz ka le kc kd ke lf kg kh ki hb bi translated">在这一步中，我们将创建一个列表，如果我们持有股票，该列表将指示1；如果我们不拥有或持有股票，该列表将指示0。</p><p id="385e" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><strong class="jp hz"> Python实现:</strong></p><pre class="lu lv lw lx fd ly lz ma mb aw mc bi"><span id="8246" class="md kk hy lz b fi me mf l mg mh">position = []<br/>for i in range(len(rsi_signal)):<br/>    if rsi_signal[i] &gt; 1:<br/>        position.append(0)<br/>    else:<br/>        position.append(1)<br/>        <br/>for i in range(len(ibm['close'])):<br/>    if rsi_signal[i] == 1:<br/>        position[i] = 1<br/>    elif rsi_signal[i] == -1:<br/>        position[i] = 0<br/>    else:<br/>        position[i] = position[i-1]<br/>        <br/>rsi = ibm['rsi_14']<br/>close_price = ibm['close']<br/>rsi_signal = pd.DataFrame(rsi_signal).rename(columns = {0:'rsi_signal'}).set_index(ibm.index)<br/>position = pd.DataFrame(position).rename(columns = {0:'rsi_position'}).set_index(ibm.index)<br/><br/>frames = [close_price, rsi, rsi_signal, position]<br/>strategy = pd.concat(frames, join = 'inner', axis = 1)<br/><br/>strategy.head()</span></pre><p id="7548" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><strong class="jp hz">输出:</strong></p><figure class="lu lv lw lx fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es mz"><img src="../Images/536de8b3e4c9ee354d02f151a6ca0847.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E-6KGc_QTOTCh1h2mQvP2A.png"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">作者图片</figcaption></figure><p id="2a48" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><strong class="jp hz">代码解释:</strong>首先，我们创建一个名为‘position’的空列表。我们传递两个for循环，一个是为“位置”列表生成值，以匹配“信号”列表的长度。另一个for循环是我们用来生成实际位置值的循环。在第二个for循环中，我们对“signal”列表的值进行迭代，而“position”列表的值被附加到满足哪个条件上。如果我们持有股票，头寸的价值仍为1；如果我们卖出或不持有股票，头寸的价值仍为0。最后，我们正在进行一些数据操作，将所有创建的列表合并到一个数据帧中。</p><p id="5ca0" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">从显示的输出中，我们可以看到，在第一行中，我们在股票中的位置仍然是1(因为RSI信号没有任何变化)，但是当相对强度指数交易信号代表卖出信号(-1)时，我们的位置突然变为0。我们的头寸将保持为0，直到交易信号发生一些变化。现在是时候实现一些回溯测试过程了！</p><h2 id="34bd" class="md kk hy bd kl mj mk ml kp mm mn mo kt jw mp mq kv ka mr ms kx ke mt mu kz mv bi translated">步骤8:回溯测试</h2><p id="20ab" class="pw-post-body-paragraph jn jo hy jp b jq lb iz js jt lc jc jv jw ld jy jz ka le kc kd ke lf kg kh ki hb bi translated">在继续之前，有必要知道什么是回溯测试。回溯测试是查看我们的交易策略在给定股票数据上表现如何的过程。在我们的例子中，我们将针对IBM股票数据为我们的相对优势指数交易策略实现一个回溯测试过程。</p><p id="c142" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><strong class="jp hz"> Python实现:</strong></p><pre class="lu lv lw lx fd ly lz ma mb aw mc bi"><span id="938d" class="md kk hy lz b fi me mf l mg mh">ibm_ret = pd.DataFrame(np.diff(ibm['close'])).rename(columns = {0:'returns'})<br/>rsi_strategy_ret = []<br/><br/>for i in range(len(ibm_ret)):<br/>    returns = ibm_ret['returns'][i]*strategy['rsi_position'][i]<br/>    rsi_strategy_ret.append(returns)<br/>    <br/>rsi_strategy_ret_df = pd.DataFrame(rsi_strategy_ret).rename(columns = {0:'rsi_returns'})<br/>investment_value = 100000<br/>number_of_stocks = floor(investment_value/ibm['close'][-1])<br/>rsi_investment_ret = []<br/><br/>for i in range(len(rsi_strategy_ret_df['rsi_returns'])):<br/>    returns = number_of_stocks*rsi_strategy_ret_df['rsi_returns'][i]<br/>    rsi_investment_ret.append(returns)<br/><br/>rsi_investment_ret_df = pd.DataFrame(rsi_investment_ret).rename(columns = {0:'investment_returns'})<br/>total_investment_ret = round(sum(rsi_investment_ret_df['investment_returns']), 2)<br/>profit_percentage = floor((total_investment_ret/investment_value)*100)<br/>print(cl('Profit gained from the RSI strategy by investing $100k in IBM : {}'.format(total_investment_ret), attrs = ['bold']))<br/>print(cl('Profit percentage of the RSI strategy : {}%'.format(profit_percentage), attrs = ['bold']))</span></pre><p id="1bd3" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><strong class="jp hz">输出:</strong></p><pre class="lu lv lw lx fd ly lz ma mb aw mc bi"><span id="ee1c" class="md kk hy lz b fi me mf l mg mh"><strong class="lz hz">Profit gained from the RSI strategy by investing $100k in IBM : 21132.23</strong><br/><strong class="lz hz">Profit percentage of the RSI strategy : 21%</strong></span></pre><p id="3e67" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><strong class="jp hz">代码解释:</strong>首先，我们使用NumPy包提供的‘diff’函数计算IBM股票的收益，并将其作为dataframe存储到‘IBM _ ret’变量中。接下来，我们将传递一个for循环来迭代' ibm_ret '变量的值，以计算我们从相对强弱指数交易策略中获得的回报，这些回报值将被追加到' rsi_strategy_ret '列表中。接下来，我们将“rsi_strategy_ret”列表转换为数据帧，并将其存储到“rsi_strategy_ret_df”变量中。</p><p id="88c7" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">接下来是回溯测试过程。我们将通过投资10万美元到我们的交易策略中来回测我们的策略。首先，我们将投资金额存储到“投资值”变量中。之后，我们正在计算使用投资金额可以购买的IBM股票数量。您可以注意到，我使用了Math package提供的“floor”函数，因为当投资金额除以IBM股票的收盘价时，它会输出一个十进制数。股票数量应该是整数，而不是小数。使用“底数”函数，我们可以去掉小数。请记住,“floor”函数比“round”函数要复杂得多。然后，我们传递一个for循环来寻找投资回报，随后是一些数据操作任务。</p><p id="6653" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">最后，我们打印出我们在交易策略中投入10万美元所获得的总回报，结果显示我们在一年中获得了大约21，000美元的利润，利润百分比为21%。太好了！</p><h1 id="3bb1" class="kj kk hy bd kl km kn ko kp kq kr ks kt je ku jf kv jh kw ji kx jk ky jl kz la bi translated">最后的想法！</h1><p id="0dd2" class="pw-post-body-paragraph jn jo hy jp b jq lb iz js jt lc jc jv jw ld jy jz ka le kc kd ke lf kg kh ki hb bi translated">经过长期的理论和实践，我们已经成功地学习了什么是RSI，以及如何用python实现和回测一个简单的基于RSI的交易策略。即使RSI是最受欢迎的交易指标之一，它也容易揭示错误的信号。跟随错误的信号，并根据这些信号进行交易，甚至会耗尽资本。幸运的是，有两种方法可以让你远离错误信号:</p><ul class=""><li id="16bf" class="lg lh hy jp b jq jr jt ju jw li ka lj ke lk ki ll lm ln lo bi translated"><strong class="jp hz">附加指标:</strong>一些股票可能波动很大，会更频繁地触及超买和超卖水平。在这种情况下，你不应该盲目地跟随RSI水平进行交易，而是应该考虑另一个技术指标来验证信号是否真实。</li><li id="0855" class="lg lh hy jp b jq lp jt lq jw lr ka ls ke lt ki ll lm ln lo bi translated"><strong class="jp hz">随机应变策略:</strong>我们在本文中采用的策略是最基本的策略之一，但在RSI的帮助下，还有很多事情可以做。所以，在直接进入现实世界的市场之前，强烈建议看看其他一些基于相对强弱指数的交易策略。</li></ul><p id="f724" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">在这篇文章中，我们没有涵盖任何一个步骤，因为这篇文章的主要目的只是教育人们了解最重要的交易指标之一，而不是赚取利润等。使用RSI时，还有一点需要记住。相对强弱指数在区间市场往往表现不佳。区间市场是表现出低动能或无动能的市场。所以，在使用相对强弱指数时，强烈建议远离区间市场。</p><p id="ce45" class="pw-post-body-paragraph jn jo hy jp b jq jr iz js jt ju jc jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">话虽如此，你已经到了文章的结尾。如果您忘记了遵循任何编码部分，不要担心。我在文章末尾提供了完整的源代码。希望你学到了新的有用的东西。</p><h2 id="fed3" class="md kk hy bd kl mj mk ml kp mm mn mo kt jw mp mq kv ka mr ms kx ke mt mu kz mv bi translated">完整代码:</h2><pre class="lu lv lw lx fd ly lz ma mb aw mc bi"><span id="97bf" class="md kk hy lz b fi me mf l mg mh">import pandas as pd <br/>import matplotlib.pyplot as plt<br/>import requests<br/>import numpy as np<br/>from math import floor<br/>from termcolor import colored as cl <br/><br/>plt.style.use('fivethirtyeight')<br/>plt.rcParams['figure.figsize'] = (20, 10)<br/><br/>def get_historical_data(symbol, start_date = None):<br/>    api_key = open(r'api_key.txt')<br/>    api_url = f'https://www.alphavantage.co/query?function=TIME_SERIES_DAILY_ADJUSTED&amp;symbol={symbol}&amp;apikey={api_key}&amp;outputsize=full'<br/>    raw_df = requests.get(api_url).json()<br/>    df = pd.DataFrame(raw_df[f'Time Series (Daily)']).T<br/>    df = df.rename(columns = {'1. open': 'open', '2. high': 'high', '3. low': 'low', '4. close': 'close', '5. adjusted close': 'adj close', '6. volume': 'volume'})<br/>    for i in df.columns:<br/>        df[i] = df[i].astype(float)<br/>    df.index = pd.to_datetime(df.index)<br/>    df = df.iloc[::-1].drop(['7. dividend amount', '8. split coefficient'], axis = 1)<br/>    if start_date:<br/>        df = df[df.index &gt;= start_date]<br/>    return df<br/><br/>ibm = get_historical_data('IBM', '2020-01-01')<br/>print(ibm)<br/><br/>def get_rsi(close, lookback):<br/>    ret = close.diff()<br/>    up = []<br/>    down = []<br/>    for i in range(len(ret)):<br/>        if ret[i] &lt; 0:<br/>            up.append(0)<br/>            down.append(ret[i])<br/>        else:<br/>            up.append(ret[i])<br/>            down.append(0)<br/>    up_series = pd.Series(up)<br/>    down_series = pd.Series(down).abs()<br/>    up_ewm = up_series.ewm(com = lookback - 1, adjust = False).mean()<br/>    down_ewm = down_series.ewm(com = lookback - 1, adjust = False).mean()<br/>    rs = up_ewm/down_ewm<br/>    rsi = 100 - (100 / (1 + rs))<br/>    rsi_df = pd.DataFrame(rsi).rename(columns = {0:'rsi'}).set_index(close.index)<br/>    rsi_df = rsi_df.dropna()<br/>    return rsi_df[3:]<br/><br/>ibm['rsi_14'] = get_rsi(ibm['close'], 14)<br/>ibm = ibm.dropna()<br/>print(ibm)<br/><br/>ax1 = plt.subplot2grid((10,1), (0,0), rowspan = 4, colspan = 1)<br/>ax2 = plt.subplot2grid((10,1), (5,0), rowspan = 4, colspan = 1)<br/>ax1.plot(ibm['close'], linewidth = 2.5)<br/>ax1.set_title('IBM CLOSE PRICE')<br/>ax2.plot(ibm['rsi_14'], color = 'orange', linewidth = 2.5)<br/>ax2.axhline(30, linestyle = '--', linewidth = 1.5, color = 'grey')<br/>ax2.axhline(70, linestyle = '--', linewidth = 1.5, color = 'grey')<br/>ax2.set_title('IBM RELATIVE STRENGTH INDEX')<br/>plt.show()<br/><br/>def implement_rsi_strategy(prices, rsi):    <br/>    buy_price = []<br/>    sell_price = []<br/>    rsi_signal = []<br/>    signal = 0<br/><br/>    for i in range(len(rsi)):<br/>        if rsi[i-1] &gt; 30 and rsi[i] &lt; 30:<br/>            if signal != 1:<br/>                buy_price.append(prices[i])<br/>                sell_price.append(np.nan)<br/>                signal = 1<br/>                rsi_signal.append(signal)<br/>            else:<br/>                buy_price.append(np.nan)<br/>                sell_price.append(np.nan)<br/>                rsi_signal.append(0)<br/>        elif rsi[i-1] &lt; 70 and rsi[i] &gt; 70:<br/>            if signal != -1:<br/>                buy_price.append(np.nan)<br/>                sell_price.append(prices[i])<br/>                signal = -1<br/>                rsi_signal.append(signal)<br/>            else:<br/>                buy_price.append(np.nan)<br/>                sell_price.append(np.nan)<br/>                rsi_signal.append(0)<br/>        else:<br/>            buy_price.append(np.nan)<br/>            sell_price.append(np.nan)<br/>            rsi_signal.append(0)<br/>            <br/>    return buy_price, sell_price, rsi_signal<br/>            <br/><br/>buy_price, sell_price, rsi_signal = implement_rsi_strategy(ibm['close'], ibm['rsi_14'])<br/><br/>ax1 = plt.subplot2grid((10,1), (0,0), rowspan = 4, colspan = 1)<br/>ax2 = plt.subplot2grid((10,1), (5,0), rowspan = 4, colspan = 1)<br/>ax1.plot(ibm['close'], linewidth = 2.5, color = 'skyblue', label = 'IBM')<br/>ax1.plot(ibm.index, buy_price, marker = '^', markersize = 10, color = 'green', label = 'BUY SIGNAL')<br/>ax1.plot(ibm.index, sell_price, marker = 'v', markersize = 10, color = 'r', label = 'SELL SIGNAL')<br/>ax1.set_title('IBM RSI TRADE SIGNALS')<br/>ax2.plot(ibm['rsi_14'], color = 'orange', linewidth = 2.5)<br/>ax2.axhline(30, linestyle = '--', linewidth = 1.5, color = 'grey')<br/>ax2.axhline(70, linestyle = '--', linewidth = 1.5, color = 'grey')<br/>plt.show()<br/><br/>position = []<br/>for i in range(len(rsi_signal)):<br/>    if rsi_signal[i] &gt; 1:<br/>        position.append(0)<br/>    else:<br/>        position.append(1)<br/>        <br/>for i in range(len(ibm['close'])):<br/>    if rsi_signal[i] == 1:<br/>        position[i] = 1<br/>    elif rsi_signal[i] == -1:<br/>        position[i] = 0<br/>    else:<br/>        position[i] = position[i-1]<br/>        <br/>rsi = ibm['rsi_14']<br/>close_price = ibm['close']<br/>rsi_signal = pd.DataFrame(rsi_signal).rename(columns = {0:'rsi_signal'}).set_index(ibm.index)<br/>position = pd.DataFrame(position).rename(columns = {0:'rsi_position'}).set_index(ibm.index)<br/><br/>frames = [close_price, rsi, rsi_signal, position]<br/>strategy = pd.concat(frames, join = 'inner', axis = 1)<br/><br/>print(strategy.head())<br/><br/>ibm_ret = pd.DataFrame(np.diff(ibm['close'])).rename(columns = {0:'returns'})<br/>rsi_strategy_ret = []<br/><br/>for i in range(len(ibm_ret)):<br/>    returns = ibm_ret['returns'][i]*strategy['rsi_position'][i]<br/>    rsi_strategy_ret.append(returns)<br/>    <br/>rsi_strategy_ret_df = pd.DataFrame(rsi_strategy_ret).rename(columns = {0:'rsi_returns'})<br/>investment_value = 100000<br/>number_of_stocks = floor(investment_value/ibm['close'][-1])<br/>rsi_investment_ret = []<br/><br/>for i in range(len(rsi_strategy_ret_df['rsi_returns'])):<br/>    returns = number_of_stocks*rsi_strategy_ret_df['rsi_returns'][i]<br/>    rsi_investment_ret.append(returns)<br/><br/>rsi_investment_ret_df = pd.DataFrame(rsi_investment_ret).rename(columns = {0:'investment_returns'})<br/>total_investment_ret = round(sum(rsi_investment_ret_df['investment_returns']), 2)<br/>profit_percentage = floor((total_investment_ret/investment_value)*100)<br/>print(cl('Profit gained from the RSI strategy by investing $100k in IBM : {}'.format(total_investment_ret), attrs = ['bold']))<br/>print(cl('Profit percentage of the RSI strategy : {}%'.format(profit_percentage), attrs = ['bold']))</span></pre></div></div>    
</body>
</html>