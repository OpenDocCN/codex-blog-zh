<html>
<head>
<title>Building and Visualizing Decision Tree in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Python构建和可视化决策树</h1>
<blockquote>原文：<a href="https://medium.com/codex/building-and-visualizing-decision-tree-in-python-2cfaafd8e1bb?source=collection_archive---------0-----------------------#2020-10-26">https://medium.com/codex/building-and-visualizing-decision-tree-in-python-2cfaafd8e1bb?source=collection_archive---------0-----------------------#2020-10-26</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><h2 id="9a75" class="hg hh hi bd b fp hj hk hl hm hn ho dx hp translated" aria-label="kicker paragraph">药典</h2><div class=""/><div class=""><h2 id="5528" class="pw-subtitle-paragraph io hr hi bd b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf dx translated">学习使用scikit构建和可视化决策树模型——学习Python语言</h2></div><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es jg"><img src="../Images/4808709faa2be5a0f194968e3ca8134b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*XVv41vnaBzx-t1LQ"/></div></div><figcaption class="js jt et er es ju jv bd b be z dx translated">伊利亚·Vjestica在<a class="ae jw" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><h1 id="0bb2" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ix ki iy kj ja kk jb kl jd km je kn ko bi translated">决策图表</h1><p id="1323" class="pw-post-body-paragraph kp kq hi kr b ks kt is ku kv kw iv kx ky kz la lb lc ld le lf lg lh li lj lk hb bi ll translated"><span class="l lm ln lo bm lp lq lr ls lt di"> D </span>决策树是当今使用的一些最强大的监督学习方法的构建模块。</p><blockquote class="lu"><p id="8a65" class="lv lw hi bd lx ly lz ma mb mc md lk dx translated">决策树基本上是一个二叉树流程图，其中每个节点根据一些特征变量分割一组观察值。决策树的目标是将数据分成组，这样一个组中的每个元素都属于同一类别。</p></blockquote><p id="20d1" class="pw-post-body-paragraph kp kq hi kr b ks me is ku kv mf iv kx ky mg la lb lc mh le lf lg mi li lj lk hb bi translated">决策树的一个重要特性是它们非常容易解释。你根本不需要熟悉机器学习技术就能理解决策树在做什么。决策树图是可行的解释。</p><h1 id="d96e" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ix ki iy kj ja kk jb kl jd km je kn ko bi translated">用于决策树的Python</h1><p id="f68d" class="pw-post-body-paragraph kp kq hi kr b ks kt is ku kv kw iv kx ky kz la lb lc ld le lf lg lh li lj lk hb bi translated">Python是一种通用编程语言，为数据科学家提供了强大的机器学习包和工具。在本文中，我们将使用python最著名的机器学习包“scikit-learn”来构建决策树模型。我们将使用scikit-learn提供的<em class="mj">‘decision tree classifier’</em>算法创建我们的模型，然后使用<em class="mj">‘plot _ tree’</em>函数可视化模型。我们开始吧！</p><h2 id="e725" class="mk jy hi bd jz ml mm mn kd mo mp mq kh ky mr ms kj lc mt mu kl lg mv mw kn ho bi translated">步骤1:导入包</h2><p id="0798" class="pw-post-body-paragraph kp kq hi kr b ks kt is ku kv kw iv kx ky kz la lb lc ld le lf lg lh li lj lk hb bi translated">构建我们的模型所涉及的主要软件包是pandas、scikit-learn和NumPy。按照代码导入python中所需的包。</p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="mx my l"/></div></figure><p id="af68" class="pw-post-body-paragraph kp kq hi kr b ks mz is ku kv na iv kx ky nb la lb lc nc le lf lg nd li lj lk hb bi translated">在导入了构建我们的模型所需的所有包之后，是时候导入数据并对其进行一些EDA了。</p><h2 id="5a24" class="mk jy hi bd jz ml mm mn kd mo mp mq kh ky mr ms kj lc mt mu kl lg mv mw kn ho bi translated">步骤2:导入数据和EDA</h2><p id="e43f" class="pw-post-body-paragraph kp kq hi kr b ks kt is ku kv kw iv kx ky kz la lb lc ld le lf lg lh li lj lk hb bi translated">在这一步中，我们将利用python中可用的“Pandas”包来导入并在其上进行一些EDA。我们将用于构建决策树模型的数据集是一个药物数据集，它是根据特定标准为患者开出的处方。我们用python导入数据吧！</p><p id="94cd" class="pw-post-body-paragraph kp kq hi kr b ks mz is ku kv na iv kx ky nb la lb lc nc le lf lg nd li lj lk hb bi translated"><strong class="kr hs"> Python实现:</strong></p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="mx my l"/></div></figure><p id="f182" class="pw-post-body-paragraph kp kq hi kr b ks mz is ku kv na iv kx ky nb la lb lc nc le lf lg nd li lj lk hb bi translated">输出:</p><pre class="jh ji jj jk fd ne nf ng nh aw ni bi"><span id="e4e2" class="mk jy hi nf b fi nj nk l nl nm"><strong class="nf hs">   Age Sex      BP Cholesterol  Na_to_K   Drug<br/>0   23   F    HIGH        HIGH   25.355  drugY<br/>1   47   M     LOW        HIGH   13.093  drugC<br/>2   47   M     LOW        HIGH   10.114  drugC<br/>3   28   F  NORMAL        HIGH    7.798  drugX<br/>4   61   F     LOW        HIGH   18.043  drugY</strong></span></pre><p id="d0b1" class="pw-post-body-paragraph kp kq hi kr b ks mz is ku kv na iv kx ky nb la lb lc nc le lf lg nd li lj lk hb bi translated">现在我们对数据集有了一个清晰的概念。导入数据后，让我们使用<em class="mj">‘info’</em>函数获取数据的一些基本信息。该函数提供的信息包括条目数、索引号、列名、非空值计数、属性类型等。</p><p id="8398" class="pw-post-body-paragraph kp kq hi kr b ks mz is ku kv na iv kx ky nb la lb lc nc le lf lg nd li lj lk hb bi translated"><strong class="kr hs"> Python实现:</strong></p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="mx my l"/></div></figure><p id="7cd0" class="pw-post-body-paragraph kp kq hi kr b ks mz is ku kv na iv kx ky nb la lb lc nc le lf lg nd li lj lk hb bi translated">输出:</p><pre class="jh ji jj jk fd ne nf ng nh aw ni bi"><span id="069a" class="mk jy hi nf b fi nj nk l nl nm"><strong class="nf hs">&lt;class 'pandas.core.frame.DataFrame'&gt;<br/>RangeIndex: 200 entries, 0 to 199<br/>Data columns (total 6 columns):<br/> #   Column       Non-Null Count  Dtype  <br/>---  ------       --------------  -----  <br/> 0   Age          200 non-null    int64  <br/> 1   Sex          200 non-null    object <br/> 2   BP           200 non-null    object <br/> 3   Cholesterol  200 non-null    object <br/> 4   Na_to_K      200 non-null    float64<br/> 5   Drug         200 non-null    object <br/>dtypes: float64(1), int64(1), object(4)<br/>memory usage: 9.5+ KB</strong></span></pre><h2 id="da1e" class="mk jy hi bd jz ml mm mn kd mo mp mq kh ky mr ms kj lc mt mu kl lg mv mw kn ho bi translated">步骤3:数据处理</h2><p id="545f" class="pw-post-body-paragraph kp kq hi kr b ks kt is ku kv kw iv kx ky kz la lb lc ld le lf lg lh li lj lk hb bi translated">我们可以看到像性别、血压和胆固醇这样的属性在本质上是分类的和对象类型的。问题是，scikit-learn中的决策树算法不支持X变量本质上是“对象”类型。因此，有必要将这些“对象”值转换为“二进制”值。用python来做吧！</p><p id="d737" class="pw-post-body-paragraph kp kq hi kr b ks mz is ku kv na iv kx ky nb la lb lc nc le lf lg nd li lj lk hb bi translated"><strong class="kr hs"> Python实现:</strong></p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="mx my l"/></div></figure><p id="6246" class="pw-post-body-paragraph kp kq hi kr b ks mz is ku kv na iv kx ky nb la lb lc nc le lf lg nd li lj lk hb bi translated">输出:</p><pre class="jh ji jj jk fd ne nf ng nh aw ni bi"><span id="1773" class="mk jy hi nf b fi nj nk l nl nm"><strong class="nf hs">     Age  Sex  BP  Cholesterol  Na_to_K   Drug<br/>0     23    1   2            1   25.355  drugY<br/>1     47    1   0            1   13.093  drugC<br/>2     47    1   0            1   10.114  drugC<br/>3     28    1   1            1    7.798  drugX<br/>4     61    1   0            1   18.043  drugY<br/>..   ...  ...  ..          ...      ...    ...<br/>195   56    1   0            1   11.567  drugC<br/>196   16    1   0            1   12.006  drugC<br/>197   52    1   1            1    9.894  drugX<br/>198   23    1   1            1   14.020  drugX<br/>199   40    1   0            1   11.349  drugX<br/><br/>[200 rows x 6 columns]</strong></span></pre><p id="5806" class="pw-post-body-paragraph kp kq hi kr b ks mz is ku kv na iv kx ky nb la lb lc nc le lf lg nd li lj lk hb bi translated">我们可以观察到，所有的“对象”值都被处理成“二进制”值来表示分类数据。例如，在胆固醇属性中，显示“低”的值被处理为0，“高”的值被处理为1。现在我们准备从数据中创建因变量和自变量。</p><h2 id="9b74" class="mk jy hi bd jz ml mm mn kd mo mp mq kh ky mr ms kj lc mt mu kl lg mv mw kn ho bi translated">步骤4:拆分数据</h2><p id="d8af" class="pw-post-body-paragraph kp kq hi kr b ks kt is ku kv kw iv kx ky kz la lb lc ld le lf lg lh li lj lk hb bi translated">将数据处理成正确的结构后，我们现在开始定义“X”变量或自变量和“Y”变量或因变量。用python来做吧！</p><p id="ed61" class="pw-post-body-paragraph kp kq hi kr b ks mz is ku kv na iv kx ky nb la lb lc nc le lf lg nd li lj lk hb bi translated"><strong class="kr hs"> Python实现:</strong></p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="mx my l"/></div></figure><p id="3497" class="pw-post-body-paragraph kp kq hi kr b ks mz is ku kv na iv kx ky nb la lb lc nc le lf lg nd li lj lk hb bi translated">输出:</p><pre class="jh ji jj jk fd ne nf ng nh aw ni bi"><span id="940e" class="mk jy hi nf b fi nj nk l nl nm"><strong class="nf hs">X variable samples : [[ 1.     2.    23.     1.    25.355]<br/> [ 1.     0.    47.     1.    13.093]<br/> [ 1.     0.    47.     1.    10.114]<br/> [ 1.     1.    28.     1.     7.798]<br/> [ 1.     0.    61.     1.    18.043]]</strong><br/><strong class="nf hs">Y variable samples : ['drugY' 'drugC' 'drugC' 'drugX' 'drugY']</strong></span></pre><p id="8a58" class="pw-post-body-paragraph kp kq hi kr b ks mz is ku kv na iv kx ky nb la lb lc nc le lf lg nd li lj lk hb bi translated">现在，我们可以通过使用scikit-learn中的<em class="mj">‘train _ test _ split’</em>算法，使用我们定义的X和Y变量将我们的数据分成训练集和测试集。按照代码在python中分割数据。</p><p id="fb30" class="pw-post-body-paragraph kp kq hi kr b ks mz is ku kv na iv kx ky nb la lb lc nc le lf lg nd li lj lk hb bi translated"><strong class="kr hs"> Python实现:</strong></p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="mx my l"/></div></figure><p id="b4ea" class="pw-post-body-paragraph kp kq hi kr b ks mz is ku kv na iv kx ky nb la lb lc nc le lf lg nd li lj lk hb bi translated">输出:</p><pre class="jh ji jj jk fd ne nf ng nh aw ni bi"><span id="25a7" class="mk jy hi nf b fi nj nk l nl nm"><strong class="nf hs">X_train shape : (160, 5)</strong><br/><strong class="nf hs">X_test shape : (40, 5)</strong><br/><strong class="nf hs">y_train shape : (160,)</strong><br/><strong class="nf hs">y_test shape : (40,)</strong></span></pre><p id="72aa" class="pw-post-body-paragraph kp kq hi kr b ks mz is ku kv na iv kx ky nb la lb lc nc le lf lg nd li lj lk hb bi translated">现在我们有了构建决策树模型的所有组件。因此，让我们继续用python构建我们的模型。</p><h2 id="c412" class="mk jy hi bd jz ml mm mn kd mo mp mq kh ky mr ms kj lc mt mu kl lg mv mw kn ho bi translated">步骤5:建立模型和预测</h2><p id="3975" class="pw-post-body-paragraph kp kq hi kr b ks kt is ku kv kw iv kx ky kz la lb lc ld le lf lg lh li lj lk hb bi translated">在scikit-learn软件包提供的“决策树分类器”算法的帮助下，构建决策树是可行的。之后，我们可以使用训练好的模型对数据进行预测。最后，我们的预测结果的精确度可以使用“精确度分数”评估标准来计算。我们用python来做这个过程吧！</p><p id="83ae" class="pw-post-body-paragraph kp kq hi kr b ks mz is ku kv na iv kx ky nb la lb lc nc le lf lg nd li lj lk hb bi translated"><strong class="kr hs"> Python实现:</strong></p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="mx my l"/></div></figure><p id="726f" class="pw-post-body-paragraph kp kq hi kr b ks mz is ku kv na iv kx ky nb la lb lc nc le lf lg nd li lj lk hb bi translated">输出:</p><pre class="jh ji jj jk fd ne nf ng nh aw ni bi"><span id="26ba" class="mk jy hi nf b fi nj nk l nl nm"><strong class="nf hs">Accuracy of the model is 88%</strong></span></pre><p id="cb45" class="pw-post-body-paragraph kp kq hi kr b ks mz is ku kv na iv kx ky nb la lb lc nc le lf lg nd li lj lk hb bi translated">在代码的第一步中，我们定义了一个名为<em class="mj">‘model’</em>的变量，我们在其中存储了DecisionTreeClassifier模型。接下来，我们使用我们的训练集来拟合和训练模型。之后，我们定义了一个名为<em class="mj">‘pred _ model’</em>的变量，其中存储了我们的模型对数据的所有预测值。最后，我们计算了我们的预测值与实际值的精度，结果是88%的准确度。</p><h2 id="ec90" class="mk jy hi bd jz ml mm mn kd mo mp mq kh ky mr ms kj lc mt mu kl lg mv mw kn ho bi translated">步骤6:可视化模型</h2><p id="45f2" class="pw-post-body-paragraph kp kq hi kr b ks kt is ku kv kw iv kx ky kz la lb lc ld le lf lg lh li lj lk hb bi translated">现在我们有了决策树模型，让我们利用python中scikit-learn包提供的“plot_tree”函数来可视化它。按照代码用python为您的决策树模型制作一个漂亮的树形图。</p><p id="2573" class="pw-post-body-paragraph kp kq hi kr b ks mz is ku kv na iv kx ky nb la lb lc nc le lf lg nd li lj lk hb bi translated"><strong class="kr hs"> Python实现:</strong></p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="mx my l"/></div></figure><p id="4d1c" class="pw-post-body-paragraph kp kq hi kr b ks mz is ku kv na iv kx ky nb la lb lc nc le lf lg nd li lj lk hb bi translated">输出:</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es nn"><img src="../Images/5c7b41c214e4d240e1ffcd16533621f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aZklp1aGiDZONJ1Jv7f1cw.png"/></div></div><figcaption class="js jt et er es ju jv bd b be z dx translated">图片作者<a class="ae jw" href="https://nikhiladithyan.medium.com/" rel="noopener">作者</a></figcaption></figure><h1 id="73ff" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ix ki iy kj ja kk jb kl jd km je kn ko bi translated">结论！</h1><p id="ef55" class="pw-post-body-paragraph kp kq hi kr b ks kt is ku kv kw iv kx ky kz la lb lc ld le lf lg lh li lj lk hb bi translated">有很多技术和其他算法用于调整决策树，避免过度拟合，比如修剪。虽然决策树通常是不稳定的，这意味着数据的微小变化会导致最佳树结构的巨大变化，但它们的简单性使它们成为广泛应用的有力候选。在神经网络流行之前，决策树是机器学习中最先进的算法。至此，我们结束了，如果您忘记了遵循任何编码部分，不要担心，我已经为本文提供了完整的代码。</p><p id="15a4" class="pw-post-body-paragraph kp kq hi kr b ks mz is ku kv na iv kx ky nb la lb lc nc le lf lg nd li lj lk hb bi translated"><strong class="kr hs">快乐的机器学习！</strong></p><p id="18df" class="pw-post-body-paragraph kp kq hi kr b ks mz is ku kv na iv kx ky nb la lb lc nc le lf lg nd li lj lk hb bi translated">完整代码:</p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="mx my l"/></div></figure></div></div>    
</body>
</html>