<html>
<head>
<title>Flutter Bloc: An introduction (with cubit)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">颤振阻滞:介绍(与丘比特)</h1>
<blockquote>原文：<a href="https://medium.com/codex/flutter-bloc-an-introduction-with-cubit-7eae1e740fd0?source=collection_archive---------0-----------------------#2022-06-08">https://medium.com/codex/flutter-bloc-an-introduction-with-cubit-7eae1e740fd0?source=collection_archive---------0-----------------------#2022-06-08</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="ffa8" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">颤振状态管理编年史10。</h1><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/abefc3824751fc5da52ef48700cee53e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TOvdbQ_dcrUqGNXfI2xZzA.png"/></div></div></figure><p id="72f6" class="pw-post-body-paragraph jp jq hi jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hb bi translated">在flutter中有许多状态管理解决方案是我特别喜欢的一点。这些不同的状态管理解决方案不仅为我们提供了基于所述包制定的“协议”来管理应用程序状态的想法或规则，而且还帮助我们实施特定的设计模式和文件夹结构，在某些情况下，在您正在进行的特定项目中，这使得某个解决方案比其他解决方案更可取。</p><p id="6f26" class="pw-post-body-paragraph jp jq hi jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hb bi translated">本质上，Bloc是一个建立在流和反应式编程设计概念之上的状态管理解决方案，使用提供者来促进其注入到小部件树中。</p><blockquote class="kn ko kp"><p id="93d8" class="jp jq kq jr b js jt ju jv jw jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl km hb bi translated">这里，我假设您事先了解提供者(不太强制性)，构建上下文和通知程序，如ChangeNotifiers和StateNotifiers。如果你不知道，请随时查看<a class="ae ku" rel="noopener" href="/geekculture/providers-an-introduction-5b139f58d283">这篇由你真正的</a>撰写的可爱文章。</p></blockquote><p id="72f5" class="pw-post-body-paragraph jp jq hi jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hb bi translated"><strong class="jr hj"> <em class="kq">你可能会问，既然有这么多其他国家管理解决方案，为什么还要关心bloc呢？</em> </strong></p><p id="c383" class="pw-post-body-paragraph jp jq hi jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hb bi translated">我会告诉你要关心。</p><p id="bfb0" class="pw-post-body-paragraph jp jq hi jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hb bi translated"><strong class="jr hj"> <em class="kq">为什么？</em>T9】</strong></p><p id="de8e" class="pw-post-body-paragraph jp jq hi jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hb bi translated">Bloc的构建采用了不同的通知更改的概念，而不是使用通知程序，它使用流，任何需要使用状态的人，只需订阅该状态的特定流，每当状态有新的更改时，它就会被简单地发出并使用(是的，这并不简单，但您会明白这一点)。Flutter和dart已经有了内置的方法来使用带有错误处理和不同状态的流，这是一个很好的用例。</p><p id="d6e5" class="pw-post-body-paragraph jp jq hi jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hb bi translated">因此，如果你有一个严重依赖流的应用程序，或者需要“类似流”的控制，那么考虑使用bloc。</p><p id="b634" class="pw-post-body-paragraph jp jq hi jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hb bi translated"><strong class="jr hj"> <em class="kq">还没完吧？</em>T13】</strong></p><p id="6094" class="pw-post-body-paragraph jp jq hi jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hb bi translated">当然不是。</p><p id="4f8f" class="pw-post-body-paragraph jp jq hi jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hb bi translated">事实上，集团帮助了我们</p><ol class=""><li id="5f62" class="kv kw hi jr b js jt jw jx ka kx ke ky ki kz km la lb lc ld bi translated">将业务逻辑从表示中分离出来，并为状态提供一个真实的来源，以及逻辑和表示之间的一种通信方式。是的，我知道，大多数国家管理解决方案都是这样，但值得注意的是，bloc也是这样。</li><li id="07f8" class="kv kw hi jr b js le jw lf ka lg ke lh ki li km la lb lc ld bi translated">Bloc使状态变化可预测，并易于重放以前的状态和跟踪状态变化，因为它是一个状态值流。听起来很酷，对吧？实现撤销和重做之类的功能变得很容易。</li><li id="e201" class="kv kw hi jr b js le jw lf ka lg ke lh ki li km la lb lc ld bi translated">由于块代码是纯dart代码，可以在angular dart和flutter以及所有dart前端风格之间灵活地重复使用，因此它有助于在您的应用程序内外重复使用代码。</li><li id="aa65" class="kv kw hi jr b js le jw lf ka lg ke lh ki li km la lb lc ld bi translated">dart中的反应式编程(RxDart)非常强大，事实上，bloc是基于它构建的，这意味着如果需要，您可以利用RxDart的功能，但如果没有，bloc提供了足够简单的抽象，非常适合用于简单的解决方案。值得注意的是，bloc构建在RxDart等之上的事实并不会使它变得沉重或笨重，RxDart毕竟只是Dart。</li></ol><p id="06fd" class="pw-post-body-paragraph jp jq hi jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hb bi translated">本质上，每一个优秀的flutter开发者都希望考虑到他们的应用程序的每一个状态，加载、已加载、错误状态等应用程序的每一个交互，从而做出适当的反应。Bloc就是基于这一点构建的，目的是让监听这些交互变得容易，并对重要的状态做出适当的响应，同时不要忘记它进行测试的简易性。</p><p id="77a2" class="pw-post-body-paragraph jp jq hi jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hb bi translated"><em class="kq">太好了，既然我们关心bloc </em>😅<em class="kq">，让我们来看看如何使用它。</em></p><p id="1844" class="pw-post-body-paragraph jp jq hi jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hb bi translated">首先，bloc有两个不同的抽象，cubit和bloc，(它们扩展了BlocBase类)</p><p id="66f9" class="pw-post-body-paragraph jp jq hi jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hb bi translated">Cubit是一个简单的case bloc，它是一个流组件，使用函数将小部件之间的交互传递给cubit，也是一个流，小部件使用这个流来发出状态变化。(实际上，这不仅仅是关于作为交互源的小部件，而是cubits可以公开用于触发状态变化等的函数的事实)。</p><p id="9cb1" class="pw-post-body-paragraph jp jq hi jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hb bi translated">在结构上，Cubit看起来与<a class="ae ku" rel="noopener" href="/flutter-community/provider-with-statenotifiers-19b2c4f9d65c"> StateNotifiers </a>非常相似，这使得它在一定程度上适合那些来自提供者(Riverpod背景)的人。</p></div><div class="ab cl lj lk gp ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="hb hc hd he hf"><p id="1057" class="pw-post-body-paragraph jp jq hi jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hb bi translated"><strong class="jr hj">让我们来看一个使用Cubit </strong>的简单例子</p><p id="bf48" class="pw-post-body-paragraph jp jq hi jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hb bi translated">首先，让我们安装bloc，</p><blockquote class="kn ko kp"><p id="d676" class="jp jq kq jr b js jt ju jv jw jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl km hb bi translated">这里有两个需要关注的包，bloc和flutter bloc。Bloc是bloc包的核心，包含bloc和Cubits等主要核心构建块，独立于flutter(可由任何dart框架使用)。<strong class="jr hj"> Flutter_bloc </strong>是一个包含一些元素的包，这些元素将用于构建依赖于Flutter的ui，如BlocProvider和BlocBuilder。</p><p id="b073" class="jp jq kq jr b js jt ju jv jw jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl km hb bi translated">你可以在vs代码中使用添加依赖功能，搜索flutter_bloc和bloc，或者我们也可以运行<strong class="jr hj">flutter pub add flutter _ bloc</strong>和<strong class="jr hj"> flutter pub add bloc </strong>来添加这两个包。</p><p id="f137" class="jp jq kq jr b js jt ju jv jw jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl km hb bi translated">然后它们将被添加到您的<strong class="jr hj"> pubspec.yaml </strong></p></blockquote><p id="518f" class="pw-post-body-paragraph jp jq hi jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hb bi translated">现在我们已经运行了，让我们试着实现一个简单的随机数生成器，它返回一个1-6范围内的数字，比如说一个低级的骰子滚动。</p><p id="bde9" class="pw-post-body-paragraph jp jq hi jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hb bi translated">所以，我们首先创建一个腕尺来处理这个</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lq"><img src="../Images/4eafcbd795ce6649eda79366f3a950a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NDS3o8aaXyo0Or0zF0ix1A.png"/></div></div></figure><blockquote class="lr"><p id="987a" class="ls lt hi bd lu lv lw lx ly lz ma km dx translated">Cubit只是一个从BlocBase扩展(继承)的类，由于它的定义，它总是需要一个初始状态。如果我们不指定状态类型，状态会被自动假定为动态类型。</p></blockquote><p id="eaf6" class="pw-post-body-paragraph jp jq hi jr b js mb ju jv jw mc jy jz ka md kc kd ke me kg kh ki mf kk kl km hb bi translated">就这么简单，我们已经创建了我们的cubit，我们希望它有一个整数状态，但是当没有掷骰子的时候就为null。我们可以继续在我们的应用程序中使用它。</p><p id="f558" class="pw-post-body-paragraph jp jq hi jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hb bi translated">这个想法是这样的，我们有一个蓝色的骰子(实际上它只是一个蓝色的方块:-)，当点击它时，它会向我们显示骰子的任意一面(显示1-6范围内的任何数字)，最初在任何点击之前，我们希望提示用户点击。首先，就像inheritedWidgets和Providers一样，为了能够使用我们创建的任何cubit，我们需要将它注入到widget树中的一个点上，该点对于我们提供的widget是可访问的。在我们的例子中，我们使用名为BlocProvider的flutter_bloc库中的小部件，将它注入MyApp小部件中。T3】</p><blockquote class="lr"><p id="4abc" class="ls lt hi bd lu lv mg mh mi mj mk km dx translated">BlocProvider接受一个[Create]函数，该函数负责创建[Bloc]或[Cubit]以及一个[child],该函数将通过BlocProvider.of(context)访问实例。它被用作一个依赖注入(DI)小部件，因此一个[Bloc]或[Cubit]的单个实例可以提供给一个子树中的多个小部件。</p></blockquote><p id="69a9" class="pw-post-body-paragraph jp jq hi jr b js mb ju jv jw mc jy jz ka md kc kd ke me kg kh ki mf kk kl km hb bi translated">因此，将创建和提供我们的Cubit放在MyApp小部件中意味着它下面的每个小部件都可以访问Cubit。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lq"><img src="../Images/ca8fa20c542c809269c1d99d3e3c1787.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zOZzLk0RJbg4QzhB3SMMXQ.png"/></div></div></figure><p id="dca3" class="pw-post-body-paragraph jp jq hi jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hb bi translated">在这之后，我们继续使用我们的肘。我们可以像这样使用小部件BlocBuilder来使用它</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lq"><img src="../Images/56a50fbcc64626bc4498783d57cbf4a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YoPGxcOujQR8sihn7Llsew.png"/></div></div></figure><p id="08c3" class="pw-post-body-paragraph jp jq hi jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hb bi translated">或者使用上下文中的扩展，这些扩展为我们提供了读取、观察和选择等方法。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lq"><img src="../Images/58524fd7b2c70dd36ad30aba43bcd0d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0LiaZeEs6DuPM7tvAwveEg.png"/></div></div><figcaption class="ml mm et er es mn mo bd b be z dx translated">使用扩展方法观察</figcaption></figure><p id="5105" class="pw-post-body-paragraph jp jq hi jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hb bi translated"><strong class="jr hj"> <em class="kq">但是你可能会问它们为什么不一样？</em> </strong></p><ul class=""><li id="ec27" class="kv kw hi jr b js jt jw jx ka kx ke ky ki kz km mp lb lc ld bi translated">这是对我们应用程序性能的主要限制，以确保我们尽可能利用最少数量的小部件重建，因此能够限制只对必要的小部件进行重建将对性能有很大帮助。因此，如果您有一个独立的小部件，它完全依赖于Cubit提供的状态，因此如果状态发生变化，它总是会被重新构建，那么使用context.watch是一个不错的选择。但是，如果您有一个较大的小部件，而该小部件只有某一部分依赖于Cubit/bloc，那么使用BlocBuilder将重新构建限制在该小部件上是合适的。</li><li id="1cfb" class="kv kw hi jr b js le jw lf ka lg ke lh ki li km mp lb lc ld bi translated">BlocBuilder是专门为管理块的生命周期而构建的，因此非常适合在小部件树中使用，除非您希望在函数中使用state或Cubit/bloc，例如在onTap中，扩展方法将派上用场，或者需要范围重建的特定小部件依赖于超过1 cuit/bloc，在这种情况下您需要使用一些东西。</li></ul><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es mq"><img src="../Images/50726daf2eebca5edebe370348baa635.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Vt1IH8eh1U5U75IQV9Ce7A.png"/></div></div><figcaption class="ml mm et er es mn mo bd b be z dx translated">主体中包含多个状态的构建器的示例</figcaption></figure><p id="f897" class="pw-post-body-paragraph jp jq hi jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hb bi translated">现在让我们回到正题上来，好吗？T11】😅</p><p id="a61d" class="pw-post-body-paragraph jp jq hi jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hb bi translated">所以我们在小部件上使用了Cubit，但是如果我们意识到，我们没有办法改变这个值，那么，我们该怎么做呢？</p><p id="05ae" class="pw-post-body-paragraph jp jq hi jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hb bi translated">在我们的cubit中，我们希望能够产生一个新的状态，幸运的是，有一个暴露的状态变量供我们使用，不幸的是，我们不能到处给状态变量分配新的状态值，因为，这个暴露的状态变量实际上是一个引擎盖下的getter，这意味着，我们只能读取它的值，而不能直接设置新的值。这是有意义的，因为我们希望每当我们设置一个新的状态时，我们希望它通知所有使用该状态的区域它已经被更新，以防需要重建，然后提供新的更新值，对于那些使用过ChangeNotifiers的人，你会意识到要做到这一点，我们更新状态，然后调用函数“notifyListeners”来为我们做这项工作。相反，bloc库为我们处理这个问题，并为我们提供了一个名为emit的方法，这个emit方法，正如它所说的那样，向所有侦听它的人发出一个新状态，如果发出的状态与以前的状态相同，则不做任何事情，这实际上帮助我们在没有明显变化时防止不必要的重建。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lq"><img src="../Images/c60b0d980b105dc8031de0c0e5de4ae2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I9jgfHizz0mW585eI2uhgw.png"/></div></div></figure><p id="84c7" class="pw-post-body-paragraph jp jq hi jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hb bi translated">然后，我们更新onTap方法，在点击时调用rollDice方法</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lq"><img src="../Images/331ea15e5930fbe78a8578ffb1f09729.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HphT9MQzzpqWpxdeJHuz5g.png"/></div></div></figure><p id="e188" class="pw-post-body-paragraph jp jq hi jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hb bi translated">所以我们完成了，我们已经探索了Cubit类，并向flutter_bloc介绍了我们自己。你可以在下面找到完整的工作代码。在下一篇文章中，我们将深入探讨bloc类，它是如何从Cubit升级的，以及如何充分利用Bloc包。</p><p id="60f7" class="pw-post-body-paragraph jp jq hi jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hb bi translated"><a class="ae ku" href="https://github.com/kefeh/bloc_example/blob/main/lib/main.dart" rel="noopener ugc nofollow" target="_blank">https://github . com/kefeh/bloc _ example/blob/main/lib/main . dart</a></p><p id="c46d" class="pw-post-body-paragraph jp jq hi jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hb bi translated">感谢阅读。</p></div></div>    
</body>
</html>