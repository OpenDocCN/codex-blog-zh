<html>
<head>
<title>Java Stream Custom Collector</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java流自定义收集器</h1>
<blockquote>原文：<a href="https://medium.com/codex/java-stream-custom-collector-376409c7af4?source=collection_archive---------2-----------------------#2021-09-12">https://medium.com/codex/java-stream-custom-collector-376409c7af4?source=collection_archive---------2-----------------------#2021-09-12</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/b8a6150b86e5f9d026a65613414fc772.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xBXV32ryrjoUzSgFlpGx3w.jpeg"/></div></div></figure><div class=""/><p id="e9f4" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">毫无疑问，<em class="jo">流</em>是添加到Java 8中的主要特性之一。如果您不知道什么是流，那么流就是支持对元素进行函数式操作的一系列对象，例如使用管道方法对集合进行map-reduce转换。你可以从甲骨文文档中获得更多信息。</p><figure class="jr js jt ju fd hk er es paragraph-image"><div class="er es jq"><img src="../Images/ef63bcd7fdd73735f3b71b07c82b08f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Qc8dTs7Uxg3OrZP_l4_oXA.png"/></div></figure><p id="2cae" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在本文中，我们将关注如何利用收集器接口并创建我们自己的自定义实现。一开始看起来可能有点复杂，但是一旦你明白了，你就会发现它非常有用。</p><h2 id="6e61" class="jv jw ht bd jx jy jz ka kb kc kd ke kf jb kg kh ki jf kj kk kl jj km kn ko kp bi translated">要求:</h2><p id="11da" class="pw-post-body-paragraph iq ir ht is b it kq iv iw ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn hb bi translated">了解Java 8、流和函数式编程。</p><h2 id="a7d2" class="jv jw ht bd jx jy jz ka kb kc kd ke kf jb kg kh ki jf kj kk kl jj km kn ko kp bi translated">什么时候用？</h2><p id="7f80" class="pw-post-body-paragraph iq ir ht is b it kq iv iw ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn hb bi translated">学习这个主题的最佳方式是通过示例，但首先，让我与您分享几个用例，然后我们可以一步一步地实现一个示例。</p><p id="5a9c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu"> <em class="jo">聚合</em> </strong>是自定义收集器使用最多的场景之一。尽管在Stream API中有预定义的方法来进行现成的聚合，但是您可能需要使用自己的特定业务需求来进行一些更复杂的聚合，这是非常常见的。聚合的输出可以是一个对象，也可以是根据您的要求分组的对象列表。</p><p id="75b6" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu"> <em class="jo">转换&amp;丰富</em> </strong>是您可以考虑利用自定义收集器的另一个用例。当然，在集合框架中有很多其他的工具可以帮助你。我想你会发现收集器是浓缩和转化过程的强有力的解决方案。</p><p id="490c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您可能会说所有这些都可以通过SQL来完成，这是真的，但是您会发现自己处于这样的情况下，运行复杂且昂贵的聚合和丰富查询可以通过使用这种方法来轻松避免。</p><h1 id="f219" class="kv jw ht bd jx kw kx ky kb kz la lb kf lc ld le ki lf lg lh kl li lj lk ko ll bi translated">收集器接口</h1><p id="b9ed" class="pw-post-body-paragraph iq ir ht is b it kq iv iw ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn hb bi translated">得益于<a class="ae jp" href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Collector.html" rel="noopener ugc nofollow" target="_blank">收集器接口</a>，所有这些都成为可能。这个接口是Java 8作为新的流API的一部分提供的。</p><pre class="jr js jt ju fd lm ln lo lp aw lq bi"><span id="019a" class="jv jw ht ln b fi lr ls l lt lu">Interface Collector&lt;T,A,R&gt; </span></pre><ul class=""><li id="0061" class="lv lw ht is b it iu ix iy jb lx jf ly jj lz jn ma mb mc md bi translated"><code class="du me mf mg ln b">T</code> —用于归约操作的流中输入元素的类型</li><li id="9bd3" class="lv lw ht is b it mh ix mi jb mj jf mk jj ml jn ma mb mc md bi translated"><code class="du me mf mg ln b">A</code> —归约运算的可变累加类型(通常隐藏为实现细节)</li><li id="b42b" class="lv lw ht is b it mh ix mi jb mj jf mk jj ml jn ma mb mc md bi translated"><code class="du me mf mg ln b">R</code> -归约操作的结果类型</li></ul><p id="9e53" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个接口有4个主要方法，它们一起工作，将条目累积到一个可变的结果容器中。他们的职责如下:</p><ul class=""><li id="ba36" class="lv lw ht is b it iu ix iy jb lx jf ly jj lz jn ma mb mc md bi translated"><code class="du me mf mg ln b">supplier()</code>:创建新的结果容器</li><li id="7e73" class="lv lw ht is b it mh ix mi jb mj jf mk jj ml jn ma mb mc md bi translated"><code class="du me mf mg ln b">accumulator()</code>:将新的数据元素合并到结果容器中。</li><li id="e4c5" class="lv lw ht is b it mh ix mi jb mj jf mk jj ml jn ma mb mc md bi translated"><code class="du me mf mg ln b">combiner()</code>:将两个结果容器合二为一。</li><li id="3a38" class="lv lw ht is b it mh ix mi jb mj jf mk jj ml jn ma mb mc md bi translated"><code class="du me mf mg ln b">finisher()</code>:对容器执行可选的最终变换</li></ul><h1 id="dbd8" class="kv jw ht bd jx kw kx ky kb kz la lb kf lc ld le ki lf lg lh kl li lj lk ko ll bi translated">自定义收集器示例</h1><h2 id="41b4" class="jv jw ht bd jx jy jz ka kb kc kd ke kf jb kg kh ki jf kj kk kl jj km kn ko kp bi translated">聚合示例</h2><p id="c3d8" class="pw-post-body-paragraph iq ir ht is b it kq iv iw ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn hb bi translated">假设您有一个用户事务列表，并且您想创建一个对象来包装该列表，并使用stream和您自己的定制收集器添加一些附加信息，如平均金额、最大金额和最近的事务日期。(为了简化，我们使用了Lombok库中的@data和@ToString)</p><pre class="jr js jt ju fd lm ln lo lp aw lq bi"><span id="fc00" class="jv jw ht ln b fi lr ls l lt lu">@Data<br/>@ToString<br/><strong class="ln hu">public class </strong>Transaction {<br/>    <strong class="ln hu">private </strong>Long <strong class="ln hu">id</strong>;<br/>    <strong class="ln hu">private </strong>Long <strong class="ln hu">userId</strong>;<br/>    <strong class="ln hu">private </strong>BigDecimal <strong class="ln hu">amount </strong>= BigDecimal.<strong class="ln hu"><em class="jo">ZERO</em></strong>;<br/>    <strong class="ln hu">private </strong>Date <strong class="ln hu">dateTime</strong>;<br/>}</span></pre><p id="9e8a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是我们希望在输出中得到的聚合对象:</p><pre class="jr js jt ju fd lm ln lo lp aw lq bi"><span id="e1db" class="jv jw ht ln b fi lr ls l lt lu">@Data<br/>@ToString<br/><strong class="ln hu">public class </strong>TransactionAggregation {<br/>    <strong class="ln hu">private </strong>BigDecimal <strong class="ln hu">average </strong>= BigDecimal.<strong class="ln hu"><em class="jo">ZERO</em></strong>;<br/>    <strong class="ln hu">private </strong>BigDecimal <strong class="ln hu">total </strong>= BigDecimal.<strong class="ln hu"><em class="jo">ZERO</em></strong>;<br/>    <strong class="ln hu">private </strong>BigDecimal <strong class="ln hu">max </strong>= BigDecimal.<strong class="ln hu"><em class="jo">ZERO</em></strong>;<br/>    <strong class="ln hu">private </strong>Date <strong class="ln hu">lastTransactionDate</strong>;<br/>    <strong class="ln hu">private </strong>List&lt;Transaction&gt; <strong class="ln hu">transactionList </strong>= <strong class="ln hu">new </strong>ArrayList&lt;&gt;();<br/>}</span></pre><p id="3c2b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们不能基于之前分享的知识开始创建自己的收集器接口实现。</p><pre class="jr js jt ju fd lm ln lo lp aw lq bi"><span id="319a" class="jv jw ht ln b fi lr ls l lt lu"><strong class="ln hu">public class </strong>TransactionAggregationCollector <strong class="ln hu">implements </strong>Collector&lt;<strong class="ln hu">Transaction</strong>, <strong class="ln hu">TransactionAggregation</strong>, <strong class="ln hu">TransactionAggregation</strong>&gt; {<br/>// implementation can find <br/>}</span></pre><p id="618a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如你所见，我们有<code class="du me mf mg ln b">Transaction</code>类作为<code class="du me mf mg ln b">T</code>，所以我们的实现将会期待一个事务对象流。对于<code class="du me mf mg ln b">A</code>和<code class="du me mf mg ln b">R</code>，我们使用<code class="du me mf mg ln b">TransactionAggregation</code>，这意味着我们的中间和结果对象将使用这种类型。</p><pre class="jr js jt ju fd lm ln lo lp aw lq bi"><span id="e83d" class="jv jw ht ln b fi lr ls l lt lu">@Override<br/><strong class="ln hu">public </strong>Supplier&lt;TransactionAggregation&gt; supplier() {<br/>    <strong class="ln hu">return </strong>() -&gt; <strong class="ln hu">new </strong>TransactionAggregation();<br/>}</span></pre><p id="c5e7" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们需要实现的第一个方法是supplier方法，这将有助于创建一个新的容器结果。在我们的例子中，它是一个新的<code class="du me mf mg ln b">TransactionAggregation</code>对象。</p><blockquote class="mm mn mo"><p id="1c09" class="iq ir jo is b it iu iv iw ix iy iz ja mp jc jd je mq jg jh ji mr jk jl jm jn hb bi translated"><strong class="is hu">注意:</strong>()-&gt;lambda表达式帮助我们实现供应商函数接口，这是供应商方法的返回类型。更多信息请参见<a class="ae jp" href="https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html" rel="noopener ugc nofollow" target="_blank">λ</a>和<a class="ae jp" href="https://docs.oracle.com/javase/8/docs/api/java/util/function/package-summary.html" rel="noopener ugc nofollow" target="_blank">功能接口</a>概念。</p></blockquote><pre class="jr js jt ju fd lm ln lo lp aw lq bi"><span id="a55a" class="jv jw ht ln b fi lr ls l lt lu">@Override<br/><strong class="ln hu">public </strong>BiConsumer&lt;TransactionAggregation, Transaction&gt; accumulator() {  <br/>        <em class="jo">// ta is same </em>TransactionAggregation object from supplier<br/>        <em class="jo">// t is each transaction item from the stream<br/>        </em><strong class="ln hu">return </strong>(ta, t) -&gt; {</span><span id="21fb" class="jv jw ht ln b fi ms ls l lt lu"><em class="jo">// Add transaction to result transaction list<br/>        </em>ta.getTransactionList().add(t);<br/><br/>        <em class="jo">// Get the Max<br/>        </em><strong class="ln hu">if</strong>( ta.getMax().compareTo(t.getAmount()) == -1 )<br/>            ta.setMax(t.getAmount());<br/><br/>        <em class="jo">// Find the latest Transaction Date<br/>        </em><strong class="ln hu">if</strong>( ta.getLastTransactionDate() == <strong class="ln hu">null </strong>){<br/>            ta.setLastTransactionDate(t.getDateTime());<br/>        } <strong class="ln hu">else if</strong>( ta.getLastTransactionDate().compareTo(t.getDateTime()) &lt; 0 ){<br/>            ta.setLastTransactionDate(t.getDateTime());<br/>        }<br/><br/>        <em class="jo">// Calculate Total amount<br/>        </em>ta.setTotal( t.getAmount().add(ta.getTotal()) );</span><span id="5d23" class="jv jw ht ln b fi ms ls l lt lu">       // Calculate Average <br/>       ta.setAverage(ta.getTotal()<br/>  .divide(new BigDecimal(ta.getTransactionList().size())));</span><span id="fbc6" class="jv jw ht ln b fi ms ls l lt lu">    };<br/>}</span></pre><p id="d26e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">累加器方法有助于我们进行聚合。只要流中有元素，实现就会重复运行。</p><blockquote class="mm mn mo"><p id="a1a9" class="iq ir jo is b it iu iv iw ix iy iz ja mp jc jd je mq jg jh ji mr jk jl jm jn hb bi translated"><a class="ae jp" href="https://docs.oracle.com/javase/8/docs/api/java/util/function/BiConsumer.html" rel="noopener ugc nofollow" target="_blank">双消费</a>为功能界面；它接受两个参数，不返回任何内容。</p></blockquote><pre class="jr js jt ju fd lm ln lo lp aw lq bi"><span id="4288" class="jv jw ht ln b fi lr ls l lt lu">@Override<br/><strong class="ln hu">public </strong>BinaryOperator&lt;TransactionAggregation&gt; combiner() {<br/>    <strong class="ln hu">return </strong>(ta1, ta2) -&gt; {<br/><br/>        <strong class="ln hu">if</strong>( ta1.getMax().compareTo(ta2.getMax()) == -1 )<br/>            ta1.setMax(ta2.getMax());<br/><br/>        ta1.setAverage( ta1.getAverage()<br/>                .add(ta2.getAverage())<br/>                .divide(<strong class="ln hu">new </strong>BigDecimal(2)) );<br/><br/>        ta1.setTotal( ta1.getTotal().add(ta2.getTotal()) );<br/><br/>       <strong class="ln hu">if</strong>( ta1.getLastTransactionDate().compareTo(ta2.getLastTransactionDate()) &lt; 0 )<br/>            ta1.setLastTransactionDate(ts2.getLastTransactionDate());<br/><br/>        <strong class="ln hu">return </strong>ta1;<br/>    };<br/>}</span></pre><p id="8603" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果您熟悉Stream API，您很可能听说过或使用过parallelStream()。它帮助您在并行线程中处理流。但是最后需要结合各个线程的结果。<code class="du me mf mg ln b">combiner()</code>方法将用于将两个线程的两个结果合并成一个对象。因此，如您所见，该实现实际上包含了组合到TransactionAggregation对象的逻辑。</p><blockquote class="mm mn mo"><p id="b8c2" class="iq ir jo is b it iu iv iw ix iy iz ja mp jc jd je mq jg jh ji mr jk jl jm jn hb bi translated"><a class="ae jp" href="https://docs.oracle.com/javase/8/docs/api/java/util/function/BinaryOperator.html" rel="noopener ugc nofollow" target="_blank"> BinaryOperator </a>表示对两个相同类型的操作数进行运算，产生与操作数相同类型的结果。对于操作数和结果都是同一类型的情况，这是对<code class="du me mf mg ln b"><a class="ae jp" href="https://docs.oracle.com/javase/8/docs/api/java/util/function/BiFunction.html" rel="noopener ugc nofollow" target="_blank">BiFunction</a></code>的专门化。</p></blockquote><pre class="jr js jt ju fd lm ln lo lp aw lq bi"><span id="33bb" class="jv jw ht ln b fi lr ls l lt lu">@Override<br/><strong class="ln hu">public </strong>Function&lt;TransactionAggregation, TransactionAggregation&gt; finisher() {<br/>    <strong class="ln hu">return </strong>(transactionAggregation) -&gt;{<br/>        <strong class="ln hu">return </strong>transactionAggregation;<br/>    };<br/>}</span></pre><p id="ab5c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du me mf mg ln b">finisher()</code>是返回最终结果的方法，它将在流管道的末端传递给调用者。</p><blockquote class="mm mn mo"><p id="1520" class="iq ir jo is b it iu iv iw ix iy iz ja mp jc jd je mq jg jh ji mr jk jl jm jn hb bi translated"><a class="ae jp" href="https://docs.oracle.com/javase/8/docs/api/java/util/function/Function.html" rel="noopener ugc nofollow" target="_blank">函数</a>表示接受一个参数并产生一个结果的函数。</p></blockquote><pre class="jr js jt ju fd lm ln lo lp aw lq bi"><span id="836e" class="jv jw ht ln b fi lr ls l lt lu">@Override<br/><strong class="ln hu">public </strong>Set&lt;Characteristics&gt; characteristics() {<br/>    <strong class="ln hu">return </strong>Collections.<em class="jo">emptySet</em>();<br/>}</span></pre><p id="1518" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">使用这种方法，您可以提供收集器的特征。在我们的例子中，我们返回的是一个空集。</p><blockquote class="mm mn mo"><p id="6977" class="iq ir jo is b it iu iv iw ix iy iz ja mp jc jd je mq jg jh ji mr jk jl jm jn hb bi translated">表示<code class="du me mf mg ln b">Collector</code>属性的特征，可用于优化归约实现。</p></blockquote><p id="ef69" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du me mf mg ln b"><a class="ae jp" href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Collector.Characteristics.html#CONCURRENT" rel="noopener ugc nofollow" target="_blank"><strong class="is hu">CONCURRENT</strong></a></code>表示这个收集器是<em class="jo">并发</em>的，意味着结果容器可以支持多个线程用同一个结果容器并发调用累加器函数。</p><p id="acea" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du me mf mg ln b"><a class="ae jp" href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Collector.Characteristics.html#IDENTITY_FINISH" rel="noopener ugc nofollow" target="_blank"><strong class="is hu">IDENTITY_FINISH</strong></a></code>表示整理器功能是同一性功能，可以省略。</p><p id="9820" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du me mf mg ln b"><a class="ae jp" href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Collector.Characteristics.html#UNORDERED" rel="noopener ugc nofollow" target="_blank"><strong class="is hu">UNORDERED</strong></a></code>表示收集操作不保证输入元素的相遇顺序。</p><pre class="jr js jt ju fd lm ln lo lp aw lq bi"><span id="7d9a" class="jv jw ht ln b fi lr ls l lt lu">TransactionAggregation transactionAggregation = transactionList.stream().collect(<strong class="ln hu">new TransactionAggregationCollector()</strong>);</span></pre><p id="174d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">正如您所看到的，使用collector非常简单，您只需要从事务列表中创建一个流，并使用自定义collector对象作为输入来调用collect方法。</p><h1 id="d0f4" class="kv jw ht bd jx kw kx ky kb kz la lb kf lc ld le ki lf lg lh kl li lj lk ko ll bi translated">结论</h1><p id="906e" class="pw-post-body-paragraph iq ir ht is b it kq iv iw ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn hb bi translated">如你所见，整个过程非常简单。当您开始使用时，您会注意到这个选项在不同的用例中是多么有用。</p><p id="f9ef" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您可以在<a class="ae jp" href="https://github.com/farzinpashaee/medium/tree/main/Java%20Stream%20Custom%20Collector" rel="noopener ugc nofollow" target="_blank"> Github </a>中找到示例源代码。</p></div></div>    
</body>
</html>