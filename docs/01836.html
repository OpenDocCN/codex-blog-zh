<html>
<head>
<title>From Hypervisors to Containers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从虚拟机管理程序到容器</h1>
<blockquote>原文：<a href="https://medium.com/codex/from-hypervisors-to-containers-11d3cc191ef6?source=collection_archive---------3-----------------------#2021-06-06">https://medium.com/codex/from-hypervisors-to-containers-11d3cc191ef6?source=collection_archive---------3-----------------------#2021-06-06</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/39335f8d10f84675d51534fbcaa35cfc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ZPeH0HE-XrFbaHcU"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae iu" href="https://unsplash.com/@inidianaa?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Tri Eptaroka Mardiana </a>拍摄的照片</figcaption></figure><p id="9b78" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="jt">“伟大的事情不是由冲动完成的，而是由一系列小事情汇集而成的。”――文森特·梵高</em></p><h1 id="81b9" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">回到过去</h1><p id="e004" class="pw-post-body-paragraph iv iw hi ix b iy ks ja jb jc kt je jf jg ku ji jj jk kv jm jn jo kw jq jr js hb bi translated">过去，开发一个应用程序后，一个单独的团队会配置一台单独的机器、路由器、交换机，将它们放入机架，然后取出应用程序并进行安装。这有时需要手动操作，并且需要在服务器群中安装一长串经过处理的专用硬件。并且主要在用于一个应用程序的一个服务器上，这有时会造成资源浪费。尽管它可以在同一台服务器上部署多个应用程序，但这是非常不安全的。</p><h1 id="3254" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">虚拟机管理程序</h1><p id="762e" class="pw-post-body-paragraph iv iw hi ix b iy ks ja jb jc kt je jf jg ku ji jj jk kv jm jn jo kw jq jr js hb bi translated">由于物理硬件资源的浪费，虚拟机管理程序作为一种共享计算机资源(包括内存和进程)的解决方案应运而生。虚拟机管理程序的作用是基于主机硬件创建隔离的环境，这允许在同一服务器/主机内创建多个独立的虚拟环境。</p><p id="956a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这增加了应用程序的可移植性和额外的安全性，因为一个虚拟机是独立于另一个虚拟机运行的。一个虚拟机包含完整的组件和依赖项，包括它自己的操作系统(<em class="jt">n</em>VMs =<em class="jt">n</em>OS)。</p><p id="d934" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">有两种类型的虚拟机管理程序</p><ol class=""><li id="6c4f" class="kx ky hi ix b iy iz jc jd jg kz jk la jo lb js lc ld le lf bi translated"><strong class="ix hj">裸机虚拟机管理程序</strong>——直接在硬件上运行。<br/> <em class="jt">前Citrix XenServer，VMware ESXi。</em></li><li id="33f0" class="kx ky hi ix b iy lg jc lh jg li jk lj jo lk js lc ld le lf bi translated"><strong class="ix hj">托管的虚拟机管理程序</strong>——运行在主机的操作系统之上。<br/> <em class="jt"> Ex — Oracle VirtualBox、微软Hyper-V. </em></li></ol><p id="0352" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">虽然虚拟机管理程序带来了应用程序的隔离、更好的资源管理，但虚拟机管理程序仍然消耗资源，更新和补丁管理应该完成。</p><figure class="lm ln lo lp fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ll"><img src="../Images/936c3fd9e162db78ac64caf4adc9293c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oF6QqYRhWPw9HF20CUqhMw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">在虚拟机管理程序上运行应用程序(图片来自<a class="ae iu" href="https://www.docker.com/sites/default/files/d8/2018-11/container-vm-whatcontainer_2.png" rel="noopener ugc nofollow" target="_blank"> Docker </a></figcaption></figure><h1 id="83e0" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">容器</h1><p id="d668" class="pw-post-body-paragraph iv iw hi ix b iy ks ja jb jc kt je jf jg ku ji jj jk kv jm jn jo kw jq jr js hb bi translated">容器是运行应用程序所必需的组件和依赖关系的单元，与操作系统或运行环境无关，并且与虚拟机不同，容器作为单独的进程而不是单独的机器运行。</p><p id="e7c3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">尽管人们认为容器是所有问题的最新解决方案，但这并不是新技术。根据<a class="ae iu" href="https://d2iq.com/blog/brief-history-containers" rel="noopener ugc nofollow" target="_blank">报道</a>容器作为Unix操作系统隔离应用程序代码的一种机制早在1970年就存在了。</p><p id="2029" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">此外，在深入研究容器之前，有一些关于容器的基本概念需要理解。</p><p id="4766" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">名称空间</strong>——“名称空间”是Linux操作系统为确保容器中的隔离而提出的东西，每个容器创建一个单独的名称空间，<em class="jt">限制该容器可以查看的内容</em>。</p><p id="0c29" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> cgroups </strong> -控制组是l <em class="jt">限制具体容器可以使用的容器。</em></p><p id="2343" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">容器开始广泛使用<a class="ae iu" href="https://chamalwr.medium.com/microservice-architecture-1ac57a5445cc" rel="noopener">微服务架构</a>。它提供了独立构建和部署的能力，而不必一次又一次地进行相同的服务器配置或网络配置，并根据需求处理可扩展性。</p><p id="3d81" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">与VMs不同，容器没有什么优势。</p><p id="575d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">标准</strong> -创建虚拟机时，设置可能会有所不同，环境取决于供应商。但是当谈到容器时<a class="ae iu" href="https://opencontainers.org/" rel="noopener ugc nofollow" target="_blank">开放容器倡议</a>提供了一个监控容器的通用标准，这有助于容器的可移植性，而不必担心供应商、运行的操作系统或环境。</p><p id="4b04" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">轻量级</strong> -在虚拟机中，当创建一个虚拟机时，每个虚拟机都必须有一个单独的操作系统。但是对于容器来说，它的核心引擎与所有其他正在运行的容器共享操作系统内核。这在尺寸和性能方面都非常有效。</p><p id="1bea" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">安全</strong> -容器作为一个完全独立的进程运行它的应用程序，这提供了彼此之间的隔离。</p><figure class="lm ln lo lp fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lq"><img src="../Images/5450cada33eaf69d8495e9957af32ed1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bOrphmm1BtsoUc9rND7lmw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">在容器上运行应用程序(图片来自<a class="ae iu" href="https://www.docker.com/sites/default/files/d8/styles/large/public/2018-11/container-what-is-container.png?itok=vle7kjDj" rel="noopener ugc nofollow" target="_blank"> Docker </a></figcaption></figure><p id="561a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但是如何找到这些容器呢？基于不同的供应商，开发者可以选择各种各样的容器应用程序。Docker、rkt (Rocket)、LXC(Linux Containers)和Docker是其中最受欢迎的。</p><h1 id="c362" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">码头工人</h1><p id="d0ba" class="pw-post-body-paragraph iv iw hi ix b iy ks ja jb jc kt je jf jg ku ji jj jk kv jm jn jo kw jq jr js hb bi translated">Docker是软件开发人员中最流行的容器应用程序。Docker架构为开发人员带来了许多便利，包括CI/CI周期的完全自动化。</p><h2 id="8ca5" class="lr jv hi bd jw ls lt lu ka lv lw lx ke jg ly lz ki jk ma mb km jo mc md kq me bi translated">Docker对象</h2><ol class=""><li id="e22b" class="kx ky hi ix b iy ks jc kt jg mf jk mg jo mh js lc ld le lf bi translated"><strong class="ix hj"> Docker Image </strong> - Docker image是一个创建工作Docker容器的模板。开发人员可以根据他们运行的应用程序定制Docker图像。举个例子，如果我们想创建一个docker映像来运行一个Java应用程序，我们必须在docker映像中安装操作系统库、Java运行时，甚至是我们的Java应用程序。Docker镜像是可定制的，可以改变其中包含的运行应用程序的一切(代码、系统库、配置、运行时)</li><li id="8cea" class="kx ky hi ix b iy lg jc lh jg li jk lj jo lk js lc ld le lf bi translated"><strong class="ix hj"> docker容器</strong>——在创建一个它应该执行的docker映像之后，这个运行的Docker映像被称为“Docker容器”。docker容器可以使用Docker API或CLI启动、停止、移除或删除。Docker容器由Docker图像定义。</li></ol><h2 id="92ea" class="lr jv hi bd jw ls lt lu ka lv lw lx ke jg ly lz ki jk ma mb km jo mc md kq me bi translated">码头建筑</h2><p id="c588" class="pw-post-body-paragraph iv iw hi ix b iy ks ja jb jc kt je jf jg ku ji jj jk kv jm jn jo kw jq jr js hb bi translated">从创建图像到管理容器并跟踪它们应该在一个适当的过程中。Docker架构展示了如何基于客户机-服务器架构处理这些流程。</p><figure class="lm ln lo lp fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mi"><img src="../Images/b651b95ca71ee878aea78e1fc823c611.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cwVMGBA4NX_NKL6hXX93yA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">Docker架构(图片来自<a class="ae iu" href="https://docs.docker.com/get-started/overview/" rel="noopener ugc nofollow" target="_blank"> Docker </a>)</figcaption></figure><p id="4a8c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Docker客户端转发客户端请求并与Docker守护进程对话，通常，这是人们与之交互的CLI界面。</p><p id="ef13" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">docker守护进程处理来自Docker客户端的所有请求，并创建、删除和运行所有Docker映像和容器。Docker守护进程甚至可以与远程守护进程通信。</p><p id="e81a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">docker registry就像是Docker图像的存储库，在开发人员创建各种Docker图像和同一图像的各种版本后，Docker registry负责处理和存储它们。默认情况下，“Docker Hub”被用作公共Docker注册中心，但在需要时也可以使用私有注册中心。</p><p id="4a19" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">同样，当涉及到docker映像时，Docker守护进程负责检查本地缓存中的Docker映像，如果没有，则从远程Docker注册表中提取映像。</p><p id="d6b0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">有关开发基于容器的应用程序的更多信息，请参考下面的参考资料。</p></div><div class="ab cl mj mk gp ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="hb hc hd he hf"><h1 id="2690" class="ju jv hi bd jw jx mq jz ka kb mr kd ke kf ms kh ki kj mt kl km kn mu kp kq kr bi translated">参考</h1><p id="091c" class="pw-post-body-paragraph iv iw hi ix b iy ks ja jb jc kt je jf jg ku ji jj jk kv jm jn jo kw jq jr js hb bi translated">开发基于容器的应用程序(教程)-第1部分</p><p id="fed2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><a class="ae iu" href="https://www.youtube.com/watch?v=hXLmW7bhA10&amp;list=PLD-mYtebG3X9HaZ1T39-aF4ghEtWy9-v3&amp;index=2" rel="noopener ugc nofollow" target="_blank">开发基于容器的应用程序(教程)——第2部分</a></p><div class="mv mw ez fb mx my"><a href="https://docs.docker.com/get-started/overview/" rel="noopener  ugc nofollow" target="_blank"><div class="mz ab dw"><div class="na ab nb cl cj nc"><h2 class="bd hj fi z dy nd ea eb ne ed ef hh bi translated">Docker概述</h2><div class="nf l"><h3 class="bd b fi z dy nd ea eb ne ed ef dx translated">Docker是一个开发、发布和运行应用程序的开放平台。Docker使您能够分离您的…</h3></div><div class="ng l"><p class="bd b fp z dy nd ea eb ne ed ef dx translated">docs.docker.com</p></div></div><div class="nh l"><div class="ni l nj nk nl nh nm io my"/></div></div></a></div></div></div>    
</body>
</html>