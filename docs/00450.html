<html>
<head>
<title>Kubernetes Patterns: 2. Declarative Deployment</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">库伯内特图案:2。声明性部署</h1>
<blockquote>原文：<a href="https://medium.com/codex/kubernetes-patterns-2-declarative-deployment-51a5375b4dc7?source=collection_archive---------3-----------------------#2021-02-05">https://medium.com/codex/kubernetes-patterns-2-declarative-deployment-51a5375b4dc7?source=collection_archive---------3-----------------------#2021-02-05</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/2b09468a60772b5c4cacb310499ca12a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a-hUbQCihsY1DbeWHOrL4g.jpeg"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">照片由<a class="ae hv" href="https://www.pexels.com/" rel="noopener ugc nofollow" target="_blank">像素</a>上的<a class="ae hv" href="https://www.pexels.com/@pixabay" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>拍摄</figcaption></figure><h2 id="f64d" class="hw hx hy bd b fp hz ia ib ic id ie dx if translated" aria-label="kicker paragraph"><a class="ae ge" href="http://medium.com/codex" rel="noopener">抄本</a></h2><div class=""/><p id="ad1d" class="pw-post-body-paragraph je jf hy jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated"><strong class="jg ii"> <em class="kc"> Kubernetes模式</em> </strong>和设计模式一样，将Kubernetes原语抽象成一些可重复的解决问题的方案。</p><h1 id="577f" class="kd ke hy bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">前置</h1><ul class=""><li id="f710" class="lb lc hy jg b jh ld jl le jp lf jt lg jx lh kb li lj lk ll bi translated"><a class="ae hv" href="https://rocky-chen.medium.com/learning-kubernetes-patterns-0-introduction-288f9f7ee787" rel="noopener"> Kubernetes图案:0。简介</a></li><li id="7c80" class="lb lc hy jg b jh lm jl ln jp lo jt lp jx lq kb li lj lk ll bi translated"><a class="ae hv" rel="noopener" href="/codex/kubernetes-patterns-1-predictable-demands-e64cf804d96d"> Kubernetes图案:1。可预测的需求</a></li></ul></div><div class="ab cl lr ls gp lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="hb hc hd he hf"><p id="8b51" class="pw-post-body-paragraph je jf hy jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">本文将介绍<strong class="jg ii"> <em class="kc">声明式部署</em> </strong>模式，主要关注Kubernetes的部署资源。将讨论以下几点:</p><ul class=""><li id="53df" class="lb lc hy jg b jh ji jl jm jp ly jt lz jx ma kb li lj lk ll bi translated">滚动更新</li><li id="6def" class="lb lc hy jg b jh lm jl ln jp lo jt lp jx lq kb li lj lk ll bi translated">固定更新</li><li id="381f" class="lb lc hy jg b jh lm jl ln jp lo jt lp jx lq kb li lj lk ll bi translated">蓝绿色释放</li><li id="83dd" class="lb lc hy jg b jh lm jl ln jp lo jt lp jx lq kb li lj lk ll bi translated">金丝雀释放</li></ul><h1 id="dda9" class="kd ke hy bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">什么是声明式部署模式？</h1><p id="b5da" class="pw-post-body-paragraph je jf hy jg b jh ld jj jk jl le jn jo jp mb jr js jt mc jv jw jx md jz ka kb hb bi translated"><strong class="jg ii"> <em class="kc">声明式部署</em> </strong>模式封装了一组容器的升级和回滚过程，并使其执行成为可重复的自动化活动。</p></div><div class="ab cl lr ls gp lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="hb hc hd he hf"><h1 id="b42b" class="kd ke hy bd kf kg me ki kj kk mf km kn ko mg kq kr ks mh ku kv kw mi ky kz la bi translated">为什么要用？</h1><p id="ba5c" class="pw-post-body-paragraph je jf hy jg b jh ld jj jk jl le jn jo jp mb jr js jt mc jv jw jx md jz ka kb hb bi translated">为了实现高可用性，云原生应用程序或服务通常部署在多个pod中。如果部署过程是手动维护的，那么对于云管理员来说会很困难。</p><p id="f4fe" class="pw-post-body-paragraph je jf hy jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">将服务升级到较新的版本涉及几个活动，比如用较新的版本启动新的Pods，停止旧版本的Pods，验证新的Pods是否成功启动，以及如果需要的话回滚到旧版本。</p><p id="9dce" class="pw-post-body-paragraph je jf hy jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">如果自动控制和执行部署过程，则可以提高效率并避免人为误操作。</p><p id="7f01" class="pw-post-body-paragraph je jf hy jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">Kubernetes原始人的部署就是为了这个目的。它负责告诉Kubernetes应该如何更新您的应用程序，使用不同的策略并调整更新过程的许多方面。</p><p id="1bca" class="pw-post-body-paragraph je jf hy jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">换句话说，我们通过部署告诉Kubernetes我们想要的部署解决方案，然后Kubernetes负责所有剩余的工作并有效地完成任务。</p><p id="e186" class="pw-post-body-paragraph je jf hy jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated"><a class="ae hv" href="https://kubernetes.io/docs/concepts/overview/working-with-objects/object-management/" rel="noopener ugc nofollow" target="_blank"> <strong class="jg ii">祈使句与陈述句</strong> </a></p><p id="0abb" class="pw-post-body-paragraph je jf hy jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">正如模式名中提到的，声明性对象配置与命令性对象配置相比较。</p><p id="cd52" class="pw-post-body-paragraph je jf hy jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">当使用声明性对象配置时，比如部署，我们定义Kubernetes系统的期望状态，而不是操作。因此，部署带来了一些好处:</p><ul class=""><li id="42c0" class="lb lc hy jg b jh ji jl jm jp ly jt lz jx ma kb li lj lk ll bi translated">部署是Kubernetes内部管理的资源。</li><li id="8678" class="lb lc hy jg b jh lm jl ln jp lo jt lp jx lq kb li lj lk ll bi translated">部署显示状态而不是步骤。</li><li id="d878" class="lb lc hy jg b jh lm jl ln jp lo jt lp jx lq kb li lj lk ll bi translated">部署配置可以用版本控制系统来管理，比如github。</li></ul></div><div class="ab cl lr ls gp lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="hb hc hd he hf"><h1 id="5e83" class="kd ke hy bd kf kg me ki kj kk mf km kn ko mg kq kr ks mh ku kv kw mi ky kz la bi translated">怎么用？</h1><h2 id="208b" class="mj ke hy bd kf mk ml mm kj mn mo mp kn jp mq mr kr jt ms mt kv jx mu mv kz ie bi translated">部署</h2><p id="65da" class="pw-post-body-paragraph je jf hy jg b jh ld jj jk jl le jn jo jp mb jr js jt mc jv jw jx md jz ka kb hb bi translated"><em class="kc">部署</em>是一种在Kubernetes中安装或更新应用程序的声明式方法，因为它创建了一个带有标签选择器的副本集。一个<em class="kc">部署</em>的核心是能够可预测地启动或停止一组吊舱。</p><p id="c227" class="pw-post-body-paragraph je jf hy jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">因此，<em class="kc">部署</em>维护了在pod上运行的应用程序容器的生命周期，而容器本身也可以接收和处理生命周期事件(例如:SIGTERM)并提供健康检查状态，这将告诉Kubernetes它们是否成功启动。</p><p id="8830" class="pw-post-body-paragraph je jf hy jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">下面是<em class="kc">部署</em>的一个例子:</p><figure class="mw mx my mz fd hk"><div class="bz dy l di"><div class="na nb l"/></div></figure><p id="21b7" class="pw-post-body-paragraph je jf hy jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">在Kubernetes集群中安装应用程序之后，当发布新版本时，它们通常需要更新。然后，应该仔细考虑如何更新部署。</p><h2 id="88e0" class="mj ke hy bd kf mk ml mm kj mn mo mp kn jp mq mr kr jt ms mt kv jx mu mv kz ie bi translated">部署策略</h2><ul class=""><li id="f8a1" class="lb lc hy jg b jh ld jl le jp lf jt lg jx lh kb li lj lk ll bi translated"><strong class="jg ii">滚动更新</strong></li></ul><p id="1987" class="pw-post-body-paragraph je jf hy jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated"><a class="ae hv" href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#rolling-update-deployment" rel="noopener ugc nofollow" target="_blank">滚动更新</a>策略的目标是保证部署过程中的零停机时间。部署会创建一个新的副本集，逐渐停止旧副本集中的单元，并逐渐启动新副本集中的单元。</p><figure class="mw mx my mz fd hk"><div class="bz dy l di"><div class="na nb l"/></div></figure><p id="cece" class="pw-post-body-paragraph je jf hy jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">滚动更新策略确保总有一些pod在运行以工作或服务于传入的请求，因此服务没有停机时间。</p><figure class="mw mx my mz fd hk er es paragraph-image"><div class="er es nc"><img src="../Images/e8758efc75f82a8cbf4c7edde2e81312.png" data-original-src="https://miro.medium.com/v2/resize:fit:1342/format:webp/1*sg10epuxYyezecRpoyyU8g.png"/></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">滚动更新</figcaption></figure><ul class=""><li id="3629" class="lb lc hy jg b jh ji jl jm jp ly jt lz jx ma kb li lj lk ll bi translated"><strong class="jg ii">修复更新(重新创建)</strong></li></ul><p id="7eeb" class="pw-post-body-paragraph je jf hy jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">RollingUpdate是在不停机的情况下升级开发，但有时停机是不可避免的。</p><p id="344d" class="pw-post-body-paragraph je jf hy jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">RollingUpdate的副作用是在更新过程中可以同时存在两个版本的容器。这在大多数情况下应该没问题，但是当容器的新版本包含不兼容的更改，尤其是不兼容的API更改时，这可能就不好了。</p><p id="c893" class="pw-post-body-paragraph je jf hy jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">固定更新或<a class="ae hv" href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#recreate-deployment" rel="noopener ugc nofollow" target="_blank">重建</a>策略通过关闭旧版本的所有容器，然后同时启动新版本的容器来处理这种情况。</p><figure class="mw mx my mz fd hk er es paragraph-image"><div class="er es nc"><img src="../Images/fd2cee2bae4b8d2f3ec5874b764abdf7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1342/format:webp/1*NXBKm4r1K3pYsbbpcOL2FA.png"/></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">使用重新创建策略修复更新</figcaption></figure><p id="712d" class="pw-post-body-paragraph je jf hy jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">固定更新在更新期间引入了停机时间，但它同时只包含单一版本的容器。要实现重新创建部署，您只需在部署规范中将<code class="du nd ne nf ng b">.spec.strategy.type</code>设置为<code class="du nd ne nf ng b">Recreate</code>。</p><figure class="mw mx my mz fd hk"><div class="bz dy l di"><div class="na nb l"/></div></figure><p id="596b" class="pw-post-body-paragraph je jf hy jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">开发人员试图避免这样的变化，这不仅会导致应用程序更新期间的停机时间，还会在客户端和服务之间引入不稳定性。</p></div><div class="ab cl lr ls gp lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="hb hc hd he hf"><h1 id="b916" class="kd ke hy bd kf kg me ki kj kk mf km kn ko mg kq kr ks mh ku kv kw mi ky kz la bi translated">什么时候用？</h1><p id="2775" class="pw-post-body-paragraph je jf hy jg b jh ld jj jk jl le jn jo jp mb jr js jt mc jv jw jx md jz ka kb hb bi translated">在Kubernetes集群中也有一些其他的策略来更新云应用程序，用于各种目的。</p><h2 id="f13a" class="mj ke hy bd kf mk ml mm kj mn mo mp kn jp mq mr kr jt ms mt kv jx mu mv kz ie bi translated">蓝绿色释放</h2><p id="1a47" class="pw-post-body-paragraph je jf hy jg b jh ld jj jk jl le jn jo jp mb jr js jt mc jv jw jx md jz ka kb hb bi translated"><em class="kc">蓝绿</em>发布是一种应用程序发布策略，它可以通过运行两个副本集来减少停机时间和风险，一个副本集用于旧版本(称为<strong class="jg ii">蓝</strong>，而另一个副本集用于新版本(称为<strong class="jg ii">绿</strong>)。</p><p id="70aa" class="pw-post-body-paragraph je jf hy jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">旧版本的pod(蓝色)继续接受和处理请求，然后当它们启动并准备好处理用户请求时，请求流量被切换到新版本的pod(绿色)。</p><figure class="mw mx my mz fd hk er es paragraph-image"><div class="er es nc"><img src="../Images/f01c72d7204e0fff2b46239848899f0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1342/format:webp/1*aWk7GjYZ3-YORhbc0RNPsg.png"/></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">蓝绿色释放</figcaption></figure><p id="0a95" class="pw-post-body-paragraph je jf hy jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">然而，蓝绿色发布策略不容易在Kubernetes中使用，除非您手动执行或者使用一些扩展，比如Service Mesh。</p><p id="8586" class="pw-post-body-paragraph je jf hy jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">蓝绿色版本的另一个好处是只有一个版本的应用程序可以同时处理用户请求。但是它需要在短时间内对应用程序的副本进行双重计数。</p><h2 id="cdcd" class="mj ke hy bd kf mk ml mm kj mn mo mp kn jp mq mr kr jt ms mt kv jx mu mv kz ie bi translated">金丝雀释放</h2><p id="c4f0" class="pw-post-body-paragraph je jf hy jg b jh ld jj jk jl le jn jo jp mb jr js jt mc jv jw jx md jz ka kb hb bi translated">Canary发布是另一种降低风险的发布策略，它用新版本替换一小部分旧版本。一旦我们对新版本有信心，然后用新版本替换旧版本的所有剩余豆荚。</p><figure class="mw mx my mz fd hk er es paragraph-image"><div class="er es nc"><img src="../Images/d9398972991f86f8207ba6bb7d3dafd1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1342/format:webp/1*l23UMoUgu-TxuT4SSiinrg.png"/></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">金丝雀释放</figcaption></figure><p id="af53" class="pw-post-body-paragraph je jf hy jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">在Canary release中，用户请求会到达旧版本和新版本的Pods，即使一开始可能会有少量的请求。</p><p id="4ba2" class="pw-post-body-paragraph je jf hy jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">在Kubernetes中，金丝雀发布可以通过Istio来完成，这是一个服务网格，可以在Kubernetes集群中使用，根据您自己的规则来调整您的流量。</p><h2 id="946f" class="mj ke hy bd kf mk ml mm kj mn mo mp kn jp mq mr kr jt ms mt kv jx mu mv kz ie bi translated">部署策略与发布策略</h2><p id="ff1e" class="pw-post-body-paragraph je jf hy jg b jh ld jj jk jl le jn jo jp mb jr js jt mc jv jw jx md jz ka kb hb bi translated">部署策略控制旧版本的单元如何被新版本的单元替换，而发布策略控制新版本的单元如何服务于用户请求。</p><figure class="mw mx my mz fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es nh"><img src="../Images/25ba6d35138558a199b81a51de6ce98a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v5xRZfe2BquBRDvJAQD05g.png"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">部署策略与发布策略</figcaption></figure><p id="66ff" class="pw-post-body-paragraph je jf hy jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">上图显示了部署和发布策略的生存时间和Pod计数。</p></div><div class="ab cl lr ls gp lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="hb hc hd he hf"><p id="79dc" class="pw-post-body-paragraph je jf hy jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated"><em class="kc"> Deployment </em>原语是Kubernetes中创建或更新应用程序的一种基本方式，并控制应用程序的生命周期。</p><p id="c3a1" class="pw-post-body-paragraph je jf hy jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">关于生命周期和健康状态，下一个健康探测模式将说明应用程序如何与Kubernetes交流其健康状态。</p></div></div>    
</body>
</html>