# 用可靠的设计原则编写干净的代码

> 原文：<https://medium.com/codex/write-clean-code-with-solid-design-principles-65fb225139d7?source=collection_archive---------11----------------------->

![](img/73f41c87bbb518633c1fb3b726fd7793.png)

[固体](http://andrew-thornton.blogspot.com/2011/06/weekly-word-solid.html)

## 介绍

**SOLID** 实际上是一个首字母缩写词，代表 5 种不同的软件设计原则，由 Robert C. Martin(又名 Bob 叔叔)提出。我们应该研究它们的原因是，这些设计原则在设计模式文献中经常被引用。所以这些原则是:

*   单一责任原则
*   **O:** 开闭原理
*   **L:** 利斯科夫替代原理
*   **I:** 界面偏析原理
*   **D:** 依存倒置原则

它们非常受欢迎，因为当我们设计软件系统时，它们非常重要。这些不是你需要知道的唯一的设计原则，但是这些绝对是最重要的原则之一。这些原则的顺序并不重要，缩写只是记忆这些原则的一种方式，因为它们非常重要。让我们开始一个一个地看这些原则。

## 单一责任原则

> 每个类应该只有一个唯一的目的，不要充满过多的功能。

为了演示单一责任原则，我创建了一个简单的 java 程序，我们可以用它来计算形状列表的总面积。

**球体**定义球体的类。

**立方体**定义立方体的类。

**AreaCalculator** 类具有`sum`方法，该方法返回我们提供给该方法的不同形状列表的总面积。在这种情况下，我们只有`Sphere` & `cube`形状。

在`**Main**`类的`**main**`方法中，我们创建了一个`**AreaCalculator**`类的实例来调用`sum`方法，并打印了我们提供给`**sum**`方法的不同形状列表的返回面积总和。(在 java 中, **main** 方法是运行程序的入口点)

现在，假设我们想要向`**AreaCalculator**`类添加另一个方法，该方法具有将`sum`方法的结果打印为 JSON 字符串格式的功能。

在`main`方法中，使用同一个`calculator`实例调用`json`方法，以 JSON 字符串的形式获取`sum`方法的结果并打印出来。

这将工作得很好。但是现在我们可以意识到我们已经打破了单一责任的规则。根据单一责任，一个**类应该只有一个单一目的**。这里的`AreaCalculator`类顾名思义负责计算不同形状列表的面积，这个责任是由我们在类中声明的`sum`方法完成的。但问题是，我们后来声明的`json`方法只是打印与`AreaCalculator`类的职责不匹配的 JSON 字符串。所以要解决这个问题，我们应该去掉这个不属于`AreaCalculator`类的叫做`json`的多余功能，并把它添加到一个与其职责相符的单独的类中。

并相应地重构主类。

再次运行后，你可以看到它的工作方式完全相同，但现在我们有一个专门的类来处理每个形状的面积总和的格式。因此`**ShapesPrinter**`类有责任将每个形状的面积总和格式化成 JSON、CSV 等格式。`**AreaCalculator**`班级有责任计算不同形状的面积总和。所以现在每个职业只有一个单一的责任，那就是单一责任原则。

## **O** 笔关闭原理

> 类应该对扩展开放，对修改关闭。换句话说，您不应该为了实现新特性而重写现有的类。

现在让我们说，我们决定添加另一个新的形状到我们的程序中，比如**长方体**来扩展这个程序**的能力。**此时该程序只能计算出**球体**和**立方体**形状的面积。

现在我们有**长方体**类。所以如果我们想计算立方体的面积，我们需要对类做一些修改。

但在这里，我们刚刚打破了开闭原则。**类应该对扩展开放，对修改关闭**。我们在这里做的是修改这个`AreaCalculator`类。所以每次我们有一个新的形状，我们就增加一个新的 if 语句。如果我们有 10 个额外的形状，我们将有一堆不同的 If 语句。所以这是不好的做法，我们需要纠正。

为了解决这个问题，首先我要创建一个名为 **Shape** 的新接口，并定义一个名为 **area** 的抽象方法。

在所有形状类(球体、立方体、长方体)中实现创建的`Shape`接口作为它们的父类，并通过覆盖它为**区域**抽象方法提供每个形状类自己的实现。

从`AreaCalculator`类中去掉所有**打开修改行为**。

所以现在我们**通过添加一个新的形状来扩展**T3，但是我们不**修改**它。这就是在这里使用接口的好处。如果我们想在将来添加一个新的形状，我们所要做的就是添加一个新的形状类，它实现了`Shape`接口，并通过覆盖它们为从接口继承的抽象方法提供了自己的实现。`AreaCalculator`班不会有什么变化。这基本上是开闭原则。

## 利斯科夫替代原理

> 每个子类或派生类都应该可以替换它的基类或父类。

假设我们决定将**三角形**形状添加到我们的形状列表中，以便计算三角形的面积。我们还决定添加另一个抽象方法`volume`来计算每个形状的**体积**以及**面积**。

尽管三角形有面积，但它没有体积，不像我们目前定义的其他形状。所以请注意，在`Triangle`类中，我们抛出了一个 **IllegalStateException** 用于实现`volume`方法。由于我们通过实现`Shape`接口认为`triangle`是一个**形状**，我们必须实现从父接口继承的所有抽象方法。这就是原因。

创建`VolumeCalculator`类，负责为不同的形状列表计算**体积**的总和，就像为**区域**创建`AreaCalculator`类一样。并调整`main`方法，以便计算和打印体积**。**

因此，如果我们在程序中添加一个三角形对象，并调用`VolumeCalculator`类中的`sum`方法来计算每个形状的体积总和，它将调用`Triangle`类中的`volume`方法。然后，因为没有这样的实现来计算体积，但抛出一个异常。

无法计算没有体积的三角形的体积。我们通过将`Triangle`类定义为`Shape`类的子类，打破了 Liskov 替换规则。`Triangle`类不可替代`Shape`类。我们可以定义`Triangle`是一个`Shape`，但是它不能计算体积，也不能遵守这个`Shape`父接口的契约。所以我们违反了规则。`Shape`父接口有我们必须实现的方法。`Triangle`可以实现一些，不能实现另一些。所以它永远无法替代它的父节点`Shape`。

作为一个解决方案，我们可以为 3D 形状创建一个单独的界面，它有一个**体积**，并将`shape`界面中的`volume`行为替换到其中。并为具有**区域**的两个 2D & 3D 形状保留`shape`界面中的`area`行为。然后制作有**面积**实现`Shape`接口的形状类和既有**面积** & **体积** `implements`又有`Shape` & `ThreeDimensionalShape`接口的形状类。

重构`VolumeCalculator` & `main`方法也一样。

## **I** 界面偏析原理

> 接口不应该强迫类实现它们不能做的事情。大的接口要分成小的。

当我们用 Liskov 替换原则清理代码时，我们已经用接口分离原则调整了代码。

*   **接口不应该强制类实现它们不能做的事情** : 2D shape 类像`Triangle`不能实现`Shape`接口，而它有像`volume`的行为。这是三角形做不到的。因此将`Shape`接口的`volume`抽象行为替换为新创建的`ThreeDimensionalShape`接口，并使立方体、球体等 3D 形状类实现了对`Shape`接口的`ThreeDimensionalShape`接口添加。这样 2D 就不会强迫像`Triangle`这样的类去实现他们确实不能做的事情。
*   **大的接口应该分成小的**:为了解决上述问题，我们将大的`Shape`接口分成小的独立接口，称为`Shape` & `ThreeDimensionalShape`及其行为。

## 从属倒置原则

> 组件应该依赖于抽象，而不是具体化。也就是说，我们应该真正实现接口。

让我们看看我们之前实现的`ShapesPrinter`类。在这个类中，我们创建了一个`AreaCalculator`类的实例，以便在`ShapesPrinter`中调用`sum`方法。

因此，我们实际上打破了两个坚实的原则。我认为如果我们对`AreaCalculator`类做了更改，那么我们实际上就违反了**开闭原则。同样在这里，我们依赖于实际的具体类(`AreaCalculator`)而不是抽象类。这意味着打破**依赖倒置原则**也。**

为了使我们的代码符合这些原则，我们创建了`IAreaCalculator`接口，并让我们的`AreaCalculator`类实现它。在`IAreaCalculator`接口中定义了`sum`抽象方法，该方法已经在`AreaCalculator`中实现。并且重构`ShapesPrinter`类以依赖于`IAreaCalculator`接口而不是`AreaCalculator`类。不要依赖具体的，要依赖抽象的接口。这里我们使用**依赖注入**。

同样，相应地重构主类。

运行程序后，将输出相同的结果。

将来，如果我们想扩展`ShapesPrinter`类，我们不会修改这个类。我们所做的就是创建一个实现`IAreaCalculator`接口的新类。

**感谢你留到本文结束。如果你喜欢看，请按那个按钮👏几次，留下评论，如果你认为这篇文章也能帮助别人，请分享。**

如果你对更多类似的文章感兴趣，请关注我的 Medium！