<html>
<head>
<title>Flutter: Widgets LifeCycleState Management</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">颤振:Widgets生命周期资产管理</h1>
<blockquote>原文：<a href="https://medium.com/codex/flutter-lifecycle-an-in-depth-look-783b07e8f706?source=collection_archive---------6-----------------------#2022-03-19">https://medium.com/codex/flutter-lifecycle-an-in-depth-look-783b07e8f706?source=collection_archive---------6-----------------------#2022-03-19</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/9741f82a6199152bb092a8f99363bb02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pSSD9pglOMGWZWJ3cJ1c2g.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">图片来源:谷歌</figcaption></figure><p id="22eb" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们将经历flutter widgets的生命周期。在移动开发中，每个移动应用程序都有自己的一组任务，必须逐一完成…例如，如果我们打开我们的应用程序，他们将首先构建应用程序，然后按照场景处理它。</p><p id="e80a" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">flutter中的一切都是一个小部件，大多数flutter应用程序都是以StatelessWidget或StatefullWidget开始的。</p><figure class="jt ju jv jw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es js"><img src="../Images/38dcb734437d68ae4073319e4c7b0e5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VG3ruVUPFHYxgQuRPN13ZA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">无状态小部件生命周期</figcaption></figure><p id="a70e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如果你的类是从StatelessWidget扩展而来的，那就意味着这个页面只是创建了Widget设计，并没有改变它们。</p><figure class="jt ju jv jw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es jx"><img src="../Images/e2bbe9a938c823217c47e5f3e0cea322.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l2E4XzWgE0SAE8K1FrWJCw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">无状态小部件语法</figcaption></figure></div><div class="ab cl jy jz gp ka" role="separator"><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd"/></div><div class="hb hc hd he hf"><p id="70ad" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如果您的类从StatefulWidget扩展，它将根据您的规范进行修改。这是一个一次性的构建，会根据您的操作进行更新。</p><figure class="jt ju jv jw fd ij er es paragraph-image"><div class="er es kf"><img src="../Images/9757ca0f2710c82a84bf7cf43d35f1f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1296/format:webp/1*gZJpoaPQSa29jRBAPqlf7w.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">有状态小部件语法</figcaption></figure><p id="8ebc" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">让我们从谈论StatefulWidget的生命周期开始。</p><figure class="jt ju jv jw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kg"><img src="../Images/291f00864038fef9deaf0aed26dd7d05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*daS1ELPm0iUlTJwBcmBtdA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">有状态小部件生命周期</figcaption></figure><ul class=""><li id="6d20" class="kh ki hi iw b ix iy jb jc jf kj jj kk jn kl jr km kn ko kp bi translated"><strong class="iw hj"><em class="kq">createState()</em></strong>T5】:当框架被告知要构建StatefulWidget时，它马上调用createState()。<br/>在树中的特定点，它为这个小部件构建可变状态。</li></ul><figure class="jt ju jv jw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kr"><img src="../Images/7dc91d7b20b0a28851a081c7f688e2cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9CgBYeppGdHYTFNGpn6nRA.png"/></div></div></figure><p id="0a99" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在StatefulWidget的生命周期中，框架可以多次调用该方法。例如，如果小部件被多次添加到树中，框架将为每个位置产生一个不同的状态对象。类似地，如果小部件从树中移除，然后重新插入，框架将执行createState来构建新的状态对象，从而简化状态对象的生命周期。</p></div><div class="ab cl jy jz gp ka" role="separator"><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd"/></div><div class="hb hc hd he hf"><figure class="jt ju jv jw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ks"><img src="../Images/cf5f7ef11c6351be3daf7376f8ccff47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HzsJXY--zFkpnUgeABPX2A.png"/></div></div></figure><ul class=""><li id="9f68" class="kh ki hi iw b ix iy jb jc jf kj jj kk jn kl jr km kn ko kp bi translated"><strong class="iw hj"><em class="kq">【initState()</em>:</strong>这是小部件形成时，在类函数Object()之后调用的第一个函数。InitState只被调用一次。它必须使用super.initState()。</li></ul><p id="dcd6" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">当这个项目被添加到树中时，它被称为。对于它产生的每个状态对象，框架将精确地调用这个函数一次。覆盖此方法以执行依赖于上下文(即此对象添加到树中的位置)或用于设置此对象的小部件(即小部件)的初始化。</p></div><div class="ab cl jy jz gp ka" role="separator"><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd"/></div><div class="hb hc hd he hf"><figure class="jt ju jv jw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kt"><img src="../Images/21b2944ffe02742309d35cea7374dd7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vP1FeccxcFJyv4jakr3Rsg.png"/></div></div></figure><ul class=""><li id="2a92" class="kh ki hi iw b ix iy jb jc jf kj jj kk jn kl jr km kn ko kp bi translated"><strong class="iw hj"><em class="kq">didChangeDependencies():</em></strong>第一次构造小部件时，在initState之后立即调用didChangeDependencies()。</li></ul><p id="540b" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">当这个状态对象的依赖关系改变时，这个方法被调用。<br/>如果前面的构建调用引用了随后更改的InheritedWidget，框架将使用此方法将更改告知此对象。这个函数可以安全地调用<code class="du ku kv kw kx b">BuildContext.dependOnInheritedWidgetOfExactType</code>。因为框架在依赖关系更新后不断调用build，子类很少覆盖这个函数。一些子类覆盖了这个方法，因为当它们的依赖关系改变时，它们需要执行一些昂贵的工作(例如，网络获取),并且每次构建都这样做成本太高。</p><p id="6ede" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在小部件的生命周期中可能会被多次调用(例如，当键盘出现和消失时)。</p></div><div class="ab cl jy jz gp ka" role="separator"><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd"/></div><div class="hb hc hd he hf"><figure class="jt ju jv jw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ky"><img src="../Images/2bb62c047fbd952ca0a2ee71828097c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2xvkmRsu5X0QRTfNABqg0A.png"/></div></div></figure><ul class=""><li id="b728" class="kh ki hi iw b ix iy jb jc jf kj jj kk jn kl jr km kn ko kp bi translated"><strong class="iw hj"> <em class="kq"> build(): </em> </strong>经常使用这种策略。它必须返回一个小部件，这是必要的。</li></ul><p id="2191" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">它描述了这个小部件所代表的用户界面的组件。<br/>框架在各种情况下都会调用这个方法。</p><p id="aa10" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这个小部件的BuildContext包含关于它在树中的构造位置的信息。例如，上下文给出了树中这个位置的继承部件。该状态对象的context属性始终与BuildContext参数相同，并且在该对象的生存期内保持不变。</p></div><div class="ab cl jy jz gp ka" role="separator"><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd"/></div><div class="hb hc hd he hf"><figure class="jt ju jv jw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kz"><img src="../Images/2bd5dfc88807f0b56885a08a9dfcfc16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WTN2pvpZ7BqcyCEm9C5v1A.png"/></div></div></figure><p id="b3cc" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj"><em class="kq">didUpdateWidget():</em></strong>如果父小部件发生变化，必须重新构建这个小部件(因为需要给它提供不同的数据)，但运行时类型保持不变，就调用这个小部件。这是因为Flutter正在重用一个长期存在的状态。在这种情况下，您可能希望重新初始化一些数据，就像在initState中一样。</p></div><div class="ab cl jy jz gp ka" role="separator"><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd"/></div><div class="hb hc hd he hf"><figure class="jt ju jv jw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es la"><img src="../Images/be216280a5b98c965f69a0af523e66bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Hm07b5axB8OsabhJ3eoUcQ.png"/></div></div></figure><p id="80af" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj"> <em class="kq"> deactivate(): </em> </strong>当状态从树中移除时被调用，尽管它可能在当前移帧完成之前被重新插入。因为状态对象可以从树中的一个地方转移到另一个地方，所以存在这种技术。</p></div><div class="ab cl jy jz gp ka" role="separator"><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd"/></div><div class="hb hc hd he hf"><figure class="jt ju jv jw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es la"><img src="../Images/be216280a5b98c965f69a0af523e66bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Hm07b5axB8OsabhJ3eoUcQ.png"/></div></div></figure><p id="e82d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj"><em class="kq">dispose():</em></strong>当状态对象被永久删除时，dispose()被调用。您应该取消订阅和取消任何动画，流和其他使用这种技术的服务。</p></div><div class="ab cl jy jz gp ka" role="separator"><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd"/></div><div class="hb hc hd he hf"><p id="219c" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><em class="kq">感谢您花时间阅读本文。如果你觉得这个帖子有用又有趣，请鼓掌推荐。</em></p><p id="a18c" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如果我做错了什么，请在评论中提出来。我很想进步。</p></div></div>    
</body>
</html>