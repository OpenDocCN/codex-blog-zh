<html>
<head>
<title>Gitting Started (Part IV): Branching Out</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Gitting Started(第四部分):拓展业务</h1>
<blockquote>原文：<a href="https://medium.com/codex/gitting-started-part-iv-branching-out-4ed81a245db2?source=collection_archive---------10-----------------------#2021-05-21">https://medium.com/codex/gitting-started-part-iv-branching-out-4ed81a245db2?source=collection_archive---------10-----------------------#2021-05-21</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="f717" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">欢迎阅读我的Git入门系列的第四部分！在这篇文章中，我将带您创建一个新的分支，提交这个分支，然后将这个分支合并回基本分支。到目前为止，在本系列中，我已经向您介绍了Git如何工作的概述，向您展示了如何在新的或现有的目录中创建新的Git存储库，并帮助您在新的repo中进行第一次提交。如果这些事情对你来说听起来很陌生，我鼓励你在继续这篇文章之前阅读或重读那些文章。</p><p id="11b4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如我在其他帖子中提到的，这些帖子假设您正在使用基于UNIX的操作系统，如OS X或任何Linux发行版，并且您对终端和系统上可用的命令行实用程序有基本的了解，如<code class="du je jf jg jh b">cd</code>、<code class="du je jf jg jh b">ls</code>、<code class="du je jf jg jh b">pwd</code>、<code class="du je jf jg jh b">rm</code>等。</p><p id="f06b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我将在本文中讨论的Git命令有:</p><ul class=""><li id="0e1c" class="ji jj hi ih b ii ij im in iq jk iu jl iy jm jc jn jo jp jq bi translated"><code class="du je jf jg jh b">git branch</code></li><li id="d046" class="ji jj hi ih b ii jr im js iq jt iu ju iy jv jc jn jo jp jq bi translated"><code class="du je jf jg jh b">git checkout</code></li><li id="7c5b" class="ji jj hi ih b ii jr im js iq jt iu ju iy jv jc jn jo jp jq bi translated"><code class="du je jf jg jh b">git diff</code></li><li id="b0fe" class="ji jj hi ih b ii jr im js iq jt iu ju iy jv jc jn jo jp jq bi translated"><code class="du je jf jg jh b">git merge</code></li><li id="303d" class="ji jj hi ih b ii jr im js iq jt iu ju iy jv jc jn jo jp jq bi translated"><code class="du je jf jg jh b">git restore</code></li></ul><p id="6db0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我还将为<code class="du je jf jg jh b">git commit</code>介绍几个新选项。</p><h1 id="87e4" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">Git分支:综述</h1><p id="6c43" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq kw is it iu kx iw ix iy ky ja jb jc hb bi translated">每个Git回购都有一个或多个分支。当您使用<code class="du je jf jg jh b">git init</code>创建git repo时，默认情况下它有一个分支，称为<code class="du je jf jg jh b">master</code>。(出于包容性的原因，行业标准正在演变为使用<code class="du je jf jg jh b">main</code>而不是<code class="du je jf jg jh b">master</code>，但是Git继续使用<code class="du je jf jg jh b">master</code>作为默认设置，不幸的是，这种情况可能会持续相当长一段时间。出于这个原因，我在这个系列中也使用<code class="du je jf jg jh b">master</code>作为默认基础分支的名称。在这里你可以找到如何将你的<code class="du je jf jg jh b">master</code>分支重命名为<code class="du je jf jg jh b">main</code>的<a class="ae jd" href="https://www.git-tower.com/learn/git/faq/git-rename-master-to-main/" rel="noopener ugc nofollow" target="_blank">说明</a>，我鼓励你考虑这么做。对于这篇文章和本系列文章来说，这样做的唯一含义是，只要<code class="du je jf jg jh b">master</code>出现在命令中，就需要用<code class="du je jf jg jh b">main</code>替换它。)</p><p id="a94b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通常，<code class="du je jf jg jh b">master</code>上的代码表示应用程序的当前部署状态或代码的最新版本。因此，最好不要直接在<code class="du je jf jg jh b">master</code>上做新的开发工作。相反，您可以创建一个新的分支，在那里进行更改，并且当您确定它们工作并且没有破坏任何东西时，将来自那个分支的修订合并到<code class="du je jf jg jh b">master</code>中。</p><p id="e83c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">可以使用任何现有的分支作为基础创建一个新的Git分支。然而，你最常使用的是<code class="du je jf jg jh b">master</code>作为你的基本分支。当您创建一个新分支时，它最初将与基本分支相同。但是，在新分支上进行的新提交不会出现在基本分支上。同样，如果在您处理新分支时对基础分支进行了额外的修订，那么基础分支上的修订将不会出现在您的分支上。这是Git的一个强大特性，它使多个开发人员能够同时处理同一个代码库。</p><p id="36f1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该图显示了一个进展，其中创建了一个新分支<code class="du je jf jg jh b">my-branch</code>，以<code class="du je jf jg jh b">master</code>为基础分支，然后创建了一个<code class="du je jf jg jh b">my-other-branch</code>，以<code class="du je jf jg jh b">my-branch</code>为基础分支。几经修改后，<code class="du je jf jg jh b">my-other-branch</code>合并为<code class="du je jf jg jh b">my-branch</code>。之后，<code class="du je jf jg jh b">my-other-branch</code>的所有修订也会出现在<code class="du je jf jg jh b">my-branch</code>上。(<code class="du je jf jg jh b">my-other-branch</code>在此之后可以删除。)然后，<code class="du je jf jg jh b">my-branch</code>合并成<code class="du je jf jg jh b">master</code>。此时，插图中显示的所有修订都出现在<code class="du je jf jg jh b">master</code>上。</p><figure class="la lb lc ld fd le er es paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="er es kz"><img src="../Images/0887955472a1cf5d934c998c234982eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zai75QvTlALi6gGrN5cw4A.jpeg"/></div></div><figcaption class="ll lm et er es ln lo bd b be z dx translated">图git中的分支和修订</figcaption></figure><p id="0740" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">本系列的<a class="ae jd" href="https://dana-scheider.medium.com/gitting-started-part-i-a-total-beginners-intro-to-git-761715f5cc13" rel="noopener">第一部分</a>给出了更多信息和该图的逐步解释。第一部分还介绍了当基础分支上的修订与被合并的另一个分支上的修订冲突时会发生什么。</p><h1 id="c2c6" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">查看现有分支</h1><p id="5ee4" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq kw is it iu kx iw ix iy ky ja jb jc hb bi translated">要查看您的存储库中当前有哪些分支，只需从repo中的任何目录运行该命令(即，<code class="du je jf jg jh b">.git</code>目录所在的目录或其任何子目录):</p><pre class="la lb lc ld fd lp jh lq lr aw ls bi"><span id="d2e4" class="lt jx hi jh b fi lu lv l lw lx">$ git branch</span></pre><p id="eafc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您将看到一个分支列表。如果您在第二部分创建的回购上运行<code class="du je jf jg jh b">git branch</code>，您将看到一个分支:<code class="du je jf jg jh b">master</code>。</p><p id="7755" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您的repo有多个分支，Git会用一个星号表示您当前所在的分支(或者，用Git语言来说，您当前已经“签出”了哪个分支)。在本例中，您可以看到有三个分支，<code class="du je jf jg jh b">master</code>、<code class="du je jf jg jh b">my-branch-1</code>和<code class="du je jf jg jh b">my-branch-2</code>，并且您目前从<code class="du je jf jg jh b">master</code>开始工作:</p><pre class="la lb lc ld fd lp jh lq lr aw ls bi"><span id="593a" class="lt jx hi jh b fi lu lv l lw lx">* master<br/>  my-branch-1<br/>  my-branch-2</span></pre><h1 id="42bb" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">创建新分支</h1><p id="ea62" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq kw is it iu kx iw ix iy ky ja jb jc hb bi translated">要创建一个新的分支，您可以使用带有<code class="du je jf jg jh b">-b</code>选项的<code class="du je jf jg jh b">git checkout</code>命令来指定新分支的名称。<code class="du je jf jg jh b">git checkout</code>是一个你会经常使用的灵活命令，这只是它的用途之一。</p><p id="8a6c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">给新分支机构命名时，选择一个能描述你要在这个分支机构做什么的名称。在这种情况下，我们将创建一个新分支来添加一个功能，用户可以在其中指定应用程序向谁问好，因此我们将通过运行以下命令来创建它:</p><pre class="la lb lc ld fd lp jh lq lr aw ls bi"><span id="b436" class="lt jx hi jh b fi lu lv l lw lx">$ git checkout -b allow-user-input</span></pre><p id="211c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果一切顺利，我们将看到输出:</p><pre class="la lb lc ld fd lp jh lq lr aw ls bi"><span id="8bf3" class="lt jx hi jh b fi lu lv l lw lx">Switched to a new branch 'allow-user-input'</span></pre><p id="4066" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从现在开始，我们提交的任何更改都将只影响<code class="du je jf jg jh b">allow-user-input</code>分支。他们还不会出现在<code class="du je jf jg jh b">master</code>上。</p><h1 id="7f71" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">在新的分公司工作</h1><p id="d1ca" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq kw is it iu kx iw ix iy ky ja jb jc hb bi translated">在新的分支上工作和在<code class="du je jf jg jh b">master</code>上工作是一样的。在这种情况下，我们将看到一些不同之处，因为我们将修改Git已经在跟踪的文件，而不是像第三部分那样向Git添加一个新文件。</p><p id="7e06" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在您选择的文本编辑器中，打开文件<code class="du je jf jg jh b">hello_world.rb</code>。目前，该文件只有一行:</p><pre class="la lb lc ld fd lp jh lq lr aw ls bi"><span id="7435" class="lt jx hi jh b fi lu lv l lw lx">puts 'Hello World!'</span></pre><p id="8014" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是将单词<code class="du je jf jg jh b">Hello World!</code>打印到控制台的Ruby代码。我们将修改它，让它提示用户输入一个名字，然后向那个人问好。在文本编辑器中，将文件内容更改为以下内容，然后保存:</p><pre class="la lb lc ld fd lp jh lq lr aw ls bi"><span id="2fb0" class="lt jx hi jh b fi lu lv l lw lx">puts 'Please enter a name:'<br/>name = gets.chomp<br/>puts 'Hello ' + name + '!'</span></pre><p id="f5b4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您运行这个命令，您将看到提示您输入一个名称:</p><pre class="la lb lc ld fd lp jh lq lr aw ls bi"><span id="1cd2" class="lt jx hi jh b fi lu lv l lw lx">$ ruby hello_world.rb</span></pre><p id="a8db" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当你输入一个名字，比如“Greg”，程序会输出<code class="du je jf jg jh b">Hello Greg!</code>到控制台。很整洁，是吧？</p><p id="6361" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们有了这个新特性，我们要确保将它提交到Git历史中。首先，我们将运行<code class="du je jf jg jh b">git status</code>来查看是否有未分级的变更。<code class="du je jf jg jh b">git status</code>的输出应该是:</p><pre class="la lb lc ld fd lp jh lq lr aw ls bi"><span id="af78" class="lt jx hi jh b fi lu lv l lw lx">On branch allow-user-input<br/>Changes not staged for commit:<br/>  (use "git add &lt;file&gt;..." to update what will be committed)<br/>  (use "git restore &lt;file&gt;..." to discard changes in the working directory)<br/>      modified:  hello_world.rb</span><span id="0287" class="lt jx hi jh b fi ly lv l lw lx">no changes added to commit (use "git add" and/or "git commit -a")</span></pre><p id="1423" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请注意，输出告诉我们，正如所料，我们在<code class="du je jf jg jh b">allow-user-input</code>分支上，并且文件<code class="du je jf jg jh b">hello_world.rb</code>已经被修改。现在，在我们准备提交变更之前，我们要确保我们清楚我们将准备什么变更。为此，我们使用<code class="du je jf jg jh b">git diff</code>命令。运行:</p><pre class="la lb lc ld fd lp jh lq lr aw ls bi"><span id="7411" class="lt jx hi jh b fi lu lv l lw lx">$ git diff<!-- --> </span></pre><p id="21b1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您应该看到以下内容:</p><pre class="la lb lc ld fd lp jh lq lr aw ls bi"><span id="6b5d" class="lt jx hi jh b fi lu lv l lw lx">diff --git a/hello_world.rb b/hello_world.rb<br/>index 733c205..7146b79 100644<br/>--- a/hello_world.rb<br/>+++ b/hello_world.rb<br/>@@ -1 +1,3 @@<br/>-puts 'Hello World!'<br/>+puts 'Please enter a name:'<br/>+name = gets.chomp<br/>+puts 'Hello ' + name + '!'<br/>(END)</span></pre><p id="a97c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个输出将在你的终端上被着色，这是非常有用的。我们最感兴趣的部分是在带有<code class="du je jf jg jh b">@@ -1 +1,3 @@</code>的线下面的部分。diff告诉我们,<code class="du je jf jg jh b">puts 'Hello World!</code>已经从文件中删除，接下来的三行已经被添加。在您的终端中，已移除的线路将以红色显示，并且前面有一个<code class="du je jf jg jh b">—</code>标志。已添加的线将以绿色显示，并带有一个<code class="du je jf jg jh b">+</code>标志。要退出diff并返回到您的命令行，您可以按下<code class="du je jf jg jh b">Q</code>。</p><p id="b3c7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们确信这些是我们想要提交的更改，我们可以运行:</p><pre class="la lb lc ld fd lp jh lq lr aw ls bi"><span id="7464" class="lt jx hi jh b fi lu lv l lw lx">$ git add hello_world.rb</span></pre><p id="1647" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我建议再次运行<code class="du je jf jg jh b">git status</code>来验证该文件现在已暂存。接下来，提交更改:</p><pre class="la lb lc ld fd lp jh lq lr aw ls bi"><span id="004f" class="lt jx hi jh b fi lu lv l lw lx">$ git commit -m "Accept name as user input"</span></pre><p id="94d3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">还有另一种更快的方式来提交这些更改。您可以通过运行以下命令来转移和提交所有已修改的文件:</p><pre class="la lb lc ld fd lp jh lq lr aw ls bi"><span id="7646" class="lt jx hi jh b fi lu lv l lw lx">$ git commit -a -m "Accept name as user input"</span></pre><p id="852d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果一切按计划进行，我们将得到以下输出:</p><pre class="la lb lc ld fd lp jh lq lr aw ls bi"><span id="8adf" class="lt jx hi jh b fi lu lv l lw lx">[allow-user-input 5f38523] Accept name as user input<br/> 1 file changed, 3 insertions(+), 1 deletion(-)</span></pre><p id="a0f6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这告诉我们已经提交的分支、提交SHA的前七位数字(有关提交SHA的更多信息，请参见<a class="ae jd" href="https://dana-scheider.medium.com/gitting-started-part-i-a-total-beginners-intro-to-git-761715f5cc13" rel="noopener">第一部分</a>)和提交消息。在此之下，有关于有多少文件被更改以及这些文件中有多少更改的信息。如果我们添加或删除一个文件，这些信息也会被给出。</p><p id="21db" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">按照UNIX惯例，您可以将<code class="du je jf jg jh b">-a</code>和<code class="du je jf jg jh b">-m</code>选项组合成:</p><pre class="la lb lc ld fd lp jh lq lr aw ls bi"><span id="1c87" class="lt jx hi jh b fi lu lv l lw lx">$ git commit -am "Accept name as user input"</span></pre><p id="58b6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">将</strong> <code class="du je jf jg jh b"><strong class="ih hj">-a</strong></code> <strong class="ih hj">标志与</strong> <code class="du je jf jg jh b"><strong class="ih hj">git commit</strong></code> <strong class="ih hj">一起使用有点冒险，就像</strong> <code class="du je jf jg jh b"><strong class="ih hj">git add .</strong></code>一样，因为如果有很多修改过的文件，你就冒着提交你并不真正想要的更改的风险。同样重要的是要知道<code class="du je jf jg jh b">git commit -a</code>不会暂存或提交当前没有被Git跟踪的新文件——只有那些已经被跟踪并且自上次提交以来已经被修改过的文件。要暂存新创建的文件，您总是需要使用<code class="du je jf jg jh b">git add</code>。</p><p id="8e70" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请注意，我们不需要做任何特殊的事情来确保变更被提交到正确的分支——我们只需要确保在提交变更时我们在那个分支上。</p><h1 id="d707" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">检查基本分支并合并</h1><p id="5ba2" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq kw is it iu kx iw ix iy ky ja jb jc hb bi translated">既然我们已经添加了漂亮的新特性，我们希望将该特性添加到<code class="du je jf jg jh b">master</code>，它将包含在下一个版本中。为了合并我们所做的修订，我们将首先运行:</p><pre class="la lb lc ld fd lp jh lq lr aw ls bi"><span id="d04a" class="lt jx hi jh b fi lu lv l lw lx">$ git checkout master</span></pre><p id="0791" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这使我们回到了<code class="du je jf jg jh b">master</code>分支。运行这样的命令总是会将您带到您指定的任何分支:</p><pre class="la lb lc ld fd lp jh lq lr aw ls bi"><span id="65bd" class="lt jx hi jh b fi lu lv l lw lx">$ git checkout branch-name<!-- --> </span></pre><p id="9b32" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您想要的分支不存在，您需要像上面那样在分支名称前使用<code class="du je jf jg jh b">-b</code>标志，否则您会得到一个错误。</p><p id="0608" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，再次运行<code class="du je jf jg jh b">git branch</code>显示有一个名为<code class="du je jf jg jh b">allow-user-input</code>的分支和另一个名为<code class="du je jf jg jh b">master</code>的分支，我们现在在<code class="du je jf jg jh b">master</code>上:</p><pre class="la lb lc ld fd lp jh lq lr aw ls bi"><span id="32f7" class="lt jx hi jh b fi lu lv l lw lx">  allow-user-input<br/>* master</span></pre><p id="5743" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在将特征分支合并到<code class="du je jf jg jh b">master</code>之前，最好先检查特征分支和<code class="du je jf jg jh b">master</code>之间的差异。(由于在<code class="du je jf jg jh b">allow-user-input</code>特性分支上可能有多次提交，以及在我们创建新分支后在主分支上的修改，这个差异不会总是与我们在最后一次提交到<code class="du je jf jg jh b">allow-user-input</code>分支之前看到的差异相同。)要检查这种差异，我们可以运行:</p><pre class="la lb lc ld fd lp jh lq lr aw ls bi"><span id="b246" class="lt jx hi jh b fi lu lv l lw lx">$ git diff allow-user-input</span></pre><p id="9f4c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这将显示出<code class="du je jf jg jh b">master</code>(或者你当前所在的分支)和<code class="du je jf jg jh b">allow-user-input</code>分支之间的区别。通常，无论您在哪个分支上，您都可以通过运行以下命令来查看任意两个分支之间的差异:</p><pre class="la lb lc ld fd lp jh lq lr aw ls bi"><span id="762a" class="lt jx hi jh b fi lu lv l lw lx">$ git diff branch-1 branch-2</span></pre><p id="617d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">即使两个分支都不依赖于另一个分支，这也是可行的。</p><p id="f0e6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这种情况下，我们看到的<code class="du je jf jg jh b">master</code>和<code class="du je jf jg jh b">allow-user-input</code>之间的差异与我们刚刚看到的差异相同。这正是我们所期待的，所以我们准备合并。我们通过运行以下命令来实现:</p><pre class="la lb lc ld fd lp jh lq lr aw ls bi"><span id="8434" class="lt jx hi jh b fi lu lv l lw lx">$ git merge allow-user-input</span></pre><p id="e1d0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该命令会将指定分支上的修订合并到您当前已签出的分支中，因此在运行该命令之前，请确保您位于要合并到的分支上。当您运行<code class="du je jf jg jh b">git merge</code>命令时，您应该会看到以下输出(提交sha—<code class="du je jf jg jh b">106b5ea</code>和<code class="du je jf jg jh b">5f38523</code> —会有所不同):</p><pre class="la lb lc ld fd lp jh lq lr aw ls bi"><span id="6896" class="lt jx hi jh b fi lu lv l lw lx">Updating 106b5ea..5f38523<br/>Fast-forward<br/> hello_world.rb | 4 +++-<br/> 1 file changed, 3 insertions(+), 1 deletion(-)</span></pre><p id="efe2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du je jf jg jh b">4 +++-</code>表示你修改了文件中的四行，增加了三行，删除了一行。请注意，Git会将对代码行的任何更改解释为一次删除(原始行)和一次插入(修改后的行)。</p><p id="814e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">合并只是单向的:来自<code class="du je jf jg jh b">allow-user-input</code>的修订现在会出现在<code class="du je jf jg jh b">master</code>上，但是<code class="du je jf jg jh b">allow-user-input</code>分支在合并后仍然会保持不变。</p><h1 id="7705" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">删除分支</h1><p id="4863" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq kw is it iu kx iw ix iy ky ja jb jc hb bi translated">如果你愿意，合并后，你可以在特征分支上做更多的工作，合并到<code class="du je jf jg jh b">master</code>或任何你喜欢的基础分支。记住，在<code class="du je jf jg jh b">allow-user-input</code>创建后对<code class="du je jf jg jh b">master</code>所做的修改不会出现在<code class="du je jf jg jh b">allow-user-input</code>分支上，即使分支合并后也是如此——如果你想让它们出现在那里，你必须要么将主文件合并到<code class="du je jf jg jh b">allow-user-input</code>中，要么使用<code class="du je jf jg jh b">git rebase</code>。重新定基可能有点冒险，因为它修改了Git历史，所以现在坚持合并。</p><p id="55d2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一般来说，一旦你合并了一个分支，你就不再需要它了。拥有太多的Git分支会变得很烦人，因为当你运行<code class="du je jf jg jh b">git branch</code>时，有一个不断增长的列表，你必须浏览它才能找到你感兴趣的分支。因此，您可能希望在合并分支后删除它们。</p><p id="e6c4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦您签出了<code class="du je jf jg jh b">master</code>并合并了<code class="du je jf jg jh b">allow-user-input</code>，您就可以运行这个来删除分支:</p><pre class="la lb lc ld fd lp jh lq lr aw ls bi"><span id="c6b7" class="lt jx hi jh b fi lu lv l lw lx">$ git branch -d allow-user-input</span></pre><p id="a3af" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您应该会看到如下所示的输出:</p><pre class="la lb lc ld fd lp jh lq lr aw ls bi"><span id="8ddd" class="lt jx hi jh b fi lu lv l lw lx">Deleted branch allow-user-input (was 5f38523)</span></pre><p id="bdad" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du je jf jg jh b">5f38523</code>是<code class="du je jf jg jh b">allow-user-input</code>分支上最后一个提交SHA的前七位数字，它们在你的机器上和在我的机器上是不同的。就是这样！您的分支已被删除。</p><p id="8a0e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有时，您可能想要删除尚未合并的分支。如果您运行<code class="du je jf jg jh b">git branch -d unmerged-branch</code>，Git将通过引发一个错误来避免永久丢失在该分支上所做的更改。错误的输出如下所示:</p><pre class="la lb lc ld fd lp jh lq lr aw ls bi"><span id="4a86" class="lt jx hi jh b fi lu lv l lw lx">error: The branch 'unmerged-branch' is not fully merged.<br/>If you are sure you want to delete it, run 'git branch -D unmerged-branch'.</span></pre><p id="3a2f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您完全确定不再需要那个分支上的修订，正如输出所说的，您可以用以下命令删除它:</p><pre class="la lb lc ld fd lp jh lq lr aw ls bi"><span id="9513" class="lt jx hi jh b fi lu lv l lw lx">$ git branch -D unmerged-branch</span></pre><p id="af2b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是要小心——在您运行<code class="du je jf jg jh b">git branch -D</code>之后，在被删除的分支上的任何未合并的变更将永远消失，并且在那之后没有办法恢复它们。在删除分支之前，您总是可以通过运行以下命令来验证有哪些更改:</p><pre class="la lb lc ld fd lp jh lq lr aw ls bi"><span id="1d76" class="lt jx hi jh b fi lu lv l lw lx">$ git diff master unmerged-branch</span></pre><h1 id="4a4a" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">结论</h1><p id="e1f9" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq kw is it iu kx iw ix iy ky ja jb jc hb bi translated">在这一点上，我认为是时候回顾一下了。如果您一直在关注这一系列文章，那么您现在已经了解了相当多的Git功能，您将在职业生涯中每天使用这些功能。您已经学会了使用<code class="du je jf jg jh b">git init</code>创建git存储库，使用<code class="du je jf jg jh b">git add</code>准备您的第一次更改，并使用<code class="du je jf jg jh b">git commit</code>将您的代码版本永久保存在Git中。</p><p id="6b09" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此外，您还了解了Git修订(或“提交”)和分支——如何创建一个新分支，找出存在哪些分支，确定您在哪个分支上，以及使用<code class="du je jf jg jh b">git branch</code>和<code class="du je jf jg jh b">git checkout</code>切换分支。您已经学会了当您确定它们已经准备好投入生产时合并变更，当您不再需要它时删除分支。给自己一个鼓励！</p><p id="7d0a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">不过，这仍然只是Git所能提供的强大功能的一小部分。版本控制最令人信服的目的可能是让您在出错时快速修复。在<a class="ae jd" href="https://dana-scheider.medium.com/gitting-started-part-v-when-sh-t-goes-south-9b15a0882d4a" rel="noopener">第五部</a>中，我将带你了解<code class="du je jf jg jh b">git revert</code>、<code class="du je jf jg jh b">git restore</code>和<code class="du je jf jg jh b">git reset</code>的基本知识以及<code class="du je jf jg jh b">git checkout</code>的其他用法。</p></div></div>    
</body>
</html>