<html>
<head>
<title>Python beginner gotchas</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python初学者入门</h1>
<blockquote>原文：<a href="https://medium.com/codex/python-beginner-gotchas-af16f26325dd?source=collection_archive---------17-----------------------#2022-06-13">https://medium.com/codex/python-beginner-gotchas-af16f26325dd?source=collection_archive---------17-----------------------#2022-06-13</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="792f" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">我在生产应用中使用Python已经一年了。这是让这条路变得更加艰难的一系列事情。</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/d4b334277a4ea10afc2695fd2e682552.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_0NHtDnwTRxQk1Ng"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated"><a class="ae jn" href="https://unsplash.com/@fidpad?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">菲迪亚斯·塞万提斯</a>在<a class="ae jn" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="f2ce" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这不是一篇抨击语言的文章，而是对一些可能让像我这样的新人感到惊讶的问题的提醒。这些问题从微小的不便到可疑的设计决策都有。请注意，这是从一个一岁的来自其他语言的学习者的角度来写的，同时保持开放的心态并努力提高效率。我希望它能帮助你不被吓到。</p><h1 id="7523" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">所有实例共享类属性</h1><p id="d99a" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">在下面的例子中，输出是什么？试试看🚀。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lh li l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">对于<a class="ae jn" href="https://docs.python.org/3/library/dataclasses.html" rel="noopener ugc nofollow" target="_blank">数据类</a>以及<a class="ae jn" href="https://replit.com/@LusSoares1/constructor-args-in-python-dataclasses#main.py" rel="noopener ugc nofollow" target="_blank">也存在这个问题🚀</a>】。</figcaption></figure><p id="e947" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在Python中，类属性是共享的；它们在该类中是唯一的(就像Java静态字段一样)。在前面的例子中，这意味着<code class="du lj lk ll lm b">_store</code>是全局可变的。这在JavaScript、Java、C#、C++或我所知道的任何其他<a class="ae jn" href="https://en.wikipedia.org/wiki/Object-oriented_programming" rel="noopener ugc nofollow" target="_blank"> OO </a>语言中都不会发生。</p><p id="f607" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">因为Python有<code class="du lj lk ll lm b">@staticmethod</code>和<code class="du lj lk ll lm b">@classmethod</code>的概念，你可能会认为事物不是静态的，直到被标记为静态，但是类属性是静态的。更不一致的是，只有像列表和字典这样可变的东西是静态的；文字不是[<a class="ae jn" href="https://replit.com/@LusSoares1/constructor-args-in-python-v2#main.py" rel="noopener ugc nofollow" target="_blank">🚀</a>】。</p><p id="8650" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> 🛠解决方法</strong>:您需要在构造函数中初始化类属性(可变属性),以确保每个类实例化都会创建新的实例:</p><pre class="iy iz ja jb fd ln lm lo bn lp lq bi"><span id="12b4" class="lr kl hi lm b be ls lt l lu lv">class UserRepositoryInMemory:<br/>   _store: Dict<br/><br/>   def __init__(self):<br/>      self._store = {}</span></pre><h1 id="9efe" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">默认参数保存在函数调用中</h1><p id="1502" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">你对下面的代码有什么期望[ <a class="ae jn" href="https://replit.com/@LusSoares1/global-named-arguments#main.py" rel="noopener ugc nofollow" target="_blank">🚀</a>】？</p><pre class="iy iz ja jb fd ln lm lo bn lp lq bi"><span id="2548" class="lr kl hi lm b be ls lt l lu lv">def append_one(list = []):<br/>   list.append(1)<br/>   print(list)<br/><br/>append_one()<br/>append_one()</span></pre><p id="96f5" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我原以为会印两次，但事实并非如此。由于<code class="du lj lk ll lm b">= []</code>是一个局部问题，所以期望每次调用函数时都初始化<code class="du lj lk ll lm b">list</code>是很正常的——这就是<a class="ae jn" href="https://replit.com/@LusSoares1/named-arguments-JS#index.js" rel="noopener ugc nofollow" target="_blank"> JavaScript </a>和<a class="ae jn" href="https://replit.com/@LusSoares1/named-arguments-kotlin" rel="noopener ugc nofollow" target="_blank"> Kotlin </a>的行为方式(C#不支持非常数默认参数)。在Python中，它只在第一次被调用。</p><p id="9c82" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这就是<a class="ae jn" href="https://docs.python-guide.org/writing/gotchas/" rel="noopener ugc nofollow" target="_blank">最潜移默化的Python“特性”</a>。简而言之，默认参数在调用之间表现为长期共享变量。由于Python中的一切都是可变的，这就产生了难以调试的问题。对于列表之类的东西，PyCharm暗示你正在走向一个陷阱:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lw"><img src="../Images/935e106313389d356d7d8bfb1f5f57f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SWDdamkaXlfJv5jbM7Cuqw.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">PyCharm警告您关于可变默认参数的问题。</figcaption></figure><p id="ade7" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">然而，它可能更普遍:在一个项目中，我在一些测试中将mock作为默认参数；这些意外地相互影响，我花了几个小时调试才找到原因。</p><p id="2fec" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> 🛠解决方法</strong>:不要对任何可能变异的东西使用关键字参数。将每个默认参数初始化为<code class="du lj lk ll lm b">None</code>，并在函数体中设置它们的默认值。不利的一面是，如果你打算通过<code class="du lj lk ll lm b">None</code>考试，你就无法通过…</p><pre class="iy iz ja jb fd ln lm lo bn lp lq bi"><span id="1bf7" class="lr kl hi lm b be ls lt l lu lv">def do_something(some_list = None, a_user = None):<br/>   if some_list == None:<br/>      some_list = []<br/>   if a_user == None:<br/>      a_user = User()<br/>   ...</span></pre><div class="lx ly ez fb lz ma"><a href="https://florimond.dev/en/posts/2018/08/python-mutable-defaults-are-the-source-of-all-evil/" rel="noopener  ugc nofollow" target="_blank"><div class="mb ab dw"><div class="mc ab md cl cj me"><h2 class="bd hj fi z dy mf ea eb mg ed ef hh bi translated">Python可变缺省值是所有罪恶的根源</h2><div class="mh l"><h3 class="bd b fi z dy mf ea eb mg ed ef dx translated">今天，我想分享一些关于Python开发人员仍然容易犯的常见错误的快速救生建议。不要…</h3></div><div class="mi l"><p class="bd b fp z dy mf ea eb mg ed ef dx translated">florimond.dev</p></div></div><div class="mj l"><div class="mk l ml mm mn mj mo jh ma"/></div></div></a></div><h1 id="f82a" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">测试不能有重复的名称</h1><p id="b4e6" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">在以前的项目中，我有大约100个按业务子域组织的测试文件。很自然地，一些跨文件夹的文件名发生了冲突。没想到的是，<a class="ae jn" href="https://docs.pytest.org/en/7.1.x/" rel="noopener ugc nofollow" target="_blank"> pytest </a>测试跑者对此并不高兴。虽然有一个解决方法，但这不应该是默认行为。平心而论，这是pytest的局限性；不是Python，但是从学习者的角度来看，pytest是测试的首选工具。</p><pre class="iy iz ja jb fd ln lm mp mq aw mr bi"><span id="d80d" class="ms kl hi lm b fi mt mu l mv lv">ERROR collecting pytest/test_helloworld.py</span><span id="7921" class="ms kl hi lm b fi mw mu l mv lv">import file mismatch:<br/>imported module 'test_helloworld' has this __file__ attribute:<br/>  D:\pytest\case\test_helloworld.py<br/>which is not the same as the test file we want to collect:<br/>  D:\pytest\pytest\test_helloworld.py<br/>HINT: remove __pycache__ / .pyc files and/or use a unique basename for your test file modules<br/>!!!!!!!!!!!!!!!!!!! Interrupted: 1 errors during collection<br/>=========================== 1 error in 0.88 seconds</span><span id="0bd9" class="ms kl hi lm b fi mw mu l mv lv"><a class="ae jn" href="https://github.com/pytest-dev/pytest/issues/3151" rel="noopener ugc nofollow" target="_blank"><em class="mx">source</em></a></span></pre><p id="e8ae" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> 🛠解决方法</strong>:我喜欢将测试文件重命名为不同的名称。然而，您可以求助于<code class="du lj lk ll lm b">__init__.py</code>技巧:在重复文件所在的一个文件夹中创建一个名为<code class="du lj lk ll lm b">__init__.py</code>的空文件。</p><h1 id="9524" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">如果关键字参数与实现不同步，测试就会失败</h1><p id="aece" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">查看以下测试片段:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lh li l"/></div></figure><p id="88f2" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">如果你用Kotlin或者C#(或者其他带有<a class="ae jn" href="https://en.wikipedia.org/wiki/Named_parameter" rel="noopener ugc nofollow" target="_blank">命名参数</a>的语言)进行测试，你不会知道为什么上面的测试失败了。命名参数应该只是语法糖并且仅仅是为了使代码更具可读性而存在。但是Python <a class="ae jn" href="https://en.wikipedia.org/wiki/Leaky_abstraction" rel="noopener ugc nofollow" target="_blank">将</a>关键字参数(与<code class="du lj lk ll lm b"><a class="ae jn" href="https://www.programiz.com/python-programming/args-and-kwargs" rel="noopener ugc nofollow" target="_blank">*args</a></code><a class="ae jn" href="https://www.programiz.com/python-programming/args-and-kwargs" rel="noopener ugc nofollow" target="_blank"/><code class="du lj lk ll lm b"><a class="ae jn" href="https://www.programiz.com/python-programming/args-and-kwargs" rel="noopener ugc nofollow" target="_blank">*kwargs</a></code>)的内部实现泄露给了pytest。这最终导致了测试和实现之间的耦合，因为它们必须总是同步的。我花了一段时间才明白。</p><p id="239a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> 🛠解决方法</strong>:我找不到任何解决方案。在我工作的项目中，我最终到处使用关键字参数——测试和实现，只是为了让pytest高兴。不确定其他测试库能不能应对。</p><h1 id="43c1" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">兰姆达斯似乎只在少数情况下有用</h1><p id="6e14" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">兰姆达斯是<a class="ae jn" href="https://en.wikipedia.org/wiki/Functional_programming" rel="noopener ugc nofollow" target="_blank"> FP </a>的支柱之一。Python支持lambdas，但至少有两件事困扰着我:</p><p id="6ed5" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">无类型提示:<br/> </strong>不能给lambda参数添加类型提示。没有类型提示意味着代码编辑器和类型检查器帮不上什么忙。<br/>类型提示(例如<code class="du lj lk ll lm b">amount: Int</code>)和lambda语法(例如<code class="du lj lk ll lm b">add_ten = lambda a<strong class="jq hj">:</strong> a + 10</code>)都使用冒号，所以没有简单的方法来解决这个问题。</p><p id="5ee7" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">你不能写多行的lambdas。好吧，如果你使用圆括号就可以，但是它们必须是一个单一的表达式(不像Java、Kotlin、Ruby、C#、JavaScript、Elixir、…)中的lambdas。这将Python lambdas的用例缩小到非常基本的情况。考虑到Python的语法，我认为没有简单的方法可以解决这个问题。</p><p id="1641" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> 🛠变通办法</strong>:避开lambdas，使用正常函数。我不喜欢这样，因为你失去了上下文。这在管道操作中尤其重要，在管道操作中，您希望在每个步骤中进行小的转换，或者在测试中配置模拟。在这两种情况下，它都强制进行了夸大的分割，并且您需要滚动很多来理解代码。</p><h1 id="9ac5" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">管道操作创造了括号地狱</h1><p id="ac04" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">假设您正在进行一些包含多个步骤的数据转换。<a class="ae jn" href="https://www.freecodecamp.org/news/an-introduction-to-programming-paradigms#declarative-programming" rel="noopener ugc nofollow" target="_blank">声明式编程</a>非常适合这里，尤其是在Elixir [ <a class="ae jn" href="https://replit.com/@LusSoares1/AnnualStrangeBackslash#main.exs" rel="noopener ugc nofollow" target="_blank">中提供的管道操作符🚀</a> ]:</p><pre class="iy iz ja jb fd ln lm lo bn lp lq bi"><span id="cb6c" class="lr kl hi lm b be ls lt l lu lv">["1", "4", "7", "2", "9", "5"] |&gt;<br/>   Enum.map(&amp;String.to_integer/1) |&gt;<br/>   Enum.map(fn x -&gt; x + 5 end) |&gt;<br/>   Enum.filter(&amp;Integer.is_even/1) |&gt;<br/>   Enum.sum() |&gt;<br/>   IO.puts()</span></pre><p id="1c48" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在科特林，没有管道运营商，但我们可以连锁经营，依靠<code class="du lj lk ll lm b">let</code> [ <a class="ae jn" href="https://replit.com/@LusSoares1/CornyBaggyTruetype#main.kt" rel="noopener ugc nofollow" target="_blank">🚀</a>】:</p><pre class="iy iz ja jb fd ln lm lo bn lp lq bi"><span id="733a" class="lr kl hi lm b be ls lt l lu lv">listOf("1", "4", "7", "2", "9", "5")<br/>   .map(String::toInt)<br/>   .map { it + 5 }<br/>   .filter { it % 2 == 0 }<br/>   .sum()<br/>   .let(::println)</span></pre><p id="1407" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在JavaScript中，由于我们没有管道操作符或等效物，我们需要一个变量[<a class="ae jn" href="https://replit.com/@LusSoares1/PleasingFragrantSquare#index.js" rel="noopener ugc nofollow" target="_blank">🚀</a>】:</p><pre class="iy iz ja jb fd ln lm lo bn lp lq bi"><span id="3e5e" class="lr kl hi lm b be ls lt l lu lv">const res = ["1", "4", "7", "2", "9", "5"]<br/>  .map(el =&gt; parseInt(el))<br/>  .map(el =&gt; el + 5)<br/>  .filter(el =&gt; el % 2 == 0)<br/>  .reduce((acc, el) =&gt; acc + el, 0)<br/>console.log(res)</span></pre><p id="5048" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在Python中，我们被困在<a class="ae jn" href="https://www.reddit.com/r/ProgrammerHumor/comments/27yykv/indent_hadouken/" rel="noopener ugc nofollow" target="_blank">嵌套函数调用</a> [ <a class="ae jn" href="https://replit.com/@LusSoares1/python-ops?v=1#main.py" rel="noopener ugc nofollow" target="_blank">🚀</a>】:</p><pre class="iy iz ja jb fd ln lm lo bn lp lq bi"><span id="3757" class="lr kl hi lm b be ls lt l lu lv">res = sum(<br/>  filter(lambda el: el % 2 == 0,<br/>    map(lambda el: el + 5,<br/>      map(int, <br/>          ["1", "4", "7", "2", "9", "5"]<br/>      )<br/>    )<br/>  )<br/>)<br/>print(res)</span></pre><p id="fb35" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">👎<strong class="jq hj">操作以相反的顺序出现</strong>(需要从里到外阅读)<br/>👎圆括号很难匹配，在几次运算后代码变得过于缩进<br/>👎Lambdas不能有类型提示，并且仅限于表达式</p><p id="0392" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">让我们用同样的方法来列举理解:</p><pre class="iy iz ja jb fd ln lm lo bn lp lq bi"><span id="419d" class="lr kl hi lm b be ls lt l lu lv">res = [el for el in [el + 5 for el in [<br/>  int(el) for el in ["1", "4", "7", "2", "9", "5"]<br/>]] if el % 2 == 0]<br/>sum = 0<br/>for el in res:<br/>  sum += el<br/>print(sum)</span></pre><p id="4dfc" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">它不会变得更好。它变得更加难以阅读，同时保留了前一个片段的缺点。还有，这是一个基本的例子；想象一个真实的场景。Python是面向对象的，所以我不明白为什么<code class="du lj lk ll lm b">map</code>、<code class="du lj lk ll lm b">filter</code>、<code class="du lj lk ll lm b">all</code>等是全局函数(即内置函数)。依我看，它们应该是数组和字典的一部分。</p><p id="8396" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> 🛠解决方法</strong>:有一些库可以填补这个空白，但是它们有一些限制。除了认识到这不是Python鼓励的模式之外，没有明显的解决方法。因此，“修复”就是选择<a class="ae jn" href="https://www.freecodecamp.org/news/an-introduction-to-programming-paradigms#imperative-programming" rel="noopener ugc nofollow" target="_blank">命令式</a>(就地)或者<a class="ae jn" href="https://www.freecodecamp.org/news/an-introduction-to-programming-paradigms#procedural-programming" rel="noopener ugc nofollow" target="_blank">程序式编程</a>(调用私有函数)。</p><h1 id="598d" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">其他不满</h1><ul class=""><li id="8160" class="my mz hi jq b jr lc ju ld jx na kb nb kf nc kj nd ne nf ng bi translated"><a class="ae jn" href="https://replit.com/@LusSoares1/MixedBulkyPackages#main.py" rel="noopener ugc nofollow" target="_blank">元组</a></li><li id="fef6" class="my mz hi jq b jr nh ju ni jx nj kb nk kf nl kj nd ne nf ng bi translated">一切都是公开可见的。</li><li id="5702" class="my mz hi jq b jr nh ju ni jx nj kb nk kf nl kj nd ne nf ng bi translated">可变性无处不在，甚至受到鼓励。</li><li id="3045" class="my mz hi jq b jr nh ju ni jx nj kb nk kf nl kj nd ne nf ng bi translated">滥用下划线(<code class="du lj lk ll lm b">__init__.py</code>、<code class="du lj lk ll lm b">__init__</code>、<code class="du lj lk ll lm b">__call__</code>、<code class="du lj lk ll lm b">__name__</code>、<code class="du lj lk ll lm b">__file__</code>、<code class="du lj lk ll lm b">"__main__"</code>等)。).</li><li id="b649" class="my mz hi jq b jr nh ju ni jx nj kb nk kf nl kj nd ne nf ng bi translated"><a class="ae jn" href="https://stackoverflow.com/questions/68439799/typeerror-missing-1-required-positional-argument-while-using-pytest-fixture" rel="noopener ugc nofollow" target="_blank">unittest和pytest的混淆</a>。</li><li id="ceda" class="my mz hi jq b jr nh ju ni jx nj kb nk kf nl kj nd ne nf ng bi translated">要创建接口，你需要从<code class="du lj lk ll lm b">ABC</code>继承？看起来很奇怪。</li><li id="a754" class="my mz hi jq b jr nh ju ni jx nj kb nk kf nl kj nd ne nf ng bi translated">为什么每个异步测试文件都需要<code class="du lj lk ll lm b">pytestmark = pytest.mark.asyncio</code>？我敢肯定这是有原因的，但它看起来像一个到处都必须安装的黑客。</li><li id="37db" class="my mz hi jq b jr nh ju ni jx nj kb nk kf nl kj nd ne nf ng bi translated">为什么<code class="du lj lk ll lm b">join</code>属于字符串而不是iterable？那是非正统的。</li><li id="f2dc" class="my mz hi jq b jr nh ju ni jx nj kb nk kf nl kj nd ne nf ng bi translated">为什么<code class="du lj lk ll lm b">strftime</code>这么缩写？函数名被限制在8个字符以内的时代已经不是70年代了。</li><li id="9f29" class="my mz hi jq b jr nh ju ni jx nj kb nk kf nl kj nd ne nf ng bi translated"><code class="du lj lk ll lm b">map</code>在映射之外创建一个迭代器，然后用<code class="du lj lk ll lm b">list</code>将其转换回一个列表。我想按需创建一个迭代器，但这只是一个观点。</li><li id="8ff2" class="my mz hi jq b jr nh ju ni jx nj kb nk kf nl kj nd ne nf ng bi translated"><code class="du lj lk ll lm b">list</code>、<code class="du lj lk ll lm b">set</code>、<code class="du lj lk ll lm b">map</code>尤其是<code class="du lj lk ll lm b">id</code>和<code class="du lj lk ll lm b">type</code>是语言关键字/内置，因此如果您使用它们来命名事物，它们会生成编辑器警告。在我看来，这些词太普通了，不可能在本土全球化。</li><li id="fbc5" class="my mz hi jq b jr nh ju ni jx nj kb nk kf nl kj nd ne nf ng bi translated">您可以将未声明的参数传递给函数和编辑器(PyCharm和Code)、linter ( <a class="ae jn" href="https://github.com/csachs/pyproject-flake8" rel="noopener ugc nofollow" target="_blank"> pflake8 </a>)、类型检查器(<a class="ae jn" href="http://mypy-lang.org/" rel="noopener ugc nofollow" target="_blank"> mypy </a>和<a class="ae jn" href="https://github.com/microsoft/pyright" rel="noopener ugc nofollow" target="_blank"> pyright </a>)，运行时也没问题。我知道我可以在运行时传递一个被<a class="ae jn" href="https://python-reference.readthedocs.io/en/latest/docs/operators/dict_unpack.html" rel="noopener ugc nofollow" target="_blank">解包的</a>字典，但是如果我显式地传递一个未声明的参数，我至少会得到一个警告。</li><li id="e43d" class="my mz hi jq b jr nh ju ni jx nj kb nk kf nl kj nd ne nf ng bi translated"><a class="ae jn" href="https://docs.quantifiedcode.com/python-anti-patterns/readability/asking_for_permission_instead_of_forgiveness_when_working_with_files.html" rel="noopener ugc nofollow" target="_blank">鼓励异常控制流</a>，这是大多数其他语言中的一个<a class="ae jn" href="https://softwareengineering.stackexchange.com/a/189225/354722" rel="noopener ugc nofollow" target="_blank">反模式</a>。(<a class="ae jn" rel="noopener" href="/codex/pragmatic-exception-handling-3831f7ce0980">了解更多</a>)</li><li id="e953" class="my mz hi jq b jr nh ju ni jx nj kb nk kf nl kj nd ne nf ng bi translated">猴子补丁(<code class="du lj lk ll lm b">@Patch</code>)被社区频繁使用。除了隐藏组件依赖，它还把重构和测试变成了痛苦。<a class="ae jn" rel="noopener" href="/codex/dependency-injection-back-to-the-basics-a52402890fdc">依赖注入</a>就是解决方案。</li></ul></div></div>    
</body>
</html>