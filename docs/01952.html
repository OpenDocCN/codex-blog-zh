<html>
<head>
<title>Implementing the Relative Vigor Index and Backtesting a Trading Strategy with Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Python实现相对活力指数和回测交易策略</h1>
<blockquote>原文：<a href="https://medium.com/codex/implementing-the-relative-vigor-index-and-backtesting-a-trading-strategy-with-python-d317afc0923a?source=collection_archive---------1-----------------------#2021-06-18">https://medium.com/codex/implementing-the-relative-vigor-index-and-backtesting-a-trading-strategy-with-python-d317afc0923a?source=collection_archive---------1-----------------------#2021-06-18</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="91dc" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">学会实施一个不太为人知的具有巨大潜力的指标，让你的交易看起来更好</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/4f08b26648f4a5f3c330fa7a8f78849b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*f5GhewzgXz9mSRKm"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">穆罕默德·哈吉在<a class="ae jn" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="98ed" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">股票交易领域的人肯定都知道随机振荡指标，因为它很受欢迎，今天，我们将探讨一个不仅类似，而且表现也像随机振荡指标的指标。这不是别人，正是相对活力指数，简称RVI。在本文中，我们将首先对指标及其背后的数学原理建立一些基本的直觉。然后，我们将继续编程，使用Python从头构建指标，回测基于它的交易策略，将策略结果与SPY ETF(专门设计用于跟踪标准普尔500市场指数运动的ETF)的结果进行比较。事不宜迟，让我们进入文章。</p><p id="e25a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在继续之前，如果你想在没有任何代码的情况下回溯测试你的交易策略，有一个解决方案。这是<a class="ae jn" href="https://www.backtestzone.com/" rel="noopener ugc nofollow" target="_blank">的后验区</a>。这是一个平台，可以免费对不同类型的可交易资产的任意数量的交易策略进行回溯测试，无需编码。点击这里的链接，你可以马上使用这个工具:<a class="ae jn" href="https://www.backtestzone.com/" rel="noopener ugc nofollow" target="_blank">https://www.backtestzone.com/</a></p><h1 id="cde0" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">相对活力指数(RVI)</h1><p id="4a98" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">相对活力指数是一个动力指标，作为一个工具，以确定当前的市场动力，向上或向下。与随机振荡器不同，相对活力指数是一个无界振荡器，不会在特定阈值之间波动，而是在中线(大多数情况下为零)振荡。相对活力指数由两部分组成，即RVI线和信号线。现在，让我们看看每个分量是如何计算的。</p><h2 id="5378" class="lh kl hi bd km li lj lk kq ll lm ln ku jx lo lp kw kb lq lr ky kf ls lt la lu bi translated">RVI线计算</h2><p id="b1e7" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">为了计算RVI线的读数，我们必须首先确定分子和分母。</p><p id="988e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">分子可以分五步计算:</strong></p><ul class=""><li id="238d" class="lv lw hi jq b jr js ju jv jx lx kb ly kf lz kj ma mb mc md bi translated">第一步是找出一只股票的当前收盘价和当前开盘价之间的差额，让我们把这个差额看作“a”。</li><li id="f96f" class="lv lw hi jq b jr me ju mf jx mg kb mh kf mi kj ma mb mc md bi translated">第二步是找出两期前的收盘价和两期前的开盘价之差，这个差乘以2。这个产品可以被认为是b。</li><li id="1f77" class="lv lw hi jq b jr me ju mf jx mg kb mh kf mi kj ma mb mc md bi translated">现在第三步，确定三期前收盘价和三期开盘价之差，然后乘以二，我们姑且认为这是‘c’。</li><li id="cd66" class="lv lw hi jq b jr me ju mf jx mg kb mh kf mi kj ma mb mc md bi translated">第四步是将我们从四个周期前的收盘价中减去四个周期前的开盘价得到的差值乘以2，这个乘积可以作为“d”。</li><li id="f264" class="lv lw hi jq b jr me ju mf jx mg kb mh kf mi kj ma mb mc md bi translated">最后一步是将确定的a、b、c和d变量相加，计算指定周期数的滚动和(典型设置为4)。分子计算可表示如下:</li></ul><pre class="iy iz ja jb fd mj mk ml mm aw mn bi"><span id="b1d3" class="lh kl hi mk b fi mo mp l mq mr"><strong class="mk hj">a </strong>= CURRENT CLOSE - CURRENT OPEN<br/><strong class="mk hj">b</strong> =  2 * ( CLOSE 2 PERIODS AGO - OPEN 2 PERIODS AGO )<br/><strong class="mk hj">c </strong>=  2 * ( CLOSE 3 PERIODS AGO - OPEN 3 PERIODS AGO )<br/><strong class="mk hj">d </strong>=  2 * ( CLOSE 4 PERIODS AGO - OPEN 4 PERIODS AGO )<br/><strong class="mk hj">Numerator</strong> = ROLLING SUM 4 [ a + b + c + d ]</span></pre><p id="7dc2" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">计算分母的过程几乎与计算分子的过程相似，但我们只需分别用高价格和低价格数据替换收盘价和开盘价数据。</p><p id="ce21" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">分母可以分五步计算:</strong></p><ul class=""><li id="d76a" class="lv lw hi jq b jr js ju jv jx lx kb ly kf lz kj ma mb mc md bi translated">第一步是找出一只股票的当前高价和当前低价之间的差额，让我们把这个差额记为“e”。</li><li id="4eab" class="lv lw hi jq b jr me ju mf jx mg kb mh kf mi kj ma mb mc md bi translated">第二步是找出两个周期前的高价和两个周期前的低价之间的差异，并将该差异乘以2。这个产品可以被认为是‘f’。</li><li id="f1bc" class="lv lw hi jq b jr me ju mf jx mg kb mh kf mi kj ma mb mc md bi translated">现在，第三步是确定三期之前的高价和三期之前的低价之差，然后乘以二，我们姑且认为这是‘g’。</li><li id="6a8b" class="lv lw hi jq b jr me ju mf jx mg kb mh kf mi kj ma mb mc md bi translated">第四步是将四个周期前的高价格减去四个周期前的低价格所得的差值乘以2，这个乘积可以作为“h”。</li><li id="b487" class="lv lw hi jq b jr me ju mf jx mg kb mh kf mi kj ma mb mc md bi translated">最后一步是将确定的e、f、g和h变量相加，并计算出以4为回望周期的滚动和。分母计算可表示如下:</li></ul><pre class="iy iz ja jb fd mj mk ml mm aw mn bi"><span id="ee87" class="lh kl hi mk b fi mo mp l mq mr"><strong class="mk hj">e </strong>= CURRENT HIGH - CURRENT LOW<br/><strong class="mk hj">f</strong> =  2 * ( HIGH 2 PERIODS AGO - LOW 2 PERIODS AGO )<br/><strong class="mk hj">g </strong>=  2 * ( HIGH 3 PERIODS AGO - LOW 3 PERIODS AGO )<br/><strong class="mk hj">h </strong>=  2 * ( HIGH 4 PERIODS AGO - LOW 4 PERIODS AGO )<br/><strong class="mk hj">Denominator </strong>= ROLLING SUM 4 [ e + f + g + h ]</span></pre><p id="ab1c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">得到分子和分母后，我们可以继续计算RVI线的读数，这真的很简单。我们只需将分子除以分母，然后通过简单的移动平均对特定数量的回看周期(周期数通常为10)进行平滑。该计算可以用数学方法表示如下:</p><pre class="iy iz ja jb fd mj mk ml mm aw mn bi"><span id="3353" class="lh kl hi mk b fi mo mp l mq mr"><strong class="mk hj">RVI LINE</strong> = SMA 10 [ NUMERATOR / DENOMINATOR ]</span></pre><h2 id="b3c7" class="lh kl hi bd km li lj lk kq ll lm ln ku jx lo lp kw kb lq lr ky kf ls lt la lu bi translated">信号线计算</h2><p id="5fd4" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">通常，将信号线作为一个组成部分的指标是通过简单移动平均或主要组成部分的指数移动平均(在我们的例子中是RVI线)在特定数量的周期内计算出来的。但是，它与相对活力指数不同。</p><p id="2717" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">信号线的计算包括四个主要步骤:</strong>第一步是将一个周期的RVI线读数乘以两个周期，我们将此视为“rvi1”。下一步是将两个周期前的RVI线读数乘以2，这可以被认为是“rvi2”。第三步是确定三个周期前的RVI线读数，这些值可视为“rvi3”。最后一步是将确定的‘rvi 1’、‘rvi 2’、‘rvi 3’与rvi线的读数相加，并将总和或结果除以6。该计算可以表示如下:</p><pre class="iy iz ja jb fd mj mk ml mm aw mn bi"><span id="7e49" class="lh kl hi mk b fi mo mp l mq mr"><strong class="mk hj">rvi1 </strong>= 2 * RVI LINE 1 PERIOD AGO<br/><strong class="mk hj">rvi2 </strong>= 2 * RVI LINE 2 PERIODS AGO<br/><strong class="mk hj">rvi3 </strong>= RVI LINE 3 PERIODS AGO<br/><strong class="mk hj">SIGNAL LINE </strong>= ( RVI LINE + rvi1 + rvi2 + rvi3 ) / 6</span></pre><p id="78d1" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这就是计算相对活力指数的组成部分的整个过程。现在，让我们分析一个图表，其中绘制了苹果的收盘价数据以及以10为回望期计算的相对活力指数，以建立对该指标及其使用方式的牢固理解。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ms"><img src="../Images/0c68aae2b083535e24f94ded8689342e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q_RMz-6O_1R47fl6bojvpQ.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">作者图片</figcaption></figure><p id="cea4" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">上面的图表分为两个面板:上面的面板显示了苹果公司的收盘价数据，下面的面板显示了以10为回望周期计算的相对活力指数的组成部分。该指标的主要特征是帮助交易者识别当前的市场动力，这可以在图表中清楚地看到，当市场表现出强劲的上升动力时，RVI指标的分量正上升，当市场处于强劲的下降动力状态时，分量下降。正如我之前所说，相对活力指数是一个无界振荡器，上图证明了这一点，可以看出，RVI指标的组成部分不像其他动量振荡器一样在特定的上限和下限之间波动，而是跨越零线或中线波动。</p><p id="d3ce" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">说到交易策略，据我所知，根据相对活力指数，可以运用三种交易策略。第一种是背离交易策略，第二种是经典的交叉策略，第三种是超买超卖策略。在本文中，我们将实施第二种交易策略，即交叉策略。这个策略在RVI线从信号线的下方穿越到上方时显示买入信号，同样，在RVI线从信号线的上方穿越到下方时显示卖出信号。RVI交叉交易策略可以表示如下:</p><pre class="iy iz ja jb fd mj mk ml mm aw mn bi"><span id="0f12" class="lh kl hi mk b fi mo mp l mq mr">IF <strong class="mk hj">PREV.RLINE</strong> &lt; <strong class="mk hj">PREV.SLINE</strong> AND <strong class="mk hj">CUR.RLINE</strong> &gt; <strong class="mk hj">CUR.SLINE</strong> ==&gt; <strong class="mk hj">BUY SIGNAL</strong><br/>IF <strong class="mk hj">PREV.RLINE</strong> &gt; <strong class="mk hj">PREV.SLINE</strong> AND <strong class="mk hj">CUR.RLINE</strong> &lt; <strong class="mk hj">CUR.SLINE</strong> ==&gt; <strong class="mk hj">SELL SIGNAL</strong></span></pre><p id="9338" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在大多数情况下，交易者使用相对活力指数和另一个技术指标来建立交易策略，但这不是本文的范围(建议尝试)。就是这样！这就结束了我们关于相对活力指数的理论部分，让我们进入编程部分，我们将首先使用Python从头构建指标，构建交叉交易策略，对苹果股票数据进行回溯测试，最后将结果与SPY ETF的结果进行比较。来做点编码吧！在继续之前，关于免责声明的一个注意事项:本文的唯一目的是教育人们，必须被视为一个信息，而不是投资建议等。</p><h1 id="48a2" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">用Python实现</h1><p id="6a30" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">编码部分分为以下几个步骤:</p><pre class="iy iz ja jb fd mj mk ml mm aw mn bi"><span id="53e8" class="lh kl hi mk b fi mo mp l mq mr"><strong class="mk hj">1. Importing Packages<br/>2. Extracting Stock Data from Twelve Data<br/>3. Relative Vigor Index Calculation<br/>4. Creating the Crossover Trading Strategy<br/>5. Plotting the Trading Lists<br/>6. Creating our Position<br/>7. Backtesting<br/>8. SPY ETF Comparison</strong></span></pre><p id="d489" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们将按照上面列表中提到的顺序，系好安全带，跟随每一个即将到来的编码部分。</p><h2 id="2330" class="lh kl hi bd km li lj lk kq ll lm ln ku jx lo lp kw kb lq lr ky kf ls lt la lu bi translated">步骤1:导入包</h2><p id="4733" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">将所需的包导入python环境是一个不可跳过的步骤。主要的包是处理数据的Pandas，处理数组和复杂函数的NumPy，用于绘图的Matplotlib，以及进行API调用的请求。二级包是数学函数的Math和字体定制的Termcolor(可选)。</p><p id="17a0" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> Python实现:</strong></p><pre class="iy iz ja jb fd mj mk ml mm aw mn bi"><span id="4277" class="lh kl hi mk b fi mo mp l mq mr"><strong class="mk hj"># IMPORTING PACKAGES<br/></strong><br/>import pandas as pd<br/>import matplotlib.pyplot as plt<br/>import numpy as np<br/>import requests<br/>from termcolor import colored as cl<br/>from math import floor<br/><br/>plt.style.use('fivethirtyeight')<br/>plt.rcParams['figure.figsize'] = (20,10)</span></pre><p id="27be" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在我们已经将所有需要的包导入到python中。我们用十二数据的API端点来拉一下苹果的历史数据。</p><h2 id="97fc" class="lh kl hi bd km li lj lk kq ll lm ln ku jx lo lp kw kb lq lr ky kf ls lt la lu bi translated">步骤2:从12个数据中提取数据</h2><p id="f818" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">在这一步中，我们将使用twelvedata.com<a class="ae jn" href="https://twelvedata.com/" rel="noopener ugc nofollow" target="_blank">提供的API端点提取苹果的历史股票数据。在此之前，关于</a><a class="ae jn" href="https://twelvedata.com/" rel="noopener ugc nofollow" target="_blank">twelvedata.com</a>的一个说明:十二数据是领先的市场数据提供商之一，拥有大量针对所有类型市场数据的API端点。它非常容易与十二数据提供的API进行交互，并且拥有有史以来最好的文档。此外，确保您在<a class="ae jn" href="https://twelvedata.com/" rel="noopener ugc nofollow" target="_blank">twelvedata.com</a>上有一个帐户，只有这样，您才能访问您的API密钥(使用API提取数据的重要元素)。</p><p id="e4a5" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> Python实现:</strong></p><pre class="iy iz ja jb fd mj mk ml mm aw mn bi"><span id="d335" class="lh kl hi mk b fi mo mp l mq mr"><strong class="mk hj"># EXTRACTING STOCK DATA<br/></strong><br/>def get_historical_data(symbol, start_date):<br/>    api_key = 'YOUR API KEY'<br/>    api_url = f'https://api.twelvedata.com/time_series?symbol={symbol}&amp;interval=1day&amp;outputsize=5000&amp;apikey={api_key}'<br/>    raw_df = requests.get(api_url).json()<br/>    df = pd.DataFrame(raw_df['values']).iloc[::-1].set_index('datetime').astype(float)<br/>    df = df[df.index &gt;= start_date]<br/>    df.index = pd.to_datetime(df.index)<br/>    return df<br/><br/>aapl = get_historical_data('AAPL', '2019-01-01')<br/>aapl.tail()</span></pre><p id="0200" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">输出:</strong></p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mt"><img src="../Images/99320bcd6f2bac5563582c246055c7e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v_espRNDeUcS1Rml27FcBA.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">作者图片</figcaption></figure><p id="e413" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">代码解释:</strong>我们做的第一件事是定义一个名为‘get _ historical _ data’的函数，它以股票的符号(‘symbol’)和历史数据的起始日期(‘start _ date’)作为参数。在函数内部，我们定义了API键和URL，并将它们存储到各自的变量中。接下来，我们使用“get”函数提取JSON格式的历史数据，并将其存储到“raw_df”变量中。在对原始JSON数据进行清理和格式化之后，我们将以干净的Pandas数据帧的形式返回它。最后，我们正在调用创建的函数来提取苹果从2019年开始的历史数据，并将其存储到‘AAPL’变量中。</p><h2 id="b9f9" class="lh kl hi bd km li lj lk kq ll lm ln ku jx lo lp kw kb lq lr ky kf ls lt la lu bi translated">第三步:相对活力指数计算</h2><p id="cace" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">在这一步，我们将按照之前讨论的方法和公式计算相对活力指数的组成部分。</p><p id="02ca" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> Python实现:</strong></p><pre class="iy iz ja jb fd mj mk ml mm aw mn bi"><span id="8d03" class="lh kl hi mk b fi mo mp l mq mr"><strong class="mk hj"># RELATIVE VIGOR INDEX CALCULATION<br/></strong><br/>def get_rvi(open, high, low, close, lookback):<br/>    a = close - open<br/>    b = 2 * (close.shift(2) - open.shift(2))<br/>    c = 2 * (close.shift(3) - open.shift(3))<br/>    d = close.shift(4) - open.shift(4)<br/>    numerator = a + b + c + d<br/>    <br/>    e = high - low<br/>    f = 2 * (high.shift(2) - low.shift(2))<br/>    g = 2 * (high.shift(3) - low.shift(3))<br/>    h = high.shift(4) - low.shift(4)<br/>    denominator = e + f + g + h<br/>    <br/>    numerator_sum = numerator.rolling(4).sum()<br/>    denominator_sum = denominator.rolling(4).sum()<br/>    rvi = (numerator_sum / denominator_sum).rolling(lookback).mean()<br/>    <br/>    rvi1 = 2 * rvi.shift(1)<br/>    rvi2 = 2 * rvi.shift(2)<br/>    rvi3 = rvi.shift(3)<br/>    rvi_signal = (rvi + rvi1 + rvi2 + rvi3) / 6<br/>    <br/>    return rvi, rvi_signal<br/><br/>aapl['rvi'], aapl['signal_line'] = get_rvi(aapl['open'], aapl['high'], aapl['low'], aapl['close'], 10)<br/>aapl = aapl.dropna()<br/>aapl = aapl[aapl.index &gt;= '2020-01-01']<br/>aapl.tail()</span></pre><p id="5430" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">输出:</strong></p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mu"><img src="../Images/f8ce296b955dc7657af35390436efe37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o7Gp_MqqqpKn6Exah68hag.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">作者图片</figcaption></figure><p id="521a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">代码解释:</strong>我们首先定义一个名为‘get _ rvi’的函数，它将股票的开盘价(‘open’)、盘高(‘high’)、盘低(‘low’)、收盘价(‘close’)数据和回看期(‘look back’)作为参数。</p><p id="7dd7" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在函数内部，我们首先计算参与分子计算的变量，即a、b、c和d。这些变量是按照我们之前讨论过的公式计算的，它们相互相加以确定分子。接下来是分母的计算，与分子的计算几乎相似，但我们只是替换了某些值。在计算RVI线的读数之前，我们先确定分子和分母的滚动和，以4作为回望周期，然后将结果代入RVI线的公式中，得到读数。</p><p id="4b78" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">之后，我们计算之前讨论过的三个前提变量，即rvi1、rvi2和rvi3，并将之前计算的rvi线值代入信号线公式，以获得读数。最后，我们返回并调用函数store Apple的相对活力指数读数，10为回望期。</p><h2 id="c3aa" class="lh kl hi bd km li lj lk kq ll lm ln ku jx lo lp kw kb lq lr ky kf ls lt la lu bi translated">步骤4:创建交易策略</h2><p id="8500" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">在这一步，我们将在python中实现所讨论的相对活力指数交叉交易策略。</p><p id="303b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> Python实现:</strong></p><pre class="iy iz ja jb fd mj mk ml mm aw mn bi"><span id="5324" class="lh kl hi mk b fi mo mp l mq mr"><strong class="mk hj"># RELATIVE VIGOR INDEX STRATEGY<br/></strong><br/>def implement_rvi_strategy(prices, rvi, signal_line):<br/>    buy_price = []<br/>    sell_price = []<br/>    rvi_signal = []<br/>    signal = 0<br/>    <br/>    for i in range(len(prices)):<br/>        if rvi[i-1] &lt; signal_line[i-1] and rvi[i] &gt; signal_line[i]:<br/>            if signal != 1:<br/>                buy_price.append(prices[i])<br/>                sell_price.append(np.nan)<br/>                signal = 1<br/>                rvi_signal.append(signal)<br/>            else:<br/>                buy_price.append(np.nan)<br/>                sell_price.append(np.nan)<br/>                rvi_signal.append(0)<br/>        elif rvi[i-1] &gt; signal_line[i-1] and rvi[i] &lt; signal_line[i]:<br/>            if signal != -1:<br/>                buy_price.append(np.nan)<br/>                sell_price.append(prices[i])<br/>                signal = -1<br/>                rvi_signal.append(signal)<br/>            else:<br/>                buy_price.append(np.nan)<br/>                sell_price.append(np.nan)<br/>                rvi_signal.append(0)<br/>        else:<br/>            buy_price.append(np.nan)<br/>            sell_price.append(np.nan)<br/>            rvi_signal.append(0)<br/>            <br/>    return buy_price, sell_price, rvi_signal<br/><br/>buy_price, sell_price, rvi_signal = implement_rvi_strategy(aapl['close'], aapl['rvi'], aapl['signal_line'])</span></pre><p id="336a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">代码解释:</strong>首先，我们定义一个名为‘implement _ rvi _ strategy’的函数，它将股票价格(‘prices’)和相对活力指数的组成部分(‘rvi’，‘signal _ line’)作为参数。</p><p id="be0d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在该函数中，我们创建了三个空列表(buy_price、sell_price和rvi_signal ),在创建交易策略时，将在这些列表中追加值。</p><p id="d12e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">之后，我们通过for循环实施交易策略。在for循环内部，我们传递某些条件，如果条件得到满足，相应的值将被追加到空列表中。如果购买股票的条件得到满足，买入价将被追加到“buy_price”列表中，信号值将被追加为1，表示购买股票。类似地，如果卖出股票的条件得到满足，卖价将被追加到“sell_price”列表中，信号值将被追加为-1，表示卖出股票。</p><p id="e942" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">最后，我们返回附加了值的列表。然后，我们调用创建的函数并将值存储到各自的变量中。除非我们画出这些值，否则这个列表没有任何意义。所以，让我们画出创建的交易列表的值。</p><h2 id="50f6" class="lh kl hi bd km li lj lk kq ll lm ln ku jx lo lp kw kb lq lr ky kf ls lt la lu bi translated">第五步:绘制交易信号</h2><p id="45dd" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">在这一步，我们将绘制已创建的交易列表，以使它们有意义。</p><p id="f92b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> Python实现:</strong></p><pre class="iy iz ja jb fd mj mk ml mm aw mn bi"><span id="0b34" class="lh kl hi mk b fi mo mp l mq mr"><strong class="mk hj"># RELATIVE VIGOR INDEX TRADING SIGNALS PLOT<br/></strong><br/>ax1 = plt.subplot2grid((11,1), (0,0), rowspan = 5, colspan = 1)<br/>ax2 = plt.subplot2grid((11,1), (6,0), rowspan = 5, colspan = 1)<br/>ax1.plot(aapl['close'], linewidth = 2)<br/>ax1.plot(aapl.index, buy_price, marker = '^', markersize = 12, color = 'green', linewidth = 0, label = 'BUY SIGNAL')<br/>ax1.plot(aapl.index, sell_price, marker = 'v', markersize = 12, color = 'r', linewidth = 0, label = 'SELL SIGNAL')<br/>ax1.legend()<br/>ax1.set_title('AAPL RVI TRADING SIGNALS')<br/>ax2.plot(aapl['rvi'], linewidth = 2, color = 'orange', label = 'RVI LINE')<br/>ax2.plot(aapl['signal_line'], linewidth = 2, color = '#BA5FE3', label = 'SIGNAL LINE')<br/>ax2.set_title('AAPL RVI 10')<br/>ax2.legend()<br/>plt.show()</span></pre><p id="0994" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">输出:</strong></p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mv"><img src="../Images/d6d18b4a8863f544d23ff4b79ab4b3b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rsNs6C4XQvCJ6mAYm_CtFg.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">作者图片</figcaption></figure><p id="baec" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">代码解释:</strong>我们正在绘制相对活力指数的组成部分，以及交叉交易策略产生的买入和卖出信号。我们可以观察到，只要RVI线的前一个读数低于信号线的前一个读数，而RVI线的当前读数高于信号线的当前读数，图表中就会出现绿色的买入信号。同样，每当RVI线的前一个读数高于信号线的前一个读数，而RVI线的当前读数低于信号线的当前读数时，图表中就会出现红色的卖出信号。</p><h2 id="c35a" class="lh kl hi bd km li lj lk kq ll lm ln ku jx lo lp kw kb lq lr ky kf ls lt la lu bi translated">步骤6:创建我们的职位</h2><p id="93f4" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">在这一步中，我们将创建一个列表，如果我们持有股票，该列表将指示1；如果我们不拥有或持有股票，该列表将指示0。</p><p id="0b3c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> Python实现:</strong></p><pre class="iy iz ja jb fd mj mk ml mm aw mn bi"><span id="2116" class="lh kl hi mk b fi mo mp l mq mr"><strong class="mk hj"># STOCK POSITION<br/></strong><br/>position = []<br/>for i in range(len(rvi_signal)):<br/>    if rvi_signal[i] &gt; 1:<br/>        position.append(0)<br/>    else:<br/>        position.append(1)<br/>        <br/>for i in range(len(aapl['close'])):<br/>    if rvi_signal[i] == 1:<br/>        position[i] = 1<br/>    elif rvi_signal[i] == -1:<br/>        position[i] = 0<br/>    else:<br/>        position[i] = position[i-1]<br/>        <br/>close_price = aapl['close']<br/>rvi = aapl['rvi']<br/>signal_line = aapl['signal_line']<br/>rvi_signal = pd.DataFrame(rvi_signal).rename(columns = {0:'rvi_signal'}).set_index(aapl.index)<br/>position = pd.DataFrame(position).rename(columns = {0:'rvi_position'}).set_index(aapl.index)<br/><br/>frames = [close_price, rvi, signal_line, rvi_signal, position]<br/>strategy = pd.concat(frames, join = 'inner', axis = 1)<br/><br/>strategy</span></pre><p id="a98a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">输出:</strong></p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mw"><img src="../Images/61120f652b44cc918235cee3c1df46ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9R6jlJJBe40WhDAeaK0W4w.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">作者图片</figcaption></figure><p id="b56e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">代码解释:</strong>首先，我们创建一个名为‘position’的空列表。我们传递两个for循环，一个是为“位置”列表生成值，以匹配“信号”列表的长度。另一个for循环是我们用来生成实际位置值的循环。在第二个for循环中，我们对“signal”列表的值进行迭代，而“position”列表的值被附加到满足哪个条件上。如果我们持有股票，头寸的价值仍为1；如果我们卖出或不持有股票，头寸的价值仍为0。最后，我们正在进行一些数据操作，将所有创建的列表合并到一个数据帧中。</p><p id="49c4" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">从显示的输出中，我们可以看到，在第一行中，我们在股票中的位置仍然是1(因为相对活力指数信号没有任何变化)，但是当相对活力指数交易信号代表卖出信号(-1)时，我们的位置突然变成-1。我们的头寸将保持为0，直到交易信号发生一些变化。现在是时候实现一些回溯测试过程了！</p><h2 id="d024" class="lh kl hi bd km li lj lk kq ll lm ln ku jx lo lp kw kb lq lr ky kf ls lt la lu bi translated">步骤7:回溯测试</h2><p id="a82d" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">在继续之前，有必要知道什么是回溯测试。回溯测试是查看我们的交易策略在给定股票数据上表现如何的过程。在我们的例子中，我们将对Apple股票数据的相对活力指数交易策略实施回溯测试过程。</p><p id="5910" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> Python实现:</strong></p><pre class="iy iz ja jb fd mj mk ml mm aw mn bi"><span id="9535" class="lh kl hi mk b fi mo mp l mq mr"><strong class="mk hj"># BACKTESTING<br/></strong><br/>aapl_ret = pd.DataFrame(np.diff(aapl['close'])).rename(columns = {0:'returns'})<br/>rvi_strategy_ret = []<br/><br/>for i in range(len(aapl_ret)):<br/>    returns = aapl_ret['returns'][i]*strategy['rvi_position'][i]<br/>    rvi_strategy_ret.append(returns)<br/>    <br/>rvi_strategy_ret_df = pd.DataFrame(rvi_strategy_ret).rename(columns = {0:'rvi_returns'})<br/>investment_value = 100000<br/>number_of_stocks = floor(investment_value/aapl['close'][0])<br/>rvi_investment_ret = []<br/><br/>for i in range(len(rvi_strategy_ret_df['rvi_returns'])):<br/>    returns = number_of_stocks*rvi_strategy_ret_df['rvi_returns'][i]<br/>    rvi_investment_ret.append(returns)<br/><br/>rvi_investment_ret_df = pd.DataFrame(rvi_investment_ret).rename(columns = {0:'investment_returns'})<br/>total_investment_ret = round(sum(rvi_investment_ret_df['investment_returns']), 2)<br/>profit_percentage = floor((total_investment_ret/investment_value)*100)<br/>print(cl('Profit gained from the RVI strategy by investing $100k in AAPL : {}'.format(total_investment_ret), attrs = ['bold']))<br/>print(cl('Profit percentage of the RVI strategy : {}%'.format(profit_percentage), attrs = ['bold']))</span></pre><p id="ef32" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">输出:</strong></p><pre class="iy iz ja jb fd mj mk ml mm aw mn bi"><span id="6b28" class="lh kl hi mk b fi mo mp l mq mr"><strong class="mk hj">Profit gained from the RVI strategy by investing $100k in AAPL : 71643.4</strong><br/><strong class="mk hj">Profit percentage of the RVI strategy : 71%</strong></span></pre><p id="fd24" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">代码解释:</strong>首先，我们使用NumPy包提供的‘diff’函数计算苹果股票的回报，并将其作为数据帧存储到‘AAPL _ ret’变量中。接下来，我们将传递一个for循环来迭代' aapl_ret '变量的值，以计算我们从RVI交易策略中获得的回报，这些回报值将被追加到' rvi_strategy_ret '列表中。接下来，我们将“rvi_strategy_ret”列表转换为数据帧，并将其存储到“rvi_strategy_ret_df”变量中。</p><p id="c66c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">接下来是回溯测试过程。我们将通过投资10万美元到我们的交易策略中来回测我们的策略。首先，我们将投资金额存储到“投资值”变量中。之后，我们正在计算使用投资金额可以购买的苹果股票数量。你可以注意到，我使用了Math软件包提供的“floor”函数，因为当投资金额除以苹果股票的收盘价时，它会输出一个十进制数。股票数量应该是整数，而不是小数。使用“底数”函数，我们可以去掉小数。请记住,“floor”函数比“round”函数要复杂得多。然后，我们传递一个for循环来查找投资回报，后面是一些数据操作任务。</p><p id="7dc1" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">最后，我们打印了我们通过投资10万到我们的交易策略中得到的总回报，并且显示我们在一年中获得了大约71，000美元的利润。那还不错！现在，让我们将我们的回报与SPY ETF(一种旨在跟踪标准普尔500股票市场指数的ETF)的回报进行比较。</p><h2 id="ce90" class="lh kl hi bd km li lj lk kq ll lm ln ku jx lo lp kw kb lq lr ky kf ls lt la lu bi translated">第八步:间谍ETF对比</h2><p id="cab1" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">这一步是可选的，但强烈推荐，因为我们可以了解我们的交易策略相对于基准(间谍ETF)的表现如何。在这一步，我们将使用我们创建的“get_historical_data”函数提取SPY ETF数据，并将我们从SPY ETF获得的回报与我们在苹果公司的RVI交叉交易策略回报进行比较。</p><p id="a05c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">你可能已经注意到，在我所有的算法交易文章中，我没有将策略结果与标准普尔500市场指数本身进行比较，而是与SPY ETF进行比较，这是因为大多数股票数据提供商(如12 Data)不提供标准普尔500指数数据。所以，我别无选择，只能选择间谍ETF。如果你有幸得到标准普尔500市场指数数据，建议用它来做比较，而不是任何ETF。</p><p id="60dd" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> Python实现:</strong></p><pre class="iy iz ja jb fd mj mk ml mm aw mn bi"><span id="62e0" class="lh kl hi mk b fi mo mp l mq mr"><strong class="mk hj"># SPY ETF COMPARISON<br/></strong><br/>def get_benchmark(start_date, investment_value):<br/>    spy = get_historical_data('SPY', start_date)['close']<br/>    benchmark = pd.DataFrame(np.diff(spy)).rename(columns = {0:'benchmark_returns'})<br/>    <br/>    investment_value = investment_value<br/>    number_of_stocks = floor(investment_value/spy[0])<br/>    benchmark_investment_ret = []<br/>    <br/>    for i in range(len(benchmark['benchmark_returns'])):<br/>        returns = number_of_stocks*benchmark['benchmark_returns'][i]<br/>        benchmark_investment_ret.append(returns)<br/><br/>    benchmark_investment_ret_df = pd.DataFrame(benchmark_investment_ret).rename(columns = {0:'investment_returns'})<br/>    return benchmark_investment_ret_df<br/><br/>benchmark = get_benchmark('2020-01-01', 100000)<br/>investment_value = 100000<br/>total_benchmark_investment_ret = round(sum(benchmark['investment_returns']), 2)<br/>benchmark_profit_percentage = floor((total_benchmark_investment_ret/investment_value)*100)<br/>print(cl('Benchmark profit by investing $100k : {}'.format(total_benchmark_investment_ret), attrs = ['bold']))<br/>print(cl('Benchmark Profit percentage : {}%'.format(benchmark_profit_percentage), attrs = ['bold']))<br/>print(cl('RVI Strategy profit is {}% higher than the Benchmark Profit'.format(profit_percentage - benchmark_profit_percentage), attrs = ['bold']))</span></pre><p id="2d9a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">输出:</strong></p><pre class="iy iz ja jb fd mj mk ml mm aw mn bi"><span id="7802" class="lh kl hi mk b fi mo mp l mq mr"><strong class="mk hj">Benchmark profit by investing $100k : 28491.13</strong><br/><strong class="mk hj">Benchmark Profit percentage : 28%</strong><br/><strong class="mk hj">RVI Strategy profit is 43% higher than the Benchmark Profit</strong></span></pre><p id="ef71" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">代码解释:</strong>这一步中使用的代码几乎与前一个回溯测试步骤中使用的代码相似，但我们不是投资苹果，而是通过不实施任何交易策略来投资SPY ETF。从输出可以看出，我们的相对活力指数交叉交易策略已经跑赢SPY ETF 43%。太好了！</p><h1 id="1140" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">最后的想法！</h1><p id="8972" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">在彻底粉碎理论和编码部分之后，我们已经成功地了解了相对活力指数是什么，该指标背后的数学原理，以及如何在Python中实现基于它的简单交易策略。</p><p id="b8ae" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">尽管我们成功超越了SPY ETF的结果，但我们仍然落后于苹果的实际回报。这可能是因为当市场波动时，相对活力指数倾向于揭示许多错误信号，这也可以在讨论我们的交叉交易策略产生的买入和卖出信号时的图表中观察到。</p><p id="13d2" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">解决这个问题的唯一方法是将相对活力指数与另一个技术指标结合起来，这个技术指标就像一个过滤器，唯一的任务就是将虚假信号与真实信号区分开来。由于相对活力指数是一个方向性指标(指标的变动与实际市场的变动成正比)，选择一个非方向性指标，尤其是波动性指标，将成为一个很好的过滤器，最终引导我们从现实市场中获得想要的结果。</p><p id="16bc" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">话虽如此，你已经到了文章的结尾。如果您忘记了遵循任何编码部分，不要担心。我在文章末尾提供了完整的源代码。希望你能从这篇文章中学到一些新的有用的东西。</p><h2 id="2d39" class="lh kl hi bd km li lj lk kq ll lm ln ku jx lo lp kw kb lq lr ky kf ls lt la lu bi translated">完整代码:</h2><pre class="iy iz ja jb fd mj mk ml mm aw mn bi"><span id="c3a5" class="lh kl hi mk b fi mo mp l mq mr"># IMPORTING PACKAGES<br/><br/>import pandas as pd<br/>import matplotlib.pyplot as plt<br/>import numpy as np<br/>import requests<br/>from termcolor import colored as cl<br/>from math import floor<br/><br/>plt.style.use('fivethirtyeight')<br/>plt.rcParams['figure.figsize'] = (20,10)<br/><br/># EXTRACTING STOCK DATA<br/><br/>def get_historical_data(symbol, start_date):<br/>    api_key = 'YOUR API KEY'<br/>    api_url = f'https://api.twelvedata.com/time_series?symbol={symbol}&amp;interval=1day&amp;outputsize=5000&amp;apikey={api_key}'<br/>    raw_df = requests.get(api_url).json()<br/>    df = pd.DataFrame(raw_df['values']).iloc[::-1].set_index('datetime').astype(float)<br/>    df = df[df.index &gt;= start_date]<br/>    df.index = pd.to_datetime(df.index)<br/>    return df<br/><br/>aapl = get_historical_data('AAPL', '2019-01-01')<br/>aapl.tail()<br/><br/># RELATIVE VIGOR INDEX CALCULATION<br/><br/>def get_rvi(open, high, low, close, lookback):<br/>    a = close - open<br/>    b = 2 * (close.shift(2) - open.shift(2))<br/>    c = 2 * (close.shift(3) - open.shift(3))<br/>    d = close.shift(4) - open.shift(4)<br/>    numerator = a + b + c + d<br/>    <br/>    e = high - low<br/>    f = 2 * (high.shift(2) - low.shift(2))<br/>    g = 2 * (high.shift(3) - low.shift(3))<br/>    h = high.shift(4) - low.shift(4)<br/>    denominator = e + f + g + h<br/>    <br/>    numerator_sum = numerator.rolling(4).sum()<br/>    denominator_sum = denominator.rolling(4).sum()<br/>    rvi = (numerator_sum / denominator_sum).rolling(lookback).mean()<br/>    <br/>    rvi1 = 2 * rvi.shift(1)<br/>    rvi2 = 2 * rvi.shift(2)<br/>    rvi3 = rvi.shift(3)<br/>    rvi_signal = (rvi + rvi1 + rvi2 + rvi3) / 6<br/>    <br/>    return rvi, rvi_signal<br/><br/>aapl['rvi'], aapl['signal_line'] = get_rvi(aapl['open'], aapl['high'], aapl['low'], aapl['close'], 10)<br/>aapl = aapl.dropna()<br/>aapl = aapl[aapl.index &gt;= '2020-01-01']<br/>aapl.tail()<br/><br/># RELATIVE VIGOR INDEX PLOT<br/><br/>ax1 = plt.subplot2grid((11,1), (0,0), rowspan = 5, colspan = 1)<br/>ax2 = plt.subplot2grid((11,1), (6,0), rowspan = 5, colspan = 1)<br/>ax1.plot(aapl['close'], linewidth = 2.5)<br/>ax1.set_title('AAPL CLOSING PRICES')<br/>ax2.plot(aapl['rvi'], linewidth = 2, color = 'orange', label = 'RVI LINE')<br/>ax2.plot(aapl['signal_line'], linewidth = 2, color = '#BA5FE3', label = 'SIGNAL LINE')<br/>ax2.legend()<br/>ax2.set_title('AAPL RVI 10')<br/>plt.show()<br/><br/># RELATIVE VIGOR INDEX STRATEGY<br/><br/>def implement_rvi_strategy(prices, rvi, signal_line):<br/>    buy_price = []<br/>    sell_price = []<br/>    rvi_signal = []<br/>    signal = 0<br/>    <br/>    for i in range(len(prices)):<br/>        if rvi[i-1] &lt; signal_line[i-1] and rvi[i] &gt; signal_line[i]:<br/>            if signal != 1:<br/>                buy_price.append(prices[i])<br/>                sell_price.append(np.nan)<br/>                signal = 1<br/>                rvi_signal.append(signal)<br/>            else:<br/>                buy_price.append(np.nan)<br/>                sell_price.append(np.nan)<br/>                rvi_signal.append(0)<br/>        elif rvi[i-1] &gt; signal_line[i-1] and rvi[i] &lt; signal_line[i]:<br/>            if signal != -1:<br/>                buy_price.append(np.nan)<br/>                sell_price.append(prices[i])<br/>                signal = -1<br/>                rvi_signal.append(signal)<br/>            else:<br/>                buy_price.append(np.nan)<br/>                sell_price.append(np.nan)<br/>                rvi_signal.append(0)<br/>        else:<br/>            buy_price.append(np.nan)<br/>            sell_price.append(np.nan)<br/>            rvi_signal.append(0)<br/>            <br/>    return buy_price, sell_price, rvi_signal<br/><br/>buy_price, sell_price, rvi_signal = implement_rvi_strategy(aapl['close'], aapl['rvi'], aapl['signal_line'])<br/><br/># RELATIVE VIGOR INDEX TRADING SIGNALS PLOT<br/><br/>ax1 = plt.subplot2grid((11,1), (0,0), rowspan = 5, colspan = 1)<br/>ax2 = plt.subplot2grid((11,1), (6,0), rowspan = 5, colspan = 1)<br/>ax1.plot(aapl['close'], linewidth = 2)<br/>ax1.plot(aapl.index, buy_price, marker = '^', markersize = 12, color = 'green', linewidth = 0, label = 'BUY SIGNAL')<br/>ax1.plot(aapl.index, sell_price, marker = 'v', markersize = 12, color = 'r', linewidth = 0, label = 'SELL SIGNAL')<br/>ax1.legend()<br/>ax1.set_title('AAPL RVI TRADING SIGNALS')<br/>ax2.plot(aapl['rvi'], linewidth = 2, color = 'orange', label = 'RVI LINE')<br/>ax2.plot(aapl['signal_line'], linewidth = 2, color = '#BA5FE3', label = 'SIGNAL LINE')<br/>ax2.set_title('AAPL RVI 10')<br/>ax2.legend()<br/>plt.show()<br/><br/># STOCK POSITION<br/><br/>position = []<br/>for i in range(len(rvi_signal)):<br/>    if rvi_signal[i] &gt; 1:<br/>        position.append(0)<br/>    else:<br/>        position.append(1)<br/>        <br/>for i in range(len(aapl['close'])):<br/>    if rvi_signal[i] == 1:<br/>        position[i] = 1<br/>    elif rvi_signal[i] == -1:<br/>        position[i] = 0<br/>    else:<br/>        position[i] = position[i-1]<br/>        <br/>close_price = aapl['close']<br/>rvi = aapl['rvi']<br/>signal_line = aapl['signal_line']<br/>rvi_signal = pd.DataFrame(rvi_signal).rename(columns = {0:'rvi_signal'}).set_index(aapl.index)<br/>position = pd.DataFrame(position).rename(columns = {0:'rvi_position'}).set_index(aapl.index)<br/><br/>frames = [close_price, rvi, signal_line, rvi_signal, position]<br/>strategy = pd.concat(frames, join = 'inner', axis = 1)<br/><br/>strategy<br/>strategy[19:24]<br/><br/># BACKTESTING<br/><br/>aapl_ret = pd.DataFrame(np.diff(aapl['close'])).rename(columns = {0:'returns'})<br/>rvi_strategy_ret = []<br/><br/>for i in range(len(aapl_ret)):<br/>    returns = aapl_ret['returns'][i]*strategy['rvi_position'][i]<br/>    rvi_strategy_ret.append(returns)<br/>    <br/>rvi_strategy_ret_df = pd.DataFrame(rvi_strategy_ret).rename(columns = {0:'rvi_returns'})<br/>investment_value = 100000<br/>number_of_stocks = floor(investment_value/aapl['close'][0])<br/>rvi_investment_ret = []<br/><br/>for i in range(len(rvi_strategy_ret_df['rvi_returns'])):<br/>    returns = number_of_stocks*rvi_strategy_ret_df['rvi_returns'][i]<br/>    rvi_investment_ret.append(returns)<br/><br/>rvi_investment_ret_df = pd.DataFrame(rvi_investment_ret).rename(columns = {0:'investment_returns'})<br/>total_investment_ret = round(sum(rvi_investment_ret_df['investment_returns']), 2)<br/>profit_percentage = floor((total_investment_ret/investment_value)*100)<br/><br/>print(cl('Profit gained from the RVI strategy by investing $100k in AAPL : {}'.format(total_investment_ret), attrs = ['bold']))<br/>print(cl('Profit percentage of the RVI strategy : {}%'.format(profit_percentage), attrs = ['bold']))<br/><br/># SPY ETF COMPARISON<br/><br/>def get_benchmark(start_date, investment_value):<br/>    spy = get_historical_data('SPY', start_date)['close']<br/>    benchmark = pd.DataFrame(np.diff(spy)).rename(columns = {0:'benchmark_returns'})<br/>    <br/>    investment_value = investment_value<br/>    number_of_stocks = floor(investment_value/spy[0])<br/>    benchmark_investment_ret = []<br/>    <br/>    for i in range(len(benchmark['benchmark_returns'])):<br/>        returns = number_of_stocks*benchmark['benchmark_returns'][i]<br/>        benchmark_investment_ret.append(returns)<br/><br/>    benchmark_investment_ret_df = pd.DataFrame(benchmark_investment_ret).rename(columns = {0:'investment_returns'})<br/>    return benchmark_investment_ret_df<br/><br/>benchmark = get_benchmark('2020-01-01', 100000)<br/><br/>investment_value = 100000<br/>total_benchmark_investment_ret = round(sum(benchmark['investment_returns']), 2)<br/>benchmark_profit_percentage = floor((total_benchmark_investment_ret/investment_value)*100)<br/><br/>print(cl('Benchmark profit by investing $100k : {}'.format(total_benchmark_investment_ret), attrs = ['bold']))<br/>print(cl('Benchmark Profit percentage : {}%'.format(benchmark_profit_percentage), attrs = ['bold']))<br/>print(cl('RVI Strategy profit is {}% higher than the Benchmark Profit'.format(profit_percentage - benchmark_profit_percentage), attrs = ['bold']))</span></pre></div></div>    
</body>
</html>