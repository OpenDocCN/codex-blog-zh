<html>
<head>
<title>To Throw or Not To Throw</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">扔还是不扔</h1>
<blockquote>原文：<a href="https://medium.com/codex/to-throw-or-not-to-throw-4e5470427060?source=collection_archive---------1-----------------------#2020-10-04">https://medium.com/codex/to-throw-or-not-to-throw-4e5470427060?source=collection_archive---------1-----------------------#2020-10-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="a92e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我经常发现团队说服自己不使用异常进行流程控制，因为他们不做像沃德·坎宁安的<a class="ae jh" href="https://web.archive.org/web/20140430044213/http://c2.com/cgi-bin/wiki?DontUseExceptionsForFlowControl" rel="noopener ugc nofollow" target="_blank">维基</a>中描述的<code class="du jd je jf jg b">ResultException</code>这样的构造。</p><p id="f438" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在大多数这样的团队中，事情可能没有那么糟糕。</p><p id="672d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是我已经看到异常以非常接近流动控制的方式被使用，特别是当所述<strong class="ih hj">异常的存在被用来触发复杂的业务场景</strong>时。</p><p id="163f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你可能也看到了这确实是一个经常使用的方法，那么这样使用异常有什么不好呢？</p><h2 id="c060" class="ji jj hi bd jk jl jm jn jo jp jq jr js iq jt ju jv iu jw jx jy iy jz ka kb kc bi translated">1.例外会增加认知的复杂性</h2><p id="40f3" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq kf is it iu kg iw ix iy kh ja jb jc hb bi translated">在你的代码中大量使用异常会使代码难以阅读和理解。记住每一个<code class="du jd je jf jg b">catch</code> <a class="ae jh" href="https://www.sonarsource.com/docs/CognitiveComplexity.pdf" rel="noopener ugc nofollow" target="_blank">都会增加</a>认知的复杂性。</p><p id="dfb1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">谈到异常，我个人的偏好总是这样:异常应该只在发生异常时使用。换句话说，<strong class="ih hj">只有当你需要从已经发生的不好的事情中快速退出时才抛出异常。</strong></p><figure class="kk kl km kn fd ko er es paragraph-image"><div class="er es kj"><img src="../Images/bebb20282ac914237226d2bb4918cc4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*OhnAs8pplGdpOtY3Pr9cwg.jpeg"/></div><figcaption class="kr ks et er es kt ku bd b be z dx translated">一个快速离开大楼的出口【图片来自<a class="ae jh" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1040527" rel="noopener ugc nofollow" target="_blank">Pixabay</a></figcaption></figure><p id="b9c4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="ki">例如，如果正在执行的业务功能是一个捕获支付的功能，并且如果履行该功能所需的一些依赖关系不可用(如外部支付网关关闭)，则抛出异常。</em></p><p id="a7e0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">另一个解决方案是完全避免异常，选择另一种机制，如<code class="du jd je jf jg b">Result</code> <a class="ae jh" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-result/" rel="noopener ugc nofollow" target="_blank">对象</a>或<a class="ae jh" href="https://www.freecodecamp.org/news/a-survival-guide-to-the-either-monad-in-scala-7293a680006/" rel="noopener ugc nofollow" target="_blank">单子</a></p><p id="eebe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然而，我还没有看到每个团队都渴望采用像<code class="du jd je jf jg b">Result </code>对象这样的新概念。此外，考虑到移植现有代码并不容易。</p><p id="1bad" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这让我开始思考。有没有一套我们可以遵循的准则，使得代码可读性更好，同时仍然使用异常？</p><p id="e9bd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，我试着列出一份清单。</p><h1 id="379d" class="kv jj hi bd jk kw kx ky jo kz la lb js lc ld le jv lf lg lh jy li lj lk kb ll bi translated">基本准则</h1><h2 id="b696" class="ji jj hi bd jk jl jm jn jo jp jq jr js iq jt ju jv iu jw jx jy iy jz ka kb kc bi translated">1.处理来自外部库的异常</h2><p id="24d2" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq kf is it iu kg iw ix iy kh ja jb jc hb bi translated">在可能抛出异常的地方附近处理从第三方库中抛出的异常。不要在下游处理异常。</p><p id="3b54" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们让第三方抛出的异常传播到代码的所有层，它会增加与库的耦合。</p><p id="e243" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果需要的话，当您将库切换到另一个库时，这也可能会引发微妙的、无法捕捉的错误。</p><h2 id="87f5" class="ji jj hi bd jk jl jm jn jo jp jq jr js iq jt ju jv iu jw jx jy iy jz ka kb kc bi translated">2.尊重建筑边界</h2><p id="d494" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq kf is it iu kg iw ix iy kh ja jb jc hb bi translated">这与上面的问题非常相似，但我将它作为一个单独的点来提及，因为这是我经常看到的事情。</p><p id="82ac" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如，避免在表示层处理从数据库层抛出的特定于数据库的异常。</p><h2 id="347c" class="ji jj hi bd jk jl jm jn jo jp jq jr js iq jt ju jv iu jw jx jy iy jz ka kb kc bi translated">3.处理您自己的异常</h2><p id="f907" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq kf is it iu kg iw ix iy kh ja jb jc hb bi translated">如果您自己在代码中抛出异常，只需处理一次。</p><p id="ca98" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这应该只在一个地方完成——如果你来自Spring世界，希望是一个专用的<code class="du jd je jf jg b">ExceptionHandler</code>类。</p><p id="cada" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个建议的原因是由于异常的本质，它们可以作为<strong class="ih hj">非本地化的</strong> <code class="du jd je jf jg b"><strong class="ih hj">goto</strong></code> <strong class="ih hj">语句。</strong></p><p id="9c53" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，我想降低它可能引发的问题的等级，只在一个地方查看异常的处理。对于未来的维护者来说，这比必须通过完整的执行链来理解发生了什么更容易。</p><p id="78cc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这种范式也可能引发一些有趣的问题需要解决。</p><p id="ac3a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们经常需要捕捉我们自己抛出的异常，可能更新一两个指标，或者一个数据库实体，并重新抛出相同的或者(甚至)不同的异常，以便下游的一些代码可以处理它。</p><p id="5622" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有一些方法可以做到上述事情，这些方法可能包括首先不使用异常，或者甚至修改代码架构，以便满足只处理一次抛出的异常的范式。</p><p id="165b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这通常并不容易，但将来当下一个人试图阅读和解读正在发生的事情时，这将会有所回报。</p><h2 id="065b" class="ji jj hi bd jk jl jm jn jo jp jq jr js iq jt ju jv iu jw jx jy iy jz ka kb kc bi translated">4.记录API方法</h2><p id="071a" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq kf is it iu kg iw ix iy kh ja jb jc hb bi translated">如果您正在编写一个抛出未检查异常的方法，请记录下来。简单的<code class="du jd je jf jg b">JavaDoc</code>评论就能达到目的。<strong class="ih hj">一个不记录它抛出的关于其契约的异常的方法。</strong></p><p id="9fdd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">帮助未来的代码维护者。如果他们没有这份文件，可能是不知道它<code class="du jd je jf jg b">throws</code>是不愉快路径情况下的一个例外。</p><p id="d42f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通常情况下，他们要么</p><ul class=""><li id="37b2" class="lm ln hi ih b ii ij im in iq lo iu lp iy lq jc lr ls lt lu bi translated">用<code class="du jd je jf jg b">try</code>和<code class="du jd je jf jg b">catch</code>块包装所有调用该方法的代码，使代码不必要地冗长(or)</li><li id="512a" class="lm ln hi ih b ii lv im lw iq lx iu ly iy lz jc lr ls lt lu bi translated">忘记捕捉异常，并可能结束将异常传播到下游层。</li></ul><p id="c077" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">两者都是糟糕的地方。</p><h1 id="eba4" class="kv jj hi bd jk kw kx ky jo kz la lb js lc ld le jv lf lg lh jy li lj lk kb ll bi translated">结论</h1><p id="f90d" class="pw-post-body-paragraph if ig hi ih b ii kd ik il im ke io ip iq kf is it iu kg iw ix iy kh ja jb jc hb bi translated">这些都是我在最近的一个项目中想到的非常基本的观点，也是我在思考如何编写更易于维护和阅读的代码的时候想到的。</p><h1 id="73c7" class="kv jj hi bd jk kw kx ky jo kz la lb js lc ld le jv lf lg lh jy li lj lk kb ll bi translated">参考</h1><ol class=""><li id="03a1" class="lm ln hi ih b ii kd im ke iq ma iu mb iy mc jc md ls lt lu bi translated">什么是认知复杂性—<a class="ae jh" href="https://www.sonarsource.com/docs/CognitiveComplexity.pdf" rel="noopener ugc nofollow" target="_blank">https://www.sonarsource.com/docs/CognitiveComplexity.pdf</a></li><li id="daa5" class="lm ln hi ih b ii lv im lw iq lx iu ly iy lz jc md ls lt lu bi translated">Scala中的单子——<a class="ae jh" href="https://www.freecodecamp.org/news/a-survival-guide-to-the-either-monad-in-scala-7293a680006/" rel="noopener ugc nofollow" target="_blank">https://www . freecodecamp . org/news/a-survival-guide-to-the-any-monad-in-Scala-7293 a 680006/</a></li><li id="207b" class="lm ln hi ih b ii lv im lw iq lx iu ly iy lz jc md ls lt lu bi translated">Kotlin结果对象—<a class="ae jh" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-result/" rel="noopener ugc nofollow" target="_blank">https://kot linlang . org/API/latest/JVM/stdlib/kot Lin/-Result/</a></li></ol></div></div>    
</body>
</html>