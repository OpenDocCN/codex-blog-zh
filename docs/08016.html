<html>
<head>
<title>LeetCode 300. Longest Increasing Subsequence — Python Solution</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">LeetCode 300。最长递增子序列— Python解决方案</h1>
<blockquote>原文：<a href="https://medium.com/codex/leetcode-300-longest-increasing-subsequence-python-solution-239657985745?source=collection_archive---------9-----------------------#2022-07-11">https://medium.com/codex/leetcode-300-longest-increasing-subsequence-python-solution-239657985745?source=collection_archive---------9-----------------------#2022-07-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="21e3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">盲75 —编程和技术面试问题—解释系列</p><h2 id="d5cb" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">问题是:</h2><figure class="jz ka kb kc fd kd er es paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="er es jy"><img src="../Images/b6b33e3b224c8072e92655af00ae4cf5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*yjDgoyYT0Nykf1m5.png"/></div></div></figure><h2 id="8955" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">解释是:</h2><p id="b83a" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">总是使用深度优先搜索O(2^n).的野蛮解决方案然后是动态规划解O(n)。这也是另一个O(nlogn)解决方案，我不会解释，因为这是一个困难的解决方案，可能不会在面试中出现。动态编程解决方案从数组的末尾反向工作到开始。原因是很容易计算出最后几个指数的最长增长序列，但是越往后越难。</p><p id="15ac" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了解决这个问题，如果您缓存反向工作的解决方案，您可以使用这些保存的计算，而不是重做工作。对此需要注意的是，您不能只使用之前计算的LIS，因为这可能不会导致最长的递增子序列。为了解决这个问题，你必须遍历所有先前计算的列表，以找到该特定值的最佳子序列，因此这个问题是O(n)。现在，为了确定每个先前计算清单的子序列，您将当前清单设置为其自身和1加上先前计算的清单的最大值。这将保证数组中每个索引的最大LIS。</p><h2 id="cdea" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated">动态规划解:O(n)</h2><p id="37e9" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">首先初始化数组来保存每个索引的LIS，然后开始向后遍历所有值。在这个循环中，创建另一个从i+1到数组中最后一个值的循环。然后确定当前值是否可以添加到LIS[j]子序列中(因为我们是向后工作的，所以它必须小于nums[j])。如果是，则将当前LIS设置为其自身和1加上LIS[j]的最大值。在循环之后，只返回列表的最大值。超级简单的代码，但是很难理解。</p><pre class="jz ka kb kc fd kp kq kr ks aw kt bi"><span id="1499" class="jd je hi kq b fi ku kv l kw kx">class Solution:<br/> def lengthOfLIS(self, nums: List[int]) -&gt; int:<br/>  LIS = [1] * len(nums)<br/> <br/>  for i in range(len(nums) — 1, -1, -1):<br/>   for j in range(i + 1, len(nums)):<br/>    if nums[i] &lt; nums[j]:<br/>     LIS[i] = max(LIS[i], 1 + LIS[j])<br/> <br/>  return max(LIS)</span></pre><h1 id="1a09" class="ky je hi bd jf kz la lb jj lc ld le jn lf lg lh jq li lj lk jt ll lm ln jw lo bi translated">信息:</h1><p id="0915" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">网址:<a class="ae lp" href="http://www.nkwade.dev/" rel="noopener ugc nofollow" target="_blank">nkwade . dev</a><br/>LinkedIn:<a class="ae lp" href="http://www.linkedin.com/in/nkwade/" rel="noopener ugc nofollow" target="_blank">linkedin.com/in/nkwade</a><br/>GitHub:<a class="ae lp" href="http://www.github.com/nkwade" rel="noopener ugc nofollow" target="_blank">github.com/nkwade</a><br/>邮箱:<a class="ae lp" href="mailto:nicholas@nkwade.dev" rel="noopener ugc nofollow" target="_blank"> nicholas@nkwade.dev </a></p></div></div>    
</body>
</html>