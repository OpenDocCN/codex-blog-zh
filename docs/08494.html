<html>
<head>
<title>Breadth-First Search, Depth-First Search, Dijakras and A* Pathfinding Algorithms in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的广度优先搜索、深度优先搜索、Dijakras和A*寻路算法</h1>
<blockquote>原文：<a href="https://medium.com/codex/python-project-idea-graph-traversal-and-pathfinding-algorithm-visualisations-99595c414293?source=collection_archive---------4-----------------------#2022-08-12">https://medium.com/codex/python-project-idea-graph-traversal-and-pathfinding-algorithm-visualisations-99595c414293?source=collection_archive---------4-----------------------#2022-08-12</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="7e6b" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">Python中的图遍历和寻路算法可视化</h2></div></div><div class="ab cl ix iy gp iz" role="separator"><span class="ja bw bk jb jc jd"/><span class="ja bw bk jb jc jd"/><span class="ja bw bk jb jc"/></div><div class="hb hc hd he hf"><h2 id="36ec" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">介绍</h2><p id="d659" class="pw-post-body-paragraph kc kd hi ke b kf kg ij kh ki kj im kk jp kl km kn jt ko kp kq jx kr ks kt ku hb bi translated">基于<strong class="ke hj">图</strong>的<em class="kv">编码挑战</em>通常出现在<em class="kv">亚马逊</em>、<em class="kv">谷歌</em>和<em class="kv">脸书</em>等科技公司的<em class="kv">技术面试</em>中。</p><p id="e118" class="pw-post-body-paragraph kc kd hi ke b kf kw ij kh ki kx im kk jp ky km kn jt kz kp kq jx la ks kt ku hb bi translated">本文提出了一个Python项目建议，用于学习<strong class="ke hj">图遍历算法</strong>。我在几年前完成了这个项目，这个想法源于<a class="ae lb" href="https://www.youtube.com/user/TheBartR" rel="noopener ugc nofollow" target="_blank"> TheBartR </a>和<a class="ae lb" href="https://github.com/clementmihailescu" rel="noopener ugc nofollow" target="_blank"> Clément Mihailescu </a>。</p><figure class="ld le lf lg fd lh er es paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="er es lc"><img src="../Images/da13ae8733f24a45db626b3926fd08bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*yU9EdN3JToi04J9n"/></div></div><figcaption class="lo lp et er es lq lr bd b be z dx translated">图片由<a class="ae lb" href="https://unsplash.com/@seefromthesky?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">伊桑@seefromthesky </a>在<a class="ae lb" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure></div><div class="ab cl ix iy gp iz" role="separator"><span class="ja bw bk jb jc jd"/><span class="ja bw bk jb jc jd"/><span class="ja bw bk jb jc"/></div><div class="hb hc hd he hf"><h1 id="05b7" class="ls jf hi bd jg lt lu lv jk lw lx ly jo io lz ip js ir ma is jw iu mb iv ka mc bi translated">项目描述</h1><h2 id="048d" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">有向和无向图</h2><p id="6b4b" class="pw-post-body-paragraph kc kd hi ke b kf kg ij kh ki kj im kk jp kl km kn jt ko kp kq jx kr ks kt ku hb bi translated">寻路方法是<em class="kv">探索节点</em>之间路线的图形搜索算法。即寻路算法的<em class="kv">目标</em>是从<strong class="ke hj">起点</strong>节点移动到<strong class="ke hj">终点</strong>节点，<strong class="ke hj">跟踪</strong>到达目标的路径。</p><p id="0b0e" class="pw-post-body-paragraph kc kd hi ke b kf kw ij kh ki kx im kk jp ky km kn jt kz kp kq jx la ks kt ku hb bi translated">在这个项目中，我实现了四个关键算法；<em class="kv">广度优先搜索</em>、<em class="kv">深度优先搜索</em>、<em class="kv">迪杰斯特拉的</em>和<em class="kv"> A* </em> (A星)。网上有许多优秀的资源可以清楚地描述这些<em class="kv">基本概念</em>。</p><p id="4175" class="pw-post-body-paragraph kc kd hi ke b kf kw ij kh ki kx im kk jp ky km kn jt kz kp kq jx la ks kt ku hb bi translated">把一个图想象成由<strong class="ke hj">节点</strong>组成的<em class="kv">网络</em>。例如，图1说明了一个<em class="kv">无向</em>和一个<em class="kv">有向</em>图。</p><ul class=""><li id="ec26" class="md me hi ke b kf kw ki kx jp mf jt mg jx mh ku mi mj mk ml bi translated"><strong class="ke hj">无向图</strong>与<em class="kv">无</em>方向<em class="kv">有联系</em>。每条边之间存在双向关系。</li><li id="b3f0" class="md me hi ke b kf mm ki mn jp mo jt mp jx mq ku mi mj mk ml bi translated"><strong class="ke hj">有向</strong>图在<em class="kv">顶点</em>之间有链接，带有<em class="kv">箭头</em>指示信息可以沿着<strong class="ke hj">边</strong>传播的方向。</li></ul><div class="ld le lf lg fd ab cb"><figure class="mr lh ms mt mu mv mw paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><img src="../Images/863ebd0ea372310a4a956e241ba62f8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*nTQMwBnbt8lqvjYGROFasQ.png"/></div></figure><figure class="mr lh mx mt mu mv mw paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><img src="../Images/828b20b787c3b55f12e565f10a126ec2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1002/format:webp/1*DjdA59OYZ--lXPtLbaUK0w.png"/></div><figcaption class="lo lp et er es lq lr bd b be z dx my di mz na translated">图1-无向图和有向图(图片由作者提供)</figcaption></figure></div><p id="066c" class="pw-post-body-paragraph kc kd hi ke b kf kw ij kh ki kx im kk jp ky km kn jt kz kp kq jx la ks kt ku hb bi translated">网格有效地充当了节点的网络。随着探索的进行，必须确定节点的过去、现在和未来<code class="du nb nc nd ne b">State</code>。要点1显示了封装了所有可能状态值的<code class="du nb nc nd ne b">enum</code>。</p><figure class="ld le lf lg fd lh"><div class="bz dy l di"><div class="nf ng l"/></div><figcaption class="lo lp et er es lq lr bd b be z dx translated">要点1 —可能的状态</figcaption></figure><p id="e046" class="pw-post-body-paragraph kc kd hi ke b kf kw ij kh ki kx im kk jp ky km kn jt kz kp kq jx la ks kt ku hb bi translated">Gist 2给出了包含<code class="du nb nc nd ne b">Node</code>类的Python代码。关键属性包括其<strong class="ke hj">网格位置</strong>、<strong class="ke hj">周围元素列表</strong>和当前<code class="du nb nc nd ne b">State</code>。</p><figure class="ld le lf lg fd lh"><div class="bz dy l di"><div class="nf ng l"/></div><figcaption class="lo lp et er es lq lr bd b be z dx translated">要点2 —节点类</figcaption></figure></div><div class="ab cl ix iy gp iz" role="separator"><span class="ja bw bk jb jc jd"/><span class="ja bw bk jb jc jd"/><span class="ja bw bk jb jc"/></div><div class="hb hc hd he hf"><h1 id="82f9" class="ls jf hi bd jg lt lu lv jk lw lx ly jo io lz ip js ir ma is jw iu mb iv ka mc bi translated">算法</h1><p id="bea7" class="pw-post-body-paragraph kc kd hi ke b kf kg ij kh ki kj im kk jp kl km kn jt ko kp kq jx kr ks kt ku hb bi translated"><strong class="ke hj">广度优先搜索(BFS) </strong>和<strong class="ke hj">深度优先搜索</strong> (DFS)是基本的图遍历算法。</p><p id="594f" class="pw-post-body-paragraph kc kd hi ke b kf kw ij kh ki kx im kk jp ky km kn jt kz kp kq jx la ks kt ku hb bi translated">BFS <em class="kv">在移动到下一层</em>之前遍历当前层的所有节点。Gist 3给出了BFS <strong class="ke hj">迭代</strong>算法的Python实现，该算法用于查找<em class="kv">网格</em>中两个节点之间的路径。</p><figure class="ld le lf lg fd lh"><div class="bz dy l di"><div class="nf ng l"/></div><figcaption class="lo lp et er es lq lr bd b be z dx translated">要点3——广度优先搜索迭代解法</figcaption></figure><p id="e599" class="pw-post-body-paragraph kc kd hi ke b kf kw ij kh ki kx im kk jp ky km kn jt kz kp kq jx la ks kt ku hb bi translated"><strong class="ke hj">编码面试挑战</strong>通常会涉及这些技术中的任何一种，作为<em class="kv">第一步分析</em>。图2说明了运行中的BFS算法。</p><figure class="ld le lf lg fd lh er es paragraph-image"><div class="er es nh"><img src="../Images/88c1b6d42526d4c645e6e24f4f43d551.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*G0bI5-8oY1bP8-1KkZ2iog.gif"/></div><figcaption class="lo lp et er es lq lr bd b be z dx translated">图2-广度优先搜索(按作者分类的图片)</figcaption></figure><p id="28be" class="pw-post-body-paragraph kc kd hi ke b kf kw ij kh ki kx im kk jp ky km kn jt kz kp kq jx la ks kt ku hb bi translated"><strong class="ke hj"> DFS </strong>尽可能远地通过<em class="kv">节点</em>，直到到达<em class="kv">附近没有未访问节点</em>的节点。Gist 4中提供了DFS Python求解器。</p><figure class="ld le lf lg fd lh"><div class="bz dy l di"><div class="nf ng l"/></div><figcaption class="lo lp et er es lq lr bd b be z dx translated">要点4 —深度优先搜索求解器</figcaption></figure><p id="7fc9" class="pw-post-body-paragraph kc kd hi ke b kf kw ij kh ki kx im kk jp ky km kn jt kz kp kq jx la ks kt ku hb bi translated">要了解这些算法之间的比较，请参见BFS和DFS之间的<a class="ae lb" href="https://www.geeksforgeeks.org/difference-between-bfs-and-dfs/#:~:text=BFS(Breadth%20First%20Search)%20uses,3.&amp;text=BFS%20is%20a%20traversal%20approach,on%20to%20the%20next%20level." rel="noopener ugc nofollow" target="_blank">差异</a>。图3显示了DFS。</p><figure class="ld le lf lg fd lh er es paragraph-image"><div class="er es nh"><img src="../Images/9b05f41091145169480da6e66a52a112.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*qsxP3Tjk_6Ur6pnrc_3KzQ.gif"/></div><figcaption class="lo lp et er es lq lr bd b be z dx translated">图3 —深度优先搜索(图片由作者提供)</figcaption></figure></div><div class="ab cl ix iy gp iz" role="separator"><span class="ja bw bk jb jc jd"/><span class="ja bw bk jb jc jd"/><span class="ja bw bk jb jc"/></div><div class="hb hc hd he hf"><h2 id="484b" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">最短路径</h2><p id="8eb6" class="pw-post-body-paragraph kc kd hi ke b kf kg ij kh ki kj im kk jp kl km kn jt ko kp kq jx kr ks kt ku hb bi translated"><strong class="ke hj"> Dijkstra的</strong>和<strong class="ke hj"> A* </strong>寻找<em class="kv">最短路径</em>，这意味着他们计算出一对节点之间最<em class="kv">简洁的路线</em>。因此，它们在开始和结束节点之间识别出<strong class="ke hj">最佳</strong>路径。</p><p id="80e2" class="pw-post-body-paragraph kc kd hi ke b kf kw ij kh ki kx im kk jp ky km kn jt kz kp kq jx la ks kt ku hb bi translated"><em class="kv">类似<em class="kv"> A* </em>的最短路径寻路方法的实际用例</em>包括<em class="kv">物流规划</em>和<em class="kv"> IP路由</em>。</p><p id="dbfc" class="pw-post-body-paragraph kc kd hi ke b kf kw ij kh ki kx im kk jp ky km kn jt kz kp kq jx la ks kt ku hb bi translated">图4说明了Dijkstra的方法。<strong class="ke hj">加权节点</strong>存在于画布上，这给该技术增加了一层进一步的复杂性。以前的方法，BFS和DFS，<em class="kv">没有考虑重量</em>。</p><figure class="ld le lf lg fd lh er es paragraph-image"><div class="er es nh"><img src="../Images/4624d9761b59e4d10b0bebe5525d9611.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*uRCp8cZaQFCceOFUMMwFMA.gif"/></div><figcaption class="lo lp et er es lq lr bd b be z dx translated">图4 — Dijkstra最短路径算法<strong class="bd jg"> </strong>(图片由作者提供)</figcaption></figure><p id="03cb" class="pw-post-body-paragraph kc kd hi ke b kf kw ij kh ki kx im kk jp ky km kn jt kz kp kq jx la ks kt ku hb bi translated"><em class="kv"> A*算法通过<strong class="ke hj">启发式函数</strong>包含额外的信息来改进Dijkstra </em>过程，启发式函数确定接下来探索哪些路径。这种试探的一个例子是起点和终点之间的<strong class="ke hj">欧几里德距离</strong>。</p><p id="8bc4" class="pw-post-body-paragraph kc kd hi ke b kf kw ij kh ki kx im kk jp ky km kn jt kz kp kq jx la ks kt ku hb bi translated">这种<strong class="ke hj">优化</strong>导致更快<em class="kv">找到最短路径</em>。A*算法可以找到已知<em class="kv"> GPS坐标</em>的单对位置之间的最短路径。图5显示了这种方法在一个比其他样本大得多的网络<em class="kv">上的<strong class="ke hj">效率</strong>。</em></p><figure class="ld le lf lg fd lh er es paragraph-image"><div class="er es nh"><img src="../Images/9ef094a4be86e84755ca91f7f17c5e26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*TmYIZKtp8dvX634FyVfagA.gif"/></div><figcaption class="lo lp et er es lq lr bd b be z dx translated">图5 — A* <strong class="bd jg"> </strong>(图片由作者提供)</figcaption></figure><p id="4649" class="pw-post-body-paragraph kc kd hi ke b kf kw ij kh ki kx im kk jp ky km kn jt kz kp kq jx la ks kt ku hb bi translated"><strong class="ke hj"> A* </strong>和<strong class="ke hj"> Dijkstra的</strong>算法或多或少是一样的，除了A*使用了<em class="kv">启发式</em>。因此，这两种算法都在同一个<code class="du nb nc nd ne b">class</code>中实现，并带有一个<code class="du nb nc nd ne b">flag</code>来指示需要使用哪一种算法。请参阅Gist 5中的代码了解这两种方法。</p><figure class="ld le lf lg fd lh"><div class="bz dy l di"><div class="nf ng l"/></div><figcaption class="lo lp et er es lq lr bd b be z dx translated">要点5 — <strong class="ak"> A* </strong>和<strong class="ak">迪杰斯特拉的</strong>算法</figcaption></figure></div><div class="ab cl ix iy gp iz" role="separator"><span class="ja bw bk jb jc jd"/><span class="ja bw bk jb jc jd"/><span class="ja bw bk jb jc"/></div><div class="hb hc hd he hf"><h2 id="ccb3" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">结论</h2><p id="1aef" class="pw-post-body-paragraph kc kd hi ke b kf kg ij kh ki kj im kk jp kl km kn jt ko kp kq jx kr ks kt ku hb bi translated">本文介绍了四种图遍历算法的Python代码和<strong class="ke hj">可视化</strong>。理解这些机制对于<em class="kv">工程</em>和<em class="kv">计算机科学学生</em>来说是有价值的，因为他们经常出现在<strong class="ke hj">编码面试</strong>中。</p><p id="48c9" class="pw-post-body-paragraph kc kd hi ke b kf kw ij kh ki kx im kk jp ky km kn jt kz kp kq jx la ks kt ku hb bi translated">如果这个项目<strong class="ke hj">想法</strong>让你感兴趣，那就去看看<a class="ae lb" href="https://towardsdatascience.com/5-sorting-algorithms-in-python-c7ece9df5dd6" rel="noopener" target="_blank">排序算法可视化</a>。这些项目对任何对编程和计算机科学感兴趣的人都很有价值。</p><div class="ni nj ez fb nk nl"><a href="https://towardsdatascience.com/5-sorting-algorithms-in-python-c7ece9df5dd6" rel="noopener follow" target="_blank"><div class="nm ab dw"><div class="nn ab no cl cj np"><h2 class="bd hj fi z dy nq ea eb nr ed ef hh bi translated">Python中的5种排序算法</h2><div class="ns l"><h3 class="bd b fi z dy nq ea eb nr ed ef dx translated">使用Python实现选择、冒泡、插入、合并和快速排序算法</h3></div><div class="nt l"><p class="bd b fp z dy nq ea eb nr ed ef dx translated">towardsdatascience.com</p></div></div><div class="nu l"><div class="nv l nw nx ny nu nz lm nl"/></div></div></a></div><p id="edb4" class="pw-post-body-paragraph kc kd hi ke b kf kw ij kh ki kx im kk jp ky km kn jt kz kp kq jx la ks kt ku hb bi translated">我经常提到<em class="kv"> Python </em>，因为那是我的编程语言偏好。然而，如果你有不同语言的技能，这些项目在你喜欢的任何语言中都是可行的。</p><p id="cc90" class="pw-post-body-paragraph kc kd hi ke b kf kw ij kh ki kx im kk jp ky km kn jt kz kp kq jx la ks kt ku hb bi translated">动画是投资组合演示的一个很好的补充。它展示了项目结果，并说明了如何实现算法的理解。该项目的<em class="kv">代码</em>存储在<a class="ae lb" href="https://github.com/ad-1/PathfindingVisualisation" rel="noopener ugc nofollow" target="_blank"> <strong class="ke hj"> GitHub </strong> </a>中。</p><div class="ni nj ez fb nk nl"><a href="https://github.com/ad-1/PathfindingVisualisation" rel="noopener  ugc nofollow" target="_blank"><div class="nm ab dw"><div class="nn ab no cl cj np"><h2 class="bd hj fi z dy nq ea eb nr ed ef hh bi translated">GitHub-ad-1/pathfindingvisualization:用Python可视化的图遍历算法，使用…</h2><div class="ns l"><h3 class="bd b fi z dy nq ea eb nr ed ef dx translated">使用Tkinter在Python中可视化的图遍历寻路算法。算法包括广度优先搜索…</h3></div><div class="nt l"><p class="bd b fp z dy nq ea eb nr ed ef dx translated">github.com</p></div></div></div></a></div><div class="ni nj ez fb nk nl"><a rel="noopener follow" target="_blank" href="/@andrewdaviesul/membership"><div class="nm ab dw"><div class="nn ab no cl cj np"><h2 class="bd hj fi z dy nq ea eb nr ed ef hh bi translated">通过我的推荐链接加入媒体-安德鲁·约瑟夫·戴维斯</h2><div class="ns l"><h3 class="bd b fi z dy nq ea eb nr ed ef dx translated">阅读安德鲁·约瑟夫·戴维斯(以及媒体上成千上万的其他作家)的每一个故事。您的会员费直接…</h3></div><div class="nt l"><p class="bd b fp z dy nq ea eb nr ed ef dx translated">medium.com</p></div></div><div class="nu l"><div class="oa l nw nx ny nu nz lm nl"/></div></div></a></div><blockquote class="ob"><p id="806e" class="oc od hi bd oe of og oh oi oj ok ku dx translated">如果您对Python、工程和数据科学感兴趣，请随时关注和查看我的其他文章。</p></blockquote><p id="bfa6" class="pw-post-body-paragraph kc kd hi ke b kf ol ij kh ki om im kk jp on km kn jt oo kp kq jx op ks kt ku hb bi translated">我希望你找到了有用的东西。感谢您的阅读。</p></div><div class="ab cl ix iy gp iz" role="separator"><span class="ja bw bk jb jc jd"/><span class="ja bw bk jb jc jd"/><span class="ja bw bk jb jc"/></div><div class="hb hc hd he hf"><h2 id="6527" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">参考</h2><p id="75a2" class="pw-post-body-paragraph kc kd hi ke b kf kg ij kh ki kj im kk jp kl km kn jt ko kp kq jx kr ks kt ku hb bi translated">[1]第四章。寻路和图搜索算法——马克·尼达姆的<a class="ae lb" href="https://learning.oreilly.com/library/view/graph-algorithms/9781492047674/" rel="noopener ugc nofollow" target="_blank">图算法，艾米·e·霍德勒</a></p></div></div>    
</body>
</html>