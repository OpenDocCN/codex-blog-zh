<html>
<head>
<title>Building a Sudoku Solver and Generator in Python (3/3)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Python构建数独解算器和生成器(3/3)</h1>
<blockquote>原文：<a href="https://medium.com/codex/building-a-sudoku-solver-and-generator-in-python-3-3-cac73d340973?source=collection_archive---------7-----------------------#2021-04-02">https://medium.com/codex/building-a-sudoku-solver-and-generator-in-python-3-3-cac73d340973?source=collection_archive---------7-----------------------#2021-04-02</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/083d426c32cd3c9bc7565073ff92e1a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UDnauIK4Zr3kIUQMX_BwqA.jpeg"/></div></div></figure><h1 id="13b7" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">完成发电机</h1><p id="c137" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">当我们玩数独游戏时，98%的时候我们期望只有一个解，因此我们需要生成只有一个解的数独游戏，这样我们就可以标记它是对还是错。为此，我们需要两个辅助函数和一个主函数，在生成电路板时调用。总的想法是，我们找到棋盘上不同的空位置，在每个位置上求解数独棋盘，并查看总共有多少个解。</p><p id="83e3" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">首先，我们将创建两个助手方法，类似于我们为求解器所做的事情，这将允许我们获得一个给定数独棋盘的所有可能解的列表</p><figure class="kr ks kt ku fd ij"><div class="bz dy l di"><div class="kv kw l"/></div></figure><p id="791e" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">这是一个求解方法，用于找出给定数独棋盘的解的数量，它接受两个与起始行和起始列相关的参数，然后使用我们传统的求解方法求解数独。这就是为什么一个数独游戏可以从棋盘上的多个空格中解决。</p><p id="5bd0" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">下一个方法是找到它遇到的第一个空白空间，但是当然有一个转折(否则我们为什么要做另一个方法？):</p><figure class="kr ks kt ku fd ij"><div class="bz dy l di"><div class="kv kw l"/></div></figure><p id="2903" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">这个方法接受一个board作为参数，这可能感觉怪怪的，因为到目前为止我们一直使用board属性，以及一个整数。在该方法中，每找到一个空单元格，变量就会递增，但是，如果该变量等于作为第二个参数传入的整数，则当前空单元格的行和列将在元组中返回。</p><p id="d976" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">我们要编写的下一个方法是main方法，它返回特定数独棋盘的解的数量:</p><figure class="kr ks kt ku fd ij"><div class="bz dy l di"><div class="kv kw l"/></div></figure><p id="3621" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">这是主要的公共方法，可以调用它来查找当前棋盘的解的数量。首先将变量_z设置为棋盘上空白单元格的数量，并创建一个for循环来多次迭代_z。在每次迭代期间，创建当前对象的一个<a class="ae kx" href="https://www.educba.com/python-deepcopy/" rel="noopener ugc nofollow" target="_blank">深拷贝</a>。这样我们就可以在不影响主对象的情况下编辑棋盘对象的副本。使用这个板副本，调用两个助手函数，板的解决方案被附加到解决方案列表中。最后，创建解决方案列表的集合列表，这是为了从列表中移除任何重复的解决方案。</p></div><div class="ab cl ky kz gp la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="hb hc hd he hf"><h1 id="b933" class="iq ir hi bd is it lf iv iw ix lg iz ja jb lh jd je jf li jh ji jj lj jl jm jn bi translated">结束这一切</h1><p id="65bf" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">为了结束一切，我们需要创建最后一个方法，它将生成一个单元格被删除的数独板，以及该板的解决方案:</p><figure class="kr ks kt ku fd ij"><div class="bz dy l di"><div class="kv kw l"/></div></figure><p id="d630" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">这个公共方法接受一个完全填充的板和一个困难作为参数。制作另一个深拷贝，这一次是填充板。有3个难度级别，每个级别描述了81个方格中有多少被从棋盘上移除。移除的方块越多，难度越大，生成棋盘的时间也越长。</p><p id="b5f8" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">首先，在3个while循环中，12个方块从整个棋盘上消失。然后，当计数器的当前值小于要移除的方块数时，程序将继续移除随机的方块。只有当棋盘有一个解时，计数器才会增加，否则被选择擦除的方格将返回到其原始值。一旦我们达到了数独只有一个解的状态，并且移除了足够多的单元格，问题板和解板(完全填充的板)都被返回。</p><p id="5449" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">当然，我们可以将这个函数打包到另一个方法中，该方法只接受难度作为参数，并调用这个主函数，以及生成随机完整棋盘的方法。然后这两者都以代码格式返回:</p><figure class="kr ks kt ku fd ij"><div class="bz dy l di"><div class="kv kw l"/></div></figure></div><div class="ab cl ky kz gp la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="hb hc hd he hf"><h1 id="f8b6" class="iq ir hi bd is it lf iv iw ix lg iz ja jb lh jd je jf li jh ji jj lj jl jm jn bi translated">最后的想法</h1><p id="6e37" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">这就结束了我的关于如何制作一个求解和生成数独引擎的3部分教程，这里有一个关于如何在你自己的脚本中使用它的简单例子:</p><figure class="kr ks kt ku fd ij"><div class="bz dy l di"><div class="kv kw l"/></div></figure><p id="8951" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">如果你喜欢这个教程，有任何问题或建议，那么请随时在这里留下评论，我一定会回答他们。</p><p id="c670" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">感谢您的阅读！💖</p></div></div>    
</body>
</html>