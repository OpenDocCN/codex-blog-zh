<html>
<head>
<title>Transcoding with FFMPEG</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用FFMPEG进行转码</h1>
<blockquote>原文：<a href="https://medium.com/codex/transcoding-with-ffmpeg-a7b6ce53b3fe?source=collection_archive---------7-----------------------#2022-03-24">https://medium.com/codex/transcoding-with-ffmpeg-a7b6ce53b3fe?source=collection_archive---------7-----------------------#2022-03-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="050d" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">介绍</h1><p id="462f" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">HTTP自适应流(HAS)广泛用于服务提供商端，以确保并最大化QoE。让我们假设一个典型的流媒体场景，其中给定的用户想要播放一个视频(使用本地分辨率<strong class="jf hj"> S </strong>)。我们有两个约束需要考虑，客户端可以支持的分辨率<strong class="jf hj">S’</strong>和带宽容量(<strong class="jf hj">R</strong>&lt;<strong class="jf hj">R</strong><em class="kb">max</em>)。</p><p id="525e" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">目标是以满足客户显示分辨率和带宽的最佳分辨率/比特率组合发送视频。这种技术在下图中通过用几个参数(CBR、CRF或CQP)对源素材进行编码来说明，这些参数分别是恒定比特率、恒定速率因子和恒定量化参数的简写。编码结果存储在服务器上，客户端请求最符合其要求的版本。</p><figure class="ki kj kk kl fd km er es paragraph-image"><div class="er es kh"><img src="../Images/89dbc65ad560dd478c0a82141020c837.png" data-original-src="https://miro.medium.com/v2/resize:fit:1246/format:webp/1*6O5qE8ySJtPexzUHBZvCzg.png"/></div><figcaption class="kp kq et er es kr ks bd b be z dx translated">自适应比特率流系统</figcaption></figure><h1 id="284c" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">代码转换部分</h1><p id="3ec4" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">让我们仔细看看我们用各种参数对源进行编码的地方。目的是创建一个比特率/分辨率对的数据库，客户端可以利用该数据库来保持在其限制范围内。考虑每秒50帧(即1920×1080)的FHD视频源中的单个场景。为了制作替代版本，我们需要更改各种设置，例如将序列从1080p缩减到720p或540p，并使用[21–51]范围内的QPs进行编码(为了简化)。</p><p id="b36c" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">接下来，我将利用FFMPEG(一个开源框架)python命令来演示代码转换过程的各个部分。<br/>要缩减序列，使用下面的FFMPEG命令:</p><pre class="ki kj kk kl fd kt ku kv kw aw kx bi"><span id="e270" class="ky ig hi ku b fi kz la l lb lc">ff = FFmpeg(inputs={‘VideoSource1080p50.yuv’: " -f rawvideo -pix_fmt 'yuv420p' -s:v '1920x1080' -r 50"},outputs = {‘VideoSource720p50.yuv’: "-vf scale=1280x720:flags=lanczos -pix_fmt ‘yuv420p’"})</span><span id="811a" class="ky ig hi ku b fi ld la l lb lc">ff.run()</span></pre><p id="04f1" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">我们现在使用我们的QP范围对生成后的缩减版本(720p，540p)进行编码。(请注意，此阶段包括本机解决方案。)</p><pre class="ki kj kk kl fd kt ku kv kw aw kx bi"><span id="ad10" class="ky ig hi ku b fi kz la l lb lc">ff = FFmpeg(inputs={‘VideoSource720p50.yuv’:”” },outputs={‘VideoSource720p50_30.yuv’: “ -c:v libx264 -x264-params qp=30”})</span><span id="3815" class="ky ig hi ku b fi ld la l lb lc">ff.run()</span></pre><p id="f382" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">上面的程序采用720p缩减版本，并使用X264编解码器进行编码，QP参数设置为30。在QP范围内，我们执行该命令(其他分辨率的过程相同)。我们可以在这个阶段获得比特率值。之后，我们可以返回到其原始分辨率，并使用与之前相同的命令计算基准电压源的PSNR度量，但使用正确的输入/输出和目标分辨率:</p><pre class="ki kj kk kl fd kt ku kv kw aw kx bi"><span id="e086" class="ky ig hi ku b fi kz la l lb lc">ff = FFmpeg(inputs={‘VideoSource540p50_40.yuv’: “ -f rawvideo -pix_fmt ‘yuv420p’ -s:v ‘960x540’ -r 50”},outputs = {‘VideoSource540p50_40_to_1080p.yuv’: “-vf scale=1920x1080:flags=lanczos -pix_fmt ‘yuv420p’”})</span><span id="6118" class="ky ig hi ku b fi ld la l lb lc">ff.run()</span></pre><p id="3f05" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">为了计算PSNR，我们引入以下命令:</p><pre class="ki kj kk kl fd kt ku kv kw aw kx bi"><span id="895e" class="ky ig hi ku b fi kz la l lb lc">ffmpeg -y -i “VideoSource540p50_40_to_1080p.yuv” -i “VideoSource1080p50.yuv” -lavfi psnr=”stats_file=PSNR_File” -f null -</span></pre><h1 id="3e95" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">凸包</h1><figure class="ki kj kk kl fd km er es paragraph-image"><div class="er es le"><img src="../Images/18de705ca85f254fcb3d4eb496a593e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1310/0*sx0jHnzvIa8yn56v"/></div><figcaption class="kp kq et er es kr ks bd b be z dx translated">视频源的凸包</figcaption></figure><p id="5df8" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">在使用我们的三种分辨率(1080p、720p和540p)计算所有编码版本的比特率和PSNR值之后，我们可以使用速率/质量对来创建每个分辨率的RQ曲线。凸包是定义所有曲线边界的曲线。</p><figure class="ki kj kk kl fd km er es paragraph-image"><div class="er es lf"><img src="../Images/e8a9cc04dc29fcaa882579da75e40abc.png" data-original-src="https://miro.medium.com/v2/resize:fit:630/format:webp/1*b-Ru2iEoJv1vx6SVzoXdIw.png"/></div><figcaption class="kp kq et er es kr ks bd b be z dx translated">比特率/分辨率对</figcaption></figure><p id="028c" class="pw-post-body-paragraph jd je hi jf b jg kc ji jj jk kd jm jn jo ke jq jr js kf ju jv jw kg jy jz ka hb bi translated">我们可以使用凸包构建上表，凸包将每个速率值与相关分辨率相关联。这个表对于解决前面提到的两个限制问题至关重要。因此，为了请求正确的版本，客户端选择最能利用其带宽同时保持最高质量的对。</p><h1 id="8afa" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">结论</h1><p id="17c1" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">在这个简短的讲座中，我们展示了如何在客户端屏幕上显示所请求的源文件的最佳版本，方法是选择适合客户端限制的合适的源文件对。概括地说，我们使用FFMPEG指令将原始文件缩小到所需的分辨率，用一系列qp对每个文件进行编码，然后将所有编码版本放大到原始分辨率，以计算源文件(称为参考)的PSNR。最后，我们通过绘制每个分辨率的RQ曲线并提取凸包来产生配对。</p><h1 id="8fa0" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">参考</h1><p id="eb49" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">【1】<a class="ae lg" href="https://ffmpeg.org/" rel="noopener ugc nofollow" target="_blank"><em class="kb"/></a><em class="kb"><br/></em>【2】<em class="kb"/><a class="ae lg" href="https://netflixtechblog.com/per-title-encode-optimization-7e99442b62a2" rel="noopener ugc nofollow" target="_blank">https://netflixtechblog . com/per-title-encode-optimization-7e 99442 b 62 a 2</a></p></div></div>    
</body>
</html>