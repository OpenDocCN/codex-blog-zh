<html>
<head>
<title>Asynchronous Rest Service in Messaging</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">消息传递中的异步Rest服务</h1>
<blockquote>原文：<a href="https://medium.com/codex/asynchronous-rest-service-in-messaging-27823d67988f?source=collection_archive---------25-----------------------#2022-06-22">https://medium.com/codex/asynchronous-rest-service-in-messaging-27823d67988f?source=collection_archive---------25-----------------------#2022-06-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="a1e4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我说的是我们如何利用微服务进行异步通信。</p><p id="cc33" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">微服务是基于<strong class="ih hj"> REST实现的，REST是“异步的”</strong>，使用<strong class="ih hj"> HTTP协议，它是“同步的”</strong>。这意味着，只要我们尝试使用REST和HTTP实现微服务，它就会变成同步的。</p><p id="704f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是如果要避免这个问题，解决的办法就是<strong class="ih hj">【消息】</strong>。我们必须使用一些消息代理。</p><p id="be43" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">等等，什么？什么是消息代理？</p><h2 id="3fd6" class="jd je hi bd jf jg jh ji jj jk jl jm jn iq jo jp jq iu jr js jt iy ju jv jw jx bi translated"><strong class="ak">消息代理:</strong></h2><blockquote class="jy jz ka"><p id="b7b1" class="if ig kb ih b ii ij ik il im in io ip kc ir is it kd iv iw ix ke iz ja jb jc hb bi translated">这就像是微服务的中间人。它从一个应用程序(生产者)接收消息，并把它们交给另一个应用程序(消费者)去做一些工作。</p></blockquote><p id="7d17" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有很多消息代理，如<strong class="ih hj"> Kafka、RabbitMQ和ActiveMQ </strong>。在这种情况下，我们将主要关注卡夫卡和RabbitMQ。</p><figure class="kg kh ki kj fd kk er es paragraph-image"><div class="er es kf"><img src="../Images/30917edf7159f29419edb70df2bd8ea8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1274/format:webp/1*De65lDfCCovhe0xr3DRxzA.jpeg"/></div></figure><p id="1177" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">RabbiMQ是一个<strong class="ih hj">普通队列管理协议</strong>。另一方面，<em class="kb"> Kafka </em>也可以做同样的事情，但是它主要是一个<strong class="ih hj">流处理系统</strong>可以处理一个消息流。</p><p id="25b3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这篇文章中，我将详细讨论这些是什么，以及我们什么时候可以同样使用它们。</p><h1 id="30c2" class="kn je hi bd jf ko kp kq jj kr ks kt jn ku kv kw jq kx ky kz jt la lb lc jw ld bi translated"><strong class="ak"> RabbitMQ vs卡夫卡:</strong></h1><p id="9a53" class="pw-post-body-paragraph if ig hi ih b ii le ik il im lf io ip iq lg is it iu lh iw ix iy li ja jb jc hb bi translated">1.如上所述，RabbitMQ是一个普通的队列管理协议，它使用一个名为AMQP(高级消息队列协议)的库，Kafka在用于处理消息流时也可以做同样的事情。</p><p id="7dd0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2.RabbitMQ中有一个智能代理，它可以完成代理内部的所有路由工作。另一方面，卡夫卡笔下的经纪人不是这样的，有一个不同的架构来实现同样的事情。</p><p id="17d6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">3.最重要的是，如果有只受您的系统影响的情况，我们可以使用RabbitMQ。如果是你私人的。</p><p id="82f7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是如果有这样的情况，比如，如果那里发生了什么事，还有其他一些系统感兴趣并希望得到通知。那你需要和卡夫卡一起去。</p><p id="1bba" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这两个我们分开考虑。</p><h1 id="f4e6" class="kn je hi bd jf ko kp kq jj kr ks kt jn ku kv kw jq kx ky kz jt la lb lc jw ld bi translated"><strong class="ak"> 1。RabbitMQ </strong></h1><figure class="kg kh ki kj fd kk er es paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="er es lj"><img src="../Images/28bcc6ac3b5382c8322b1313fa117352.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jKg35ZWGsXMC95ThkxdnNA.jpeg"/></div></div></figure><p id="ad35" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里，我们不直接将消息推送到队列中。我们有<strong class="ih hj">交换</strong>，它是一个<em class="kb">消息路由代理</em>。此外，我们还有一个<strong class="ih hj">路由键</strong>，它是用于将消息推送到不同队列的<em class="kb">。Route key使您能够将队列绑定到交换，然后消费者可以使用消息。</em></p><p id="bda3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里，当我们将消息路由到队列时，有不同的类型。(根据exchange配置，它决定进入哪个队列)</p><ol class=""><li id="395c" class="lo lp hi ih b ii ij im in iq lq iu lr iy ls jc lt lu lv lw bi translated"><strong class="ih hj">扇出交换</strong> :-这将<em class="kb">把消息复制到它所连接的每个队列中</em></li><li id="5ec7" class="lo lp hi ih b ii lx im ly iq lz iu ma iy mb jc lt lu lv lw bi translated"><strong class="ih hj">直接交换</strong> :-您可以<em class="kb">将消息直接定向到特定队列</em></li><li id="cf9e" class="lo lp hi ih b ii lx im ly iq lz iu ma iy mb jc lt lu lv lw bi translated"><strong class="ih hj">主题交换</strong> :-根据路由关键字和队列绑定的路由模式之间的通配符匹配，向队列<em class="kb">发送消息</em></li><li id="4b4f" class="lo lp hi ih b ii lx im ly iq lz iu ma iy mb jc lt lu lv lw bi translated"><strong class="ih hj">消息头交换</strong>:——这使用带有消息头和可选值的<em class="kb">参数来路由消息</em>。</li><li id="daca" class="lo lp hi ih b ii lx im ly iq lz iu ma iy mb jc lt lu lv lw bi translated"><strong class="ih hj">默认交换</strong> :-这是一个未命名的预先声明的直接交换</li></ol><p id="d39c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如何向消费者发布消息:</p><p id="0800" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">RabbitMQ以<strong class="ih hj">“Round Robbin”</strong>格式分发消息。但是我们对此有异议。</p><p id="a170" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">1.让我们假设这样的情况，某些消息需要更长的时间来处理。这可能会导致这种情况。有时，一些用户可能会在一些用户空闲的时候填满消息，这会花费更多的时间。</p><p id="3f52" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了避免这些问题，解决方案是“<strong class="ih hj">公平调度</strong>”。在公平调度中，我们有一种叫做“<strong class="ih hj">预取</strong>”的东西。</p><p id="957b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们的预取设置为3。这意味着RabbitMQ只会给你3条消息。然后，所有的消费者总会有一些信息。这样，我们就能克服这个问题。</p><p id="c6ba" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2.还有一个问题。通常，RabbitMQ将消息传递给消费者，它将从队列中删除消息。但是，如果发生了消费者无法处理的事情，消费者收到消息后会发生什么呢？现在消息无处可去，因为RabbitMQ在将消息传递给消费者后删除了消息。</p><p id="be64" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了避免这种问题，我们可以有一个“<strong class="ih hj"> ACK机制</strong>”。它的作用是，告诉RabbitMQ避免自动确认。然后它会告诉RabbitMQ什么时候删除消息。</p><h1 id="9199" class="kn je hi bd jf ko kp kq jj kr ks kt jn ku kv kw jq kx ky kz jt la lb lc jw ld bi translated">2.卡夫卡</h1><p id="8992" class="pw-post-body-paragraph if ig hi ih b ii le ik il im lf io ip iq lg is it iu lh iw ix iy li ja jb jc hb bi translated">这是更受欢迎的消息代理。这里，它使用了发布-订阅模式。</p><figure class="kg kh ki kj fd kk er es paragraph-image"><div class="er es mc"><img src="../Images/7b0ab92348090713801e9483a8d00c1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1284/format:webp/1*3_47khru4iPPXKsAUe9o_w.jpeg"/></div></figure><p id="de98" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在Kafka中，我们有一个<strong class="ih hj">主题</strong>,在主题中，我们可以有<strong class="ih hj">分区</strong>,当我们做实现时需要一个强有力的想法。如上所述，生产者将向主题发送消息，并且有分区。分区将接收消息并将它们发送给消费者。</p><p id="f766" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">不像RabbitMQ，在Kafka中，我们没有使用“循环”格式，因为Kafka有另一套做事的方法。</p><p id="be1b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第一点是可以有“<strong class="ih hj">消费者群体</strong>”，不同的消费者群体可以有不同数量的消费者。</p><p id="7233" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">卡夫卡的作品是怎样的，</p><p id="864a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当发布者发布消息给卡夫卡时，我们可以设置一个<strong class="ih hj">键</strong>。有些案件没有关键。但通常我们都有钥匙。</p><p id="4072" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们有了密钥，那么Kafka有一个叫做“模式”的算法，它将决定消息如何分配给分区。</p><p id="a058" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于消费者组，我们有一些限制，因为我们可以让消费者在具有多个分区的同一个消费者组中。但是有一个规则。<strong class="ih hj"> <em class="kb">总是同一个消费群中的几个消费者应小于或等于该话题拥有的分区数</em>。</strong>(可以打开更多的消费者。但是消息不会传递给这些消费者。)</p><p id="8a1a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">总结事实后，</p><ol class=""><li id="e38e" class="lo lp hi ih b ii ij im in iq lq iu lr iy ls jc lt lu lv lw bi translated"><strong class="ih hj"> <em class="kb">同一消费群中的几个消费者应小于或等于几个分区题目有</em>。</strong></li><li id="8948" class="lo lp hi ih b ii lx im ly iq lz iu ma iy mb jc lt lu lv lw bi translated">如果<strong class="ih hj">你想要一个订单保证</strong>，<strong class="ih hj">你需要有一把“钥匙”</strong>。(例如，如果您有一个消费者id，并且您需要将特定的消费者消息作为一个订单。)在这里，卡夫卡将遵循模式算法，并决定如何向消费者分发消息。</li><li id="ea3b" class="lo lp hi ih b ii lx im ly iq lz iu ma iy mb jc lt lu lv lw bi translated">如果您的实现没有密钥，那么Kafka不会使用模式算法，它将遵循<strong class="ih hj">“循环”模式</strong>来决定如何向消费者分发消息。</li></ol><p id="69ee" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，你需要记住的是，根据你的需求，选择最合适的消息经纪人，获得收益，乐在其中。</p></div></div>    
</body>
</html>