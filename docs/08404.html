<html>
<head>
<title>Python re Module</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python re模块</h1>
<blockquote>原文：<a href="https://medium.com/codex/python-re-module-e0feac601764?source=collection_archive---------10-----------------------#2022-08-05">https://medium.com/codex/python-re-module-e0feac601764?source=collection_archive---------10-----------------------#2022-08-05</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="5caa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正则表达式(RegEx)是定义搜索模式的字符序列。Python有一个内置的“re”模块来处理同样的问题。</p><p id="5b97" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在开始重新模块之前，让我们了解一下普通字符串和原始字符串之间的区别，因为我们将在“重新”模块中使用原始字符串。</p><p id="118d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Python原始字符串是通过在字符串前面加上“R”或“R”来创建的。Python原始字符串将反斜杠(\)视为文字字符。当我们想要一个包含反斜杠的字符串，并且不希望它被当作转义字符时，这是很有用的。</p><p id="f5e8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们看看下面代码中的区别。</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="65a6" class="jm jn hi ji b fi jo jp l jq jr">#Print with Normal String<br/><br/>print('\tName')<br/><br/>#Print with Raw String<br/><br/>print(r'\tName')</span><span id="b42a" class="jm jn hi ji b fi js jp l jq jr">Output-<br/>   Name<br/>\tName</span></pre><p id="16b2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以在上面的例子中，\t被认为是一个制表符，但在原始字符串中，它将只被打印为' \t '。</p><p id="dc25" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要使用正则表达式，首先，我们需要创建一个模式，它将找到我们想要的匹配，然后使用finditr()方法执行操作，让我们检查下面的代码。</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="bd12" class="jm jn hi ji b fi jo jp l jq jr">import re<br/><br/>sentence = 'My little son now has started learning abc in school'<br/>pattern = re.compile(r'abc')<br/>matches = pattern.finditer(sentence)<br/><br/>for match in matches:<br/>    print(match)<br/>Output-<br/>&lt;re.Match object; span=(39, 42), match='abc'&gt;</span></pre><p id="c8ac" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上面的例子中，我们已经写了一个匹配小“abc”的模式。在这个字符串中,“abc”将出现在从39到42的索引号上。因此它将返回带有索引号的匹配。</p><p id="146f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是所有模式的列表。</p><figure class="jd je jf jg fd ju er es paragraph-image"><div class="er es jt"><img src="../Images/f44046945db04c203a8d9cbd5d2c0773.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/1*zQyCt3CPLz7aIfE8ZMaz8g.png"/></div></figure><p id="d868" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面我们来逐一探讨几个模式。'.'匹配除新行之外的任何字符。</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="26a4" class="jm jn hi ji b fi jo jp l jq jr">import re<br/><br/>sentence = 'school'<br/>pattern = re.compile(r'.')<br/>matches = pattern.finditer(sentence)<br/>for match in matches:<br/>    print(match)<br/>Output-<br/>&lt;re.Match object; span=(0, 1), match='s'&gt;<br/>&lt;re.Match object; span=(1, 2), match='c'&gt;<br/>&lt;re.Match object; span=(2, 3), match='h'&gt;<br/>&lt;re.Match object; span=(3, 4), match='o'&gt;<br/>&lt;re.Match object; span=(4, 5), match='o'&gt;<br/>&lt;re.Match object; span=(5, 6), match='l'&gt;</span></pre><p id="dde9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">\d '用于仅匹配0-9之间的数字。下面是相同的代码。</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="601b" class="jm jn hi ji b fi jo jp l jq jr">import re<br/><br/>sentence = 'school123'<br/>pattern = re.compile(r'\d')<br/>matches = pattern.finditer(sentence)<br/>for match in matches:<br/>    print(match)<br/>Output-<br/>&lt;re.Match object; span=(6, 7), match='1'&gt;<br/>&lt;re.Match object; span=(7, 8), match='2'&gt;<br/>&lt;re.Match object; span=(8, 9), match='3'&gt;</span></pre><p id="1a01" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">相反的' \D '用来匹配非数字。在正则表达式中，大写字母否定小写字母正在执行的运算。</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="7ca5" class="jm jn hi ji b fi jo jp l jq jr">import re<br/><br/>sentence = 'school123'<br/>pattern = re.compile(r'\D')<br/>matches = pattern.finditer(sentence)<br/>for match in matches:<br/>    print(match)<br/>Output-<br/>&lt;re.Match object; span=(0, 1), match='s'&gt;<br/>&lt;re.Match object; span=(1, 2), match='c'&gt;<br/>&lt;re.Match object; span=(2, 3), match='h'&gt;<br/>&lt;re.Match object; span=(3, 4), match='o'&gt;<br/>&lt;re.Match object; span=(4, 5), match='o'&gt;<br/>&lt;re.Match object; span=(5, 6), match='l'&gt;</span></pre><p id="64c8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">“B”用于检查单词边界，而“\b”用于检查非单词边界。当需要单独匹配一系列字母或数字时，单词边界特别方便。或者当您希望确保它们出现在字符序列的开头或结尾时，这很有用。</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="3b48" class="jm jn hi ji b fi jo jp l jq jr">import re<br/><br/>sentence = 'school schoolschool'<br/>pattern = re.compile(r'school\b')<br/>matches = pattern.finditer(sentence)<br/><br/>for match in matches:<br/>     print(match)<br/>Output-<br/>&lt;re.Match object; span=(0, 6), match='school'&gt;<br/>&lt;re.Match object; span=(13, 19), match='school'&gt;</span></pre><p id="ee0b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它匹配学校两次，因为第二个学校在字符串末尾不包含空格。</p><p id="0165" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">'^'用于匹配字符串的开头。下面是相同的代码。</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="3541" class="jm jn hi ji b fi jo jp l jq jr">import re<br/><br/>sentence = 'My little son now has started learning abc in school'<br/>pattern = re.compile(r'^My')<br/>matches = pattern.finditer(sentence)<br/><br/>for match in matches:<br/>     print(match)<br/>Output-<br/>&lt;re.Match object; span=(0, 2), match='My'&gt;</span></pre><p id="a646" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">类似地，使用' $ '来匹配字符串的结尾。</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="8b51" class="jm jn hi ji b fi jo jp l jq jr">import re<br/><br/>sentence = 'My little son now has started learning abc in school'<br/>pattern = re.compile(r'school$')<br/>matches = pattern.finditer(sentence)<br/><br/>for match in matches:<br/>     print(match)<br/>Output-<br/>&lt;re.Match object; span=(46, 52), match='school'&gt;</span></pre><p id="df9e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">[]'匹配括号中的字符，假设如果我们在括号中提到'[a-zA-Z]'，它将匹配小写A到Z和大写A到Z之间的任何字母。</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="ba47" class="jm jn hi ji b fi jo jp l jq jr">sentence = 'My little son now has started learning abc in school'<br/>pattern = re.compile(r'[A-Z]')<br/>matches = pattern.finditer(sentence)<br/><br/>for match in matches:<br/>     print(match)<br/>Output-<br/>&lt;re.Match object; span=(0, 1), match='M'&gt;</span></pre><p id="0ecf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">字符串中只有一个大写字母“M ”,因此它只返回一个匹配项。相反'[^]用来匹配字符，不在括号中。</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="d675" class="jm jn hi ji b fi jo jp l jq jr">sentence = 'My little son now has started learning abc in school'<br/>pattern = re.compile(r'[^a-z\s]')<br/>matches = pattern.finditer(sentence)<br/><br/>for match in matches:<br/>     print(match)<br/>Output-<br/>&lt;re.Match object; span=(0, 1), match='M'&gt;</span></pre><p id="a62a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这将忽略所有小写字母和空格，因此只返回大写字母“M”。</p><p id="4b15" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">“()”代表组，假设我们有多个邮件域，我们希望匹配只包含Gmail和Yahoo的电子邮件id。所以我们可以用()'来表示同样的意思。</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="9e14" class="jm jn hi ji b fi jo jp l jq jr">str = """<br/>vivek@gmail.com<br/>vivek1@yahoo.com<br/>vivek2@outlook.com<br/>"""<br/><br/>pattern = re.compile('.+(gmail|yahoo)+\.(com)')<br/>matches = pattern.finditer(str)<br/>for match in matches:<br/>     print(match)<br/>Output-<br/>&lt;re.Match object; span=(1, 16), <a class="ae jx" href="mailto:match='vivek@gmail.com" rel="noopener ugc nofollow" target="_blank">match='vivek@gmail.com</a>'&gt;<br/>&lt;re.Match object; span=(17, 33), <a class="ae jx" href="mailto:match='vivek1@yahoo.com" rel="noopener ugc nofollow" target="_blank">match='vivek1@yahoo.com</a>'&gt;</span></pre><p id="0a01" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在同一个例子中，如果我输入' * '而不是'+'，它将返回所有三封电子邮件，因为' * '表示0或更大，所以它将打印outlook.com。</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="4483" class="jm jn hi ji b fi jo jp l jq jr">import re<br/>str = """<br/>vivek@gmail.com<br/>vivek1@yahoo.com<br/>vivek2@outlook.com<br/>"""<br/><br/>pattern = re.compile('.+(gmail|yahoo)*\.(com)')<br/>matches = pattern.finditer(str)<br/>for match in matches:<br/>     print(match)<br/>Output-<br/>&lt;re.Match object; span=(1, 16), <a class="ae jx" href="mailto:match='vivek@gmail.com" rel="noopener ugc nofollow" target="_blank">match='vivek@gmail.com</a>'&gt;<br/>&lt;re.Match object; span=(17, 33), <a class="ae jx" href="mailto:match='vivek1@yahoo.com" rel="noopener ugc nofollow" target="_blank">match='vivek1@yahoo.com</a>'&gt;<br/>&lt;re.Match object; span=(34, 52), <a class="ae jx" href="mailto:match='vivek2@outlook.com" rel="noopener ugc nofollow" target="_blank">match='vivek2@outlook.com</a>'&gt;</span></pre><p id="5910" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在下一个示例中，我们将电子邮件id outlook.com更改为outlook.edu，因此如果我们运行相同的代码，我们将得到两个匹配，因为最后一个中的“com”是强制的。</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="0540" class="jm jn hi ji b fi jo jp l jq jr">import re<br/>str = """<br/>vivek@gmail.com<br/>vivek1@yahoo.com<br/>vivek2@outlook.edu<br/>"""<br/><br/>pattern = re.compile('.+(gmail|yahoo)*\.(com)')<br/>matches = pattern.finditer(str)<br/>for match in matches:<br/>     print(match)<br/>Output-<br/>&lt;re.Match object; span=(1, 16), <a class="ae jx" href="mailto:match='vivek@gmail.com" rel="noopener ugc nofollow" target="_blank">match='vivek@gmail.com</a>'&gt;<br/>&lt;re.Match object; span=(17, 33), <a class="ae jx" href="mailto:match='vivek1@yahoo.com" rel="noopener ugc nofollow" target="_blank">match='vivek1@yahoo.com</a>'&gt;</span></pre><p id="bfe9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这里我们可以使用？当它匹配0或1时使其可选。</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="e8c0" class="jm jn hi ji b fi jo jp l jq jr">import re<br/>str = """<br/>vivek@gmail.com<br/>vivek1@yahoo.com<br/>vivek2@outlook.edu<br/>"""<br/><br/>pattern = re.compile('.+(gmail|yahoo)*\.(com)?')<br/>matches = pattern.finditer(str)<br/>for match in matches:<br/>     print(match)<br/>Output-<br/>&lt;re.Match object; span=(1, 16), <a class="ae jx" href="mailto:match='vivek@gmail.com" rel="noopener ugc nofollow" target="_blank">match='vivek@gmail.com</a>'&gt;<br/>&lt;re.Match object; span=(17, 33), <a class="ae jx" href="mailto:match='vivek1@yahoo.com" rel="noopener ugc nofollow" target="_blank">match='vivek1@yahoo.com</a>'&gt;<br/>&lt;re.Match object; span=(34, 49), match='vivek2@outlook.'&gt;</span></pre><p id="7db9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上面的例子中，我们现在得到了三个匹配，但是没有得到“edu ”,因为它不属于这个组。</p><p id="8f0d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们还有一个场景，我们需要按照下面的格式匹配电话号码。</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="35ac" class="jm jn hi ji b fi jo jp l jq jr">str = """<br/>999-4568-123<br/>897-3258-325<br/>698-7548-654<br/>"""</span></pre><p id="8a26" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它包含数字'-'符号，所以我们可以使用' \d '来匹配数字，下面是代码。</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="5373" class="jm jn hi ji b fi jo jp l jq jr">import re<br/>str = """<br/>999-4568-123<br/>897-3258-325<br/>698-7548-654<br/>"""<br/><br/>pattern = re.compile('\d\d\d-\d\d\d\d-\d\d\d')<br/>matches = pattern.finditer(str)<br/>for match in matches:<br/>     print(match)<br/>Output- <br/>&lt;re.Match object; span=(1, 13), match='999-4568-123'&gt;<br/>&lt;re.Match object; span=(14, 26), match='897-3258-325'&gt;<br/>&lt;re.Match object; span=(27, 39), match='698-7548-654'&gt;</span></pre><p id="6b00" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以它匹配电话号码，但我们需要多次键入' \d '，这可能会导致错误。</p><p id="3eee" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了避免这种情况，我们可以使用' {} '来传递确切的数字，就像在第一个'-'之前一样，因为' \d '出现了三次，所以我们可以写成-' \ d { 3 } '</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="3bc3" class="jm jn hi ji b fi jo jp l jq jr">import re<br/>str = """<br/>999-4568-123<br/>897-3258-325<br/>698-7548-654<br/>"""<br/><br/>pattern = re.compile('\d{3}-\d{4}-\d{3}')<br/>matches = pattern.finditer(str)<br/>for match in matches:<br/>     print(match)<br/>Output-<br/>&lt;re.Match object; span=(1, 13), match='999-4568-123'&gt;<br/>&lt;re.Match object; span=(14, 26), match='897-3258-325'&gt;<br/>&lt;re.Match object; span=(27, 39), match='698-7548-654'&gt;</span></pre><p id="3b6b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用这个now代码变得更加易读，并提供相同的结果。</p><p id="e7a7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在检查group和sub的示例。</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="e9f8" class="jm jn hi ji b fi jo jp l jq jr">import re<br/>str = """<br/>www.google.com<br/>www.yahoo.com<br/>www.gmail.com<br/>"""<br/><br/>pattern = re.compile('(www.)?(\w+)?(\.\w+)')<br/>matches = pattern.finditer(str)<br/>for match in matches:<br/>     print(match)<br/>Output-<br/>&lt;re.Match object; span=(1, 15), match='<a class="ae jx" href="http://www.google.com'" rel="noopener ugc nofollow" target="_blank">www.google.com'</a>&gt;<br/>&lt;re.Match object; span=(16, 29), match='<a class="ae jx" href="http://www.yahoo.com'" rel="noopener ugc nofollow" target="_blank">www.yahoo.com'</a>&gt;<br/>&lt;re.Match object; span=(30, 43), match='<a class="ae jx" href="http://www.gmail.com'" rel="noopener ugc nofollow" target="_blank">www.gmail.com'</a>&gt;</span></pre><p id="efe1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里我们有3个网站，我们的模式匹配所有三个。但是作为输出，我们只需要“google.com”并删除“www”</p><p id="afbe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以在我们的正则表达式中，我们有三组首先匹配‘www’(www。)，第二个是google这样的名字— (\w+)，第三个是域名— (\。\w+)。</p><p id="f6de" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，如果我们希望在结果中有任何特定的组，那么我们可以使用group方法。</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="05ed" class="jm jn hi ji b fi jo jp l jq jr">import re<br/>str = """<br/>www.google.com<br/>www.yahoo.com<br/>www.gmail.com<br/>"""<br/><br/>pattern = re.compile('(www.)?(\w+)?(\.\w+)')<br/>matches = pattern.finditer(str)<br/>for match in matches:<br/>     print(match.group(2))<br/>Output -<br/>google<br/>yahoo<br/>gmail</span></pre><p id="3fdb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里index从1开始，所以第二个索引是name。我们还有一个子方法，可以提供多个组序列并过滤结果。</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="460b" class="jm jn hi ji b fi jo jp l jq jr">import re<br/>str = """<br/>www.google.com<br/>www.yahoo.com<br/>www.gmail.com<br/>"""<br/><br/>pattern = re.compile('(www.)?(\w+)?(\.\w+)')<br/>matches = pattern.finditer(str)<br/>sub_Pattern = pattern.sub(r'\2\3',str)<br/>print(sub_Pattern)<br/>Output-<br/>google.com<br/>yahoo.com<br/>gmail.com</span></pre><p id="237b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里，我们传递子模式中的组序列2和3，并获得预期的输出。</p><p id="7d5b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">关于。match()-re的一个函数将搜索正则表达式模式并返回第一个匹配项。RegEx Match方法只在字符串的开头检查匹配。因此，如果在第一行中找到匹配，它将返回match对象。但是如果在其他行中找到匹配，RegEx Match函数返回null。</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="b1b9" class="jm jn hi ji b fi jo jp l jq jr">import re<br/>str = "My little son now has started learning abc in"<br/>#Matching at begining of the string<br/>pattern = re.match('My',str)<br/>print(pattern)<br/>#Matching at the middle of the string<br/>pattern = re.match('started',str)<br/>print(pattern)<br/>Output-<br/>&lt;re.Match object; span=(0, 2), match='My'&gt;<br/>None</span></pre><p id="2a50" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，如果我们想在一个完整的字符串中进行匹配，那么我们可以使用search()而不是match()。</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="afb9" class="jm jn hi ji b fi jo jp l jq jr">import re<br/>str = "My little son now has started learning abc in"<br/>#Matching at begining of the string<br/>pattern = re.search('My',str)<br/>print(pattern)<br/>#Matching at the middle of the string<br/>pattern = re.search('started',str)<br/>print(pattern)<br/>Output-<br/>&lt;re.Match object; span=(0, 2), match='My'&gt;<br/>&lt;re.Match object; span=(22, 29), match='started'&gt;</span></pre></div></div>    
</body>
</html>