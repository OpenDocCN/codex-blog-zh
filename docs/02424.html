<html>
<head>
<title>Making Network Requests Using Combine Framework</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Combine框架发出网络请求</h1>
<blockquote>原文：<a href="https://medium.com/codex/making-network-requests-using-combine-framework-ff34151611db?source=collection_archive---------0-----------------------#2021-07-20">https://medium.com/codex/making-network-requests-using-combine-framework-ff34151611db?source=collection_archive---------0-----------------------#2021-07-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="69d9" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated"><em class="ix">我在iOS联合网络实践项目中的发现</em></h2></div><figure class="iz ja jb jc fd jd er es paragraph-image"><div role="button" tabindex="0" class="je jf di jg bf jh"><div class="er es iy"><img src="../Images/ed05f6e3546767740132be537778b23f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0PAgn-LDukJ3qdT5OsONAw.png"/></div></div><figcaption class="jk jl et er es jm jn bd b be z dx translated">封面图像</figcaption></figure><p id="e182" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">之前我开始了一个小项目来练习使用苹果的Combine框架。在这篇文章中，我想讨论一下我对发出网络请求的代码的一些发现。</p><p id="d2ba" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">首先，我将首先谈论一些执行简单网络请求的常用代码。接下来我将集中讨论两个主题，即<strong class="jq hj">处理加载状态和取消</strong>，并分享我对如何很好地实现这些特性的发现和看法。</p><p id="edc8" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在此之前，您可以先了解一下实验项目的背景:</p><div class="kl km ez fb kn ko"><a rel="noopener follow" target="_blank" href="/@rdchc/my-combine-networking-lab-project-86c63404ca7c"><div class="kp ab dw"><div class="kq ab kr cl cj ks"><h2 class="bd hj fi z dy kt ea eb ku ed ef hh bi translated">我的联合网络实验室项目</h2><div class="kv l"><h3 class="bd b fi z dy kt ea eb ku ed ef dx translated">我做了一个小的iOS项目来练习如何使用Combine框架来处理网络请求。</h3></div><div class="kw l"><p class="bd b fp z dy kt ea eb ku ed ef dx translated">medium.com</p></div></div><div class="kx l"><div class="ky l kz la lb kx lc ji ko"/></div></div></a></div></div><div class="ab cl ld le gp lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="hb hc hd he hf"><h1 id="3d12" class="lk ll hi bd lm ln lo lp lq lr ls lt lu io lv ip lw ir lx is ly iu lz iv ma mb bi translated">网络请求</h1><p id="3b93" class="pw-post-body-paragraph jo jp hi jq b jr mc ij jt ju md im jw jx me jz ka kb mf kd ke kf mg kh ki kj hb bi translated">在过去，当我们发出网络请求时，我们通常会创建一个<code class="du mh mi mj mk b">URLSession</code>并调用<code class="du mh mi mj mk b">dataTask(with:completionHandler:)</code>函数，然后在完成处理程序中处理返回的响应或错误。</p><p id="869d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">用反应式风格写并不难。<code class="du mh mi mj mk b">URLSession</code>类有一个<code class="du mh mi mj mk b">DataTaskPublisher</code>让我们在订阅后获取发布的结果。该发布者或者以元组格式发布返回的数据和响应，或者因出错而终止订阅。我们遵循常见的网络请求模式:<strong class="jq hj">创建URL →创建数据任务→解码返回的响应或处理错误</strong>:</p><pre class="iz ja jb jc fd ml mk mm mn aw mo bi"><span id="33e7" class="mp ll hi mk b fi mq mr l ms mt">let url = URL(string: \(urlString))!<br/>URLSession.shared.dataTaskPublisher(for: url)<br/>  .map(\.data)<br/>  .decode(type: MealsResponse.self, decoder: JSONDecoder())<br/>  .map { ... }<br/>  .mapError { ... }<br/>  .eraseToAnyPublisher()<br/>  .sink(receiveCompletion: ..., receiveValue: ...)</span></pre><p id="d1a0" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">对于正常流程，我们获取返回的<code class="du mh mi mj mk b">Data</code>，将其解码以适应响应结构，最后将其映射到一些模型，以便在<code class="du mh mi mj mk b">sink</code>的<code class="du mh mi mj mk b">receiveValue</code>块中处理。</p><p id="2740" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">如果数据任务或解码操作失败，我们可以将错误映射到我们想要的类型，并在<code class="du mh mi mj mk b">sink</code>的<code class="du mh mi mj mk b">receiveCompletion</code>块中处理它。注意，在上面的代码中，<code class="du mh mi mj mk b">dataTaskPublisher</code>可能会带来<code class="du mh mi mj mk b">URLError</code>，而<code class="du mh mi mj mk b">decode</code>操作符可能会带来<code class="du mh mi mj mk b">DecodingError</code>。</p><h2 id="0f65" class="mp ll hi bd lm mu mv mw lq mx my mz lu jx na nb lw kb nc nd ly kf ne nf ma ng bi translated">检查URL响应</h2><p id="4994" class="pw-post-body-paragraph jo jp hi jq b jr mc ij jt ju md im jw jx me jz ka kb mf kd ke kf mg kh ki kj hb bi translated">我们通常希望向返回的URL响应添加一些额外的验证，例如，检查响应是否返回表示成功的状态代码200。我们可以按照<a class="ae kk" href="https://developer.apple.com/documentation/foundation/urlsession/processing_url_session_data_task_results_with_combine" rel="noopener ugc nofollow" target="_blank">苹果文档</a>的示例代码来添加这个额外的检查:</p><pre class="iz ja jb jc fd ml mk mm mn aw mo bi"><span id="3229" class="mp ll hi mk b fi mq mr l ms mt">urlSession.dataTaskPublisher(for: url)<br/>  .tryMap() { element -&gt; Data in<br/>    guard let httpResponse = element.response as? HTTPURLResponse,<br/>      httpResponse.statusCode == 200 else {<br/>        throw URLError(.badServerResponse)<br/>      }<br/>    return element.data<br/>  }<br/>  .decode(...)<br/>  .sink(...)</span></pre><p id="2c27" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">当然，我们可以添加更多的检查，并在闭包内抛出其他错误。这里的重点是<strong class="jq hj">使用</strong> <code class="du mh mi mj mk b"><strong class="jq hj">tryMap</strong></code> <strong class="jq hj">操作符来抛出任何一种错误，或者将结果的数据映射到最后</strong>进行进一步处理。</p><p id="c42f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">上面的示例代码只是在出现问题时抛出一个<code class="du mh mi mj mk b">URLError</code>。您可能会考虑在项目中创建自定义错误类型。在这种情况下，我们可以利用<code class="du mh mi mj mk b">mapError</code>操作符将错误映射成我们想要的错误类型。</p><p id="966b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">然而，在我看来，<strong class="jq hj">将原始错误类型向下传递到业务逻辑层</strong>(例如，视图模型)更简单，除非您想要列举您的应用程序处理的每个错误案例，并且您不关心底层错误。这样，我们可以避免任何由映射错误引起的逻辑错误解释，这可能是一件不必要的事情。</p><h2 id="c7e4" class="mp ll hi bd lm mu mv mw lq mx my mz lu jx na nb lw kb nc nd ly kf ne nf ma ng bi translated">总结常见操作</h2><p id="528e" class="pw-post-body-paragraph jo jp hi jq b jr mc ij jt ju md im jw jx me jz ka kb mf kd ke kf mg kh ki kj hb bi translated">由于检查URL响应和解码数据是常见的任务，我们可以<strong class="jq hj">简单地将它们组合在一起，并包装在一个自定义操作符</strong>中，这样我们就可以在整个应用程序中统一所有这些通用逻辑。在练习项目中，我创建了一个<code class="du mh mi mj mk b">tryDecodeResponse</code>操作符，并在其中调用了<code class="du mh mi mj mk b">tryMap</code>和<code class="du mh mi mj mk b">decode</code>操作符:</p><figure class="iz ja jb jc fd jd"><div class="bz dy l di"><div class="nh ni l"/></div></figure><p id="fb12" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">然后，每当我们需要执行网络请求时(例如在<code class="du mh mi mj mk b">APIClient</code>类内部)，我们可以调用我们的操作符来使我们的代码更简洁:</p><pre class="iz ja jb jc fd ml mk mm mn aw mo bi"><span id="c149" class="mp ll hi mk b fi mq mr l ms mt">func fetchCategories() -&gt; AnyPublisher&lt;[MealCategory], Error&gt; {<br/>  let url = URL(string: ...)<br/>  return urlSession.dataTaskPublisher(for: url)<br/>    <strong class="mk hj">.tryDecodeResponse(type: MealCategoriesResponse.self, decoder: JSONDecoder())</strong><br/>    .map { ... }<br/>    .eraseToAnyPublisher()<br/>}</span></pre><h2 id="6be9" class="mp ll hi bd lm mu mv mw lq mx my mz lu jx na nb lw kb nc nd ly kf ne nf ma ng bi translated">显示提取的值</h2><p id="f67e" class="pw-post-body-paragraph jo jp hi jq b jr mc ij jt ju md im jw jx me jz ka kb mf kd ke kf mg kh ki kj hb bi translated">最后一项任务是在用户界面中显示我们刚刚获取的值。由于网络回调使用另一个队列，<strong class="jq hj">当我们在UI中显示任何东西时，我们必须切换到主线程</strong>。</p><p id="c18f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">通过使用<code class="du mh mi mj mk b">receive(on:options:)</code>操作符，我们可以选择许多选项来指定主线程。在项目中，<strong class="jq hj">我选择将它放在每次</strong> <code class="du mh mi mj mk b"><strong class="jq hj">assign(to:on:)</strong></code> <strong class="jq hj">调用</strong>之前，因为我认为这是确保和检查UI绑定是否在主线程上的最佳位置:</p><pre class="iz ja jb jc fd ml mk mm mn aw mo bi"><span id="d5c7" class="mp ll hi mk b fi mq mr l ms mt">func bindViewModel(_ vm: MealItemViewModel) {<br/>  vm.$title<br/>    <strong class="mk hj">.receive(on: DispatchQueue.main)</strong><br/>    .assign(to: \.text, on: titleLabel)<br/>    .store(in: &amp;subscriptions)</span><span id="babd" class="mp ll hi mk b fi nj mr l ms mt">  vm.$detail<br/>    <strong class="mk hj">.receive(on: DispatchQueue.main)</strong><br/>    .assign(to: \.text, on: statusLabel)<br/>    .store(in: &amp;subscriptions)</span><span id="e867" class="mp ll hi mk b fi nj mr l ms mt">  vm.statusSubject<br/>    .map { $0 != .ongoing }<br/>    <strong class="mk hj">.receive(on: DispatchQueue.main)</strong><br/>    .assign(to: \.isEnabled, on: fetchButton)<br/>    .store(in: &amp;subscriptions)</span><span id="1917" class="mp ll hi mk b fi nj mr l ms mt">  vm.$cancellable<br/>    <strong class="mk hj">.receive(on: DispatchQueue.main)</strong><br/>    .assign(to: \.isEnabled, on: cancelButton)<br/>    .store(in: &amp;subscriptions)</span></pre></div><div class="ab cl ld le gp lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="hb hc hd he hf"><h1 id="aaed" class="lk ll hi bd lm ln lo lp lq lr ls lt lu io lv ip lw ir lx is ly iu lz iv ma mb bi translated">装载状态</h1><p id="2d79" class="pw-post-body-paragraph jo jp hi jq b jr mc ij jt ju md im jw jx me jz ka kb mf kd ke kf mg kh ki kj hb bi translated">网络请求的一个常见规范是处理加载状态。特别是，为了更好的用户体验，大多数应用程序中都有跑步活动指示器(无论是小图标还是全屏显示)。</p><h2 id="94d8" class="mp ll hi bd lm mu mv mw lq mx my mz lu jx na nb lw kb nc nd ly kf ne nf ma ng bi translated">使用加载状态枚举</h2><p id="0e13" class="pw-post-body-paragraph jo jp hi jq b jr mc ij jt ju md im jw jx me jz ka kb mf kd ke kf mg kh ki kj hb bi translated">我从Sundell 的文章的一个<a class="ae kk" href="https://www.swiftbysundell.com/articles/combine-self-cancellable-memory-management/" rel="noopener ugc nofollow" target="_blank"> <em class="nk"> Swift中获取了加载状态的概念，并创建了一个<code class="du mh mi mj mk b">FetchStatus</code> enum，其值为<code class="du mh mi mj mk b">.ongoing</code>、<code class="du mh mi mj mk b">.finished</code>和<code class="du mh mi mj mk b">.ready</code>，指示组件是否正在加载、加载成功或其他情况。</em></a></p><p id="26d7" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">为了跟踪数据任务发布者的状态，我使用了</strong> <code class="du mh mi mj mk b"><strong class="jq hj">.handleEvents</strong></code> <strong class="jq hj">操作符</strong>来更新网络请求开始、取消、成功完成或出错的时间:</p><pre class="iz ja jb jc fd ml mk mm mn aw mo bi"><span id="5b4c" class="mp ll hi mk b fi mq mr l ms mt">@Published var status: FetchStatus = .ready</span><span id="3525" class="mp ll hi mk b fi nj mr l ms mt">func fetch() {<br/>  apiClient.fetch()<br/>    .handleEvents(receiveSubscription: { [weak self] _ in<br/>      self?.status = .ongoing<br/>    }, receiveCompletion: { [weak self] completion in<br/>      switch completion {<br/>      case .finished:<br/>        self?.status = .finished<br/>      case .failure:<br/>        self?.status = .ready<br/>      }<br/>    }, receiveCancel: { [weak self] in<br/>      self?.status = .ready<br/>    })<br/>    .sink(...)<br/>}</span></pre><p id="d487" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在我的实践项目中，我将类似的逻辑放在了<code class="du mh mi mj mk b">ViewModel</code>的<code class="du mh mi mj mk b">mockFetch()</code>函数中，以便在模拟组件中进行测试。我使用了<code class="du mh mi mj mk b">@Published</code>属性包装器来进一步绑定到UI层。</p><p id="1043" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">然后我在想，有没有什么方法可以隐藏这个丑陋、繁琐的实现，让它在所有调用者之间通用？所以我在 <code class="du mh mi mj mk b"><strong class="jq hj">Publisher</strong></code> <strong class="jq hj">协议内创建了一个<strong class="jq hj">新操作符，带有一个</strong> <code class="du mh mi mj mk b"><strong class="jq hj">Subject</strong></code> <strong class="jq hj">参数</strong>，负责记录新的加载状态。</strong></p><p id="002b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">首先，我们用新的速记操作符扩展了<code class="du mh mi mj mk b">Publisher</code>协议:</p><figure class="iz ja jb jc fd jd"><div class="bz dy l di"><div class="nh ni l"/></div></figure><p id="ebc0" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我改用<code class="du mh mi mj mk b">Subject</code>类型，而不是原来的<code class="du mh mi mj mk b">Published</code>，因为我发现使用<code class="du mh mi mj mk b">Published</code>类型很难发送新值。</p><p id="f12d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">然后我们可以将它绑定到其他与UI相关的元素。在这个项目中，我使用了我们新的速记操作符，并将状态主题绑定到一个已发布的<code class="du mh mi mj mk b">showLoading</code>布尔值来操作加载UI:</p><pre class="iz ja jb jc fd ml mk mm mn aw mo bi"><span id="7030" class="mp ll hi mk b fi mq mr l ms mt">private(set) var categoriesItemViewModel = MealItemViewModel()<br/>@Published var showLoading: Bool = false<br/><br/>private func setupBindings() {<br/>  categoriesItemViewModel.statusSubject<br/>    <strong class="mk hj">.map { $0 == .ongoing }<br/>    .assign(to: &amp;$showLoading)</strong><br/>}<br/><br/>func fetchCategories() {<br/>  sharedFetchSubscription = mealApiClient.fetchCategories()<br/>    <strong class="mk hj">.observeFetchStatus(with: categoriesItemViewModel.statusSubject)</strong><br/>    .sink(...)<br/>}</span></pre><p id="80cc" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">注意，上面的代码片段只处理一种状态。如果类中有多个状态主题，我们需要使用更多的发布器，如<code class="du mh mi mj mk b">CombineLatest</code>或<code class="du mh mi mj mk b">Merge</code>来组合所有的状态，以确定是否有项目正在加载。</p><h2 id="ccc3" class="mp ll hi bd lm mu mv mw lq mx my mz lu jx na nb lw kb nc nd ly kf ne nf ma ng bi translated">使用布尔值</h2><p id="50fb" class="pw-post-body-paragraph jo jp hi jq b jr mc ij jt ju md im jw jx me jz ka kb mf kd ke kf mg kh ki kj hb bi translated">有时我们可能只是想知道是否有东西在加载。在这种情况下，将装载状态分成几种情况可能过于复杂。<strong class="jq hj">鉴于一次只能有一个任务处于加载状态</strong>，我们可以使用一个更简单的布尔主语来达到目的:</p><figure class="iz ja jb jc fd jd"><div class="bz dy l di"><div class="nh ni l"/></div></figure><p id="dbe0" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">然后我们稍微修改上面的绑定和调用以适应这个新的操作符:</p><pre class="iz ja jb jc fd ml mk mm mn aw mo bi"><span id="0263" class="mp ll hi mk b fi mq mr l ms mt"><strong class="mk hj">private(set) var isLoadingSubject = PassthroughSubject&lt;Bool, Never&gt;()</strong><br/>@Published var showLoading: Bool = false<br/><br/>private func setupBindings() {<br/>  <strong class="mk hj">isLoadingSubject<br/></strong>    .assign(to: &amp;$showLoading)<br/>}<br/><br/>func fetchCategories() {<br/>  sharedFetchSubscription = mealApiClient.fetchCategories()<br/>    <strong class="mk hj">.observeFetchStatus(with: isLoadingSubject)</strong><br/>    .sink(...)<br/>}</span></pre><p id="a094" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">请注意，由于我们只能向布尔主题发送true和false值，因此只有当我们确定一次只执行一个加载任务时，这个解决方案才是有用的。</p><h2 id="cdcb" class="mp ll hi bd lm mu mv mw lq mx my mz lu jx na nb lw kb nc nd ly kf ne nf ma ng bi translated">使用计数变量</h2><p id="2b65" class="pw-post-body-paragraph jo jp hi jq b jr mc ij jt ju md im jw jx me jz ka kb mf kd ke kf mg kh ki kj hb bi translated">如果一个屏幕可以同时运行几个加载任务，并且您希望在一个或多个任务正在加载时显示加载指示器，我们可以更改主题来存储加载任务计数。</p><p id="87f2" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">首先，我们创建一个<code class="du mh mi mj mk b">CurrentValueSubject</code>来保存我们的加载任务计数。我们只能选择<code class="du mh mi mj mk b">CurrentValueSubject</code>作为选项，因为我们需要它的当前值来增加或减少计数。</p><pre class="iz ja jb jc fd ml mk mm mn aw mo bi"><span id="01f2" class="mp ll hi mk b fi mq mr l ms mt">private var loadingTaskCountSubject = CurrentValueSubject&lt;Int, Never&gt;(0)</span></pre><p id="c58d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">然后，我们用一个存储加载任务计数的<code class="du mh mi mj mk b">CurrentValueSubject</code>创建一个速记操作符来观察获取状态。</p><figure class="iz ja jb jc fd jd"><div class="bz dy l di"><div class="nh ni l"/></div></figure><p id="301b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">然后，当执行网络请求时，我们用新的操作符替换以前的<code class="du mh mi mj mk b">observeFetchStatus(with:)</code>操作符:</p><pre class="iz ja jb jc fd ml mk mm mn aw mo bi"><span id="78e2" class="mp ll hi mk b fi mq mr l ms mt">func fetchCategories() {<br/>  mealApiClient.fetchCategories()<br/><strong class="mk hj">    .observeFetchStatus(with: loadingTaskCountSubject)</strong><br/>    .sink(...)<br/>    .store(in: &amp;subscriptions)<br/>}</span></pre><p id="7b5c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">为了设置绑定，我们用下面的新逻辑替换原来的逻辑，只要加载任务计数大于0，就表示有东西正在加载:</p><pre class="iz ja jb jc fd ml mk mm mn aw mo bi"><span id="f975" class="mp ll hi mk b fi mq mr l ms mt">private func setupBindings() {<br/>  loadingTaskCountSubject<br/>    <strong class="mk hj">.map { $0 &gt; 0 }<br/></strong>    .assign(to: &amp;$showLoading)<br/>}</span></pre></div><div class="ab cl ld le gp lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="hb hc hd he hf"><h1 id="62ba" class="lk ll hi bd lm ln lo lp lq lr ls lt lu io lv ip lw ir lx is ly iu lz iv ma mb bi translated">取消</h1><p id="efa0" class="pw-post-body-paragraph jo jp hi jq b jr mc ij jt ju md im jw jx me jz ka kb mf kd ke kf mg kh ki kj hb bi translated">因为<code class="du mh mi mj mk b">Subscription</code>协议符合<code class="du mh mi mj mk b">Cancellable</code>协议，所以所有的订阅都可以被取消。事实上，取消约会随处可见:</p><ul class=""><li id="72ff" class="nl nm hi jq b jr js ju jv jx nn kb no kf np kj nq nr ns nt bi translated">我们可以手动调用<code class="du mh mi mj mk b">cancel()</code>来取消特定的订阅。</li><li id="ac44" class="nl nm hi jq b jr nu ju nv jx nw kb nx kf ny kj nq nr ns nt bi translated">丢失对某个订阅的所有引用会触发取消初始化，这会自动使该订阅对自身进行调用<code class="du mh mi mj mk b">cancel()</code>。</li></ul><h2 id="8b0b" class="mp ll hi bd lm mu mv mw lq mx my mz lu jx na nb lw kb nc nd ly kf ne nf ma ng bi translated">取消特定订阅</h2><p id="5698" class="pw-post-body-paragraph jo jp hi jq b jr mc ij jt ju md im jw jx me jz ka kb mf kd ke kf mg kh ki kj hb bi translated">在通常的实践中，我们经常创建一个取消令牌包作为<code class="du mh mi mj mk b">Set&lt;AnyCancellable&gt;</code>，这样所有的订阅都可以通过在类中强烈引用它们来保存。但是，如果我们希望可以单独取消订阅，则不可能使用这种方法，因为如果只给定了集合，我们就无法取出特定的取消令牌。</p><p id="8105" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">相反，我们可以<strong class="jq hj">在类中创建一个单独的</strong> <code class="du mh mi mj mk b"><strong class="jq hj">AnyCancellable?</strong></code> <strong class="jq hj">属性</strong>，这样我们就可以直接引用它。基本上这个属性在去初始化的时候也会自动调用<code class="du mh mi mj mk b">cancel()</code>。</p><pre class="iz ja jb jc fd ml mk mm mn aw mo bi"><span id="6dc5" class="mp ll hi mk b fi mq mr l ms mt">var mySubscription: AnyCancellable?</span><span id="e4bc" class="mp ll hi mk b fi nj mr l ms mt">mySubscription = Future&lt;String, Never&gt; { resolve in<br/>  resolve(.success("Success"))<br/>}<br/>  .delay(for: .seconds(2), scheduler: RunLoop.current)<br/>  .sink { print($0) }</span><span id="e075" class="mp ll hi mk b fi nj mr l ms mt">mySubscription?.cancel()</span></pre><p id="9f22" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">从这个概念延伸，如果我们有不同的订阅，每次最多运行一个，我们可以<strong class="jq hj">创建一个共享的</strong> <code class="du mh mi mj mk b"><strong class="jq hj">AnyCancellable?</strong></code> <strong class="jq hj">属性</strong>并让那些发布者订阅它，这样当新的订阅替换旧的订阅时，旧的订阅可以自动取消。</p><pre class="iz ja jb jc fd ml mk mm mn aw mo bi"><span id="a089" class="mp ll hi mk b fi mq mr l ms mt">var sharedSubscription: AnyCancellable?</span><span id="4360" class="mp ll hi mk b fi nj mr l ms mt">sharedSubscription = &lt;some subscription to publisher A&gt;<br/>sharedSubscription = &lt;some subscription to publisher B&gt; // The subscription with publisher A is cancelled at this moment</span></pre><p id="f5b2" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">看看这个例子，我多次调用了<code class="du mh mi mj mk b">fetchCategories()</code>，注意订阅何时被取消:</p><pre class="iz ja jb jc fd ml mk mm mn aw mo bi"><span id="3d7e" class="mp ll hi mk b fi mq mr l ms mt">var sharedFetchSubscription: AnyCancellable?</span><span id="b113" class="mp ll hi mk b fi nj mr l ms mt">func fetchCategories() {<br/>  sharedFetchSubscription = mealApiClient.fetchCategories()<br/>    <strong class="mk hj">.print("Categories")</strong><br/>    .sink(receiveCompletion: { [weak self] in<strong class="mk hj"><br/>      ...<br/>    </strong>}, receiveValue: { [weak self] in<br/>      ...<br/>    })<br/>}</span></pre><figure class="iz ja jb jc fd jd er es paragraph-image"><div role="button" tabindex="0" class="je jf di jg bf jh"><div class="er es nz"><img src="../Images/b1e62ec00d98d1b494a2423becef3dca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D3SbFuR8J6E2EnWldTBy-g.png"/></div></div><figcaption class="jk jl et er es jm jn bd b be z dx translated">当收到新的订阅时，原来的订阅立即被取消</figcaption></figure><p id="0a0d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">以项目的<code class="du mh mi mj mk b">ViewModel</code>为例。我一直将膳食类别和膳食列表订阅提取到同一个<code class="du mh mi mj mk b">sharedFetchSubscription</code>变量中，类似于上面的代码。如果我们移除全屏加载逻辑(并添加一些临时代码来显示状态)，我们可以尝试快速点击不同的获取按钮，以查看之前的获取是否没有产生任何结果:</p><figure class="iz ja jb jc fd jd"><div class="bz dy l di"><div class="nh ni l"/></div></figure><figure class="iz ja jb jc fd jd er es paragraph-image"><div class="er es oa"><img src="../Images/be88079b1402a331979c9ace433af67f.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*SHO08k7jHdlrDL5o22njHQ.gif"/></div><figcaption class="jk jl et er es jm jn bd b be z dx translated">获取面食后，餐饮类别网络获取立即被取消</figcaption></figure><h2 id="2d3c" class="mp ll hi bd lm mu mv mw lq mx my mz lu jx na nb lw kb nc nd ly kf ne nf ma ng bi translated">取消主题触发的先前订阅</h2><p id="5070" class="pw-post-body-paragraph jo jp hi jq b jr mc ij jt ju md im jw jx me jz ka kb mf kd ke kf mg kh ki kj hb bi translated">当订阅设置在函数内部时，上述情况有效，每次触发事件时都会调用该函数。然而，<strong class="jq hj">有时我们将网络请求绑定到主题</strong>上，这样当主题接收到一个值时，它可以创建一个新的网络请求订阅:</p><pre class="iz ja jb jc fd ml mk mm mn aw mo bi"><span id="4637" class="mp ll hi mk b fi mq mr l ms mt">var fetchTriggeredSubject = PassthroughSubject&lt;Void, Never&gt;()<br/>private var subscriptions = Set&lt;AnyCancellable&gt;()</span><span id="aabe" class="mp ll hi mk b fi nj mr l ms mt">private func setupBindings() {<br/>  fetchTriggeredSubject<br/>    .flatMap { [weak self] () -&gt; AnyPublisher&lt;MyType, Error&gt; in<br/>      guard let self = self else {<br/>        return Empty().eraseToAnyPublisher()<br/>      }<br/>      return self.apiClient.fetch()<br/>        .eraseToAnyPublisher()<br/>    }<br/>    .sink(receiveCompletion: { ... }, receiveValue: { ... })<br/>    .store(in: &amp;subscriptions)<br/>}</span></pre><p id="9cbd" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这在正常情况下不会带来任何问题。但是，如果我们希望可以手动取消获取订阅，使用这种方法会很麻烦，因为<strong class="jq hj">网络请求是从主题</strong>映射的。取消订阅意味着我们将操作与主题分离，这不是我们想要做的。</p><p id="0add" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">而且多次向subject发送值会触发内网请求多次运行，这意味着我们无法在代码级取消之前正在进行的网络请求。</p><p id="0e29" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我在StackOverflow 中找到了一个<a class="ae kk" href="https://stackoverflow.com/a/61403996" rel="noopener ugc nofollow" target="_blank">答案，似乎对这个案例有用。主要思路是将<code class="du mh mi mj mk b">flatMap(_:)</code>改为<code class="du mh mi mj mk b">map(_:)</code>保留主体的错误类型，然后<strong class="jq hj">使用</strong> <code class="du mh mi mj mk b"><strong class="jq hj">switchToLatest()</strong></code> <strong class="jq hj">只保留最新订阅</strong>。根据苹果文件:</a></p><blockquote class="ob oc od"><p id="9ebe" class="jo jp nk jq b jr js ij jt ju jv im jw oe jy jz ka of kc kd ke og kg kh ki kj hb bi translated">当该操作者从上游发布者接收到新的发布者时，<strong class="jq hj">它取消其先前的订阅</strong>。使用此功能可以防止早期发布者执行不必要的工作，如创建网络请求发布者，避免频繁更新用户界面发布者。</p></blockquote><p id="d81b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">所以我们可以将上面的代码修改如下:</p><pre class="iz ja jb jc fd ml mk mm mn aw mo bi"><span id="6a8b" class="mp ll hi mk b fi mq mr l ms mt">var fetchTriggeredSubject = PassthroughSubject&lt;Void, Never&gt;()<br/>private var subscriptions = Set&lt;AnyCancellable&gt;()</span><span id="2b3e" class="mp ll hi mk b fi nj mr l ms mt">private func setupBindings() {<br/>  fetchTriggeredSubject<br/>    <strong class="mk hj">.map</strong> { [weak self] () -&gt; AnyPublisher&lt;MyType, Error&gt; in<br/>      guard let self = self else {<br/>        return Empty().eraseToAnyPublisher()<br/>      }<br/>      return self.apiClient.fetch()<br/>        .eraseToAnyPublisher()<br/>    }<br/>    <strong class="mk hj">.switchToLatest()</strong><br/>    .sink(receiveCompletion: { ... }, receiveValue: { ... })<br/>    .store(in: &amp;subscriptions)<br/>}</span></pre><p id="93f3" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我在模拟网络请求组件中试用了这个模板，打印的结果显示以前的订阅确实被取消了:</p><figure class="iz ja jb jc fd jd er es paragraph-image"><div class="er es oh"><img src="../Images/2f1f962f1dcc905bdff466f33dca493b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1112/format:webp/1*jx5Qo5-GYRCK9UXlc7FywA.png"/></div><figcaption class="jk jl et er es jm jn bd b be z dx translated">旧的订阅在新的订阅进来之前就被取消了</figcaption></figure><p id="f1a2" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">因此，这解决了自动取消先前订阅的问题。但是，由于内部发布者仍然存在于<code class="du mh mi mj mk b">map</code>操作符的转换闭包中，<strong class="jq hj">我们仍然不能将其取出来进行手动取消</strong>。如果你有更好的想法，欢迎分享讨论！与此同时，我认为在函数中创建和存储订阅可能是实现这一目的的一种更简单而有效的方法。</p></div><div class="ab cl ld le gp lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="hb hc hd he hf"><h1 id="e037" class="lk ll hi bd lm ln lo lp lq lr ls lt lu io lv ip lw ir lx is ly iu lz iv ma mb bi translated">结论</h1><p id="f3e7" class="pw-post-body-paragraph jo jp hi jq b jr mc ij jt ju md im jw jx me jz ka kb mf kd ke kf mg kh ki kj hb bi translated">在本文中，我们已经使用Combine框架完成了一些常见的网络任务。最基本的是，我们创建一个<code class="du mh mi mj mk b">URLSession.dataTaskPublisher</code>并订阅它来发出网络请求。然后我们<strong class="jq hj">检查它返回的响应，解码数据并将其映射到我们的模型中，并在业务逻辑层做进一步的操作</strong>。</p><p id="1144" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">为了制作加载状态，我们使用了<code class="du mh mi mj mk b"><strong class="jq hj">handleEvents</strong></code> <strong class="jq hj">操作符</strong>并重点关注了<code class="du mh mi mj mk b"><strong class="jq hj">receiveSubscription</strong></code><strong class="jq hj"/><code class="du mh mi mj mk b"><strong class="jq hj">receiveCompletion</strong></code><strong class="jq hj">和</strong> <code class="du mh mi mj mk b"><strong class="jq hj">receiveCancel</strong></code> <strong class="jq hj">事件</strong>来执行实际网络任务之外的副作用。根据用例，我们可以将副作用绑定到枚举、布尔或计数主题，以我们想要的方式操纵加载状态。</p><p id="d6bc" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">为了使网络任务可取消，我们应该记住<strong class="jq hj">引用数据任务的订阅</strong>，这样我们就可以直接在那些引用上调用<code class="du mh mi mj mk b">cancel()</code>。对于像<code class="du mh mi mj mk b">Subject</code> s这样由其他信号触发的网络任务，即使我们允许自动取消之前的网络请求，但由于无法管理(取消)这类发布者，因此<strong class="jq hj">不直接将信号映射到数据任务发布者</strong>中仍然是必要的。</p><p id="1fb2" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这些概括了整篇文章。如果您有任何意见或想法，请随时留下评论，这样每个人都可以讨论它！</p></div></div>    
</body>
</html>