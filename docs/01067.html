<html>
<head>
<title>Understanding “this” in JavaScript — The Complete Guide</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解JavaScript中的“this”——完整指南</h1>
<blockquote>原文：<a href="https://medium.com/codex/understanding-this-in-javascript-the-complete-guide-c4c21fe15ff8?source=collection_archive---------10-----------------------#2021-04-02">https://medium.com/codex/understanding-this-in-javascript-the-complete-guide-c4c21fe15ff8?source=collection_archive---------10-----------------------#2021-04-02</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/491f92600e282238fea79b0739b73ffb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*VhXB2I0VraR9oGVK"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">扎卡里·凯米格在<a class="ae hv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><div class=""/><p id="c11f" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Namaste Devs，我敢肯定你在学习甚至面试的时候已经把自己和JS里的“这个”搞混了。有一天，当你坐在电脑前阅读这篇文章时，你会有一个灵光乍现的时刻。我将尝试解释“this”的传统工作方式和ES6中的新实现(箭头函数)。所以坐稳了。</p><p id="e144" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">简单地说，“this”是对包含当前函数的对象的<strong class="ix hz">引用。就这么简单，但是什么是当前对象，以及在代码运行时它是如何动态变化的，这就有点令人困惑了。</strong></p><p id="7e26" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">它的值将取决于运行时函数被调用的位置，用专业术语来说，我们称之为<strong class="ix hz">“调用点”</strong>。调用一个函数有多种方法，为了简单起见，我将在这里展示其中的两种</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="c77e" class="kc kd hy jy b fi ke kf l kg kh">function doSomething(a){<br/>   console.log(a);<br/>}</span><span id="fd3a" class="kc kd hy jy b fi ki kf l kg kh">var obj = {<br/> key: "value",<br/> doSomething: function(){ console.log(" namaste"); }<br/>}</span><span id="69e4" class="kc kd hy jy b fi ki kf l kg kh">// you can call the function doSomething like this</span><span id="80cb" class="kc kd hy jy b fi ki kf l kg kh">doSomething("jainish"); // jainish<br/>obj.doSomething(); // namaste</span></pre><p id="f336" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">嗯，这个你已经知道了，那么你认为我想从这点说明什么呢？看看我们是如何调用这些函数的。他们有什么不同吗？如果有，区别有多重要？</p><p id="ac17" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这个的答案是<strong class="ix hz">“执行上下文”</strong>。但是WTF是上下文，怎么有用。为了解释这一点，让我深入研究一下JS在幕后是如何工作的。</p><p id="37ed" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们来理解当一个简单的JS程序被执行时会发生什么。</p><ol class=""><li id="67a4" class="kj kk hy ix b iy iz jc jd jg kl jk km jo kn js ko kp kq kr bi translated">创建<strong class="ix hz">全局执行上下文</strong>并将其推入执行堆栈。</li><li id="6b93" class="kj kk hy ix b iy ks jc kt jg ku jk kv jo kw js ko kp kq kr bi translated">然后，引擎执行代码。</li><li id="f96e" class="kj kk hy ix b iy ks jc kt jg ku jk kv jo kw js ko kp kq kr bi translated">如果遇到函数调用，引擎将首先编译代码，在此期间创建新的<strong class="ix hz">执行上下文</strong>并将其推送到执行堆栈上，最后执行代码</li><li id="c29e" class="kj kk hy ix b iy ks jc kt jg ku jk kv jo kw js ko kp kq kr bi translated">执行完成后，弹出fn执行上下文</li></ol><p id="617d" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hz">“执行上下文”</strong>是JS中的一个抽象概念。它是一个对象，包含函数执行所需的特定信息。该信息包含多个属性。仅举几个例子。</p><ol class=""><li id="94bb" class="kj kk hy ix b iy iz jc jd jg kl jk km jo kn js ko kp kq kr bi translated"><strong class="ix hz">Activation/Variable object</strong>=&gt;存储传递给函数的参数、变量以及该函数中声明的函数的信息。</li><li id="295e" class="kj kk hy ix b iy ks jc kt jg ku jk kv jo kw js ko kp kq kr bi translated"><strong class="ix hz">范围链</strong>的创建。(<a class="ae hv" href="https://jainishshah12.medium.com/yeh-lexical-scope-hai-kya-da08a1601f2f" rel="noopener">你可以在这里了解更多</a>)</li><li id="1f7a" class="kj kk hy ix b iy ks jc kt jg ku jk kv jo kw js ko kp kq kr bi translated">此的<strong class="ix hz">值。</strong></li></ol><p id="92f4" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">全局执行上下文类似于函数上下文，只是默认情况下它是加载到堆栈中的。</p><p id="7635" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这并没有准确回答上面提到的两个doSomething函数之间的区别，但它表明“<strong class="ix hz"> this </strong>”本质上是动态的，并且根据调用位置而变化(其<strong class="ix hz">值基于执行上下文堆栈</strong>顶部的上下文)。</p><p id="b570" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">有4个简单的规则来描述“这”是如何工作的</p><ol class=""><li id="6a2a" class="kj kk hy ix b iy iz jc jd jg kl jk km jo kn js ko kp kq kr bi translated">默认绑定</li><li id="6c28" class="kj kk hy ix b iy ks jc kt jg ku jk kv jo kw js ko kp kq kr bi translated">隐式结合</li><li id="82f7" class="kj kk hy ix b iy ks jc kt jg ku jk kv jo kw js ko kp kq kr bi translated">显式绑定</li><li id="2934" class="kj kk hy ix b iy ks jc kt jg ku jk kv jo kw js ko kp kq kr bi translated">“新”运算符</li></ol><p id="d3d5" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当然，我们将讨论某些例外(注意:ES6的箭头函数使用一些不同的机制，首先理解这些规则将有助于您理解箭头函数是如何工作的)</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="14ba" class="kc kd hy jy b fi ke kf l kg kh">function doSomething(){<br/>  console.log(this.a);<br/>}</span><span id="4ab1" class="kc kd hy jy b fi ki kf l kg kh">var a = 6;</span><span id="4e4e" class="kc kd hy jy b fi ki kf l kg kh">doSomething(); //6</span></pre><p id="5ab9" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">可以看到我们已经在全局空间声明了函数(not is a function)。当我们执行这个函数时，它输出6。但是为什么呢？</p><p id="c572" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">答:我们谈到了执行堆栈，默认情况下，全局执行上下文位于堆栈顶部。当我们调用某个东西时，它的执行上下文将被推送到栈顶。因为这个函数属于全局对象，所以它的值将是全局对象(Node.js中的global和browser env中的window)。全局对象具有属性“a ”,因此输出将是6。这是一个<strong class="ix hz">【默认绑定】</strong>的例子</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="0603" class="kc kd hy jy b fi ke kf l kg kh">function doSomething(){<br/>  console.log(this.a);<br/>}</span><span id="0074" class="kc kd hy jy b fi ki kf l kg kh">var a = 6;<br/>var obj = {<br/>  a : 12,<br/>  doSomething: doSomething<br/>};</span><span id="8295" class="kc kd hy jy b fi ki kf l kg kh">obj.doSomething(); //12</span></pre><p id="3d03" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里发生了什么变化？在这种情况下，我们用前缀(“obj”)调用doSomething。).以这种方式调用函数会将函数执行上下文中“this”的值设置为“obj”(对对象obj的引用)。obj具有属性“a ”,因此打印的值将是12。用对象引用作为函数调用的前缀是<strong class="ix hz">“隐式绑定”</strong>的一个例子。您正在隐式调用一个对象的函数。</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="db1d" class="kc kd hy jy b fi ke kf l kg kh">var a = 6;<br/>var obj = {<br/>  a : 12,<br/>  doSomething: function() { console.log(this.a) }<br/>};</span><span id="a520" class="kc kd hy jy b fi ki kf l kg kh">var foo = obj.doSomething;</span><span id="bd9c" class="kc kd hy jy b fi ki kf l kg kh">foo(); //6</span></pre><p id="8383" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">该死的。！！我们刚刚了解到，用obj引用调用一个函数会打印12，但wtf做到了打印6。这里有一个重要的概念。一个函数定义存储在堆中，当你用obj的doSomething赋值“foo”时，你实际上是在内存中传递那个函数的引用。在对象引用和函数声明的地方没有相互联系，但这取决于调用函数的地方。将执行上下文考虑在内。全局执行上下文在栈顶。你调用函数foo，它是全局上下文的一个属性，所以当执行foo时，它的值将被设置为全局上下文。所以答案是6。</p><p id="f90d" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我希望到目前为止，你能够理解我们带入画面的“对象”。如果没有，请重新阅读到这一点。</p><p id="6488" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">隐式和默认绑定是<strong class="ix hz"> "JS引擎对这个"</strong>"的值做出决定的一种方式。但是如果你是一个开发者，你想设置这个值。您希望在什么情况下指定该值？语言中为此提供了什么机制？</p><p id="a93c" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们举个例子。</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="e5b4" class="kc kd hy jy b fi ke kf l kg kh">var input = 1;</span><span id="d1cb" class="kc kd hy jy b fi ki kf l kg kh">function square() { <br/> let cbFn = function(){ console.log(this.input*this.input) };<br/> setTimeout( cbFn , 1000);<br/>};</span><span id="7f8d" class="kc kd hy jy b fi ki kf l kg kh">var obj = {<br/> input : 3,<br/> square: square<br/>};</span><span id="960f" class="kc kd hy jy b fi ki kf l kg kh">obj.square(); // 1</span></pre><p id="63ea" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我敢肯定你会猜到答案是9，但为什么它打印1！！这一次我们甚至调用了带有对象引用的函数。男孩，我累了…..好吧，再忍耐一分钟。很简单…答案就是执行上下文堆栈。</p><p id="599e" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当您调用函数obj.square()时，square函数被推送到执行上下文堆栈上，其中“this”指向“obj”。如果不是setTimeout，而是打印平方逻辑，它会打印“9”。但是哪里出了问题？看看你什么时候设置的，引擎会把它放在一边，等以后执行。这样一来，square函数的执行就结束了，这导致它的执行上下文从堆栈中弹出。当setTimeout解析后，它被推送到堆栈中，全局对象位于堆栈的顶部。正如你现在看到的，他的函数将作为全局对象的一部分被调用，因此它将选择输入值“1”并打印“1”。</p><p id="3ecc" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">你将如何修理它？这就是你应该有一些机制的地方，你可以在setTimeout的函数中显式地设置这个值为obj。再比如<strong class="ix hz">“事件处理程序”</strong>。当您在事件处理程序上添加回调时，您必须确保“this”的值只是对该DOM元素的引用。</p><h2 id="977c" class="kc kd hy bd kx ky kz la lb lc ld le lf jg lg lh li jk lj lk ll jo lm ln lo lp bi translated"><strong class="ak">调用、绑定、应用</strong></h2><p id="2645" class="pw-post-body-paragraph iv iw hy ix b iy lq ja jb jc lr je jf jg ls ji jj jk lt jm jn jo lu jq jr js hb bi translated">这三个函数有助于将“this”的值显式设置为我们想要的对象。</p><p id="7647" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hz">调用并应用使用给定的“上下文”和参数立即调用函数</strong>。而<strong class="ix hz"> bind返回一个函数</strong>，其上下文(this)设置不可更改。</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="bcec" class="kc kd hy jy b fi ke kf l kg kh">function foo() { <br/>  console.log(this.key);<br/>}</span><span id="4942" class="kc kd hy jy b fi ki kf l kg kh">var objA = { key : "A" };<br/>var objB = { key : "B" };</span><span id="90b9" class="kc kd hy jy b fi ki kf l kg kh">foo.call(objA) // A<br/>foo.call(objB) // B</span><span id="4135" class="kc kd hy jy b fi ki kf l kg kh">// Apply works the same way , there is a small difference between  // call and apply on format of arguments passed to it</span><span id="f79b" class="kc kd hy jy b fi ki kf l kg kh">var bindedFoo = foo.bind(objA);</span><span id="5e2a" class="kc kd hy jy b fi ki kf l kg kh">bindedFoo(); // A;</span><span id="26fe" class="kc kd hy jy b fi ki kf l kg kh">var doubleBindedFoo = bindedFoo.bind(objB);</span><span id="a390" class="kc kd hy jy b fi ki kf l kg kh">doubleBindedFoo() // A (Once binded the value of this can't be changed)</span></pre><p id="98eb" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">上面的例子展示了动态绑定工作的基本结构。让我们再次以setTimeout为例，修改它来解决这个问题</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="af5d" class="kc kd hy jy b fi ke kf l kg kh">function doSomething(){<br/> let cbFn = function () { console.log(this.input*this.input )};<br/> let bindedcbFn = cbFn.bind(this);<br/> setTimeout( bindedcbFn , 1000 );<br/>}</span><span id="e6fa" class="kc kd hy jy b fi ki kf l kg kh">var obj = { <br/>     input : 3, <br/>     doSomething: doSomething <br/>};<br/></span><span id="448d" class="kc kd hy jy b fi ki kf l kg kh">obj.doSomething(); // 9</span><span id="6b87" class="kc kd hy jy b fi ki kf l kg kh">// One great example can be of debounce method ("primarily used in // search, suggestion =&gt; while the user is typing don't make API    // calls , instead delay the execution till user finishes typing")</span><span id="18e0" class="kc kd hy jy b fi ki kf l kg kh">function debounce(fn,timeout) {<br/> let timer;<br/> <br/> return  function (...args) { <br/>     let context = this;<br/>     clearTimeout(timer);<br/>     setTimeout(  function() { fn.apply(context,args) } , timeout );<br/>    };<br/>}</span></pre><p id="4852" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所以这些都是显式绑定“这个”的方式。您可能已经使用了构造函数。但是JS真的有类吗，构造函数有意义吗？？原来构造fn只是一个常规函数。在任何函数前使用<strong class="ix hz">“new”</strong>关键字，使其成为构造函数fn。但是“新”关键字的作用是什么。</p><p id="8a85" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果构造函数没有返回一个对象,“new”关键字将创建一个全新的对象并返回它。但是“这个”是从哪里来的呢？事实证明当你用" new "关键字调用一个函数时。<strong class="ix hz"> JS在后台新建一个对象，并将新建对象的引用传递给函数，从而使这个新对象成为“this”。</strong></p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="95b7" class="kc kd hy jy b fi ke kf l kg kh">function Name(fname, lName) {  <br/>   this.fname = fname; <br/>   this.lName = lName;  <br/>}</span><span id="0bdb" class="kc kd hy jy b fi ki kf l kg kh">var newObj = new Name("jainish", "shah");<br/>console.log( newObj.fname + "  " + newObj.lname); // "jainish shah"</span></pre><p id="cccb" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最后…我们已经在这里讨论了所有4个规则。但是，如果一个以上的规则同时出现，我们需要一些优先规则呢</p><ol class=""><li id="e184" class="kj kk hy ix b iy iz jc jd jg kl jk km jo kn js ko kp kq kr bi translated">新绑定</li><li id="b07d" class="kj kk hy ix b iy ks jc kt jg ku jk kv jo kw js ko kp kq kr bi translated">显式绑定</li><li id="e433" class="kj kk hy ix b iy ks jc kt jg ku jk kv jo kw js ko kp kq kr bi translated">隐式结合</li><li id="3596" class="kj kk hy ix b iy ks jc kt jg ku jk kv jo kw js ko kp kq kr bi translated">默认绑定</li></ol><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="7764" class="kc kd hy jy b fi ke kf l kg kh">function foo() {<br/>  console.log(this.name || "name not defined");<br/>}</span><span id="80d7" class="kc kd hy jy b fi ki kf l kg kh">var obj = { name: 'jainish' };<br/>var bindedFoo = foo.bind(obj);<br/>bindedFoo() // jainish</span><span id="68b5" class="kc kd hy jy b fi ki kf l kg kh">var newFoo = new bindedFoo(); // name not defined</span></pre><p id="549b" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您可以清楚地看到，即使bindedFoo fn将“this”设置为obj，它也会被“new”关键字覆盖。这与上面所说的“一旦绑定”fn就“不能改变值”的说法相矛盾，并不完全正确。它高度依赖于“bind”方法的实现。(为polyfill签出mdn文档)</p><p id="170b" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这就把我们带到了文章的结尾。我知道它很长，但是大小很重要😂😂。我将在下一篇文章中讨论“箭头函数”。我希望你学到新的东西，直到下一个。</p><p id="bcae" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如有任何疑问，请联系我@ jainishshah12@gmail.com</p></div></div>    
</body>
</html>