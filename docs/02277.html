<html>
<head>
<title>Challenges implementing DDD</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">实施DDD面临的挑战</h1>
<blockquote>原文：<a href="https://medium.com/codex/challenges-implementing-ddd-4113d602caf6?source=collection_archive---------2-----------------------#2021-07-11">https://medium.com/codex/challenges-implementing-ddd-4113d602caf6?source=collection_archive---------2-----------------------#2021-07-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/e07f5d833d8e47620b2e2f708945a32f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ij523ELw9I6rVqK7LchdXg.png"/></div></div></figure><p id="7979" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我已经读完了Eric Evans(蓝皮书)和Vaughn Vernon(红皮书)的DDD书籍，并想写下我个人关于实施DDD的挑战的笔记。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es jo"><img src="../Images/f7c90b55676160b6b60dd5511f8c1b23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eb5kXrfPVJajwjOtaNo7Lw.png"/></div></div></figure><p id="768f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">虽然所有的原创想法都来自蓝皮书，但我承认红皮书让你对如何应用DDD方法有了更多的理解。这并不奇怪，因为蓝皮书是在2003年出版的，所以在提供例子的情况下，自然感觉有点过时，但尽管如此，DDD的思想在两本书中都是相同的。</p><p id="9c47" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我想说，DDD是一个非常复杂的话题，有很多方法和模式，所以我甚至不想在这里一一介绍。我只想总结一下，DDD就是要理解业务领域，并在代码中恰当地反映出来。省略了许多细节，该方法要求在代码中有一个专用的领域层，使用领域专家的语言描述业务逻辑。重要的是，有一个复杂的领域逻辑和理想的领域专家来从DDD中获益，因为它有自己的价格。</p><p id="65ea" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">正如我提到的，DDD方法需要一个尽可能用业务语言(通用语言)描述的领域层。它很自然地将我们推向所谓的"<a class="ae jt" href="https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html" rel="noopener ugc nofollow" target="_blank">干净的架构</a>"，因为业务专家不说技术术语，所以领域层应该尽可能与框架无关。</p><p id="c36f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="ju">小备注:DDD通常用六角架构实现，但这不是强制要求，因为它也可以用分层架构实现。</em></p></div><div class="ab cl jv jw gp jx" role="separator"><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka"/></div><div class="hb hc hd he hf"><p id="6ca3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在让我们强调第一个挑战:</p></div><div class="ab cl jv jw gp jx" role="separator"><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka"/></div><div class="hb hc hd he hf"><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es kc"><img src="../Images/a807c9bcf451b28a6e933193fecec269.png" data-original-src="https://miro.medium.com/v2/resize:fit:456/format:webp/1*v7-6M9s9E9Xt42pnkC3mUA.png"/></div></figure><p id="88d0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">从领域层移除框架需要很多额外的抽象。看看DDD图。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es kd"><img src="../Images/fd58c282bc4851b2515d1d799f81e3c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1162/format:webp/0*HBmLFSlj5ibfYTSs.png"/></div></figure><p id="3f56" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">请注意，实体和存储库不是JPA抽象。它们是领域抽象。</strong>这意味着您需要在创建域对象时(使用工厂或存储库)将数据放入域对象，并在保存域对象时(使用存储库)检索数据。</p><p id="381b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您可能希望使用Java mapper库将信息复制到域层或从域层复制信息。我建议看看<a class="ae jt" href="https://github.com/remondis-it/remap" rel="noopener ugc nofollow" target="_blank">重映射</a>库。它使用漂亮的DSL +提供类型安全映射，保证在映射<strong class="is hj"> <em class="ju">(但仅在运行时)</em> </strong> <em class="ju">期间不会遗漏任何字段。</em></p><p id="e8d3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">作为一个经验法则:如果你没有复杂的领域逻辑，你可能不需要实现DDD，因为它带来更多的开销而不是好处。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es ke"><img src="../Images/3ca52b580a6391146019f126f06d33ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:460/format:webp/1*NnsmqasCN-qCRlPh_ycVcA.png"/></div></figure><p id="eab8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">第二个挑战是事务管理。在解释之前，我强烈建议阅读“红皮书”中关于存储库的第12章。我个人认为这是最有用的章节之一，因为它给出了一种看待持久层的不同方式。</p><p id="2874" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">基本上，有两种类型的存储库:</p><ul class=""><li id="bb6d" class="kf kg hi is b it iu ix iy jb kh jf ki jj kj jn kk kl km kn bi translated"><strong class="is hj">面向集合的存储库</strong>——实现JPA存储库的更传统的方式，因为它经常需要“工作单元——即事务”,并跟踪实体的变化</li><li id="274a" class="kf kg hi is b it ko ix kp jb kq jf kr jj ks jn kk kl km kn bi translated"><strong class="is hj">面向持久性的存储库— </strong>存储库的每个操作都应该单独执行(没有“工作单元”)</li></ul><p id="7db1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在让我们回到挑战上来。<strong class="is hj">域存储库应该只返回域实体和集合，而不是JPA实体</strong>。这意味着面向集合的方法更难实现，因为域实体只持有数据的副本(在与框架无关的域层的情况下)。跟踪更改是可能的，但需要额外的努力。</p><p id="5ae7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">实现面向持久性的方法要容易得多，因为DDD集合代表了可以原子提交的抽象。此外，面向持久性的方法使我们更接近“干净的架构”,因为我们不依赖于“工作单元”,只有在这种情况下，我们才能轻松地用NoSQL实现替换RDBM实现。使用面向持久性的方法，我们甚至可以将事务管理从应用层转移到持久层。</p><p id="1287" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">作为结论，我要指出的是，如果您处理以数据为中心的系统而不是以域为中心的系统，那么DDD可能不是最佳选择，因为您经常会违反“每个聚合一个事务”这样的规则，并且必须将一些逻辑移到DB查询中(由于性能要求)。emark:这里我只谈论“战术设计”,因为在我看来“战略设计”在任何情况下都是有用的。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es ke"><img src="../Images/e27c13ffa4e583950144c7d4e04bd4fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:460/format:webp/1*OA91ULUzCnFQClcpuaFFwg.png"/></div></figure><p id="2fd3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后一个挑战是实现可靠的事件。DDD背后有一个简单的想法——对于实体持久性，有一个专用层，对于与其他系统的通信，有一些事件将外部系统的依赖性从域层解耦。理想情况下，我们希望以原子的方式提交数据库更改和发送事件，但不幸的是，没有简单的方法来做到这一点。“两阶段提交”有一个糟糕的名声(由于性能问题和协调器故障问题)，并且大多数现代系统不支持该协议。</p><p id="3b13" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">它让我们选择先做什么:提交事务还是发送事件？在提交事务之前发送事件可能会导致不一致的状态，因为无法保证随后会提交事务(应用程序可能会在任何时候被终止，尤其是在云原生应用程序时代)。最有可能的是，我们希望在提交数据库更改后发送事件。在这种情况下，我们需要做出选择:</p><ul class=""><li id="4193" class="kf kg hi is b it iu ix iy jb kh jf ki jj kj jn kk kl km kn bi translated">发送保证“最多一次”的事件</li><li id="6611" class="kf kg hi is b it ko ix kp jb kq jf kr jj ks jn kk kl km kn bi translated">发送保证“至少一次”的事件</li></ul><p id="305d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">发送保证“最多一次”的事件非常简单。不需要做任何特殊的事情，我们只是接受这样一个事实，即在应用程序失败的情况下，在尝试发送之前，事件可能会丢失。不幸的是，并不是所有的需求都接受这种保证。</p><p id="9e0a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">实现“至少一次”保证更加复杂，因为它需要在同一事务中的同一存储中保存事件和数据库更改。交付事件可以使用专门的工作或特殊工具来完成，如“<a class="ae jt" href="https://debezium.io/" rel="noopener ugc nofollow" target="_blank"> Debezium </a>”和“<a class="ae jt" href="https://docs.confluent.io/platform/current/connect/index.html" rel="noopener ugc nofollow" target="_blank"> Kafka Connect </a>”。这种模式被称为<a class="ae jt" href="https://en.wikipedia.org/wiki/Change_data_capture" rel="noopener ugc nofollow" target="_blank">“变更数据捕获”</a>模式，许多云提供商为流变更提供现成的解决方案。但是我们仍然需要使用相同的事务来保存主要的更改和事件。这将我们推回到之前的主题:要么我们需要在应用层进行事务管理(在面向集合的存储库的情况下)，要么我们需要一个“一致的”保存方法来接受聚合和事件(在面向持久化的存储库的情况下)。对于面向持久性的存储库，当我们处理不支持事务的非SQL数据库时，事情变得复杂(因为没有办法实现“一致的”保存方法)。我们可能只监视数据库数据本身的变化，并在域层之外生成事件(更多细节见本文)。</p><p id="c441" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此，没有解决这个问题的“灵丹妙药”,因此应用程序不能完全与持久性无关，数据库也不能轻易交换。您仍然需要至少了解数据库的“家族”,以及它为可靠事件的持久层的正确实现提供了什么保证。</p></div><div class="ab cl jv jw gp jx" role="separator"><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka"/></div><div class="hb hc hd he hf"><p id="7721" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">综上所述，我认为DDD有很多好的想法，但是任何软件都包含需要考虑的技术挑战，并且不是所有的都可以容易地在领域层呈现或隐藏。</p></div></div>    
</body>
</html>