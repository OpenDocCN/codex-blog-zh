<html>
<head>
<title>JavaScript Promise for Dummies</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向傻瓜的JavaScript承诺</h1>
<blockquote>原文：<a href="https://medium.com/codex/javascript-promise-for-dummies-f3e763c2ec26?source=collection_archive---------4-----------------------#2021-05-31">https://medium.com/codex/javascript-promise-for-dummies-f3e763c2ec26?source=collection_archive---------4-----------------------#2021-05-31</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="9015" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">我保证这很容易。</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/91f78151b9d32cbf9e3edceb990adea1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Kvpf-g5sYkLXN6sWPSYCIQ.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">由作者通过<a class="ae jn" href="https://carbon.now.sh/zjVsEKXaL4qCQx6FXCnl" rel="noopener ugc nofollow" target="_blank">碳</a>创造</figcaption></figure><p id="b026" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">如果你在javascript中不使用承诺，你就错过了。JavaScript异步工作<strong class="jq hj"/>。这是一个方便的工具，让你的代码同步工作<strong class="jq hj"/>。</p><h1 id="6830" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">为什么要答应？</h1><p id="5fa3" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">有时候你需要等待Axios(一个流行的HTTP请求库)返回值，然后再继续。一个承诺可以让你做到这一点。</p><p id="0b10" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">它允许您编写异步执行但可预测的代码。</p><h2 id="32d3" class="lh kl hi bd km li lj lk kq ll lm ln ku jx lo lp kw kb lq lr ky kf ls lt la lu bi translated">如果它是纯同步的</h2><p id="661e" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">您将无法运行并行HTTP请求。</p><p id="5cbc" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">您可能需要发送多个HTTP请求来从多个API点获取数据。</p><p id="76a0" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">异步执行允许您一次运行多个HTTP请求。Javascript本质上是异步的，所以我们很好。</p><h2 id="839f" class="lh kl hi bd km li lj lk kq ll lm ln ku jx lo lp kw kb lq lr ky kf ls lt la lu bi translated">如果它是完全异步的</h2><p id="5182" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">您将无法暂停代码执行。</p><p id="2223" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">发送HTTP请求后，您将得到响应。这些响应很重要，可能会被后面的另一段代码所需要。</p><p id="dc1a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">如果我们不使用Promise，下一行代码(可能需要响应)将在不等待响应的情况下运行。因此，由于未定义的响应，运行将是错误的。</p></div><div class="ab cl lv lw gp lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="hb hc hd he hf"><h1 id="c3fa" class="kk kl hi bd km kn mc kp kq kr md kt ku io me ip kw ir mf is ky iu mg iv la lb bi translated">创造承诺</h1><p id="2978" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">让我们看一个基本的承诺。</p><pre class="iy iz ja jb fd mh mi mj mk aw ml bi"><span id="8186" class="lh kl hi mi b fi mm mn l mo mp">new Promise ((resolve, reject) =&gt; {<br/>  let success = true;<br/>  // Code<br/>  if (success) resolve()<br/>  else reject()<br/>})</span></pre><p id="ed31" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">其思想是，如果一切顺利，承诺将得到解决，如果一切不顺利，承诺将被拒绝。一个函数通常包装承诺。</p><pre class="iy iz ja jb fd mh mi mj mk aw ml bi"><span id="7a2c" class="lh kl hi mi b fi mm mn l mo mp">function sleep (t) {<br/>  return new Promise((resolve, reject) =&gt; {<br/>    setTimeout(() =&gt; {<br/>      resolve()<br/>    }, t)<br/>  })<br/>}</span></pre></div><div class="ab cl lv lw gp lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="hb hc hd he hf"><h1 id="afe1" class="kk kl hi bd km kn mc kp kq kr md kt ku io me ip kw ir mf is ky iu mg iv la lb bi translated">处理承诺</h1><p id="0e10" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">有两种方法处理承诺(由函数返回):</p><h2 id="f059" class="lh kl hi bd km li lj lk kq ll lm ln ku jx lo lp kw kb lq lr ky kf ls lt la lu bi translated">然后接住</h2><p id="7519" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">我用一个代码来解释。让我们使用我们的睡眠功能。</p><pre class="iy iz ja jb fd mh mi mj mk aw ml bi"><span id="f143" class="lh kl hi mi b fi mm mn l mo mp">sleep(5000)<br/>  .then(() =&gt; {<br/>    console.log("done sleeping!")<br/>  })<br/>  .catch(() =&gt; {<br/>    console.log("error while sleeping!")  <br/>  })</span></pre><p id="6cf5" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">调用睡眠函数后，我们可以使用then和catch处理返回的承诺。</p><blockquote class="mq mr ms"><p id="fc59" class="jo jp mt jq b jr js ij jt ju jv im jw mu jy jz ka mv kc kd ke mw kg kh ki kj hb bi translated">。然后()处理resolve()</p><p id="7ad7" class="jo jp mt jq b jr js ij jt ju jv im jw mu jy jz ka mv kc kd ke mw kg kh ki kj hb bi translated">。catch()处理reject()</p></blockquote><p id="a6f0" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">你现在应该明白了。如果一个承诺解决了，那么我们可以继续。</p><p id="7740" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">如果一个承诺被拒绝，那么我们捕获抛出的错误。</p><p id="abf5" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">您还可以通过resolve和reject传递值，这样一旦承诺完成，then和catch就会接收值。</p><pre class="iy iz ja jb fd mh mi mj mk aw ml bi"><span id="8fc9" class="lh kl hi mi b fi mm mn l mo mp">function sleep (t) {<br/>  return new Promise((resolve, reject) =&gt; {<br/>    setTimeout(() =&gt; {<br/>      let random = Math.random()<br/>      if (random &gt; 0.5) resolve("I can sleep!")<br/>      else reject("I cannot sleep!")<br/>    }, t)<br/>  })<br/>}</span><span id="9c10" class="lh kl hi mi b fi mx mn l mo mp">sleep(1000)<br/>  .then((res) =&gt; console.log(res))<br/>  .catch((err) =&gt; console.log(err))</span><span id="3fee" class="lh kl hi mi b fi mx mn l mo mp">// if random &gt; 0.5<br/>&gt; I can sleep! </span><span id="28fb" class="lh kl hi mi b fi mx mn l mo mp">// else<br/>&gt; I cannot sleep!</span></pre><h2 id="5425" class="lh kl hi bd km li lj lk kq ll lm ln ku jx lo lp kw kb lq lr ky kf ls lt la lu bi translated">异步等待</h2><p id="3a74" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">然后抓住方法是伟大的，但当我们需要一个接一个的多个承诺时，它会变得混乱。它看起来会像这样。</p><pre class="iy iz ja jb fd mh mi mj mk aw ml bi"><span id="bd0d" class="lh kl hi mi b fi mm mn l mo mp">sleep(1000)<br/>  .then((res) =&gt; {<br/>    // sleep again<br/>    sleep(1000)<br/>      .then((res) =&gt; {    <br/>        // sleep again<br/>        sleep(1000)<br/>          .then((res) =&gt; console.log("I sleep 3 times!"))<br/>          .catch((err) =&gt; console.log(err))})<br/>      .catch((err) =&gt; console.log(err)) <br/>  })<br/>  .catch((err) =&gt; console.log(err))</span></pre><p id="1cc7" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">对我来说像是承诺地狱。当然，代码是无用的，但你得到的想法。</p><p id="96fa" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">Async-await解决了这个问题。</p><pre class="iy iz ja jb fd mh mi mj mk aw ml bi"><span id="49d4" class="lh kl hi mi b fi mm mn l mo mp">async function main() {<br/>  try { <br/>    await sleep(1000)<br/>    await sleep(1000)<br/>    await sleep(1000)<br/>  } catch (e) {<br/>    // handle error<br/>  }<br/>}</span><span id="aeda" class="lh kl hi mi b fi mx mn l mo mp">main()</span></pre><p id="1ec3" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">看起来是不是很棒？代码更加容易理解和简洁。</p><blockquote class="mq mr ms"><p id="987b" class="jo jp mt jq b jr js ij jt ju jv im jw mu jy jz ka mv kc kd ke mw kg kh ki kj hb bi translated">等待承诺的解决。它取代了。然后()。</p><p id="3ebe" class="jo jp mt jq b jr js ij jt ju jv im jw mu jy jz ka mv kc kd ke mw kg kh ki kj hb bi translated">try and catch块处理错误。它取代了。catch()。</p></blockquote><p id="893a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">如果您想从承诺接收响应，您可以将它赋给一个变量。</p><pre class="iy iz ja jb fd mh mi mj mk aw ml bi"><span id="d6e5" class="lh kl hi mi b fi mm mn l mo mp">let res = await sleep(1000)</span></pre><p id="1b20" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">注意，您需要用一个异步函数来包装它(注意，异步是函数定义的开始)。</p></div><div class="ab cl lv lw gp lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="hb hc hd he hf"><h1 id="8781" class="kk kl hi bd km kn mc kp kq kr md kt ku io me ip kw ir mf is ky iu mg iv la lb bi translated"><strong class="ak">使用并行工程的承诺</strong></h1><p id="c5b2" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">假设您需要来自多个API点的数据才能继续。JavaScript本质上是并行执行代码的。然而，如何等待所有的人呢？</p><p id="9d5f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">Async-await和then-catch通过等待一个承诺完成来执行下一行。</p><h2 id="06cb" class="lh kl hi bd km li lj lk kq ll lm ln ku jx lo lp kw kb lq lr ky kf ls lt la lu bi translated">为Promise.all鼓掌()</h2><p id="f677" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">Promise.all()解决了这个问题。该函数将等待<strong class="jq hj">承诺数组</strong>完成。</p><p id="f066" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我通过代码来解释。</p><p id="ed0b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们有一个向URL发送HTTP请求的函数。</p><pre class="iy iz ja jb fd mh mi mj mk aw ml bi"><span id="df01" class="lh kl hi mi b fi mm mn l mo mp">function sendRequest (url) {<br/>  return new Promise ((resolve, reject) =&gt; {<br/>    // do something fun here<br/>  })<br/>}</span></pre><p id="2680" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们有多个网址。</p><pre class="iy iz ja jb fd mh mi mj mk aw ml bi"><span id="4faa" class="lh kl hi mi b fi mm mn l mo mp">let urls = [url1, url2, url3, url4]</span></pre><p id="eeb1" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们可以同时发送多个请求并将承诺添加到一个数组中。</p><pre class="iy iz ja jb fd mh mi mj mk aw ml bi"><span id="e6fb" class="lh kl hi mi b fi mm mn l mo mp">let promises = []<br/>urls.map(url =&gt; {<br/>  promises.push(sendRequest(url))<br/>})<br/>[<br/>  Promise { &lt;pending&gt; },<br/>  Promise { &lt;pending&gt; },<br/>  Promise { &lt;pending&gt; },<br/>  Promise { &lt;pending&gt; }<br/>]</span></pre><p id="1185" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">承诺变量将如下所示:</p><pre class="iy iz ja jb fd mh mi mj mk aw ml bi"><span id="a68f" class="lh kl hi mi b fi mm mn l mo mp">console.log(promises)<br/>[<br/>  Promise { &lt;pending&gt; },<br/>  Promise { &lt;pending&gt; },<br/>  Promise { &lt;pending&gt; },<br/>  Promise { &lt;pending&gt; }<br/>]</span></pre><p id="b30e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">然后我们用Promise.all()</p><pre class="iy iz ja jb fd mh mi mj mk aw ml bi"><span id="e388" class="lh kl hi mi b fi mm mn l mo mp">Promise.all(promises)<br/>  .then(responses =&gt; console.log(responses))<br/>  .catch(err =&gt; console.log(err))</span></pre><p id="86dc" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">响应将是来自每个请求的顺序响应数组。</p><pre class="iy iz ja jb fd mh mi mj mk aw ml bi"><span id="94ca" class="lh kl hi mi b fi mm mn l mo mp">console.log(responses)<br/>&gt; ['from url1','from url2','from url3','from url4']</span></pre></div><div class="ab cl lv lw gp lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="hb hc hd he hf"><h1 id="5cb6" class="kk kl hi bd km kn mc kp kq kr md kt ku io me ip kw ir mf is ky iu mg iv la lb bi translated">外卖食品</h1><p id="8207" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">JavaScript Promise太棒了。它被NPM的图书馆广泛使用。即使您不使用库，当您想要改变JavaScript的异步特性时，它也会派上用场。</p><p id="ad7a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">比起使用while循环来暂停，promise是一种更优雅的方式。</p></div></div>    
</body>
</html>