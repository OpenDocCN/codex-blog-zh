<html>
<head>
<title>Ruby Procs and Lambdas: What’s the difference?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Ruby Procs和Lambdas:有什么区别？</h1>
<blockquote>原文：<a href="https://medium.com/codex/ruby-procs-and-lambdas-whats-the-difference-bb64225e7c13?source=collection_archive---------11-----------------------#2021-03-15">https://medium.com/codex/ruby-procs-and-lambdas-whats-the-difference-bb64225e7c13?source=collection_archive---------11-----------------------#2021-03-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/1b85e31fa9ed6b1e85bd0dfe1b76abb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qtrsyYn8k94Cx1Zc"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">阿诺德·弗朗西斯卡在<a class="ae hv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h2 id="9cdb" class="hw hx hy bd b fp hz ia ib ic id ie dx if translated" aria-label="kicker paragraph"><a class="ae ge" href="http://medium.com/codex" rel="noopener">法典</a></h2><div class=""/><p id="f149" class="pw-post-body-paragraph je jf hy jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">Procs和Lambdas的用法相似，但在特定方面有所不同。这两个函数都是高阶函数，它们将其他函数作为参数，或者将它们作为结果返回。将它进一步分解成一个块是一个无名方法，它作为参数传递给另一个方法。</p><p id="f687" class="pw-post-body-paragraph je jf hy jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">块不能保存为变量。它们是ruby“一切都是对象”规则不成立的少数例子之一。</p><h1 id="ee79" class="kc kd hy bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">Procs</h1><p id="ee96" class="pw-post-body-paragraph je jf hy jg b jh la jj jk jl lb jn jo jp lc jr js jt ld jv jw jx le jz ka kb hb bi translated">过程是可以绑定到一组局部变量的代码块。它们本质上是一个保存的代码块。</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="488b" class="lo kd hy lk b fi lp lq l lr ls">def foo(x, y, proc_block)<br/>  proc_block.(x, y)<br/>end</span><span id="f4d0" class="lo kd hy lk b fi lt lq l lr ls">add = proc { |a, b| a + b }</span><span id="7e68" class="lo kd hy lk b fi lt lq l lr ls">puts foo(3, 6, add)</span><span id="cf71" class="lo kd hy lk b fi lt lq l lr ls">  =&gt; result is 9</span></pre><p id="3ed7" class="pw-post-body-paragraph je jf hy jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">我们用参数<code class="du lu lv lw lk b">x</code>、<code class="du lu lv lw lk b">y</code>和<code class="du lu lv lw lk b">proc_block</code>声明一个方法<code class="du lu lv lw lk b">foo</code>。<code class="du lu lv lw lk b">x</code>和<code class="du lu lv lw lk b">y</code>将是数字，而<code class="du lu lv lw lk b">proc_block</code>将是触发。</p><p id="ef98" class="pw-post-body-paragraph je jf hy jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">然后我们声明变量<code class="du lu lv lw lk b">add</code>，这是一个保存为<code class="du lu lv lw lk b">proc</code>的代码块。我们用单词<code class="du lu lv lw lk b">proc</code>声明一个<code class="du lu lv lw lk b">proc</code>，然后在花括号中是我们想要运行的代码。</p><p id="da4c" class="pw-post-body-paragraph je jf hy jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">最后，我们把它们放在一起，输入两个值和我们的过程。结果是9的和！</p><h1 id="ead4" class="kc kd hy bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">兰姆达斯</h1><p id="f8e6" class="pw-post-body-paragraph je jf hy jg b jh la jj jk jl lb jn jo jp lc jr js jt ld jv jw jx le jz ka kb hb bi translated">兰姆达斯来自<code class="du lu lv lw lk b">proc</code>班，长得很像！然而，这两者之间存在着微小但同时又很大的差异。它们是匿名函数，所以本质上是自动执行的<code class="du lu lv lw lk b">proc</code>。你可以通过使用单词<code class="du lu lv lw lk b">lambda</code>(老派)或者使用带有<code class="du lu lv lw lk b">-&gt;</code>的‘stabby’语法来声明一个lambda。我将重新创建上面的<code class="du lu lv lw lk b">proc</code>示例。</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="6e92" class="lo kd hy lk b fi lp lq l lr ls">def foo(x, y)<br/>  -&gt;(x + y)<br/>end</span><span id="7fe4" class="lo kd hy lk b fi lt lq l lr ls">x = 3; y = 6</span><span id="13e9" class="lo kd hy lk b fi lt lq l lr ls">result = foo(x, y).call </span><span id="7e1a" class="lo kd hy lk b fi lt lq l lr ls"># or you can invoke using just .()</span><span id="2fb6" class="lo kd hy lk b fi lt lq l lr ls">result2 = foo(x, y).()</span><span id="a275" class="lo kd hy lk b fi lt lq l lr ls">result    #9<br/>result2   #2</span></pre><p id="4b5a" class="pw-post-body-paragraph je jf hy jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">这里有一个关于lambda和proc是什么的简短概述！</p></div></div>    
</body>
</html>