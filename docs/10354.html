<html>
<head>
<title>How to use Symfony messenger to consume RabbitMQ messages (with example)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用Symfony messenger消费RabbitMQ消息(附示例)</h1>
<blockquote>原文：<a href="https://medium.com/codex/how-to-use-symfony-messenger-to-consume-rabbitmq-messages-with-example-1440da1ef68?source=collection_archive---------7-----------------------#2022-12-24">https://medium.com/codex/how-to-use-symfony-messenger-to-consume-rabbitmq-messages-with-example-1440da1ef68?source=collection_archive---------7-----------------------#2022-12-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="6ac7" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">PHP中事件驱动架构的实践方法</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/34d41481545a6d700a97a6a64965e598.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*mteaR2sXkKf50tk2"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated"><a class="ae jn" href="https://unsplash.com/@trommelkopf?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">史蒂夫·哈维</a>在<a class="ae jn" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</figcaption></figure><p id="d160" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我已经更详细地解释了什么是事件驱动架构。</p><p id="7434" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">如果你是这个概念的新手，需要阅读更多相关内容，请访问<a class="ae jn" href="https://anastasionico.uk/blog/a-quick-guide-to-event-driven-architecture" rel="noopener ugc nofollow" target="_blank">事件驱动架构快速指南</a>。</p><p id="11ca" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">如果你已经知道了足够多，并想把你的手放在一些Symfony代码，这是你的职位。</p><p id="1256" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在本文中，您将学习如何使用PHP使用存储在RabbitMQ中的消息。</p><p id="5ced" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们将通过Symfony Messenger消费它。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="ab fe cl kk"><img src="../Images/6aea16598d71eebcc533644715448159.png" data-original-src="https://miro.medium.com/v2/0*vPjJ_q5vxkiGZCgy"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">照片由erica steeves在Unsplash上拍摄</figcaption></figure><h1 id="0996" class="kl km hi bd kn ko kp kq kr ks kt ku kv io kw ip kx ir ky is kz iu la iv lb lc bi translated">什么是事件驱动架构？</h1><p id="d008" class="pw-post-body-paragraph jo jp hi jq b jr ld ij jt ju le im jw jx lf jz ka kb lg kd ke kf lh kh ki kj hb bi translated">系统的传统架构是一个典型的请求/响应架构。</p><p id="0cda" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">一个服务执行一个涉及其他服务的动作。</p><p id="fc9c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">当第二个做它的事情时，第一个需要等待。</p><p id="720d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这很有效，但不是构建系统的最佳方式。</p><p id="0e76" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在<a class="ae jn" href="https://ably.com/blog/introduction-event-driven-architecture" rel="noopener ugc nofollow" target="_blank">事件驱动架构</a>中，流程遵循事件模式。</p><p id="6ef2" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">当事情发生时，例如，一个需要动作的事件，<strong class="jq hj">我们存储它而不是处理它。</strong></p><p id="5ee3" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这样，我们正在交互的服务确实需要停下来等待。</p><p id="0da9" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">第二个可以检索事件并在准备好的时候执行操作。</p><p id="5c3e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">为了能够使用这个架构，我们需要在某个地方存储这个事件。</strong></p><p id="0c6b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">有几个活动经纪人。</p><p id="7a83" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">最著名的是<em class="li"> Apache Kafka、Google Cloud Pub/Sub、RabbitMQ。</em></p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="ab fe cl kk"><img src="../Images/86130b93106a12c89a678dfd2a3163e0.png" data-original-src="https://miro.medium.com/v2/0*1Di7SNmRsz0ZHC-a"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">Volodymyr Hryshchenko在Unsplash上拍摄的照片</figcaption></figure><h1 id="bc37" class="kl km hi bd kn ko kp kq kr ks kt ku kv io kw ip kx ir ky is kz iu la iv lb lc bi translated">兔子q</h1><p id="e7e6" class="pw-post-body-paragraph jo jp hi jq b jr ld ij jt ju le im jw jx lf jz ka kb lg kd ke kf lh kh ki kj hb bi translated">RabbitMQ是最受欢迎的开源消息代理之一。</p><p id="ad45" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">它支持许多消息协议。</p><p id="456a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们可以用多种配置来部署它。</p><p id="5aa0" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">它还可以在许多操作系统和云环境中运行。</p><p id="c11a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">它的工作方式是通过创建可以包含许多队列的不同通道。</strong></p><p id="72c7" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">反过来，这些队列可以存储许多事件或消息。</p><p id="3dcb" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们在本文中使用<a class="ae jn" href="https://www.rabbitmq.com/" rel="noopener ugc nofollow" target="_blank"> RabbitMQ </a>的方式是存储消息。</p><p id="2c68" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">然后我们将使用PHP应用程序检索这些消息。</p><p id="037f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">如果你想学习更多关于这门语言的知识，请阅读<a class="ae jn" href="https://anastasionico.uk/blog/php-basics" rel="noopener ugc nofollow" target="_blank">PHP基础知识</a></p><p id="da3c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">因为程序员不想一直重复发明轮子。</p><p id="d025" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们将为我们的应用程序使用一个PHP框架。</p><p id="57db" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">本文选择的框架是Symfony。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="ab fe cl kk"><img src="../Images/26fa10e36e2f06a47a2c64a7e2c0dab7.png" data-original-src="https://miro.medium.com/v2/0*oK3VXsbdVZduQsEL"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">本·格里菲斯在Unsplash上拍摄的照片</figcaption></figure><h1 id="fa0a" class="kl km hi bd kn ko kp kq kr ks kt ku kv io kw ip kx ir ky is kz iu la iv lb lc bi translated">Symfony</h1><p id="1d06" class="pw-post-body-paragraph jo jp hi jq b jr ld ij jt ju le im jw jx lf jz ka kb lg kd ke kf lh kh ki kj hb bi translated">Symfony是目前最流行的PHP开发框架之一。</p><p id="170f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">它由具有各自用途的组件集组成。</p><p id="7472" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">通过将所有这些组件放在一起，我们不需要担心配置。</p><p id="e8f5" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">诸如授权、认证、路由等。</p><p id="c124" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><a class="ae jn" href="https://symfony.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="jq hj"> Symfony </strong> </a> <strong class="jq hj">已经将它全部内置在应用程序里面。</strong></p><p id="8249" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我已经写了一些关于Symfony的指南，如果你想开始使用它，这里有<a class="ae jn" href="https://anastasionico.uk/blog/how-to-install-symfony-6" rel="noopener ugc nofollow" target="_blank">如何在你的机器上安装Symfony 6</a></p><p id="d7b8" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">Symfony Messenger是这些组件中的一个，也是本文需要的一个。</p><h1 id="a442" class="kl km hi bd kn ko kp kq kr ks kt ku kv io kw ip kx ir ky is kz iu la iv lb lc bi translated">如何使用Symfony消费RabbitMQ消息</h1><p id="3cd0" class="pw-post-body-paragraph jo jp hi jq b jr ld ij jt ju le im jw jx lf jz ka kb lg kd ke kf lh kh ki kj hb bi translated">Symfony使开发人员能够轻松地创建一个能够从代理检索消息的结构。</p><p id="9de9" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在我们的例子中，我们只需要4块就可以完成任务。</p><p id="815f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们需要:</p><ul class=""><li id="e842" class="lj lk hi jq b jr js ju jv jx ll kb lm kf ln kj lo lp lq lr bi translated"><strong class="jq hj">消息类是保存消息数据的类</strong>；</li><li id="b0f0" class="lj lk hi jq b jr ls ju lt jx lu kb lv kf lw kj lo lp lq lr bi translated"><strong class="jq hj">handler类负责读取消息</strong>。它还将把动作委托给一个或多个服务；</li><li id="f7cc" class="lj lk hi jq b jr ls ju lt jx lu kb lv kf lw kj lo lp lq lr bi translated">序列化器类是信息被翻译成可读版本供我们的应用程序使用的地方；</li><li id="87ce" class="lj lk hi jq b jr ls ju lt jx lu kb lv kf lw kj lo lp lq lr bi translated">传输是我们发送和接收消息所需要的；</li></ul><h2 id="a154" class="lx km hi bd kn ly lz ma kr mb mc md kv jx me mf kx kb mg mh kz kf mi mj lb mk bi translated">消息类</h2><p id="8388" class="pw-post-body-paragraph jo jp hi jq b jr ld ij jt ju le im jw jx lf jz ka kb lg kd ke kf lh kh ki kj hb bi translated">首先，我们想要的是来自RabbitMQ的消息。</p><p id="ce86" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">为了让每个人都清楚这个例子，我们将在我们的对象中使用一个项目，</p><p id="4dad" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这将是一个order_id及其值。</p><pre class="iy iz ja jb fd ml mm mn bn mo mp bi"><span id="c775" class="mq km hi mm b be mr ms l mt mu">{'order_id': 1234567}</span></pre><p id="3a78" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">为了处理这种格式，我们需要一个带有订单的setter和getter的类。</p><pre class="iy iz ja jb fd ml mm mn bn mo mp bi"><span id="163b" class="mq km hi mm b be mr ms l mt mu">namespace App\Message;<br/> <br/>class PurchasesNotification<br/>{<br/>    private int $order_id;<br/> <br/>    public function getOrderId(): int<br/>    {<br/>        return $this---&gt;order_id;<br/>    }<br/> <br/>    public function setOrderId(int $order_id)<br/>    {<br/>        $this-&gt;order_id = $order_id;<br/>    }<br/>}</span></pre><p id="572e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">很简单，不是吗？</p><h2 id="cda5" class="lx km hi bd kn ly lz ma kr mb mc md kv jx me mf kx kb mg mh kz kf mi mj lb mk bi translated">处理程序类</h2><p id="aa19" class="pw-post-body-paragraph jo jp hi jq b jr ld ij jt ju le im jw jx lf jz ka kb lg kd ke kf lh kh ki kj hb bi translated">处理者是奇迹发生的地方。</p><p id="305c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在Symfony中，<strong class="jq hj">处理程序是PHP可调用的。</strong></p><p id="086f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">调度该消息时调用的就是该类。</p><p id="f020" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">handler类读取上面的PurchasesNotification类。</p><p id="c47d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">然后，它可以执行任务或将任务委托给适当的服务。</p><pre class="iy iz ja jb fd ml mm mn bn mo mp bi"><span id="d2ac" class="mq km hi mm b be mr ms l mt mu">namespace App\MessageHandler;<br/> <br/>use App\Message\PurchasesNotification;<br/>use Symfony\Component\Messenger\Attribute\AsMessageHandler;<br/>use App\Service\PurchasesService;<br/> <br/>#[AsMessageHandler]<br/>class PurchasesHandler<br/>{<br/>    public function __construct(public PurchasesService $service)<br/>    {}<br/> <br/>    public function __invoke(PurchasesNotification $message)<br/>    {<br/>        $orderId = json_decode((string) $message---&gt;getOrderId(), true);<br/>         <br/>        try {<br/>            $this-&gt;service-&gt;getPurchases($orderId);<br/>        } catch (\Exception $exception) {<br/>            echo $exception-&gt;getMessage();<br/>        }<br/>    }<br/>}<br/></span></pre><p id="89bb" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在本例中，我所做的是从消息类的<code class="du mv mw mx mm b">getOrderId()</code>方法中获取订单ID。</p><p id="7e30" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">然后我调用一个PurchasesService类来处理它。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="ab fe cl kk"><img src="../Images/36842ea4b1a7d07a0277444e0fa71938.png" data-original-src="https://miro.medium.com/v2/0*6B91a25LYLipijWx"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">由Kutan Ural在Unsplash上拍摄的照片</figcaption></figure><h2 id="659d" class="lx km hi bd kn ly lz ma kr mb mc md kv jx me mf kx kb mg mh kz kf mi mj lb mk bi translated">序列化程序类</h2><p id="2435" class="pw-post-body-paragraph jo jp hi jq b jr ld ij jt ju le im jw jx lf jz ka kb lg kd ke kf lh kh ki kj hb bi translated">不幸的是，这个代码还没有准备好工作。</p><p id="10d8" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">原因是PHP不能用它的标准序列化器来序列化它。</p><pre class="iy iz ja jb fd ml mm mn bn mo mp bi"><span id="cba6" class="mq km hi mm b be mr ms l mt mu">Could not decode message using PHP serialization {...}</span></pre><p id="2263" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">为了解决这个问题，我们需要创建自己的序列化类。</p><p id="8616" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">此类必须具有MessageSerializerInterface，并包含2个方法:</p><p id="4e20" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">第一个将从传入的Rabbit消息中获取消息体和消息头，并创建一个我们的应用程序可以读取的信封。</p><p id="cdaa" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">后者使用Envelope的这个实例来获取消息，并以可用的格式返回一个包含数据的数组。</p><pre class="iy iz ja jb fd ml mm mn bn mo mp bi"><span id="8b8c" class="mq km hi mm b be mr ms l mt mu">namespace App\Serializer;<br/> <br/>use App\Message\PurchasesNotification;<br/>use Symfony\Component\Messenger\Envelope;<br/>use Symfony\Component\Messenger\Exception\MessageDecodingFailedException;<br/>use Symfony\Component\Messenger\Transport\Serialization\SerializerInterface as MessageSerializerInterface;<br/>use Symfony\Component\Serializer\SerializerInterface;<br/> <br/>class ExternalMessageSerializer implements MessageSerializerInterface<br/>{<br/>    public function __construct(private SerializerInterface $serializer)<br/>    {}<br/>     <br/>    public function decode(array $encodedEnvelope): Envelope<br/>    {<br/>        $body = $encodedEnvelope['body'];<br/>        $headers = $encodedEnvelope['headers'];<br/>         <br/>        try {<br/>            $message = $this---&gt;serializer-&gt;deserialize($body, PurchasesNotification::class, 'json');<br/>             <br/>        } catch (\Throwable $throwable) {<br/>            throw new MessageDecodingFailedException($throwable-&gt;getMessage());<br/>        }<br/>         <br/>        $stamps = [];<br/>        if (!empty($headers['stamps'])) {<br/>            $stamps = unserialize($headers['stamps']);<br/>        }<br/>         <br/>        return new Envelope($message, $stamps);<br/>    }<br/> <br/> <br/>    public function encode(Envelope $envelope): array<br/>    {<br/>        $message = $envelope-&gt;getMessage();<br/>        $stamps = $envelope-&gt;all();<br/>         <br/>        if ($message instanceof PurchasesNotification) {<br/>            $data = [<br/>                'order_id' =&gt; $message-&gt;getOrderId()<br/>            ];<br/>        } else {<br/>            throw new \Exception(sprintf('Serializer does not support message of type %d.', $message::class));<br/>        }<br/>        return [<br/>            'body' =&gt; json_encode($data),<br/>            'headers' =&gt; [<br/>                'stamps' =&gt; serialize($stamps)<br/>            ]<br/>        ];<br/>    }<br/>}</span></pre><h2 id="abbe" class="lx km hi bd kn ly lz ma kr mb mc md kv jx me mf kx kb mg mh kz kf mi mj lb mk bi translated">交通工具</h2><p id="2a60" class="pw-post-body-paragraph jo jp hi jq b jr ld ij jt ju le im jw jx lf jz ka kb lg kd ke kf lh kh ki kj hb bi translated">传输由RabbitMQ的配置组成。</p><p id="82ac" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们告诉Symfony如何处理传入的消息，以及一旦该消息成为我们可以在系统中管理的类的实例时该做什么。</p><p id="a5b7" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">Symfony还不知道如何得到这个消息。</p><p id="4826" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">简而言之，我们需要告诉它RabbitMQ存在，并且它准备好发送消息。</p><p id="91f0" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们这样做的方法是通过<code class="du mv mw mx mm b">config/packages</code>目录中的messenger.yaml文件。</p><pre class="iy iz ja jb fd ml mm mn bn mo mp bi"><span id="f0c1" class="mq km hi mm b be mr ms l mt mu">framework:<br/>  messenger:<br/>    serializer:<br/>      default_serializer: App\Serializer\ExternalMessageSerializer<br/>       <br/>    transports:<br/>      external_messages: '%env(MESSENGER_TRANSPORT_DSN)%/queue_order'<br/>      serializer: App\Serializer\ExternalMessageSerializer<br/>     <br/>    routing:<br/>      'App\Message\PurchasesNotification': external_messages</span></pre><p id="536a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在，Symfony知道一个带有该DNS的外部消息正在等待它。</p><p id="a8c2" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><code class="du mv mw mx mm b">MESSENGER_TRANSPORT_DSN</code>环境变量如下所示。</p><p id="ac05" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><code class="du mv mw mx mm b">MESSENGER_TRANSPORT_DSN=amqp://guest:guest@rabbit:5672/%2f</code></p><p id="19d9" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">Symfony现在也知道，在信息到达后，它必须使用我们定制的<code class="du mv mw mx mm b">ExternalMessageSerializer</code>来翻译它。</p><p id="6ffe" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">并且消息的格式与<code class="du mv mw mx mm b">PurchasesNotification</code>类的格式相同。</p><p id="349d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">从这里我们可以添加更多的信息，但是对于这篇基础文章，我宁愿保持简单。</p><h2 id="67ec" class="lx km hi bd kn ly lz ma kr mb mc md kv jx me mf kx kb mg mh kz kf mi mj lb mk bi translated">听信息</h2><p id="8754" class="pw-post-body-paragraph jo jp hi jq b jr ld ij jt ju le im jw jx lf jz ka kb lg kd ke kf lh kh ki kj hb bi translated">既然拼图的所有部分都已完成，我们就可以运行监听RabbitMQ的命令了。</p><p id="22a8" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">假设我们的传输名称是external_messages，这就是我们需要消费的内容。</p><p id="d13d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">从终端，cd到您的项目的根目录，并键入以下命令:</p><p id="317d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><code class="du mv mw mx mm b">bin/console messenger:consume external_messages</code></p><p id="c7f8" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">一切都应该成功的。</p><p id="0545" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">您的消息应该已经从代理队列中消失。</p><p id="e51b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">事实上，服务已经处理了它们。</p><h1 id="f2ce" class="kl km hi bd kn ko kp kq kr ks kt ku kv io kw ip kx ir ky is kz iu la iv lb lc bi translated">结论</h1><p id="9556" class="pw-post-body-paragraph jo jp hi jq b jr ld ij jt ju le im jw jx lf jz ka kb lg kd ke kf lh kh ki kj hb bi translated">您已经看到了如何让Symfony应用程序从消息代理接收消息。</p><p id="aabf" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">事件驱动架构在数据的安全性和可靠性方面有很多优点。</p><p id="4d67" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">而且使用这个PHP框架也很容易到位。</p><p id="f5dc" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">毕竟，我们只需要创建或更新4个文件。</p><p id="e83b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">你曾经在你的应用程序中使用过事件驱动架构吗？</p><p id="b280" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">如果你想了解更多关于这个主题和其他PHP文章，请点击本页的按钮</p></div><div class="ab cl my mz gp na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="hb hc hd he hf"><p id="2139" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><em class="li">最初发布于</em><a class="ae jn" href="https://anastasionico.uk/blog/consume-rabbitmq-messages-with-symfony-messenger" rel="noopener ugc nofollow" target="_blank"><em class="li">https://anastasionico . uk</em></a><em class="li">。</em></p></div></div>    
</body>
</html>