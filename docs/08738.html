<html>
<head>
<title>N + 1 Queries Problem (A Django example)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">N + 1查询问题(Django示例)</h1>
<blockquote>原文：<a href="https://medium.com/codex/n-1-queries-problem-a-django-example-fd57e3a1761e?source=collection_archive---------4-----------------------#2022-08-30">https://medium.com/codex/n-1-queries-problem-a-django-example-fd57e3a1761e?source=collection_archive---------4-----------------------#2022-08-30</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="90fe" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">严重的性能问题。</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/f8c18b0e5f1350c4122f4beb1d4c6afd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*geEUTANhEQ14I8euv60rSA.jpeg"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">摘自马库斯·温克勒的《Unsplash》</figcaption></figure><p id="4793" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">在这篇文章中，我们将学习N + 1查询问题，它是什么以及如何解决它。</p><h1 id="3433" class="kj kk hi bd kl km kn ko kp kq kr ks kt io ku ip kv ir kw is kx iu ky iv kz la bi translated"><strong class="ak">什么是N + 1查询问题？</strong></h1><p id="fc05" class="pw-post-body-paragraph jn jo hi jp b jq lb ij js jt lc im jv jw ld jy jz ka le kc kd ke lf kg kh ki hb bi translated">简而言之，N + 1查询问题是一个性能反模式，它发生在针对前一个查询的每个结果执行查询时。这里是你从第一个查询中得到的每个结果的查询次数。这意味着如果我们执行一个查询，得到200个结果，那么N + 1 = 201个查询。</p><p id="e756" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">让我们看一个例子来熟悉这个问题。假设我们有这样的代码:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lg lh l"/></div></figure><p id="0ed9" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">在这个简单的例子中，我们有posts QuerySet和一个for循环，该循环遍历它并打印每篇文章的标题和作者。通过查看代码，您会发现我们有一个Post模型和一个Author模型。这告诉您author属性是一个外键。</p><p id="404f" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">让我们看看我们的代码执行了多少查询:</p><p id="4bb2" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">首先，我们已经创建了<strong class="jp hj"> Post </strong> QuerySet，所以到目前为止，我们已经执行了0个查询。为什么？因为QuerySets很懒。我引用Django的文件:</p><blockquote class="li"><p id="9b5f" class="lj lk hi bd ll lm ln lo lp lq lr ki dx translated"><em class="ls">“查询集是懒惰的——创建</em> <code class="du lt lu lv lw b"><em class="ls">QuerySet</em></code> <em class="ls">的行为不涉及任何数据库活动。您可以整天将过滤器堆叠在一起，Django不会真正运行查询，直到对</em> <code class="du lt lu lv lw b"><em class="ls">QuerySet</em></code> <em class="ls">求值。”</em></p></blockquote><p id="0525" class="pw-post-body-paragraph jn jo hi jp b jq lx ij js jt ly im jv jw lz jy jz ka ma kc kd ke mb kg kh ki hb bi translated">您可以在此阅读更多关于此表格的信息<a class="ae mc" href="https://docs.djangoproject.com/en/4.1/topics/db/queries/#querysets-are-lazy" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="b9db" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">然后，我们对帖子进行迭代，这将导致QuerySet评估并获取其结果。现在，我们有一个查询。</p><p id="f0cb" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">之后，我们打印与文章对应的标题和作者。由于标题是文章本身的一个字段，我们将没有额外的查询，因为它已经在第一个查询中被获取。但是作者呢？我们记得它是一个外键，所以Django没有获取它。因此，Django将通过执行另一个查询来获取给定author_id的相应名称(显然，author模型包含一个名称字段)，从而做额外的工作。</p><p id="12bd" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">到目前为止，我们已经执行了<strong class="jp hj"> 1个</strong>查询来获取文章，执行了<strong class="jp hj"> N个</strong>查询来获取作者。<strong class="jp hj"> N </strong>是岗位数量。</p><p id="c080" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">想象一下，我们有100万个帖子😆。</p><h1 id="faee" class="kj kk hi bd kl km kn ko kp kq kr ks kt io ku ip kv ir kw is kx iu ky iv kz la bi translated">如何解决这个问题？</h1><p id="60f5" class="pw-post-body-paragraph jn jo hi jp b jq lb ij js jt lc im jv jw ld jy jz ka le kc kd ke lf kg kh ki hb bi translated"><strong class="jp hj"> select_related() </strong>和<strong class="jp hj"> prefetch_related() </strong>是两个QuerySet方法，提供了解决N+1查询问题的解决方案。</p><p id="c8e1" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><a class="ae mc" href="https://docs.djangoproject.com/en/4.1/ref/models/querysets/#django.db.models.query.QuerySet.select_related" rel="noopener ugc nofollow" target="_blank"> <strong class="jp hj"> select_related() </strong> </a>在执行查询时，返回一个选择附加相关对象数据的查询集。使用此方法后，我们之前的代码将如下所示:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lg lh l"/></div></figure><p id="1187" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">现在我们只有<strong class="jp hj"> 1 </strong>查询来选择文章及其相关作者。</p><p id="76f9" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><a class="ae mc" href="https://docs.djangoproject.com/en/4.1/ref/models/querysets/#django.db.models.query.QuerySet.prefetch_related" rel="noopener ugc nofollow" target="_blank"><strong class="jp hj">prefetch _ related</strong></a><strong class="jp hj">()</strong>返回一个QuerySet，它将在单个批处理中自动检索每个指定查找的相关对象。现在，代码将如下所示:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lg lh l"/></div></figure><p id="c0e4" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">这两种方法的区别在于<strong class="jp hj"> select_related() </strong>创建一个SQL连接，并在select语句中包含相关对象数据。它只适用于外键和一对一的关系。另一方面，<strong class="jp hj"> prefetch_related() </strong>对每个关系进行单独的查找，并使用Python执行连接。这使我们能够预取各种关系对象，它们是:<em class="md">多对多、多对一、外键和一对一关系。</em></p><p id="cee1" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">有一些工具可以让你发现N + 1个查询问题，但是我不会在这篇短文中讨论它们。</p><p id="3857" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">感谢你阅读这篇文章，❤</p><p id="3252" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">在<a class="ae mc" href="https://www.linkedin.com/in/younes-belouche-641bb3197/" rel="noopener ugc nofollow" target="_blank"> Linkedin </a>、<a class="ae mc" href="https://www.instagram.com/younes_belouche/" rel="noopener ugc nofollow" target="_blank"> Instagram </a>和<a class="ae mc" href="https://github.com/dombroks" rel="noopener ugc nofollow" target="_blank"> Github </a>上和我联系。</p></div></div>    
</body>
</html>