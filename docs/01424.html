<html>
<head>
<title>Getting Started with PostgreSQL Set Operators</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">PostgreSQL集合运算符入门</h1>
<blockquote>原文：<a href="https://medium.com/codex/getting-started-with-postgresql-set-operators-a4474de17523?source=collection_archive---------8-----------------------#2021-04-27">https://medium.com/codex/getting-started-with-postgresql-set-operators-a4474de17523?source=collection_archive---------8-----------------------#2021-04-27</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/74d9536a57dc53a962a249c522e28dad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Qg1XsIMiDX_pZr0JX0yXRQ.png"/></div></div></figure><p id="5bb5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Postgres提供了集合操作符，使得从数据库中查询和过滤搜索结果变得容易。集合运算符用于连接两个或多个SELECT语句的结果。这些运算符是UNION、UNION ALL、INTERSECT和EXCEPT——每个运算符都可以用于跨多个表构建查询，并筛选您需要的特定数据。</p><p id="7670" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了返回两个SELECT语句的组合结果，我们使用并集运算符。该操作符从查询的结果中删除所有重复的结果——每个重复的结果只列出一行。为了检查这种行为，可以使用UNION ALL集合操作符，因为它在最终结果中保留了重复项。INTERSECT集合运算符只列出两个SELECT查询共享的记录，相反，EXCEPT集合运算符从第二个SELECT查询中删除结果。因此，INTERSECT和EXCEPT集合运算符用于产生不重复的结果。</p><p id="2c80" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所有集合操作符最初共享相同的优先级(除了INTERSECT，我们将在后面讨论它)。因为括号的优先级高于悬空运算符，所以它们会导致顺序不同。</p><blockquote class="jo jp jq"><p id="5887" class="iq ir jr is b it iu iv iw ix iy iz ja js jc jd je jt jg jh ji ju jk jl jm jn hb bi translated"><strong class="is hj">注意— </strong> <br/>所有使用集合运算符的SELECT语句必须选择相同数量的列。显示中使用的列是从第一个查询中获得的。</p></blockquote><p id="abf0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">列列表数据类型必须可以被Postgres隐式转换。如果查询中的相应列属于不同的数据类型，Postgres不会执行隐式类型转换。如果第一个查询中的列是INT类型的，而第二个查询中的对应列是CHAR类型的，Postgres将<strong class="is hj">而不是</strong>执行隐式转换——相反，它将引发类型错误。</p><p id="310b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了对结果集进行排序，使用了位置排序。集合运算符不允许对单个结果集进行排序。在查询结束时，ORDER BY只能出现一次。</p><p id="b114" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">UNION和INTERSECT运算符中查询的顺序并不重要，也不会改变最终结果——UNION和INTERSECT运算符是可交换的。</p><p id="5e18" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">与UNION运算符相比，UNION ALL具有更好的性能，因为在筛选重复项和对结果进行排序时不使用资源。</p><ul class=""><li id="a349" class="jv jw hi is b it iu ix iy jb jx jf jy jj jz jn ka kb kc kd bi translated">可以使用集合运算符作为子查询的一部分。</li><li id="d51c" class="jv jw hi is b it ke ix kf jb kg jf kh jj ki jn ka kb kc kd bi translated">不能在包含表集合表达式的SELECT语句中使用集合运算符。</li></ul><h2 id="9def" class="kj kk hi bd kl km kn ko kp kq kr ks kt jb ku kv kw jf kx ky kz jj la lb lc ld bi translated">创建表格</h2><p id="8235" class="pw-post-body-paragraph iq ir hi is b it le iv iw ix lf iz ja jb lg jd je jf lh jh ji jj li jl jm jn hb bi translated">在我们继续研究集合运算符之前，我们需要创建将在整个教程中使用的表:</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="66f3" class="kj kk hi lo b fi ls lt l lu lv">DROP TABLE IF EXISTS top_rated_films;<br/><br/>CREATE TABLE top_rated_films(<br/>title VARCHAR NOT NULL,<br/>release_year SMALLINT);<br/><br/>DROP TABLE IF EXISTS most_popular_films;<br/>CREATE TABLE most_popular_films(<br/>title VARCHAR NOT NULL,<br/>release_year SMALLINT);<br/><br/>INSERT INTO top_rated_films(title, release_year)<br/>VALUES<br/>('Fast and furious 7', 2011),<br/>('The redemption', 2015),<br/>('Shooter', 2017);<br/><br/>INSERT INTO most_popular_films(title, release_year)<br/>VALUES<br/>('American snipper', 2015),<br/>('Doulou continent',2018),<br/>('Outpost',2019),<br/>('Shooter', 2017);</span></pre><figure class="lj lk ll lm fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lw"><img src="../Images/8a8be43632de36e432c90c9e2abf0cb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*qkiL0psa3bzVqLUI.png"/></div></div></figure><h2 id="7a41" class="kj kk hi bd kl km kn ko kp kq kr ks kt jb ku kv kw jf kx ky kz jj la lb lc ld bi translated">联盟</h2><p id="0c19" class="pw-post-body-paragraph iq ir hi is b it le iv iw ix lf iz ja jb lg jd je jf lh jh ji jj li jl jm jn hb bi translated">Postgres显示删除重复值后所有复合选择查询的组合结果，当UNION运算符连接多个选择查询时，结果按升序排序:</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="9e8e" class="kj kk hi lo b fi ls lt l lu lv">SELECT * FROM top_rated_films<br/><br/>UNION<br/><br/>SELECT * FROM most_popular_films</span></pre><figure class="lj lk ll lm fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lx"><img src="../Images/8e4fc3bdebeeaa38f6875723c70171d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*6kgr0shAetZ5qltm.png"/></div></div></figure><blockquote class="jo jp jq"><p id="f7e9" class="iq ir jr is b it iu iv iw ix iy iz ja js jc jd je jt jg jh ji ju jk jl jm jn hb bi translated"><strong class="is hj">注意— </strong> <br/>选择的列必须是兼容的数据类型，否则Postgres会抛出类型错误:</p></blockquote><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="4437" class="kj kk hi lo b fi ls lt l lu lv">SELECT title FROM top_rated_films<br/><br/>UNION<br/><br/>SELECT release_year FROM most_popular_films<br/><br/>//error<br/>UNION types character varying and smallint cannot be matched</span></pre><h2 id="1bee" class="kj kk hi bd kl km kn ko kp kq kr ks kt jb ku kv kw jf kx ky kz jj la lb lc ld bi translated">联合所有</h2><p id="d05a" class="pw-post-body-paragraph iq ir hi is b it le iv iw ix lf iz ja jb lg jd je jf lh jh ji jj li jl jm jn hb bi translated">UNION和UNION ALL运算符类似，不同之处在于UNION ALL返回的结果集不删除重复项，也不对数据进行排序。</p><p id="7b9f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">检查下面联合部分中的查询。请务必注意在没有排序和删除重复项的情况下生成的输出中的差异:</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="85c2" class="kj kk hi lo b fi ls lt l lu lv">SELECT * FROM top_rated_films<br/><br/>UNION ALL<br/><br/>SELECT * FROM most_popular_films</span></pre><figure class="lj lk ll lm fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ly"><img src="../Images/70f221edf484e98213104cb260fb212d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*vT_-OrxvC8CLuBLa.png"/></div></div></figure><h2 id="ff73" class="kj kk hi bd kl km kn ko kp kq kr ks kt jb ku kv kw jf kx ky kz jj la lb lc ld bi translated">横断</h2><p id="8e1b" class="pw-post-body-paragraph iq ir hi is b it le iv iw ix lf iz ja jb lg jd je jf lh jh ji jj li jl jm jn hb bi translated">显示两个select语句中没有重复的公共行，并且数据按排序顺序排列；使用INTERSECT运算符。射手电影被返回，因为它在最高评级和最受欢迎的电影表中都可用。</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="dcce" class="kj kk hi lo b fi ls lt l lu lv">SELECT *<br/>FROM most_popular_films <br/>INTERSECT<br/>SELECT *<br/>FROM top_rated_films;</span></pre><figure class="lj lk ll lm fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lz"><img src="../Images/95192fe245e7196b86224fb879a00884.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*vqo6X5u6cZbcqyPz.png"/></div></div></figure><h2 id="5c86" class="kj kk hi bd kl km kn ko kp kq kr ks kt jb ku kv kw jf kx ky kz jj la lb lc ld bi translated">除...之外</h2><p id="6a98" class="pw-post-body-paragraph iq ir hi is b it le iv iw ix lf iz ja jb lg jd je jf lh jh ji jj li jl jm jn hb bi translated">为了显示在第一个查询中存在但在第二个查询中不存在的行，使用了EXCEPT运算符。它不返回重复项，默认情况下，数据按升序排列。</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="3d50" class="kj kk hi lo b fi ls lt l lu lv">SELECT * FROM most_popular_films<br/>EXCEPT<br/>SELECT * FROM top_rated_films</span></pre><figure class="lj lk ll lm fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ma"><img src="../Images/9a2a9f77f828a40fc6cbe669426a9a47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*wo_CXLBTO9nEegj4.png"/></div></div></figure><h2 id="855c" class="kj kk hi bd kl km kn ko kp kq kr ks kt jb ku kv kw jf kx ky kz jj la lb lc ld bi translated">在集合运算中使用ORDER BY子句</h2><p id="5f68" class="pw-post-body-paragraph iq ir hi is b it le iv iw ix lf iz ja jb lg jd je jf lh jh ji jj li jl jm jn hb bi translated">在包含复合SELECT语句的查询中，ORDER BY子句只能在末尾出现一次。这表明单个SELECT语句<strong class="is hj">不能</strong>包含ORDER BY子句。排序仅基于出现在第一个选择查询中的列。建议使用列位置对复合查询进行排序。</p><p id="d623" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下面的查询对两个部门的结果进行排序，并将它们统一起来:</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="2e64" class="kj kk hi lo b fi ls lt l lu lv">SELECT * FROM most_popular_films<br/>UNION ALL<br/>SELECT * FROM top_rated_films<br/>ORDER BY title;</span></pre><figure class="lj lk ll lm fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mb"><img src="../Images/660b411605034fe44c9baaa6a06f0ed3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*YwTgTyYGly1LnXy0.png"/></div></div></figure><h2 id="6fa3" class="kj kk hi bd kl km kn ko kp kq kr ks kt jb ku kv kw jf kx ky kz jj la lb lc ld bi translated">结论</h2><p id="ecd9" class="pw-post-body-paragraph iq ir hi is b it le iv iw ix lf iz ja jb lg jd je jf lh jh ji jj li jl jm jn hb bi translated">现在您已经学会了如何使用Postgres集合运算符，您可以使用它们来优化数据库查询，以检索和比较不同列中的数据，从而简化数据检索过程。</p></div></div>    
</body>
</html>