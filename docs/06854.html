<html>
<head>
<title>Binary Search in 400 Words</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">二分搜索法400字</h1>
<blockquote>原文：<a href="https://medium.com/codex/binary-search-in-400-words-726f1afe3e82?source=collection_archive---------19-----------------------#2022-05-16">https://medium.com/codex/binary-search-in-400-words-726f1afe3e82?source=collection_archive---------19-----------------------#2022-05-16</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/2b0d5e9bdf5c93870f02948e2e18c063.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s1AR98tEzrQ5NDeswJ_u-g.jpeg"/></div></div></figure><p id="1892" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">二分搜索法是<strong class="is hj">一种用于排序数组</strong>的搜索算法，包括连续将数组一分为二。该算法大大快于普通的线性搜索，将时间复杂度从O(n)降低到<strong class="is hj"> O(log n) </strong>。</p><p id="37af" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这一切意味着什么？</p><p id="0306" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">假设您有一个排序的数字数组，类似于[1，3，4，6，7，8，9]，您想检查数字7是否在数组中。你将如何实现它？</p><p id="9b6d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最简单的方法就是遍历一次数组，对于每个元素，检查它是否等于7。如果我们已经到达数组的末尾，并且没有元素是相等的，那么我们将知道数组中不存在7。这种方法叫做<strong class="is hj">线性搜索。</strong></p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es jo"><img src="../Images/d1b622c1f756fb7be0facf64750fe845.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vtJEE6zjVuN7OQvS_x2x4Q.png"/></div></div><figcaption class="jt ju et er es jv jw bd b be z dx translated">线性搜索</figcaption></figure><p id="759e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">线性搜索理解起来非常直观，但是对于在大型数据集上进行搜索来说，它的效率可能相当低。如果我们的数组不只是七个数字长，而是由数百万或数十亿个元素组成(在大型数据库时代很常见)，并且我们必须执行数千次搜索，那么线性搜索将会非常慢。</p><p id="183a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">那么我们如何解决这个问题呢？</p><p id="c28c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们可以利用数组的一个重要属性:<strong class="is hj">它被排序的事实</strong>。有序数组是特殊的，因为无论你在一个有序数组中的什么位置，所有较小的数字总是在一边，所有较大的数字总是在一边。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es jx"><img src="../Images/760eed287164f846499b3528a63acfd1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oSwx1CEtG-zDLV-pJhiBkg.png"/></div></div></figure><p id="db1d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果我们简单地从询问我们正在寻找的数字是大于还是小于在我们排序的数组中间的数字开始(如果它等于我们已经找到的第一次尝试！)，我们可以<strong class="is hj">立即丢弃数组中数字不能在</strong>的那一半。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es jy"><img src="../Images/b386fe5905094ea8c55be350a3f84159.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SKovW824z_UrzAFAF_NaPw.png"/></div></div></figure><p id="cc8a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后我们可以重复这个过程，不断地将子数组的长度减半，越来越接近我们要寻找的数字。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es jy"><img src="../Images/3dad1642a2f1c5edeb1d5a0e5f2807f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lkWKBdm3OQnYSafjP_DqyA.png"/></div></div></figure><p id="4bd6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当“中间的数字”等于我们要搜索的数字(数字在数组中)或者当我们已经丢弃了整个数组(数字不在数组中)时，我们停止搜索。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es jz"><img src="../Images/94136c128e74b2d9027263708ee33f68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3mUI3bWetTvDyQiXCwR-Qw.png"/></div></div></figure><p id="58ab" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，因为我们可以在每次迭代中丢弃数组的一半，所以最多需要迭代次数排序数组长度的log₂，这意味着<strong class="is hj">在十亿个数字的数组中搜索一个元素最多需要30次操作</strong>(相比之下，使用线性搜索需要十亿次)。这就是二分搜索法的美丽之处。</p><h1 id="f4fe" class="kb kc hi bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">其他资源:</h1><ul class=""><li id="0eb3" class="kz la hi is b it lb ix lc jb ld jf le jj lf jn lg lh li lj bi translated">* <a class="ae lk" href="https://www.youtube.com/watch?v=MFhxShGxHWc" rel="noopener ugc nofollow" target="_blank">火船二分搜索法视频</a> *</li><li id="da83" class="kz la hi is b it ll ix lm jb ln jf lo jj lp jn lg lh li lj bi translated"><a class="ae lk" href="https://www.geeksforgeeks.org/binary-search/" rel="noopener ugc nofollow" target="_blank"> GeeksforGeeks二分搜索法文章</a></li><li id="dc06" class="kz la hi is b it ll ix lm jb ln jf lo jj lp jn lg lh li lj bi translated"><a class="ae lk" href="https://www.youtube.com/watch?v=6ysjqCUv3K4" rel="noopener ugc nofollow" target="_blank"> CS道场二分搜索法视频</a></li><li id="20e6" class="kz la hi is b it ll ix lm jb ln jf lo jj lp jn lg lh li lj bi translated"><a class="ae lk" href="https://www.khanacademy.org/computing/computer-science/algorithms/binary-search/a/binary-search" rel="noopener ugc nofollow" target="_blank">可汗学院二分搜索法课程</a></li></ul></div></div>    
</body>
</html>