<html>
<head>
<title>Will Fill Factor solves index fragmentation in SQL Server?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">填充因子会解决SQL Server中的索引碎片问题吗？</h1>
<blockquote>原文：<a href="https://medium.com/codex/will-fill-factor-solves-index-fragmentation-in-sql-server-421a1c4fa55e?source=collection_archive---------18-----------------------#2021-07-25">https://medium.com/codex/will-fill-factor-solves-index-fragmentation-in-sql-server-421a1c4fa55e?source=collection_archive---------18-----------------------#2021-07-25</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="bb95" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">碎片是指索引页中的空白空间以及索引页的逻辑和物理顺序的差异。请阅读我之前的<a class="ae jd" href="https://ganeshkamalakannan.medium.com/index-fragmentation-in-sql-server-83b0f8c5708e" rel="noopener">帖子</a>来了解索引碎片以及它是如何发生的。</p><p id="4002" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">填充因子是解决索引碎片的建议之一。我想分享我在尝试解决索引碎片时使用填充因子的经验。</p><p id="4e74" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">填充因子是我们可以在数据库级别或每个索引级别定义的索引属性之一。基本上，它是一个百分比，告诉SQL Server一个叶级页面可以用多少百分比的数据填充。</p><p id="6cd7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">数据库级默认值为0，这意味着SQL Server可以填充8KB的最大页面大小。假设我们将其值设置为90%,那么SQL Server将只占用索引叶级别中每个页面的页面大小的90%。</p><p id="1819" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们以用于索引碎片的同一个例子来理解填充因子。有一个电话目录表，如图1所示。Ashlee Wilson刚搬到这个城市，她的详细信息必须插入第1页Arthi Rajan和Asley Bernick之间。但是第1页上没有空间了，除了最后一页(第9页)索引中的所有页面都满了。SQL Server将添加一个新页面，并将页面1的50%移动到页面10，这称为页面拆分。阿什莉·威尔逊将被添加到第1页。这会导致电话目录索引出现碎片。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/867e5e64db9985a0c54569d39cce0397.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*rt9sNd3SlSTRu73M.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">图1:电话目录索引</figcaption></figure><p id="c351" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">类似地，当Arthi Rajan得到另一部电话时，SQL Server必须添加另一个页面，将第1页的50%移动到第10页，并容纳第1页中的更改。这也会导致索引碎片。</p><p id="ff80" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们把这个索引的填充因子改为75%，电话目录现在看起来像图2。所有页面仅填充了75%,数据分布在12个页面上。无论Arthi Rajan获得额外的电话还是Ashlee Wilson搬到城市，第1页都有空间，因此不需要拆分第1页数据。这避免了索引上的碎片。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es ju"><img src="../Images/a2f37148d82426d2e48eae4a9e8141e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OlFFTeZJHCHqAg4B3qB72w.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">图2:填充系数为75%的电话目录索引</figcaption></figure><p id="cfd8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以前，要从该索引中读取所有数据，SQL Server必须读取9页，但在填充因子为75%的情况下，SQL Server必须读取额外的3页，这增加了查询的IO成本。同样，它会占用更多的内存。</p><p id="85a4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用100%填充因子，当无序插入发生或数据更新扩展现有行数据时，会发生页拆分，这会降低数据插入或更新的性能。从磁盘读取数据时，外部碎片也可能会降低读取性能。</p><p id="8474" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">另一方面，较小的填充因子会增加页面空间的浪费，并使内部碎片永久化。由于每页上剩余的额外可用空间会占用更多的磁盘和内存空间，索引的总页数会增加。当从磁盘和内存中读取数据时，这会影响读取性能。像stats update、backup和index rebuild \ index reorganize这样的维护任务需要处理更多的页面，这增加了维护时间。</p><p id="c365" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们讨论几个索引类型，看看我们应该对碎片有多担心，以及我们是否需要将填充因子作为一个选项来考虑。当聚集索引键是一个标识时，无序插入不会发生，外部碎片也不会由于插入而发生。如果表没有很多可变长度的列，换句话说，由于数据更新而导致的行扩展的可能性不大，由于更新而导致的碎片也将是最小的，如果我们有像索引重组和重建这样的常规索引维护策略，这不会降低读取性能。</p><p id="930e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当聚集索引键是一个像GUID这样的随机值时，将会发生无序插入，这会在页面填满时导致碎片。如果表中有许多可变长度的列，并且对现有行的数据更新很常见，那么它会扩展行大小，从而导致页拆分\索引碎片，在这种情况下，最好为将来的扩展留出一些空间。</p><p id="a39a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">选择填充因子时，我们应该小心百分比。正确的百分比没有硬性规定。这取决于索引类型以及数据更新会导致多少碎片，因此应该通过适当的测试在不同的百分比之间进行调整来确定。</p><p id="1a34" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们以这种方式结束这篇文章，填充因子将在一定程度上解决索引碎片问题，但它也有副作用。只有从磁盘读取数据时，外部碎片才会降低读取性能。从磁盘或内存中读取数据时，索引页中额外的可用空间会影响性能。如果我们试图回答“填充因子会解决索引碎片并提高性能吗？”最好的答案可能是，“这要看情况！”。</p></div></div>    
</body>
</html>