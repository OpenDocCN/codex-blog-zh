<html>
<head>
<title>Separating Monolith Laravel + VueJS to Backend and Frontend with Webpack5</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Webpack5将Monolith Laravel + VueJS分隔为后端和前端</h1>
<blockquote>原文：<a href="https://medium.com/codex/separating-monolith-laravel-vuejs-to-backend-and-frontend-with-webpack5-e34956b936d1?source=collection_archive---------0-----------------------#2022-05-04">https://medium.com/codex/separating-monolith-laravel-vuejs-to-backend-and-frontend-with-webpack5-e34956b936d1?source=collection_archive---------0-----------------------#2022-05-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/7629faf988b4eb93236751402b591867.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cf0-o8wAHSSV31xLyxXGSQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">从整体到后端—前端的去耦</figcaption></figure><p id="fda8" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi js translated"><span class="l jt ju jv bm jw jx jy jz ka di">我们</span>在<a class="ae kb" href="https://trengo.com" rel="noopener ugc nofollow" target="_blank">特伦戈</a>决定将Monolith架构分为后端和前端，我很荣幸这样做。当然这取决于项目的潜力，我相信了解我们如何发现兔子洞以及如何解决它们是很有用的。<br/>我是尼玛，欢迎来到我的博客。</p></div><div class="ab cl kc kd gp ke" role="separator"><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh"/></div><div class="hb hc hd he hf"><h1 id="90b4" class="kj kk hi bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">问题是</h1><p id="cffa" class="pw-post-body-paragraph iu iv hi iw b ix lh iz ja jb li jd je jf lj jh ji jj lk jl jm jn ll jp jq jr hb bi translated">这取决于你和你的团队结构来处理Monolith架构或后端前端或微前端等。我不打算解释利弊，但如果你决定将你的Laravel+Vuejs Monolith分成后端和前端，这将是一篇适合你的好文章。<br/>如果你有一个整体架构，很可能你有一个会在大团队中引起混乱的单一报告。从CI/CD和技术角度来看，拥有单独的存储库将非常有帮助。</p><h1 id="552c" class="kj kk hi bd kl km lm ko kp kq ln ks kt ku lo kw kx ky lp la lb lc lq le lf lg bi translated">解决方法</h1><p id="8686" class="pw-post-body-paragraph iu iv hi iw b ix lh iz ja jb li jd je jf lj jh ji jj lk jl jm jn ll jp jq jr hb bi translated">你会搜索的第一个短语是“<a class="ae kb" href="https://laracasts.com/discuss/channels/laravel/can-i-completely-separate-vuejs-front-end-to-laravel-back-end" rel="noopener ugc nofollow" target="_blank">我能把Vue.js前端和Laravel后端完全分开吗</a>”，答案是“可以”，但是怎么做呢？<br/>我们找到了四种解决方案:<br/>用<strong class="iw hj"> Webpack5 </strong>分离—用Vite分离—用<strong class="iw hj"> Webpack4 </strong>分离—用<strong class="iw hj"> Laravel-mix </strong>本身分离。<br/>这里有利弊，我会解释我们为什么选择Webpack5，但这完全取决于你。</p><h2 id="ad05" class="lr kk hi bd kl ls lt lu kp lv lw lx kt jf ly lz kx jj ma mb lb jn mc md lf me bi translated">拉勒维尔-米克斯</h2><p id="a4e7" class="pw-post-body-paragraph iu iv hi iw b ix lh iz ja jb li jd je jf lj jh ji jj lk jl jm jn ll jp jq jr hb bi translated">当我们不打算使用其中的大部分功能时，用Laravel-mix分离Monolith架构是没有用的。Laravel-Mix是非常强大的，只有当你打算用Laravel开发一个整体应用程序的时候。大量的Webpack配置，这是非常耗时的配置，而且你不能在将来自己将你的Webpack版本从4升级到5或5到6，直到Laravel-Mix给出更新，这意味着你不能用最新的技术更新。</p><h2 id="0975" class="lr kk hi bd kl ls lt lu kp lv lw lx kt jf ly lz kx jj ma mb lb jn mc md lf me bi translated"><strong class="ak">网络包4 </strong></h2><p id="9f60" class="pw-post-body-paragraph iu iv hi iw b ix lh iz ja jb li jd je jf lj jh ji jj lk jl jm jn ll jp jq jr hb bi translated">用Laravel-Mix代替Webpack是一个很好的解决方案，但是用哪个版本呢？正如Webpack所说，如果你想拥有一个可执行的应用程序，请始终尝试使用最新版本。Webpack 4对模块联合等新技术有太多的干扰，sass-loader@11.0.0和vue@2.6.12之间的冲突会抛出this.getOptions()在Webpack 5中处理的错误，等等……如果你关心应用程序更新，我强烈建议选择其他选项。</p><h2 id="bd5d" class="lr kk hi bd kl ls lt lu kp lv lw lx kt jf ly lz kx jj ma mb lb jn mc md lf me bi translated">轻快地</h2><p id="b2ef" class="pw-post-body-paragraph iu iv hi iw b ix lh iz ja jb li jd je jf lj jh ji jj lk jl jm jn ll jp jq jr hb bi translated">也许你听说过<a class="ae kb" href="https://vitejs.dev" rel="noopener ugc nofollow" target="_blank"> Vite </a>，</p><blockquote class="mf mg mh"><p id="d6cd" class="iu iv mi iw b ix iy iz ja jb jc jd je mj jg jh ji mk jk jl jm ml jo jp jq jr hb bi translated">Vite是一个构建工具，旨在为现代web项目提供更快、更精简的开发体验</p></blockquote><p id="f79c" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我对Vite有很好的体验，它帮助我很轻松地配置我的应用程序。但是为什么我们的Vue项目没有选择它呢？</p><blockquote class="mf mg mh"><p id="aacf" class="iu iv mi iw b ix iy iz ja jb jc jd je mj jg jh ji mk jk jl jm ml jo jp jq jr hb bi translated">注意:如果你有一个路线列表。js它将尝试在开发模式下建立所有的路线，取决于你的项目，这将需要很多分钟。</p></blockquote><p id="e091" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">Vite还不成熟，你不能指望它进入生产模式(2022)。你不能否认Vite的性能，但对于遗留代码和结构，你将面临一些更大的问题。如果您想享受它的强大功能，使用动态导入来帮助代码拆分和SplitChunk会是一个很好的技巧。鉴于Vite如此强大，它不适合我们的项目和遗留结构，但如果我想从头开始一个新项目，我肯定会使用Vite。</p><h1 id="32ae" class="kj kk hi bd kl km lm ko kp kq ln ks kt ku lo kw kx ky lp la lb lc lq le lf lg bi translated">网络包5</h1><p id="57a2" class="pw-post-body-paragraph iu iv hi iw b ix lh iz ja jb li jd je jf lj jh ji jj lk jl jm jn ll jp jq jr hb bi translated">令人欣慰的是有各种各样的图书馆可供选择。Webpack 5是基于我们项目的最好的库，这是一个大项目，在Laravel-Mix上有很多配置，需要迁移到新的bundler。<br/>我们不会对PostCss或捆绑router.js有任何问题，当然，Webpack HMR(热模块重新加载)不是很快，因为它使用socket.js使其实时，但我会向您展示它比Laravel-Mix 5快两倍。</p><h1 id="c39e" class="kj kk hi bd kl km lm ko kp kq ln ks kt ku lo kw kx ky lp la lb lc lq le lf lg bi translated">逐步地</h1><p id="3a69" class="pw-post-body-paragraph iu iv hi iw b ix lh iz ja jb li jd je jf lj jh ji jj lk jl jm jn ll jp jq jr hb bi translated">是时候深入代码并找到兔子洞了。首先，我们必须找到所有的挑战，找到解决它们的方法。我会根据我的经验列举一些可能性。</p><h2 id="a817" class="lr kk hi bd kl ls lt lu kp lv lw lx kt jf ly lz kx jj ma mb lb jn mc md lf me bi translated">我正在使用Laravel路线，而不是休息</h2><p id="9998" class="pw-post-body-paragraph iu iv hi iw b ix lh iz ja jb li jd je jf lj jh ji jj lk jl jm jn ll jp jq jr hb bi translated">我强烈建议首先迁移到REST，这是迁移中最重要的部分。例如，我们有一个“/authenticate/login”路由来处理用户登录过程，在这种情况下，最好的方法是将其迁移到“/api/authenticate/login”中，该路由将接受JSON参数并响应JSON。如果您的整个应用程序没有处于REST状态，那么让我们在您的任务管理系统中创建一个带有“critical”标记的重构卡。</p><h2 id="9b30" class="lr kk hi bd kl ls lt lu kp lv lw lx kt jf ly lz kx jj ma mb lb jn mc md lf me bi translated">我有一个“index.blade.php”而不是index.html</h2><p id="b2c8" class="pw-post-body-paragraph iu iv hi iw b ix lh iz ja jb li jd je jf lj jh ji jj lk jl jm jn ll jp jq jr hb bi translated">我们将稍后用Webpack处理它，唯一的事情是将整个文件复制/粘贴到一个新的index.html中，就是这样，让Webpack处理它。</p><h2 id="af3e" class="lr kk hi bd kl ls lt lu kp lv lw lx kt jf ly lz kx jj ma mb lb jn mc md lf me bi translated">如何处理环境？</h2><p id="a578" class="pw-post-body-paragraph iu iv hi iw b ix lh iz ja jb li jd je jf lj jh ji jj lk jl jm jn ll jp jq jr hb bi translated">所有“env”变量将从“import.meta.EnvName”更改为“process.env.EnvName”，这意味着我们必须替换所有变量并创建一个”。env”文件，其中包含所需的变量。</p><h2 id="fa45" class="lr kk hi bd kl ls lt lu kp lv lw lx kt jf ly lz kx jj ma mb lb jn mc md lf me bi translated">“进口”方式呢？</h2><p id="ed32" class="pw-post-body-paragraph iu iv hi iw b ix lh iz ja jb li jd je jf lj jh ji jj lk jl jm jn ll jp jq jr hb bi translated">仅替换“导入(…)”。默认“with”要求(…)。“默认”。</p><h2 id="0eab" class="lr kk hi bd kl ls lt lu kp lv lw lx kt jf ly lz kx jj ma mb lb jn mc md lf me bi translated">我们的代码库会改变吗？</h2><p id="a4c5" class="pw-post-body-paragraph iu iv hi iw b ix lh iz ja jb li jd je jf lj jh ji jj lk jl jm jn ll jp jq jr hb bi translated">当然不是，如果你有一个标准的代码库，你就不会有问题。</p><h1 id="6bb6" class="kj kk hi bd kl km lm ko kp kq ln ks kt ku lo kw kx ky lp la lb lc lq le lf lg bi translated">如何在Vuejs 2上配置Webpack5？</h1><p id="3fe8" class="pw-post-body-paragraph iu iv hi iw b ix lh iz ja jb li jd je jf lj jh ji jj lk jl jm jn ll jp jq jr hb bi translated">这非常简单，我强烈建议将“开发”和“生产”配置分离，这样您就可以更好地控制每个环境配置。这两个环境之间有冲突是很常见的。<br/>让我们从创建一个名为你的应用程序的新目录开始，并创建如下的目录结构:</p><pre class="mm mn mo mp fd mq mr ms mt aw mu bi"><span id="e2b2" class="lr kk hi mr b fi mv mw l mx my">.<br/>|-- README.md<br/>|-- package.json<br/>|-- public<br/>|-- src<br/>-- webpack<br/>    |-- paths.js<br/>    |-- webpack.common.js<br/>    |-- webpack.config.dev.js<br/>    `-- webpack.config.prod.js</span></pre><p id="2666" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">是时候安装依赖项了。</p><pre class="mm mn mo mp fd mq mr ms mt aw mu bi"><span id="c6ae" class="lr kk hi mr b fi mv mw l mx my">npm i -D @webpack-cli/serve clean-webpack-plugin compression-webpack-plugin copy-webpack-plugin css-minimizer-webpack-plugin dotenv-webpack html-webpack-plugin optimize-css-assets-webpack-plugin speed-measure-webpack-plugin terser-webpack-plugin webpack webpack-bundle-analyzer webpack-cli webpack-dev-server webpack-hot-middleware webpack-merge css-loader vue-loader esbuild-loader </span></pre><p id="ee68" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我试着安装了所有的devDependencies，如果其中一些没有安装，我们会继续安装。<br/>现在我们来看看“webpack.common.js”是什么样子的。</p><figure class="mm mn mo mp fd ij"><div class="bz dy l di"><div class="mz na l"/></div></figure><p id="8c8a" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">它太长了，是的，我知道，我不打算解释加载器，因为你可以在Medium或他们的Git库中找到它们，因此，如果有必要，我试图添加注释，但让我们快速回顾一下。</p><p id="1fcd" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj"> SpeedMeasurePlugin </strong>:这个插件将帮助我们测量Webpack的性能。找出哪一个加载程序缺乏性能是非常有用的。我们应该用它来包装我们的配置。</p><p id="fdf5" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">条目:条目应该指向运行Vuejs应用程序的主javascript文件。</p><p id="e2c4" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">提供插件</strong>:</p><blockquote class="mf mg mh"><p id="41ce" class="iu iv mi iw b ix iy iz ja jb jc jd je mj jg jh ji mk jk jl jm ml jo jp jq jr hb bi translated">自动加载模块，而不是到处<code class="du nb nc nd mr b">import</code>或<code class="du nb nc nd mr b">require</code>它们。</p></blockquote><p id="d387" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如果您正在使用一个下划线库，如“lodash”或“Jquery ”,它有一个特殊的语法，对于Webpack来说是不常见的，并且没有导入到文件中，那么您必须在这个插件中提供它们。</p><p id="be87" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这个插件对我们来说非常有用，因为我们有来自“Laravel”的“public”文件夹，在解耦后我们将需要它。如您所知，Laravel-mix已经“公开”连接到“Vuejs”应用程序。因此，在迁移后，没有一个图像或任何资产会正确加载，因为Webpack无法访问“public”文件夹(在文件夹范围之外)，该插件将尝试建立此连接。</p><p id="0c58" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj"> ESBuild </strong>:是时候用ES-build替换babel-loader来加速我们的Webpack构建了。不再解释，我们来看文档:<a class="ae kb" href="https://github.com/privatenumber/esbuild-loader" rel="noopener ugc nofollow" target="_blank">https://github.com/privatenumber/esbuild-loader</a></p><p id="f0d9" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们现在很好，让我们继续发展。它是如此简单。</p><figure class="mm mn mo mp fd ij"><div class="bz dy l di"><div class="mz na l"/></div></figure><p id="1e8f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">因为太简单了，我只想解释一下HotModuleReplacementPlugin和source-map。</p><p id="afab" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">HotModuleReplacementPlugin</strong>:或者HMR是一个插件，当我们在IDE中保存我们的更改时，它会重新加载页面，与其他观察器相关的好处是状态持久性，这意味着每次重新加载后，您的状态都会保持，因为插件只会重新加载特定的和相关的DOM。</p><p id="f084" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj"> devtool </strong>:可能一开始并不是那么清楚。让我们看看Webpack文档中的Devtool是什么。</p><blockquote class="mf mg mh"><p id="da60" class="iu iv mi iw b ix iy iz ja jb jc jd je mj jg jh ji mk jk jl jm ml jo jp jq jr hb bi translated"><code class="du nb nc nd mr b">source-map-loader</code>从所有JavaScript条目中提取现有的源映射。这既包括内嵌的源地图，也包括通过URL链接的源地图。所有的源地图数据都传递给webpack，按照<a class="ae kb" href="https://webpack.js.org/configuration/" rel="noopener ugc nofollow" target="_blank"> webpack.config.js </a>中<code class="du nb nc nd mr b">devtool</code>选项指定的<a class="ae kb" href="https://webpack.js.org/configuration/devtool/" rel="noopener ugc nofollow" target="_blank">源地图样式</a>进行处理。</p></blockquote><p id="9309" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">最常用的是在浏览器中调试代码，源映射还不是可转换的，你可以在其中看到你的Vuejs代码，找到哪个部分有bug。因为它会降低性能，所以最佳实践是只让它处于开发模式。你可以在这里找到不同来源地图的列表:<a class="ae kb" href="https://webpack.js.org/configuration/devtool/" rel="noopener ugc nofollow" target="_blank">https://webpack.js.org/configuration/devtool/</a></p><p id="e611" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我更喜欢使用“内联源代码图”,它会给我足够的细节，并会增加我在开发模式下的构建和重建时间。</p><p id="d19a" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">生产这么刺激？所以我们走吧。</p><figure class="mm mn mo mp fd ij"><div class="bz dy l di"><div class="mz na l"/></div></figure><p id="4699" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">首先，您会看到devtool是假的，在生产中不提供可调试版本是有意义的，因为这将增加包的大小、构建时间，并且客户端也不需要它。</p><p id="a642" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj"> splitChunks </strong>:在优化阶段，我们使用splitChunks，通过将捆绑包分割成独立的模块，<a class="ae kb" href="https://webpack.js.org/plugins/split-chunks-plugin/" rel="noopener ugc nofollow" target="_blank">https://webpack.js.org/plugins/split-chunks-plugin/</a></p><p id="e643" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj"> TerserPlugin </strong>:任何人都知道Terser插件会影响性能，Terser使用了很多算法来尽可能地将javascript代码精简到最精简的版本。<a class="ae kb" href="https://webpack.js.org/plugins/terser-webpack-plugin/" rel="noopener ugc nofollow" target="_blank">https://webpack.js.org/plugins/terser-webpack-plugin/</a></p><p id="1169" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">唯一留下的是paths.js</p><pre class="mm mn mo mp fd mq mr ms mt aw mu bi"><span id="5605" class="lr kk hi mr b fi mv mw l mx my">const paths = require('path')<br/><br/>module.exports = {<br/>// Source files<br/>src: paths.resolve(__dirname, '../src'),<br/><br/>// Production build files<br/>build: paths.resolve(__dirname, '../dist'),<br/><br/>// Static files that get copied to build folder<br/>public: paths.resolve(__dirname, '../public'),<br/>}</span></pre><p id="c8d3" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这太简单了，不需要解释。😄</p><p id="26c9" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">大部分都完成了，让我们修改我们的package.json</p><pre class="mm mn mo mp fd mq mr ms mt aw mu bi"><span id="4e76" class="lr kk hi mr b fi mv mw l mx my">"scripts": {<br/>  "dev": "webpack server --mode=development --config ./webpack/webpack.config.dev.js",<br/>  "build": "webpack --mode=production --config ./webpack/webpack.config.prod.js",<br/>  "serve:dev": "pm2 start ecosystem.config.js --env development",<br/>  "serve:prod": "pm2 start ecosystem.config.js --env production"<br/>},</span></pre><p id="defd" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">很明显，只有我想解释一下“发球:dev和prod”。我更喜欢使用PM2作为我们的过程管理器，如果你不熟悉它，我会强烈建议看看它的文档:<a class="ae kb" href="https://pm2.keymetrics.io/." rel="noopener ugc nofollow" target="_blank">https://pm2.keymetrics.io/.</a>“生态系统.配置. js”是PM2的主要配置文件，用于定义生产或开发的不同行为，你可以通过运行“serve:dev”在本地机器上检查构建的项目，它实际上与生产相同，尽量使开发和生产环境相同以减少错误是非常重要的。</p><p id="b55a" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">生态系统. config.js </strong></p><pre class="mm mn mo mp fd mq mr ms mt aw mu bi"><span id="3395" class="lr kk hi mr b fi mv mw l mx my">module.exports = {<br/>    script: 'serve',<br/>env_development: {<br/>    NODE_ENV: 'development',<br/>    PM2_SERVE_PATH: './dist',<br/>    PM2_SERVE_PORT: 3000,<br/>    PM2_SERVE_SPA: 'true',<br/>},<br/>env_production: {<br/>    NODE_ENV: 'production',<br/>    PM2_SERVE_PATH: './dist',<br/>    PM2_SERVE_PORT: 8080,<br/>    PM2_SERVE_SPA: 'true',<br/>},<br/>deploy: {<br/>        development: {<br/>          host: ['localhost', '127.0.0.1'],<br/>        },<br/>        production: {<br/>          host: ['production.domain', 'production IPAddress'],<br/>        },<br/>    },<br/>};</span></pre><h1 id="8dc9" class="kj kk hi bd kl km lm ko kp kq ln ks kt ku lo kw kx ky lp la lb lc lq le lf lg bi translated">是时候处理数字了</h1><p id="effc" class="pw-post-body-paragraph iu iv hi iw b ix lh iz ja jb li jd je jf lj jh ji jj lk jl jm jn ll jp jq jr hb bi translated">现在是时候用当前的Laravel-mix项目来回顾新Webpack配置的基准了。当然和你的项目有关。这些基准测试与一个有很多文件的大项目有关。</p><p id="9691" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj"> Laravel混音制作时间— 3.30分钟</strong></p><figure class="mm mn mo mp fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ne"><img src="../Images/2f1b349f6ca87f6ccc688c7c3c00f50f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tP7frhYzI6Td2W_4fSBqrA.png"/></div></div></figure><p id="86c5" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj"> Webpack5构建时间— 1.9461分钟</strong></p><figure class="mm mn mo mp fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ne"><img src="../Images/2265ee8ca251834ccf05dd717578678a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pYi-fpVLsVJKo3cRbHpGTQ.png"/></div></div></figure><p id="8aa1" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">你可以看到它几乎快了两倍。但是这不是唯一的基准，我还有另一个有趣的运行测试基准</p><p id="d529" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj"> Laravel-mix — 6.44秒</strong></p><figure class="mm mn mo mp fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ne"><img src="../Images/4c1ba3f707ab3a836137375aafad503e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JQDB7_sfSUHLW-RliVDUcA.png"/></div></div></figure><p id="1f18" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">web pack 5–3.318秒</strong></p><figure class="mm mn mo mp fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ne"><img src="../Images/cc6382496a16a1da5d6b5c1d019c3ac3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g7wV37a1yL5POOGe-FibSQ.png"/></div></div></figure><p id="34e0" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">结果同上。这些变化让我们在特伦戈有了更好的表现。</p><h1 id="6eab" class="kj kk hi bd kl km lm ko kp kq ln ks kt ku lo kw kx ky lp la lb lc lq le lf lg bi translated">结论</h1><p id="65dc" class="pw-post-body-paragraph iu iv hi iw b ix lh iz ja jb li jd je jf lj jh ji jj lk jl jm jn ll jp jq jr hb bi translated">选择最好的模块捆绑器取决于您的项目，没有特定的方法来提高您的项目性能，对于某些项目，Laravel-mix是最好的，或者可能是Vite。最重要的是了解你的项目和里面的兔子洞。例如，在Laravel Monolith项目中，如果您使用直接路由器，如:“认证/忘记密码”，您必须将其更改为REST API，并使用JWT或其他加密处理一切。</p><p id="3cfa" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">一件重要的事情</strong>是将整个master.blade.php复制到主html模板新结构中的“public/index.html”中。<br/>没有别的事要提，好好享受你的编码吧😉</p></div></div>    
</body>
</html>