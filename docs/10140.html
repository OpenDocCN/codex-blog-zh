<html>
<head>
<title>Becoming a SOLID developer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">成为一名优秀的开发者</h1>
<blockquote>原文：<a href="https://medium.com/codex/becoming-a-solid-developer-7f0e0ab359f6?source=collection_archive---------7-----------------------#2022-12-07">https://medium.com/codex/becoming-a-solid-developer-7f0e0ab359f6?source=collection_archive---------7-----------------------#2022-12-07</a></blockquote><div><div class="dt gx gy gz ha hb"/><div class="hc hd he hf hg"><h2 id="7e9b" class="hh hi hj bd b fq hk hl hm hn ho hp dy hq translated" aria-label="kicker paragraph"><a class="ae gf" href="https://geraldnguyen.medium.com/list/software-development-f70ae37efe1c" rel="noopener">软件开发</a></h2><div class=""/><div class=""><h2 id="620e" class="pw-subtitle-paragraph ip hs hj bd b iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg dy translated">通过遵循可靠的软件工程原则</h2></div><p id="3a56" class="pw-post-body-paragraph jh ji hj jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc hc bi translated">被人叫<em class="kd">实</em>是一种恭维。这个词带有可靠和体面的积极意义。我们所有人都应该努力成为其中一员。</p><figure class="kf kg kh ki fe kj es et paragraph-image"><div class="es et ke"><img src="../Images/39bce6fd3c82ae39e9c7bc9ea6e5f81a.png" data-original-src="https://miro.medium.com/v2/resize:fit:730/format:webp/1*jgPZbah9dkZgepyo6D2xwQ.png"/></div><figcaption class="km kn eu es et ko kp bd b be z dy translated"><a class="ae kq" href="https://www.collinsdictionary.com/dictionary/english/solid" rel="noopener ugc nofollow" target="_blank">https://www.collinsdictionary.com/dictionary/english/solid</a>(截图)</figcaption></figure><p id="5bc7" class="pw-post-body-paragraph jh ji hj jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc hc bi translated">如果你是一名软件工程师或者想成为一名软件工程师，你很幸运，因为有一套坚实的原则来指引你的道路。</p></div><div class="ab cl kr ks gq kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="hc hd he hf hg"><p id="4e9c" class="pw-post-body-paragraph jh ji hj jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc hc bi translated">SOLID是软件工程专业的缩写。它代表:</p><ul class=""><li id="9932" class="ky kz hj jj b jk jl jn jo jq la ju lb jy lc kc ld le lf lg bi translated">单一责任原则</li><li id="d9fa" class="ky kz hj jj b jk lh jn li jq lj ju lk jy ll kc ld le lf lg bi translated"><strong class="jj ht"> O </strong>关笔原理</li><li id="aa0d" class="ky kz hj jj b jk lh jn li jq lj ju lk jy ll kc ld le lf lg bi translated"><strong class="jj ht"> L </strong>伊斯科夫替代原理</li><li id="e9a4" class="ky kz hj jj b jk lh jn li jq lj ju lk jy ll kc ld le lf lg bi translated"><strong class="jj ht"> I </strong>界面偏析原理</li><li id="e1cf" class="ky kz hj jj b jk lh jn li jq lj ju lk jy ll kc ld le lf lg bi translated"><strong class="jj ht">维</strong>依赖反转原理</li></ul><p id="8814" class="pw-post-body-paragraph jh ji hj jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc hc bi translated">这个术语是由迈克尔·费瑟在2004年左右创造的，最初是由鲍勃叔叔在他2000年的论文《设计原则和设计模式》和他的其他文章《T29》和书籍《T31》中收集的</p><p id="acb2" class="pw-post-body-paragraph jh ji hj jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc hc bi translated">让我们更详细地看看这些原则。</p><h1 id="64bc" class="lm ln hj bd lo lp lq lr ls lt lu lv lw iy lx iz ly jb lz jc ma je mb jf mc md bi translated">单一责任</h1><blockquote class="me mf mg"><p id="e822" class="jh ji kd jj b jk jl it jm jn jo iw jp mh jr js jt mi jv jw jx mj jz ka kb kc hc bi translated">每个类应该有一个单一的责任。</p></blockquote><p id="3cd5" class="pw-post-body-paragraph jh ji hj jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc hc bi translated">An <code class="dv mk ml mm mn b">EmailService</code>应该只关心发送电子邮件，而不是发送电子邮件<em class="kd">和</em>更新订单状态。</p><p id="b75f" class="pw-post-body-paragraph jh ji hj jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc hc bi translated">一个<code class="dv mk ml mm mn b">Car</code>类应该是关于汽车，而不是其他类型的机动车辆。如果我们需要描述一辆电动汽车，那么用<code class="dv mk ml mm mn b">ElectricCar</code>这样的子类比用电动和汽油车特征的<code class="dv mk ml mm mn b">Car</code>重载更合适。</p><h1 id="7873" class="lm ln hj bd lo lp lq lr ls lt lu lv lw iy lx iz ly jb lz jc ma je mb jf mc md bi translated">开闭原理</h1><blockquote class="me mf mg"><p id="023f" class="jh ji kd jj b jk jl it jm jn jo iw jp mh jr js jt mi jv jw jx mj jz ka kb kc hc bi translated">模块应该对扩展开放，但对修改关闭</p></blockquote><p id="4e5d" class="pw-post-body-paragraph jh ji hj jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc hc bi translated">这个<code class="dv mk ml mm mn b">EmailService</code>可以通过一个<code class="dv mk ml mm mn b">RecallableEmailService</code>来扩展，为刚发送的邮件增加召回功能。</p><figure class="kf kg kh ki fe kj es et paragraph-image"><div class="es et mo"><img src="../Images/ce68c78258fbf17ef8d74f3ce6df69b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1254/format:webp/1*cvKw_Z8ZspbkJieyjInM0w.png"/></div><figcaption class="km kn eu es et ko kp bd b be z dy translated">电子邮件服务及其关联</figcaption></figure><p id="037c" class="pw-post-body-paragraph jh ji hj jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc hc bi translated"><code class="dv mk ml mm mn b">ElectricCar</code>在不修改<code class="dv mk ml mm mn b">Car</code>内部的情况下增加了电气特性。</p><h1 id="2896" class="lm ln hj bd lo lp lq lr ls lt lu lv lw iy lx iz ly jb lz jc ma je mb jf mc md bi translated">利斯科夫替代</h1><blockquote class="me mf mg"><p id="6ad6" class="jh ji kd jj b jk jl it jm jn jo iw jp mh jr js jt mi jv jw jx mj jz ka kb kc hc bi translated">子类应该可以替代它们的基类</p></blockquote><p id="ffeb" class="pw-post-body-paragraph jh ji hj jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc hc bi translated">在面向对象设计的上下文中，接受基类实例的类或方法应该能够接受其子类的任何实例。</p><p id="e611" class="pw-post-body-paragraph jh ji hj jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc hc bi translated">一个<code class="dv mk ml mm mn b">OrderService</code>应该可以使用任何符合<code class="dv mk ml mm mn b">EmailService</code>接口的实例，而不用关心该实例的实际类是<code class="dv mk ml mm mn b">EmailService</code>本身还是<code class="dv mk ml mm mn b">RecallableEmailService</code></p><p id="2d0d" class="pw-post-body-paragraph jh ji hj jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc hc bi translated">一个<code class="dv mk ml mm mn b">UrbanTripPlanner</code>应该能够使用<code class="dv mk ml mm mn b">Car</code>的任何实例来确定一条路线，而不知道它是代表一辆电动车还是汽油车。</p><h1 id="1bf5" class="lm ln hj bd lo lp lq lr ls lt lu lv lw iy lx iz ly jb lz jc ma je mb jf mc md bi translated">界面分离</h1><blockquote class="me mf mg"><p id="3c91" class="jh ji kd jj b jk jl it jm jn jo iw jp mh jr js jt mi jv jw jx mj jz ka kb kc hc bi translated">许多客户端专用接口比一个通用接口更好</p></blockquote><p id="8a61" class="pw-post-body-paragraph jh ji hj jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc hc bi translated">一个<code class="dv mk ml mm mn b">OrderService</code>不需要<code class="dv mk ml mm mn b">recallEmail(...)</code>。因此，它只依靠<code class="dv mk ml mm mn b">EmailService</code>发送电子邮件，而不是<code class="dv mk ml mm mn b">RecallableEmailService</code></p><p id="e2be" class="pw-post-body-paragraph jh ji hj jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc hc bi translated">类似地，<code class="dv mk ml mm mn b">UrbanTripPlanner</code>不需要来自<code class="dv mk ml mm mn b">EletricCar</code>的<code class="dv mk ml mm mn b">recharge(...)</code>方法。这仅取决于<code class="dv mk ml mm mn b">Car</code>提供的接口</p><figure class="kf kg kh ki fe kj es et paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="es et mp"><img src="../Images/e02960d1a89852476c661775d004202d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AZ1fklqQkAmglfU5NxLC3g.png"/></div></div><figcaption class="km kn eu es et ko kp bd b be z dy translated">汽车及其协会</figcaption></figure><h1 id="07e2" class="lm ln hj bd lo lp lq lr ls lt lu lv lw iy lx iz ly jb lz jc ma je mb jf mc md bi translated">依赖性倒置</h1><blockquote class="me mf mg"><p id="35bf" class="jh ji kd jj b jk jl it jm jn jo iw jp mh jr js jt mi jv jw jx mj jz ka kb kc hc bi translated">依赖于抽象。不要依赖具体事物。</p></blockquote><p id="09c8" class="pw-post-body-paragraph jh ji hj jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc hc bi translated">程序性的依赖机制从顶层开始，逐渐扩展，并依赖于具体的实现细节。</p><p id="e491" class="pw-post-body-paragraph jh ji hj jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc hc bi translated">在面向对象编程中，依赖关系是<em class="kd">倒过来的</em>。大多数依赖应该是基于抽象的。在实现存在的地方，它与抽象的关系<em class="kd">颠倒</em>。现在，实现依赖于抽象，而不是直接依赖于抽象。</p><figure class="kf kg kh ki fe kj es et paragraph-image"><div class="es et mu"><img src="../Images/e16ba3022b512c36c1f11f71f5349c8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1134/format:webp/1*xZNkJr8o1fxcJ2efNggICA.png"/></div><figcaption class="km kn eu es et ko kp bd b be z dy translated">来源:鲍勃大叔的设计原则和<br/>设计模式</figcaption></figure><p id="e17a" class="pw-post-body-paragraph jh ji hj jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc hc bi translated">一个<code class="dv mk ml mm mn b">OrderService</code>依赖于<code class="dv mk ml mm mn b">EmailService</code>提供的接口，而不是它的IMAP或POP实现。</p><p id="48e6" class="pw-post-body-paragraph jh ji hj jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc hc bi translated">一个<code class="dv mk ml mm mn b">UrbanTripPlanner</code>依赖于<code class="dv mk ml mm mn b">Car</code>提供的接口，而不是它的特斯拉或丰田实现</p></div><div class="ab cl kr ks gq kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="hc hd he hf hg"><h1 id="5456" class="lm ln hj bd lo lp mv lr ls lt mw lv lw iy mx iz ly jb my jc ma je mz jf mc md bi translated">结论</h1><p id="cba1" class="pw-post-body-paragraph jh ji hj jj b jk na it jm jn nb iw jp jq nc js jt ju nd jw jx jy ne ka kb kc hc bi translated">我们已经研究了SOLID缩写词的来源，并且通过两个面向对象的设计用例详细地研究了它们。</p><p id="5cae" class="pw-post-body-paragraph jh ji hj jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc hc bi translated">你可能在过去不知道的情况下遵循了这些原则，因为它们是好的实践。封装，在我看来，是遵循<strong class="jj ht">开闭原则</strong>的。</p><p id="bd1e" class="pw-post-body-paragraph jh ji hj jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc hc bi translated">你可能也应用了其中的一些，因为事情就是这样。从语法上来说，<code class="dv mk ml mm mn b">ElectricCar</code>对象总是可以传入一个<code class="dv mk ml mm mn b">Car</code>参数，从而遵循<strong class="jj ht">利斯科夫替换原则</strong>。如果你使用过依赖注入，你已经遵循了<strong class="jj ht">依赖倒置原则</strong>。</p><p id="5532" class="pw-post-body-paragraph jh ji hj jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc hc bi translated">其他原则需要一点思考。<strong class="jj ht">单一责任原则</strong>需要一个好的OO模型来保持方法/类/模块的干净和精简。在遵循<strong class="jj ht">界面分离原则</strong>时，您可能需要良好的判断力来确定分离的深度。</p><h1 id="2901" class="lm ln hj bd lo lp lq lr ls lt lu lv lw iy lx iz ly jb lz jc ma je mb jf mc md bi translated">参考</h1><ul class=""><li id="d4f1" class="ky kz hj jj b jk na jn nb jq nf ju ng jy nh kc ld le lf lg bi translated"><a class="ae kq" href="https://web.archive.org/web/20150906155800/http://www.objectmentor.com/resources/articles/Principles_and_Patterns.pdf" rel="noopener ugc nofollow" target="_blank">设计原则和设计模式</a>论文</li><li id="254e" class="ky kz hj jj b jk lh jn li jq lj ju lk jy ll kc ld le lf lg bi translated"><a class="ae kq" href="http://www.butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod" rel="noopener ugc nofollow" target="_blank">OOD原理</a>篇</li><li id="376b" class="ky kz hj jj b jk lh jn li jq lj ju lk jy ll kc ld le lf lg bi translated"><a class="ae kq" href="https://www.oreilly.com/library/view/clean-architecture-a/9780134494272/" rel="noopener ugc nofollow" target="_blank">干净的架构:软件结构和设计的工匠指南</a></li><li id="dd4f" class="ky kz hj jj b jk lh jn li jq lj ju lk jy ll kc ld le lf lg bi translated"><a class="ae kq" href="https://en.wikipedia.org/wiki/SOLID" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/SOLID</a></li></ul></div><div class="ab cl kr ks gq kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="hc hd he hf hg"><p id="8285" class="pw-post-body-paragraph jh ji hj jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc hc bi translated">如果你喜欢这篇文章，请<a class="ae kq" href="https://geraldnguyen.medium.com/subscribe" rel="noopener">关注我</a>获取更多优质内容。</p><p id="07f8" class="pw-post-body-paragraph jh ji hj jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc hc bi translated">本系列的其他文章:</p><ul class=""><li id="7de5" class="ky kz hj jj b jk jl jn jo jq la ju lb jy lc kc ld le lf lg bi translated"><a class="ae kq" rel="noopener" href="/codex/becoming-a-solid-developer-7f0e0ab359f6">成为一名优秀的开发者</a></li><li id="5934" class="ky kz hj jj b jk lh jn li jq lj ju lk jy ll kc ld le lf lg bi translated"><a class="ae kq" rel="noopener" href="/codex/solid-in-action-the-single-responsibility-principle-7cb70c32cc03">扎实行动——单一责任原则</a></li><li id="231d" class="ky kz hj jj b jk lh jn li jq lj ju lk jy ll kc ld le lf lg bi translated"><a class="ae kq" rel="noopener" href="/codex/solid-in-action-the-open-closed-principle-5b8d09a60a5a">固体在行动——开合原理</a></li><li id="592e" class="ky kz hj jj b jk lh jn li jq lj ju lk jy ll kc ld le lf lg bi translated"><a class="ae kq" rel="noopener" href="/geekculture/solid-in-action-the-liskov-substitution-principle-4b1868ad81fd">实际行动——利斯科夫替代原理</a></li><li id="402d" class="ky kz hj jj b jk lh jn li jq lj ju lk jy ll kc ld le lf lg bi translated"><a class="ae kq" rel="noopener" href="/geekculture/solid-in-action-the-interface-segregation-principle-6c8f92d2133a">固体在作用——界面分离原理</a></li><li id="9072" class="ky kz hj jj b jk lh jn li jq lj ju lk jy ll kc ld le lf lg bi translated"><a class="ae kq" rel="noopener" href="/geekculture/solid-in-action-the-dependency-inversion-principle-5567bddd6cfc">实操——依赖倒置原则</a></li></ul><p id="2b77" class="pw-post-body-paragraph jh ji hj jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc hc bi translated">谢谢你。</p></div></div>    
</body>
</html>