<html>
<head>
<title>Downloading public comments with a simple-to-use Python wrapper for the Regulations.gov API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用简单易用的Python包装器为Regulations.gov API下载公众意见</h1>
<blockquote>原文：<a href="https://medium.com/codex/downloading-public-comments-with-a-simple-to-use-python-wrapper-for-the-regulations-gov-api-7affe8a4dadc?source=collection_archive---------13-----------------------#2021-07-22">https://medium.com/codex/downloading-public-comments-with-a-simple-to-use-python-wrapper-for-the-regulations-gov-api-7affe8a4dadc?source=collection_archive---------13-----------------------#2021-07-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="7e9f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Python包装器:<a class="ae jd" href="https://github.com/willjobs/regulations-public-comments" rel="noopener ugc nofollow" target="_blank">https://github.com/willjobs/regulations-public-comments</a></p><p id="19ef" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">TL；博士</strong>:我为Regulations.gov API的v4创建了一个Python包装器，极大地简化了从Regulations.gov下载公众意见的过程。您可以在命令行使用它(不使用任何Python)来下载给定摘要或摘要上的所有公共评论，或者使用一点Python来进行定制查询(例如，下载过去一个月中关于任何EPA法规的所有评论)。这可能是第一个简化Regulations.gov API第4版使用的公开包装器。</p><p id="696c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在美国，当联邦机构提出新的法规时，他们需要经过正式的审查过程。通常，这包括规则制定提案通知(NPRM)、公众意见征询期、公众意见回复和最终规则(见<a class="ae jd" href="https://www.regulations.gov/about" rel="noopener ugc nofollow" target="_blank">本</a>、<a class="ae jd" href="https://www.regulations.gov/learn" rel="noopener ugc nofollow" target="_blank">本</a>和<a class="ae jd" href="https://crsreports.congress.gov/product/pdf/RL/RL32240" rel="noopener ugc nofollow" target="_blank">本</a>)。公众意见允许个人和组织提供额外的背景、支持信息和对提议的法规的意见(或删除)，尽管它们不被视为对法规的“投票”。</p><p id="f2ac" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">数据的结构如下:与给定的提案法规相关的所有材料都包含在一个<strong class="ih hj">摘要</strong>中。每个摘要可能包含一个或多个各种类型的<strong class="ih hj">文档</strong>(通知、提议的规则、规则、支持&amp;相关材料及其他)，公众可以对任何文档发表评论。注释与文档相关，而不是与摘要相关。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es je"><img src="../Images/cdcd90977663c8cfbcf11201766a74cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/format:webp/0*19LS_j8u3WtTGGaV.png"/></div></figure><p id="5f54" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2003年，公众意见流程第一次以电子方式提供，这导致参与度大幅上升。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es jm"><img src="../Images/c99122f1b8e05344f7cf8e1d1fad1092.png" data-original-src="https://miro.medium.com/v2/resize:fit:918/format:webp/0*ODxdRQiW8B2jf0uM.png"/></div></figure><p id="eda4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">web界面允许用户使用搜索词搜索摘要、文档和评论，并根据机构、文档类型、发布日期和评论到期日期等进行过滤。对摘要的搜索也可以通过各种其他标准来过滤。</p><p id="7133" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jd" href="https://sunlightfoundation.com/2012/02/23/regs-dot-gov-gets-an-api/" rel="noopener ugc nofollow" target="_blank">2012年</a>创建了一个公共API的1.0版本，允许用户以编程方式从Regulations.gov下载评论(参见<a class="ae jd" href="https://web.archive.org/web/20120921002013/https://www.regulations.gov/docs/Regulations_Gov_API_User_Guide.pdf" rel="noopener ugc nofollow" target="_blank"> v1文档</a>)。从那以后有了几次更新，API的v4于2020年9月发布<a class="ae jd" href="https://regulatorystudies.columbian.gwu.edu/new-regulationsgov-api" rel="noopener ugc nofollow" target="_blank">。这个API的最新版本还增加了用户上传评论的功能。</a></p><p id="2e09" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">API是非常<a class="ae jd" href="https://open.gsa.gov/api/regulationsgov/" rel="noopener ugc nofollow" target="_blank">有据可查的</a>，有例子和明确的参数和响应规范。尽管如此，还是有一些问题。例如，<code class="du jn jo jp jq b">postedDate</code>过滤使用<code class="du jn jo jp jq b">yyyy-mm-dd</code>格式，而<code class="du jn jo jp jq b">lastModifiedDate</code>过滤使用<code class="du jn jo jp jq b">yyyy-mm-dd hh24:mi:ss</code>格式。此外，<code class="du jn jo jp jq b">lastModifiedDate</code>过滤器使用东部时区，但是响应中返回的值使用UTC，如果您不知道并试图对多个请求分页，这可能会造成不匹配。另一个例子:当您试图过滤特定文档的评论时，您必须使用文档的<code class="du jn jo jp jq b">objectId</code>(API返回的内部标识符)，而不是它的<code class="du jn jo jp jq b">documentId</code>。</p><p id="6b48" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">分页机制也很棘手:每个“页面”(一个请求)最多允许250个“项目”(注释、文档或摘要)，一个查询最多可以访问其中的20个页面，每个查询总共有5000个项目。然而，如果您正在查询(例如)过去两年中所有关于EPA相关法规的评论，该怎么办呢？API会将您限制在5，000个条目以内，即使评论的数量肯定会比这多(在本例中，<a class="ae jd" href="https://www.regulations.gov/search/comment?agencyIds=EPA&amp;postedDateFrom=2019-07-01&amp;postedDateTo=2021-07-01" rel="noopener ugc nofollow" target="_blank">超过80，000个</a>)。如文档示例中所述，处理这种情况的方法是:</p><ol class=""><li id="65ac" class="jr js hi ih b ii ij im in iq jt iu ju iy jv jc jw jx jy jz bi translated">像往常一样构造查询，按<code class="du jn jo jp jq b">lastModifiedDate</code>排序。</li><li id="ac30" class="jr js hi ih b ii ka im kb iq kc iu kd iy ke jc jw jx jy jz bi translated">在第一页之后，每个后续请求应该将<code class="du jn jo jp jq b">page[num]</code>设置为等于当前页码。</li><li id="981e" class="jr js hi ih b ii ka im kb iq kc iu kd iy ke jc jw jx jy jz bi translated">在最后一页(第20页)，记录最后一项的<code class="du jn jo jp jq b">lastModifiedDate</code>。</li><li id="a753" class="jr js hi ih b ii ka im kb iq kc iu kd iy ke jc jw jx jy jz bi translated">重复步骤1-3，现在添加一个过滤器，使<code class="du jn jo jp jq b">lastModifiedDate</code>大于或等于步骤3中记录的<code class="du jn jo jp jq b">lastModifiedDate</code>。您必须将日期和时间设置为大于<em class="kf">或等于</em>，因为可能会有评论在同一时间发布(例如，如果它们被批量上传或被系统人员修改)。然而，这确保了您将获得重复，所以您必须自己处理它们。</li></ol><p id="a9ee" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，一个API键(可以在<a class="ae jd" href="https://open.gsa.gov/api/regulationsgov/" rel="noopener ugc nofollow" target="_blank"> API文档页面</a>上请求)被限制为每小时不超过1000个请求。Python包装器通过检测请求错误并每20分钟自动轮询一次来处理这种限制，直到API键的限制被重置(有时请求会在60分钟之前重置)，此时请求会继续。</p><p id="c13d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">每小时1000个请求可能听起来很多，但事实证明，为了获得给定评论的文本，您必须单独访问它。上面关于一次获取250个项目的描述只能让您获得每个项目的一些“标题”信息，而您最感兴趣的可能是“细节”信息。为了更好地理解这一点，在API文档的最底部有一个Schemas部分，它列出了给定项返回的所有数据属性。“Comment”项是我上面描述的分页过程返回的内容，它只包括<code class="du jn jo jp jq b">agencyId</code>、<code class="du jn jo jp jq b">documentType</code>、<code class="du jn jo jp jq b">highlightedContent</code>、<code class="du jn jo jp jq b">lastModifiedDate</code>、<code class="du jn jo jp jq b">objectId</code>、<code class="du jn jo jp jq b">postedDate</code>、<code class="du jn jo jp jq b">title</code>和<code class="du jn jo jp jq b">withdrawn</code>。注释的实际文本存在于模式的“CommentDetail”项中，在<code class="du jn jo jp jq b">comment</code>属性中，由<code class="du jn jo jp jq b">commentId</code>一次访问一个。</p><p id="c731" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我攻读硕士学位期间，我的工作是作为NLP课程的一个项目开始的，随着我的代码库的形成，我意识到我从使用API中学到的经验可能对其他人有用。在我开始这个项目之前，我花了大量的时间搜索GitHub和Google，看看我是否可以基于其他人的工作进行构建，但是似乎没有API v4的现有包装器。我发现阳光实验室(<a class="ae jd" href="https://sunlightfoundation.com/2020/09/24/a-note-from-the-sunlight-foundations-board-chair/" rel="noopener ugc nofollow" target="_blank">一个现已解散的组织</a>)的回购，然而他们的代码最后一次更新是在2015年，不再工作。我发现的另一个repo最后一次更新是在2020年1月(这意味着它针对v3 API)，将自己描述为“准系统工具”，并需要手动编辑Python文件才能下载给定docket ID的注释。因此，由于没有预先存在的针对v4 API的代码库，我构建了自己的代码库。</p><h1 id="0c3a" class="kg kh hi bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">命令行快速入门</h1><p id="7bb0" class="pw-post-body-paragraph if ig hi ih b ii le ik il im lf io ip iq lg is it iu lh iw ix iy li ja jb jc hb bi translated">开始使用这段代码最简单的方法是使用命令行。要么克隆整个回购，要么<a class="ae jd" href="https://raw.githubusercontent.com/willjobs/regulations-public-comments/master/comments_downloader.py" rel="noopener ugc nofollow" target="_blank">下载comments_downloader.py </a>。它用的是Python 3；你还需要<code class="du jn jo jp jq b">pandas</code>库(如果你还没有，运行<code class="du jn jo jp jq b">pip install pandas</code>，或者<code class="du jn jo jp jq b">conda install pandas</code>，如果你已经安装了Anaconda或者miniconda)。命令行方式允许您下载给定文档(由<code class="du jn jo jp jq b">documentId</code>指定)或docket(跨所有文档，由<code class="du jn jo jp jq b">docketId</code>指定)的所有注释。除了ID之外，您还需要指定您的API密钥，您可以在<a class="ae jd" href="https://open.gsa.gov/api/regulationsgov/#getting-started" rel="noopener ugc nofollow" target="_blank">Regulations.gov文档页面</a>上注册。注意:本文档中所有的<code class="du jn jo jp jq b">DEMO_KEY</code>实例都应该替换为您的API密钥。这些评论将被下载到当前目录下的一个以格式<code class="du jn jo jp jq b">YOUR-ID-HERE.csv</code>命名的CSV文件中。例如:</p><pre class="jf jg jh ji fd lj jq lk ll aw lm bi"><span id="0c7c" class="ln kh hi jq b fi lo lp l lq lr"># download all comments for docket FDA-2021-N-0270 (across all its documents)<br/>python comments_downloader.py --key DEMO_KEY --docket FDA-2021-N-0270<br/><br/>Downloading comments for docket ID FDA-2021-N-0270...<br/>2021-07-18 16:26:30: Getting documents associated with docket FDA-2021-N-0270...<br/><br/>Found 1 documents...<br/>2021-07-18 16:26:31: Writing 1 records to document_headers_162630.csv...Done<br/>2021-07-18 16:26:31: Removing any duplicates in the CSV...<br/>2021-07-18 16:26:31: Done. Removed 0 duplicate rows from document_headers_162630.csv.<br/>2021-07-18 16:26:31: Finished: approximately 1 documents collected<br/><br/>Done----------------<br/><br/>******************************<br/>2021-07-18 16:26:31: Getting comments for document FDA-2021-N-0270-0001...<br/><br/>2021-07-18 16:26:31: Getting objectId for document FDA-2021-N-0270-0001...Got it (0900006484a930da)<br/>2021-07-18 16:26:31: Getting comment headers associated with document FDA-2021-N-0270-0001...<br/><br/>Found 188 comments...<br/>2021-07-18 16:26:31: Writing 188 records to comment_headers_162631.csv...Done<br/>2021-07-18 16:26:31: Removing any duplicates in the CSV...<br/>2021-07-18 16:26:32: Done. Removed 0 duplicate rows from comment_headers_162631.csv.<br/>2021-07-18 16:26:32: Finished: approximately 188 comments collected<br/><br/>Done getting comment IDs----------------<br/><br/>2021-07-18 16:26:32: Getting comments associated with document FDA-2021-N-0270-0001...<br/><br/>2021-07-18 16:26:32: Gathering details for 188 comments...<br/>2021-07-18 16:27:03: Writing 188 records to FDA-2021-N-0270.csv...Done<br/>2021-07-18 16:27:03: Finished: 188 comments collected<br/><br/>Done getting all 188 comments for document FDA-2021-N-0270-0001----------------<br/><br/>DONE retrieving all 188 comments from 1 document(s) for docket FDA-2021-N-0270----------------</span></pre><p id="67ae" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">类似地，要下载一个<em class="kf">文档</em>的所有注释，您可以在命令行指定<code class="du jn jo jp jq b">--document</code>和文档ID(即您在URL中看到的那个):</p><pre class="jf jg jh ji fd lj jq lk ll aw lm bi"><span id="e74f" class="ln kh hi jq b fi lo lp l lq lr"># download all comments for document FDA-2009-N-0501-0012<br/>python comments_downloader.py --key DEMO_KEY --document FDA-2009-N-0501-0012<br/><br/>Downloading comments for document ID FDA-2009-N-0501-0012...<br/>2021-07-20 20:11:09: Getting objectId for document FDA-2009-N-0501-0012...Got it (09000064847f0822)<br/>2021-07-20 20:11:09: Getting comment headers associated with document FDA-2009-N-0501-0012...<br/><br/>Found 10 comments...<br/>2021-07-20 20:11:10: Writing 10 records to comment_headers_201109.csv...Done<br/>2021-07-20 20:11:10: Removing any duplicates in the CSV...<br/>2021-07-20 20:11:10: Done. Removed 0 duplicate rows from comment_headers_201109.csv.<br/>2021-07-20 20:11:10: Finished: approximately 10 comments collected<br/><br/>Done getting comment IDs----------------<br/><br/>2021-07-20 20:11:10: Getting comments associated with document FDA-2009-N-0501-0012...<br/><br/>2021-07-20 20:11:10: Gathering details for 10 comments...<br/>2021-07-20 20:11:12: Writing 10 records to FDA-2009-N-0501-0012.csv...Done<br/>2021-07-20 20:11:12: Finished: 10 comments collected<br/><br/>Done getting all 10 comments for document FDA-2009-N-0501-0012----------------<br/><br/>Done getting all 10 comments for document FDA-2009-N-0501-0012----------------</span></pre><p id="292a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一个重要的注意事项:这个代码不下载附件(pdf，Word文档等。).但是，我将列<code class="du jn jo jp jq b">attachmentLinks</code>添加到输出中，它包含给定评论的任何附件的URL的管道分隔(|)列表。鉴于<a class="ae jd" href="https://github.com/willjobs/public-comments-project/tree/main/blogposts/post5#pipeline" rel="noopener ugc nofollow" target="_blank">给定文档上几乎30%的评论</a>是“附加的”评论，其中评论主体中的文本类似于“参见附加的评论”，这是一个相当大的信息量，因此对于一些项目来说，使用本专栏中的URL可能是必要的。</p><p id="e341" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">值得注意的是，以上两个例子都返回了少量的评论。如果您查询的摘要或文档有超过1，000条评论，您将达到API键的速率限制，并且将不得不等待一个小时来重置速率限制。代码将自动为您处理这些，等待并每20分钟检查一次，看看您是否又收到了1，000个请求。有可能<a class="ae jd" href="https://www.regulations.gov/support" rel="noopener ugc nofollow" target="_blank">联系服务台</a>每小时获得多达2000个请求，每个用户最多两个密钥。</p><p id="b414" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于90%的用例来说，命令行可能就是所有需要的，因为人们通常只对特定清单上的注释感兴趣。然而，对于定制的查询，例如一次下载许多摘要的评论，或者在SQLite数据库中检索结果。db)代替CSV，可以用Python。</p><h1 id="e664" class="kg kh hi bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">使用Python进行自定义查询</h1><p id="fe66" class="pw-post-body-paragraph if ig hi ih b ii le ik il im lf io ip iq lg is it iu lh iw ix iy li ja jb jc hb bi translated">存储库中的Jupyter notebook<a class="ae jd" href="https://github.com/willjobs/regulations-public-comments/blob/master/Examples.ipynb" rel="noopener ugc nofollow" target="_blank">examples . ipynb</a>演示了如何使用comments _ downloader.py这是获取更多示例的好地方。注意使用这段代码需要<code class="du jn jo jp jq b">pandas</code>库。</p><p id="4d9b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用代码的第一步是导入它并创建一个<code class="du jn jo jp jq b">CommentsDownloader</code>类的新实例(用在<a class="ae jd" href="https://open.gsa.gov/api/regulationsgov/#getting-started" rel="noopener ugc nofollow" target="_blank">https://open.gsa.gov/api/regulationsgov/#getting-started</a>获得的API键替换<code class="du jn jo jp jq b">DEMO_KEY</code>:</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="ls lt l"/></div></figure><h1 id="6829" class="kg kh hi bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">示例1:</h1><p id="8542" class="pw-post-body-paragraph if ig hi ih b ii le ik il im lf io ip iq lg is it iu lh iw ix iy li ja jb jc hb bi translated">在第一个例子中，我们可以将我们的注释下载到SQLite数据库<em class="kf">和</em>CSV中，为每个数据库指定我们自己的文件名(或者，您也可以只导出到SQLite或CSV):</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="ls lt l"/></div></figure><p id="607a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">结果与您在命令行中得到的结果相同。在CSV上使用SQLite数据库有几个好处:可以在其上运行SQL(包括连接等。)，您可以添加约束，并且可以保证注释字符串中的字符不会影响CSV导入。(代码尽最大努力避免CSV的这个问题:引号字符用双引号括起来，换行符用空格替换，这样CSV中的每一行都是一个“记录”)。另一个很大的好处是你可以把来自摘要、文档和评论的数据都存储在一个地方。例如，当下载给定摘要上的所有评论时，关于文档的标题信息将存储在<code class="du jn jo jp jq b">documents_header</code>表中，评论标题将在<code class="du jn jo jp jq b">comments_header</code>表中，关于每个评论的细节(包括评论的文本)将在<code class="du jn jo jp jq b">comments_detail</code>表中。这与命令行输出相反，命令行输出只会将<code class="du jn jo jp jq b">comments_detail</code>表的等价物输出到CSV。完整的数据库模式在这里是<a class="ae jd" href="https://github.com/willjobs/regulations-public-comments#database-schema" rel="noopener ugc nofollow" target="_blank"/>。</p><h1 id="7903" class="kg kh hi bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">示例2</h1><p id="eb22" class="pw-post-body-paragraph if ig hi ih b ii le ik il im lf io ip iq lg is it iu lh iw ix iy li ja jb jc hb bi translated">要下载与多个摘要(或文档)相关联的所有注释，下面的搭建工作得很好(注意，如果我们指定了一个CSV文件名，则所有摘要的注释将包含在一个CSV文件中):</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="ls lt l"/></div></figure><h1 id="fea5" class="kg kh hi bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">旁白</h1><p id="2a08" class="pw-post-body-paragraph if ig hi ih b ii le ik il im lf io ip iq lg is it iu lh iw ix iy li ja jb jc hb bi translated">值得注意的是，上面三行非<code class="du jn jo jp jq b">print</code>代码中抽象出了多少东西。通常没有办法直接从<code class="du jn jo jp jq b">docketId</code>转到注释，因为API中可用的过滤器只允许按文档过滤注释。因此，首先使用<code class="du jn jo jp jq b">docketId</code>查询每个docket的文档，使用<code class="du jn jo jp jq b">documents</code>端点(而不是上面使用<code class="du jn jo jp jq b">gather_headers</code>时的<code class="du jn jo jp jq b">dockets</code>):</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="ls lt l"/></div></figure><p id="d7a8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后，您可以使用下载到<code class="du jn jo jp jq b">EPA_water_documents.csv</code>中的文档头来查询它们的相关注释，但是您首先需要从该文件中获取每个文档的<code class="du jn jo jp jq b">objectId</code>。这是因为API通过文档的<code class="du jn jo jp jq b">objectId</code>而不是<code class="du jn jo jp jq b">documentId</code>过滤评论(我猜是因为后端的数据问题，实际上有多个文档具有相同的<code class="du jn jo jp jq b">documentId</code>；我见过一些罕见的<code class="du jn jo jp jq b">documentId</code>的怪异行为。然后，您可以使用这些<code class="du jn jo jp jq b">objectId</code>来获取评论，与上面类似:</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="ls lt l"/></div></figure><p id="cd80" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，有了这些注释头，您可以使用<code class="du jn jo jp jq b">EPA_water_comments_header.csv</code>中的每个<code class="du jn jo jp jq b">commentId</code>通过访问“Details”端点来收集每个注释的完整数据:</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="ls lt l"/></div></figure><p id="ddb0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">注意，如果您使用的是SQLite，而不是四处浮动的四个单独的CSV文件，那么您将拥有一个将所有这些数据存储在同一位置的数据库。</p><h1 id="512c" class="kg kh hi bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">示例3</h1><p id="12da" class="pw-post-body-paragraph if ig hi ih b ii le ik il im lf io ip iq lg is it iu lh iw ix iy li ja jb jc hb bi translated">最后，一个(稍微)更复杂的自定义查询示例:假设我们想要下载所有与包含术语“水”的EPA摘要相关的评论，这些评论是在2017年1月1日到2020年12月31日之间发布的。我们的第一步是在2017年1月1日和2020年12月31日之间获得带有“水”的<code class="du jn jo jp jq b">searchTerm</code>和<code class="du jn jo jp jq b">lastModifiedDate</code>的摘要标题:</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="ls lt l"/></div></figure><p id="111e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以上结果将353条记录(dockets)下载到文件<a class="ae jd" href="https://willjobs.com/blog/assets/EPA_water_dockets.csv" rel="noopener ugc nofollow" target="_blank"> EPA_water_dockets.csv </a>。现在你要做的就是:</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="ls lt l"/></div></figure><p id="d00b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">更多关于Regulations.gov及其API的信息，你可以访问<a class="ae jd" href="https://open.gsa.gov/api/regulationsgov/" rel="noopener ugc nofollow" target="_blank">官方文档</a>，或者查看我在硕士期间为一个项目写的<a class="ae jd" href="https://github.com/willjobs/public-comments-project/tree/main/blogposts" rel="noopener ugc nofollow" target="_blank">博客帖子</a>。特别是，<a class="ae jd" href="https://github.com/willjobs/public-comments-project/tree/main/blogposts/post1" rel="noopener ugc nofollow" target="_blank">的帖子1 </a>有一个关于<a class="ae jd" href="https://github.com/willjobs/public-comments-project/tree/main/blogposts/post1#web" rel="noopener ugc nofollow" target="_blank">web界面</a>和评论示例的部分，而<a class="ae jd" href="https://github.com/willjobs/public-comments-project/tree/main/blogposts/post2" rel="noopener ugc nofollow" target="_blank">的帖子2 </a>比这篇帖子更详细地介绍了API和一些观察结果。此外，你可以查看这个代码的文档。</p></div><div class="ab cl lu lv gp lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="hb hc hd he hf"><p id="f497" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="kf">原载于2021年7月22日https://willjobs.com</em><a class="ae jd" href="https://willjobs.com/blog/downloading-public-comments" rel="noopener ugc nofollow" target="_blank"><em class="kf"/></a><em class="kf">。</em></p></div></div>    
</body>
</html>