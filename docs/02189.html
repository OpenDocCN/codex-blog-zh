<html>
<head>
<title>Modules in Ruby</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Ruby中的模块</h1>
<blockquote>原文：<a href="https://medium.com/codex/modules-in-ruby-72263d88b9af?source=collection_archive---------3-----------------------#2021-07-06">https://medium.com/codex/modules-in-ruby-72263d88b9af?source=collection_archive---------3-----------------------#2021-07-06</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="5a7d" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">不能像类那样实例化的那个！</h2></div><h1 id="f2ec" class="ix iy hi bd iz ja jb jc jd je jf jg jh io ji ip jj ir jk is jl iu jm iv jn jo bi translated">先决条件</h1><p id="0aa8" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">为了更好地理解这个主题，我建议您对Ruby   <strong class="jr hj">中的</strong> <a class="ae kl" href="https://juzer-shakir.medium.com/class-and-its-different-methods-in-ruby-ea8e919c87a4" rel="noopener"> <strong class="jr hj">类有扎实的<strong class="jr hj">知识。</strong></strong></a></p></div><div class="ab cl km kn gp ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="hb hc hd he hf"><h1 id="8e2f" class="ix iy hi bd iz ja kt jc jd je ku jg jh io kv ip jj ir kw is jl iu kx iv jn jo bi translated">目录</h1><p id="a555" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">↦ <a class="ae kl" href="#aa20" rel="noopener ugc nofollow"> <strong class="jr hj">定义</strong> </a></p><p id="2af5" class="pw-post-body-paragraph jp jq hi jr b js ky ij ju jv kz im jx jy la ka kb kc lb ke kf kg lc ki kj kk hb bi translated">↦ <a class="ae kl" href="#ee3b" rel="noopener ugc nofollow"> <strong class="jr hj">嵌套模块</strong> </a></p><p id="ffc4" class="pw-post-body-paragraph jp jq hi jr b js ky ij ju jv kz im jx jy la ka kb kc lb ke kf kg lc ki kj kk hb bi translated">↦ <a class="ae kl" href="#cf38" rel="noopener ugc nofollow">访问常数<strong class="jr hj">访问常数</strong>访问常数</a></p><p id="972b" class="pw-post-body-paragraph jp jq hi jr b js ky ij ju jv kz im jx jy la ka kb kc lb ke kf kg lc ki kj kk hb bi translated">↦ <a class="ae kl" href="#edd9" rel="noopener ugc nofollow">模块中的<strong class="jr hj">方法</strong>模块</a></p><p id="2de1" class="pw-post-body-paragraph jp jq hi jr b js ky ij ju jv kz im jx jy la ka kb kc lb ke kf kg lc ki kj kk hb bi translated">↦ <a class="ae kl" href="#0f43" rel="noopener ugc nofollow">模块中的<strong class="jr hj">类</strong>模块</a></p><p id="d66b" class="pw-post-body-paragraph jp jq hi jr b js ky ij ju jv kz im jx jy la ka kb kc lb ke kf kg lc ki kj kk hb bi translated">↦ <a class="ae kl" href="#e06c" rel="noopener ugc nofollow"> <strong class="jr hj">为什么要使用模块？</strong> </a></p><p id="2244" class="pw-post-body-paragraph jp jq hi jr b js ky ij ju jv kz im jx jy la ka kb kc lb ke kf kg lc ki kj kk hb bi translated">↦ <a class="ae kl" href="#cafc" rel="noopener ugc nofollow"> <strong class="jr hj">命名空间</strong> </a></p><p id="9a61" class="pw-post-body-paragraph jp jq hi jr b js ky ij ju jv kz im jx jy la ka kb kc lb ke kf kg lc ki kj kk hb bi translated">↦ <a class="ae kl" href="#4472" rel="noopener ugc nofollow"> <strong class="jr hj">米欣</strong> </a> <strong class="jr hj"> <br/> </strong> ↪ <a class="ae kl" href="#26b6" rel="noopener ugc nofollow">包括</a> <br/> ↪ <a class="ae kl" href="#9277" rel="noopener ugc nofollow">前置</a> <br/> ↪ <a class="ae kl" href="#90b9" rel="noopener ugc nofollow">延伸</a></p><p id="7003" class="pw-post-body-paragraph jp jq hi jr b js ky ij ju jv kz im jx jy la ka kb kc lb ke kf kg lc ki kj kk hb bi translated">↦ <a class="ae kl" href="#cf1d" rel="noopener ugc nofollow"> <strong class="jr hj">从不同的文件中访问一个模块</strong> </a></p></div><div class="ab cl km kn gp ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="hb hc hd he hf"><h1 id="aa20" class="ix iy hi bd iz ja kt jc jd je ku jg jh io kv ip jj ir kw is jl iu kx iv jn jo bi translated">定义</h1><blockquote class="ld"><p id="afe5" class="le lf hi bd lg lh li lj lk ll lm kk dx translated">模块是容器中常量、方法、类和变量的集合。</p></blockquote><figure class="lo lp lq lr ls lt er es paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="er es ln"><img src="../Images/c4af46d3b7cabf7ef50c6777dfc20807.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mkDD0clp558XwuzYhTJExg.png"/></div></div><figcaption class="ma mb et er es mc md bd b be z dx translated">本文涵盖的主题</figcaption></figure></div><div class="ab cl km kn gp ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="hb hc hd he hf"><p id="77eb" class="pw-post-body-paragraph jp jq hi jr b js ky ij ju jv kz im jx jy la ka kb kc lb ke kf kg lc ki kj kk hb bi translated">它类似于一个<em class="me">类</em>，但关键区别在于<strong class="jr hj"> <em class="me">模块</em>不能像<em class="me">类</em>那样被实例化</strong>。</p><pre class="mf mg mh mi fd mj mk ml mm aw mn bi"><span id="c831" class="mo iy hi mk b fi mp mq l mr ms"># module begins<br/>module Test<br/> # end of scope<br/>end</span></pre><p id="a00e" class="pw-post-body-paragraph jp jq hi jr b js ky ij ju jv kz im jx jy la ka kb kc lb ke kf kg lc ki kj kk hb bi translated">模块由关键字<code class="du mt mu mv mk b"><em class="me">module</em></code>初始化，后跟'<em class="me"> module_name' </em>，<code class="du mt mu mv mk b"><em class="me">Test</em></code>，首字母大写，因为它们是常量<a class="ae kl" href="https://juzer-shakir.medium.com/constants-in-ruby-956c66883f28" rel="noopener"/>。最后通过<code class="du mt mu mv mk b"><em class="me">end</em></code>关键字结束它的范围。</p></div><div class="ab cl km kn gp ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="hb hc hd he hf"><h1 id="ee3b" class="ix iy hi bd iz ja kt jc jd je ku jg jh io kv ip jj ir kw is jl iu kx iv jn jo bi translated">嵌套模块</h1><p id="e55a" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">是啊！模块也可以嵌套，就像嵌套类或嵌套方法一样。</p><figure class="mf mg mh mi fd lt"><div class="bz dy l di"><div class="mw mx l"/></div></figure><p id="a55d" class="pw-post-body-paragraph jp jq hi jr b js ky ij ju jv kz im jx jy la ka kb kc lb ke kf kg lc ki kj kk hb bi translated">我们可以直接访问内部模块<code class="du mt mu mv mk b">Inner</code>，方法是调用它的父模块<code class="du mt mu mv mk b">Outer</code>，后跟一个双冒号操作符<code class="du mt mu mv mk b">::</code>，后跟内部模块的名称。(线<em class="me"> #9 </em>)</p><p id="cf12" class="pw-post-body-paragraph jp jq hi jr b js ky ij ju jv kz im jx jy la ka kb kc lb ke kf kg lc ki kj kk hb bi translated">我们也可以像重新打开Rubys的内置类或者我们自己定义的类一样重新打开模块，直接访问内部模块，如第<em class="me"> #12 </em>行所示。这种风格有利于程序员将缩进的数量从两行减少到一行。</p></div><div class="ab cl km kn gp ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="hb hc hd he hf"><h1 id="cf38" class="ix iy hi bd iz ja kt jc jd je ku jg jh io kv ip jj ir kw is jl iu kx iv jn jo bi translated"><strong class="ak">模块中的常量</strong></h1><figure class="mf mg mh mi fd lt"><div class="bz dy l di"><div class="mw mx l"/></div></figure><p id="2ba4" class="pw-post-body-paragraph jp jq hi jr b js ky ij ju jv kz im jx jy la ka kb kc lb ke kf kg lc ki kj kk hb bi translated">我们通过给<em class="me"> module_name </em>、<code class="du mt mu mv mk b"><em class="me">Test</em></code>，后跟双冒号运算符、<code class="du mt mu mv mk b">::</code>，再后跟<em class="me"> constant_name、</em>、<code class="du mt mu mv mk b">Module_constant</code>来访问模块的<em class="me">常量</em>。</p><p id="57a9" class="pw-post-body-paragraph jp jq hi jr b js ky ij ju jv kz im jx jy la ka kb kc lb ke kf kg lc ki kj kk hb bi translated"><code class="du mt mu mv mk b">Module_constant</code>是一个常量对象，可以被模块<code class="du mt mu mv mk b">Test</code>中定义的方法、类和模块访问。然而，常量在模块<code class="du mt mu mv mk b">Test</code>的范围之外是不可访问的。</p></div><div class="ab cl km kn gp ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="hb hc hd he hf"><h1 id="edd9" class="ix iy hi bd iz ja kt jc jd je ku jg jh io kv ip jj ir kw is jl iu kx iv jn jo bi translated">模块中的方法</h1><figure class="mf mg mh mi fd lt"><div class="bz dy l di"><div class="mw mx l"/></div></figure><p id="c35f" class="pw-post-body-paragraph jp jq hi jr b js ky ij ju jv kz im jx jy la ka kb kc lb ke kf kg lc ki kj kk hb bi translated">定义和访问<em class="me">实例</em>和<em class="me">模块</em>方法类似于我们对<em class="me">类</em>所做的。</p><p id="5bd6" class="pw-post-body-paragraph jp jq hi jr b js ky ij ju jv kz im jx jy la ka kb kc lb ke kf kg lc ki kj kk hb bi translated">由于我们不能将<em class="me">模块</em>实例化为<em class="me">类</em>，访问<em class="me">实例方法</em>将在本文后面的<a class="ae kl" href="#4472" rel="noopener ugc nofollow"> <strong class="jr hj"> Mixin </strong> </a>部分讨论。</p><h1 id="0f43" class="ix iy hi bd iz ja jb jc jd je jf jg jh io ji ip jj ir jk is jl iu jm iv jn jo bi translated">模块中的类</h1><figure class="mf mg mh mi fd lt"><div class="bz dy l di"><div class="mw mx l"/></div></figure><p id="e46d" class="pw-post-body-paragraph jp jq hi jr b js ky ij ju jv kz im jx jy la ka kb kc lb ke kf kg lc ki kj kk hb bi translated">正如我们可以从<em class="me">模块</em>中访问<em class="me">常量</em>一样，我们也可以访问<em class="me">模块</em>范围之外的<em class="me">类</em>。</p></div><div class="ab cl km kn gp ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="hb hc hd he hf"><h1 id="e06c" class="ix iy hi bd iz ja kt jc jd je ku jg jh io kv ip jj ir kw is jl iu kx iv jn jo bi translated"><strong class="ak">为什么要用模块而不是类？</strong></h1><p id="58d0" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">出于这两个原因:</p><ol class=""><li id="7112" class="my mz hi jr b js ky jv kz jy na kc nb kg nc kk nd ne nf ng bi translated"><strong class="jr hj">命名空间</strong></li><li id="2668" class="my mz hi jr b js nh jv ni jy nj kc nk kg nl kk nd ne nf ng bi translated"><strong class="jr hj"> Mixin </strong></li></ol><p id="c9f2" class="pw-post-body-paragraph jp jq hi jr b js ky ij ju jv kz im jx jy la ka kb kc lb ke kf kg lc ki kj kk hb bi translated">我们来讨论一下:</p><h1 id="cafc" class="ix iy hi bd iz ja jb jc jd je jf jg jh io ji ip jj ir jk is jl iu jm iv jn jo bi translated">命名空间</h1><blockquote class="nm nn no"><p id="4594" class="jp jq me jr b js ky ij ju jv kz im jx np la ka kb nq lb ke kf nr lc ki kj kk hb bi translated">命名空间是将逻辑上相关的对象捆绑在一起的一种方式。它允许名称冲突的类或模块共存，同时避免冲突。</p></blockquote><p id="64ba" class="pw-post-body-paragraph jp jq hi jr b js ky ij ju jv kz im jx jy la ka kb kc lb ke kf kg lc ki kj kk hb bi translated">这方面的一个例子是<em class="me">导轨</em>模块。</p><figure class="mf mg mh mi fd lt"><div class="bz dy l di"><div class="mw mx l"/></div></figure><p id="c610" class="pw-post-body-paragraph jp jq hi jr b js ky ij ju jv kz im jx jy la ka kb kc lb ke kf kg lc ki kj kk hb bi translated">这里的<code class="du mt mu mv mk b"><em class="me">Application</em></code>类是在<code class="du mt mu mv mk b"><em class="me">Rails</em></code>模块的范围内定义的。</p><p id="d860" class="pw-post-body-paragraph jp jq hi jr b js ky ij ju jv kz im jx jy la ka kb kc lb ke kf kg lc ki kj kk hb bi translated">由于<code class="du mt mu mv mk b"><em class="me">Application</em></code>类是一个很常见的类名，我们可能会在另一个gem中遇到，所以为了避免相似名称的冲突，<code class="du mt mu mv mk b"><em class="me">Application</em></code>类被封装在<code class="du mt mu mv mk b"><em class="me">Rails</em></code>模块中。</p><p id="1ee4" class="pw-post-body-paragraph jp jq hi jr b js ky ij ju jv kz im jx jy la ka kb kc lb ke kf kg lc ki kj kk hb bi translated">这意味着类<code class="du mt mu mv mk b"><em class="me">Rails::Application</em></code>永远不会与在其他地方定义的<code class="du mt mu mv mk b"><em class="me">Application</em></code> <em class="me"> </em>类或<code class="du mt mu mv mk b"><em class="me">Other_gem::Application</em></code>类冲突。</p><h1 id="4472" class="ix iy hi bd iz ja jb jc jd je jf jg jh io ji ip jj ir jk is jl iu jm iv jn jo bi translated">米欣</h1><blockquote class="nm nn no"><p id="e18b" class="jp jq me jr b js ky ij ju jv kz im jx np la ka kb nq lb ke kf nr lc ki kj kk hb bi translated">Mixin是一种工具，通过使用<code class="du mt mu mv mk b">include</code>、<code class="du mt mu mv mk b">prepend</code>和<code class="du mt mu mv mk b">extend</code>关键字，可以在另一个模块或类中调用一个模块。</p></blockquote><h2 id="26b6" class="mo iy hi bd iz ns nt nu jd nv nw nx jh jy ny nz jj kc oa ob jl kg oc od jn oe bi translated">包括:</h2><figure class="mf mg mh mi fd lt"><div class="bz dy l di"><div class="mw mx l"/></div></figure><p id="a43b" class="pw-post-body-paragraph jp jq hi jr b js ky ij ju jv kz im jx jy la ka kb kc lb ke kf kg lc ki kj kk hb bi translated">这里，我们在模块<code class="du mt mu mv mk b"><em class="me">Mod</em></code>的范围之外创建了一个类<code class="du mt mu mv mk b"><em class="me">Klass</em></code> <em class="me"> </em>，我们将<code class="du mt mu mv mk b"><em class="me">Mod</em></code>模块的实例方法作为实例提供给类 <code class="du mt mu mv mk b"><strong class="jr hj"><em class="me">Klass</em></strong></code> <strong class="jr hj">。</strong></p><p id="a96b" class="pw-post-body-paragraph jp jq hi jr b js ky ij ju jv kz im jx jy la ka kb kc lb ke kf kg lc ki kj kk hb bi translated">当我们对类<code class="du mt mu mv mk b">Klass</code>调用<code class="du mt mu mv mk b">.<em class="me">ancestors</em></code>方法时，它给出了类<code class="du mt mu mv mk b"><em class="me">Klass</em></code> <em class="me"> </em>从<em class="me">继承的类和模块的列表。</em></p><p id="ba88" class="pw-post-body-paragraph jp jq hi jr b js ky ij ju jv kz im jx jy la ka kb kc lb ke kf kg lc ki kj kk hb bi translated">在<em class="me"> </em>之前，我们<em class="me"> </em>调用<code class="du mt mu mv mk b"><em class="me">include</em></code>，类<code class="du mt mu mv mk b"><em class="me">Klass</em></code>直接从<code class="du mt mu mv mk b"><em class="me">Object</em></code> <em class="me">，</em>继承，但是在<code class="du mt mu mv mk b"><em class="me">include</em></code>调用之后，类<code class="du mt mu mv mk b"><em class="me">Klass</em></code>现在直接从模块<code class="du mt mu mv mk b"><em class="me">Mod</em></code>继承。</p><p id="9c66" class="pw-post-body-paragraph jp jq hi jr b js ky ij ju jv kz im jx jy la ka kb kc lb ke kf kg lc ki kj kk hb bi translated"><strong class="jr hj"/><code class="du mt mu mv mk b"><strong class="jr hj">include</strong></code><strong class="jr hj">关键字将声明的模块的方法添加到声明为实例方法的类中。</strong></p><p id="d0d8" class="pw-post-body-paragraph jp jq hi jr b js ky ij ju jv kz im jx jy la ka kb kc lb ke kf kg lc ki kj kk hb bi translated">换句话说:</p><p id="0654" class="pw-post-body-paragraph jp jq hi jr b js ky ij ju jv kz im jx jy la ka kb kc lb ke kf kg lc ki kj kk hb bi translated"><strong class="jr hj"/><code class="du mt mu mv mk b"><strong class="jr hj"><em class="me">include</em></strong></code><strong class="jr hj">关键字使<em class="me">模块</em>成为<em class="me">类的父模块，它在祖先链中声明了</em>。</strong></p><p id="2c21" class="pw-post-body-paragraph jp jq hi jr b js ky ij ju jv kz im jx jy la ka kb kc lb ke kf kg lc ki kj kk hb bi translated">因此，当我们将一个<em class="me">实例方法</em>调用到类<code class="du mt mu mv mk b"><em class="me">Klass</em></code> <em class="me">，</em>时，它们会在它们的父模块<code class="du mt mu mv mk b"><em class="me">Mod</em></code>中找到一个<em class="me">实例方法</em>并给出输出。</p><p id="2596" class="pw-post-body-paragraph jp jq hi jr b js ky ij ju jv kz im jx jy la ka kb kc lb ke kf kg lc ki kj kk hb bi translated"><strong class="jr hj">但是，模块方法只对</strong> <code class="du mt mu mv mk b"><strong class="jr hj"><em class="me">Mod</em></strong></code> <strong class="jr hj">模块本身可用。</strong></p><p id="c49e" class="pw-post-body-paragraph jp jq hi jr b js ky ij ju jv kz im jx jy la ka kb kc lb ke kf kg lc ki kj kk hb bi translated">现在，如果我们在一个<em class="me">类</em>中<code class="du mt mu mv mk b"><em class="me">include</em></code>两个不同的模块具有相同的“<em class="me">method _ name”</em>会怎么样呢？</p><figure class="mf mg mh mi fd lt"><div class="bz dy l di"><div class="mw mx l"/></div></figure><p id="8104" class="pw-post-body-paragraph jp jq hi jr b js ky ij ju jv kz im jx jy la ka kb kc lb ke kf kg lc ki kj kk hb bi translated">从第一个模块直接导入的第二个模块。</p><p id="cbeb" class="pw-post-body-paragraph jp jq hi jr b js ky ij ju jv kz im jx jy la ka kb kc lb ke kf kg lc ki kj kk hb bi translated">所以当我们调用<code class="du mt mu mv mk b"><em class="me">method_1</em></code>时，它将首先查看它是否在类<code class="du mt mu mv mk b"><em class="me">Klass</em></code>中可用，然后它将在层次结构中向上一步到模块<code class="du mt mu mv mk b"><em class="me">Mod_2</em></code>以找到<em class="me">方法</em>，它在那里找到它并给出输出。</p><p id="40ea" class="pw-post-body-paragraph jp jq hi jr b js ky ij ju jv kz im jx jy la ka kb kc lb ke kf kg lc ki kj kk hb bi translated">如果我们从<code class="du mt mu mv mk b"><em class="me">Mod_1</em></code>中移除<code class="du mt mu mv mk b"><em class="me">method_1</em></code>，这不会给出任何不同的输出，因为它不会去那里寻找<em class="me">方法</em>，然而，如果我们从<code class="du mt mu mv mk b"><em class="me">Mod_2</em></code>中移除<code class="du mt mu mv mk b"><em class="me">method_1</em></code>，那么它会在<code class="du mt mu mv mk b"><em class="me">Mod_1</em></code>中找到<code class="du mt mu mv mk b"><em class="me">method_1</em></code>并给出它的输出。</p><h2 id="9277" class="mo iy hi bd iz ns nt nu jd nv nw nx jh jy ny nz jj kc oa ob jl kg oc od jn oe bi translated"><strong class="ak">前置</strong></h2><figure class="mf mg mh mi fd lt"><div class="bz dy l di"><div class="mw mx l"/></div></figure><p id="bfa5" class="pw-post-body-paragraph jp jq hi jr b js ky ij ju jv kz im jx jy la ka kb kc lb ke kf kg lc ki kj kk hb bi translated"><strong class="jr hj"/><code class="du mt mu mv mk b"><strong class="jr hj"><em class="me">prepend</em></strong></code><strong class="jr hj">关键字使<em class="me">模块</em>成为<em class="me">类的子模块，它在祖先链中被声明为</em>。</strong></p><p id="806c" class="pw-post-body-paragraph jp jq hi jr b js ky ij ju jv kz im jx jy la ka kb kc lb ke kf kg lc ki kj kk hb bi translated">或者，</p><p id="ea94" class="pw-post-body-paragraph jp jq hi jr b js ky ij ju jv kz im jx jy la ka kb kc lb ke kf kg lc ki kj kk hb bi translated"><strong class="jr hj">声明</strong> <code class="du mt mu mv mk b"><strong class="jr hj">prepend</strong></code> <strong class="jr hj">关键字的类是被声明模块的父类。</strong></p><p id="82a9" class="pw-post-body-paragraph jp jq hi jr b js ky ij ju jv kz im jx jy la ka kb kc lb ke kf kg lc ki kj kk hb bi translated">因此，当我给出一个在<em class="me">模块</em>和<em class="me">类</em>中都可用的<em class="me">方法</em>时，它将首先在<em class="me">模块</em>中查找，作为其祖先链中的第一个成员。</p><h2 id="90b9" class="mo iy hi bd iz ns nt nu jd nv nw nx jh jy ny nz jj kc oa ob jl kg oc od jn oe bi translated"><strong class="ak">延长</strong></h2><figure class="mf mg mh mi fd lt"><div class="bz dy l di"><div class="mw mx l"/></div></figure><p id="ecee" class="pw-post-body-paragraph jp jq hi jr b js ky ij ju jv kz im jx jy la ka kb kc lb ke kf kg lc ki kj kk hb bi translated"><strong class="jr hj"/><code class="du mt mu mv mk b"><strong class="jr hj">extend</strong></code><strong class="jr hj">关键字将声明模块的实例方法添加到声明为类方法的类中。</strong></p><p id="080b" class="pw-post-body-paragraph jp jq hi jr b js ky ij ju jv kz im jx jy la ka kb kc lb ke kf kg lc ki kj kk hb bi translated">或者，</p><p id="3511" class="pw-post-body-paragraph jp jq hi jr b js ky ij ju jv kz im jx jy la ka kb kc lb ke kf kg lc ki kj kk hb bi translated"><strong class="jr hj"/><code class="du mt mu mv mk b"><strong class="jr hj">extend</strong></code><strong class="jr hj">关键字使m <em class="me">模块</em>的<em class="me">实例方法</em>成为<em class="me">实例方法</em>到<em class="me">单例类</em>的一个实例方法，其中</strong> <code class="du mt mu mv mk b"><strong class="jr hj">extend</strong></code> <strong class="jr hj">在<em class="me">中声明。</em> </strong></p><p id="1b4c" class="pw-post-body-paragraph jp jq hi jr b js ky ij ju jv kz im jx jy la ka kb kc lb ke kf kg lc ki kj kk hb bi translated">换句话说，</p><p id="3df2" class="pw-post-body-paragraph jp jq hi jr b js ky ij ju jv kz im jx jy la ka kb kc lb ke kf kg lc ki kj kk hb bi translated"><strong class="jr hj"/><code class="du mt mu mv mk b"><strong class="jr hj">extend</strong></code><strong class="jr hj">关键字带来了<em class="me">实例方法</em>中的一个</strong><code class="du mt mu mv mk b"><strong class="jr hj">Mod</strong></code><strong class="jr hj">，作为<em class="me">单体方法</em>的</strong> <code class="du mt mu mv mk b"><strong class="jr hj">Klass</strong></code> <strong class="jr hj">。</strong></p><pre class="mf mg mh mi fd mj mk ml mm aw mn bi"><span id="ec68" class="mo iy hi mk b fi mp mq l mr ms">Klass.singleton_methods  <br/># =&gt; [:method_1]</span></pre><p id="68ac" class="pw-post-body-paragraph jp jq hi jr b js ky ij ju jv kz im jx jy la ka kb kc lb ke kf kg lc ki kj kk hb bi translated">类<code class="du mt mu mv mk b"><em class="me">Klass</em></code>的祖先链没有受到影响，但是<em class="me">单例类</em>的祖先链受到影响...</p><pre class="mf mg mh mi fd mj mk ml mm aw mn bi"><span id="9a35" class="mo iy hi mk b fi mp mq l mr ms">p Klass.singleton_class.ancestors</span><span id="4a21" class="mo iy hi mk b fi of mq l mr ms">[#&lt;Class:Klass&gt;, Mod, #&lt;Class:Object&gt;, #&lt;Class:BasicObject&gt;, Class, Module, Object, Kernel, BasicObject]</span></pre><p id="2e82" class="pw-post-body-paragraph jp jq hi jr b js ky ij ju jv kz im jx jy la ka kb kc lb ke kf kg lc ki kj kk hb bi translated">模块<code class="du mt mu mv mk b"><em class="me">Mod</em></code> <em class="me"> </em>是<em class="me"> </em>单例类<code class="du mt mu mv mk b"><em class="me">Class:Klass</em></code>的父类。所以当我们调用<code class="du mt mu mv mk b"><em class="me">Klass.method_1</em></code>时，我们正在从单例类、<code class="du mt mu mv mk b">Class:Klass.</code>中访问<code class="du mt mu mv mk b"><em class="me">method_1</em></code> <em class="me"/></p></div><div class="ab cl km kn gp ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="hb hc hd he hf"><h1 id="cf1d" class="ix iy hi bd iz ja kt jc jd je ku jg jh io kv ip jj ir kw is jl iu kx iv jn jo bi translated">从不同文件访问模块</h1><p id="6047" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">这个我在这篇<a class="ae kl" href="https://juzer-shakir.medium.com/accessing-module-in-root-in-ruby-8eb46dbb38e1" rel="noopener">文章</a>里已经详细解释过了。</p></div><div class="ab cl km kn gp ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="hb hc hd he hf"><h1 id="1bea" class="ix iy hi bd iz ja kt jc jd je ku jg jh io kv ip jj ir kw is jl iu kx iv jn jo bi translated">额外资源</h1><p id="1277" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated"><strong class="jr hj">前置的真实例子:</strong></p><div class="og oh ez fb oi oj"><a href="https://chunksofco.de/rubys-prepend-how-is-it-useful-d3bba8d11a95" rel="noopener  ugc nofollow" target="_blank"><div class="ok ab dw"><div class="ol ab om cl cj on"><h2 class="bd hj fi z dy oo ea eb op ed ef hh bi translated">Ruby的Prepend:它是如何有用的？</h2><div class="oq l"><h3 class="bd b fi z dy oo ea eb op ed ef dx translated">用一个真实的例子</h3></div><div class="or l"><p class="bd b fp z dy oo ea eb op ed ef dx translated">chunksofco.de</p></div></div><div class="os l"><div class="ot l ou ov ow os ox ly oj"/></div></div></a></div><p id="f2d9" class="pw-post-body-paragraph jp jq hi jr b js ky ij ju jv kz im jx jy la ka kb kc lb ke kf kg lc ki kj kk hb bi translated"><strong class="jr hj"> Rubys的内置模块有:</strong></p><div class="og oh ez fb oi oj"><a href="https://juzer-shakir.medium.com/enumerable-module-in-ruby-7cb0e42d4b3f" rel="noopener follow" target="_blank"><div class="ok ab dw"><div class="ol ab om cl cj on"><h2 class="bd hj fi z dy oo ea eb op ed ef hh bi translated">Ruby中的一个可枚举模块</h2><div class="oq l"><h3 class="bd b fi z dy oo ea eb op ed ef dx translated">Ruby提供了丰富的方法资源，可供类使用。</h3></div><div class="or l"><p class="bd b fp z dy oo ea eb op ed ef dx translated">juzer-shakir.medium.com</p></div></div><div class="os l"><div class="oy l ou ov ow os ox ly oj"/></div></div></a></div><div class="og oh ez fb oi oj"><a rel="noopener follow" target="_blank" href="/kode-art/everything-is-comparable-in-ruby-cf9ab5e8252f"><div class="ok ab dw"><div class="ol ab om cl cj on"><h2 class="bd hj fi z dy oo ea eb op ed ef hh bi translated">在Ruby中，一切都是“可比的”</h2><div class="oq l"><h3 class="bd b fi z dy oo ea eb op ed ef dx translated">欢迎😉</h3></div><div class="or l"><p class="bd b fp z dy oo ea eb op ed ef dx translated">medium.com</p></div></div><div class="os l"><div class="oz l ou ov ow os ox ly oj"/></div></div></a></div></div><div class="ab cl km kn gp ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="hb hc hd he hf"><p id="c234" class="pw-post-body-paragraph jp jq hi jr b js ky ij ju jv kz im jx jy la ka kb kc lb ke kf kg lc ki kj kk hb bi translated">欢迎对本文提出任何建议或编辑！谢谢大家！</p><p id="3fc5" class="pw-post-body-paragraph jp jq hi jr b js ky ij ju jv kz im jx jy la ka kb kc lb ke kf kg lc ki kj kk hb bi translated"><strong class="jr hj">我上一篇:</strong><a class="ae kl" href="https://juzer-shakir.medium.com/class-and-its-different-methods-in-ruby-ea8e919c87a4" rel="noopener">Ruby中的一个类</a> <br/> <strong class="jr hj">我下一篇:</strong><a class="ae kl" href="https://juzer-shakir.medium.com/enumerable-module-in-ruby-7cb0e42d4b3f" rel="noopener">Ruby中的一个可枚举模块</a></p></div><div class="ab cl km kn gp ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="hb hc hd he hf"><p id="a493" class="pw-post-body-paragraph jp jq hi jr b js ky ij ju jv kz im jx jy la ka kb kc lb ke kf kg lc ki kj kk hb bi translated"><a class="ae kl" href="https://github.com/JuzerShakir" rel="noopener ugc nofollow" target="_blank"><strong class="jr hj">GitHub</strong></a>|<a class="ae kl" href="https://www.linkedin.com/in/juzershakir/" rel="noopener ugc nofollow" target="_blank"><strong class="jr hj">领英</strong> </a></p></div></div>    
</body>
</html>