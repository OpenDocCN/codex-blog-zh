<html>
<head>
<title>Algorithmic Trading with the Disparity Index in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中带差异指数的算法交易</h1>
<blockquote>原文：<a href="https://medium.com/codex/algorithmic-trading-with-the-disparity-index-in-python-24a0479c452b?source=collection_archive---------0-----------------------#2021-06-06">https://medium.com/codex/algorithmic-trading-with-the-disparity-index-in-python-24a0479c452b?source=collection_archive---------0-----------------------#2021-06-06</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="b27d" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">在Python中编码和回溯测试一个强大的指示器</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/dcb2a397a4701eb905d227c45430811c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*XIlbTqrKmCSqXRuo"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">杰佛森·桑多斯在<a class="ae jn" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="959d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">有大量的技术指标用于交易目的，但是如此挑剔的交易者最终只会选择其中的一小部分，我们今天要讨论的指标无疑会增加这个列表。看，差距指数。在本文中，我们将首先讨论差异指数是什么，该指标背后的数学原理，然后，我们将继续进行编码部分，首先使用Python从头构建该指标，基于它构建一个简单的交易策略，对谷歌股票进行回溯测试，并将回报与SPY ETF(一种旨在跟踪标准普尔500市场指数走势的ETF)的回报进行比较。</p><p id="b6ed" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在继续之前，如果你想在没有任何代码的情况下回溯测试你的交易策略，有一个解决方案。这是<a class="ae jn" href="https://www.backtestzone.com/" rel="noopener ugc nofollow" target="_blank">的后验区</a>。这是一个平台，可以免费对不同类型的可交易资产的任意数量的交易策略进行回溯测试，无需编码。点击这里的链接，你可以马上使用这个工具:<a class="ae jn" href="https://www.backtestzone.com/" rel="noopener ugc nofollow" target="_blank">https://www.backtestzone.com/</a></p><h1 id="15bc" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">差异指数</h1><p id="881b" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">差异指数是一个动量指标，用于测量股票的当前收盘价与其在指定时间段内的移动平均值之间的距离，并以百分比的形式解释读数。与其他动量振荡器不同，差异指数不限制在某些水平之间，因此是一个无界振荡器。</p><p id="3eb4" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">交易者经常使用差异指数来确定市场的当前势头。如果差异指数的读数高于零，则可以观察到市场的上升势头，类似地，如果该指标的读数低于零，则认为市场处于下降势头。</p><p id="d5a9" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">视差指数的计算非常简单。首先，我们必须找出一只股票的收盘价格与指定时间段内的移动平均线之间的差值，并将该差值除以移动平均线，然后乘以100。以14作为回看周期的典型设置的视差指数的计算可以表示如下:</p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="b862" class="lm kl hi li b fi ln lo l lp lq"><strong class="li hj">DI 14</strong> = [ <strong class="li hj">C.PRICE</strong> - <strong class="li hj">MOVING  AVG 14</strong> ] / [ <strong class="li hj">MOVING AVG 14</strong> ] * <strong class="li hj">100</strong></span><span id="9ae7" class="lm kl hi li b fi lr lo l lp lq">where,<br/>DI 14 = 14-day Disparity Index<br/>MOVING AVG 14 = 14-day Moving Average<br/>C.PRICE = Closing price of the stock</span></pre><p id="05f8" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这就是计算视差指数读数的整个过程。现在，让我们来分析一个图表，其中绘制了谷歌的收盘价数据及其14天差异指数。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ls"><img src="../Images/2c09b0bb27c6575b825cb1c0bacdeb2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3UC-U9weNFaTZuGlHpnrSg.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">作者图片</figcaption></figure><p id="8fc8" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">上面的图表分为两个面板:上面的面板显示谷歌的收盘价，下面的面板显示14天差异指数的读数。从上面的图表中，我们可以看到，每当差异指数的读数高于零线时，就会绘制一个绿色直方图，表示市场中的积极或向上的势头，类似地，每当差异指数低于零线时，就会绘制一个红色直方图，表示消极或向下的势头。这是使用差异指数的一种方式。交易者使用这一指标的另一种方式是检测区间市场(价格在一定范围内来回波动，既不显示正价格也不显示负价格运动的市场)。有时，可以看到差异指数的棒线在零线的两侧来回移动，表明市场正在调整或盘整。该指标的这一特性在交易时对交易者来说很方便(对我个人来说)。</p><p id="fc89" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">据我所知，有两种基于差异指数的交易策略。第一个是突破策略，交易者假设两个极端水平绘制在图的两侧，这种策略在差异指数低于较低水平时显示买入信号，类似地，当差异指数高于较高水平时产生卖出信号。这些阈值因资产而异，因为差异指数是一个无界振荡器。第二个是零线交叉策略，当差异指数从零线以下到零线以上时显示买入信号，当差异指数从零线以上到零线以下时产生卖出信号。</p><p id="1ef0" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在本文中，我们将实施第二种策略，即零线交叉策略，但由于视差指数易于揭示大量错误信号，我们将调整传统的交叉策略。只有当过去四个读数低于零线，当前读数高于零线时，我们调整的策略才会显示买入信号。同样，只有在过去四个读数高于零线，当前读数低于零线时，才会产生卖出。这样做将大大减少该策略产生的错误信号的数量，从而提高其性能。我们调整后的零线交叉交易策略可以表示如下:</p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="e118" class="lm kl hi li b fi ln lo l lp lq">IF <strong class="li hj">PREV.4 DIs</strong> &lt; <strong class="li hj">ZERO-LINE </strong>AND <strong class="li hj">CURR.DI</strong> &gt; <strong class="li hj">ZERO-LINE</strong> ==&gt; <strong class="li hj">BUY SIGNAL</strong><br/>IF <strong class="li hj">PREV.4 DIs</strong> &gt; <strong class="li hj">ZERO-LINE</strong> AND <strong class="li hj">CURR.DI</strong> &lt; <strong class="li hj">ZERO-LINE</strong> ==&gt; <strong class="li hj">SELL SIGNAL</strong></span></pre><p id="f4f1" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这就结束了我们关于差异指数的理论部分。现在，让我们转到编程部分，首先从头开始构建指标，构建我们刚刚讨论过的调整过的零线交叉策略，然后将我们的策略与Python中SPY ETF的性能进行比较。来做点编码吧！在继续之前，关于免责声明的一个注意事项:本文的唯一目的是教育人们，必须被视为一个信息，而不是投资建议等。</p><h1 id="6c3d" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">用Python实现</h1><p id="f130" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">编码部分分为以下几个步骤:</p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="1065" class="lm kl hi li b fi ln lo l lp lq"><strong class="li hj">1. Importing Packages<br/>2. Extracting Stock Data from Twelve Data<br/>3. Disparity Index Calculation<br/>4. Creating the Tuned Zero-line Crossover Trading Strategy<br/>5. Plotting the Trading Lists<br/>6. Creating our Position<br/>7. Backtesting<br/>8. SPY ETF Comparison</strong></span></pre><p id="efd7" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们将按照上面列表中提到的顺序，系好安全带，跟随每一个即将到来的编码部分。</p><h2 id="2faa" class="lm kl hi bd km lt lu lv kq lw lx ly ku jx lz ma kw kb mb mc ky kf md me la mf bi translated">步骤1:导入包</h2><p id="946d" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">将所需的包导入python环境是一个不可跳过的步骤。主要的包是处理数据的Pandas，处理数组和复杂函数的NumPy，用于绘图的Matplotlib，以及进行API调用的请求。二级包是数学函数的Math和字体定制的Termcolor(可选)。</p><p id="2f4e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> Python实现:</strong></p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="6f25" class="lm kl hi li b fi ln lo l lp lq"><strong class="li hj"># IMPORTING PACKAGES<br/></strong><br/>import numpy as np<br/>import requests<br/>import pandas as pd<br/>import matplotlib.pyplot as plt<br/>from math import floor<br/>from termcolor import colored as cl<br/><br/>plt.style.use('fivethirtyeight')<br/>plt.rcParams['figure.figsize'] = (20,10)</span></pre><p id="a48e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在我们已经将所有需要的包导入到python中。我们用十二数据的API端点来拉一下Google的历史数据。</p><h2 id="c6f6" class="lm kl hi bd km lt lu lv kq lw lx ly ku jx lz ma kw kb mb mc ky kf md me la mf bi translated">步骤2:从12个数据中提取数据</h2><p id="cdbc" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">在这一步中，我们将使用twelvedata.com<a class="ae jn" href="https://twelvedata.com/" rel="noopener ugc nofollow" target="_blank">提供的API端点提取谷歌的历史股票数据。在此之前，关于</a><a class="ae jn" href="https://twelvedata.com/" rel="noopener ugc nofollow" target="_blank">twelvedata.com</a>的一个说明:十二数据是领先的市场数据提供商之一，拥有大量针对所有类型市场数据的API端点。它非常容易与十二数据提供的API进行交互，并且拥有有史以来最好的文档。此外，确保您在<a class="ae jn" href="https://twelvedata.com/" rel="noopener ugc nofollow" target="_blank">twelvedata.com</a>上有一个帐户，只有这样，您才能访问您的API密钥(使用API提取数据的重要元素)。</p><p id="b990" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> Python实现:</strong></p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="0e8a" class="lm kl hi li b fi ln lo l lp lq"><strong class="li hj"># EXTRACTING STOCK DATA<br/></strong><br/>def get_historical_data(symbol, start_date):<br/>    api_key = 'YOUR API KEY'<br/>    api_url = f'https://api.twelvedata.com/time_series?symbol={symbol}&amp;interval=1day&amp;outputsize=5000&amp;apikey={api_key}'<br/>    raw_df = requests.get(api_url).json()<br/>    df = pd.DataFrame(raw_df['values']).iloc[::-1].set_index('datetime').astype(float)<br/>    df = df[df.index &gt;= start_date]<br/>    df.index = pd.to_datetime(df.index)<br/>    return df<br/><br/>googl = get_historical_data('GOOGL', '2020-01-01')<br/>googl.tail()</span></pre><p id="62f4" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">输出:</strong></p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mg"><img src="../Images/356910b380ae909454542b7f51671ab1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uyOmehdsWn9M8r2lLyjRyQ.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">作者图片</figcaption></figure><p id="1ba9" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">代码解释:</strong>我们做的第一件事是定义一个名为‘get _ historical _ data’的函数，它以股票的符号(‘symbol’)和历史数据的起始日期(‘start _ date’)作为参数。在函数内部，我们定义了API键和URL，并将它们存储到各自的变量中。接下来，我们使用“get”函数提取JSON格式的历史数据，并将其存储到“raw_df”变量中。在对原始JSON数据进行清理和格式化之后，我们将以干净的Pandas数据帧的形式返回它。最后，我们调用创建的函数来提取Google从2020年开始的历史数据，并将其存储到“googl”变量中。</p><h2 id="b8c7" class="lm kl hi bd km lt lu lv kq lw lx ly ku jx lz ma kw kb mb mc ky kf md me la mf bi translated">步骤3:视差指数计算</h2><p id="d5b2" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">在这一步中，我们将按照之前讨论的公式计算视差指数的读数。</p><p id="3821" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> Python实现:</strong></p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="3321" class="lm kl hi li b fi ln lo l lp lq"><strong class="li hj"># DISPARITY INDEX CALCULATION<br/></strong><br/>def get_di(data, lookback):<br/>    ma = data.rolling(lookback).mean()<br/>    di = ((data - ma) / ma) * 100<br/>    return di<br/><br/>googl['di_14'] = get_di(googl['close'], 14)<br/>googl = googl.dropna()<br/>googl.tail()</span></pre><p id="2643" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">输出:</strong></p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mh"><img src="../Images/d894bc67aa00ab93c08f8bd564275ac6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8PNJXoPjZPz0lqzhXBpyCg.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">作者图片</figcaption></figure><p id="3813" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">代码解释:</strong>首先，我们定义一个名为“get_di”的函数，它将股票的收盘价(“数据”)和回望期作为参数。在函数中，我们首先计算指定数量的回望期的收盘价数据的移动平均值。然后，我们将确定的值代入视差指数公式来计算读数。最后，我们返回并调用创建的函数来存储Google的14天差异指数读数。</p><h2 id="6f17" class="lm kl hi bd km lt lu lv kq lw lx ly ku jx lz ma kw kb mb mc ky kf md me la mf bi translated">步骤4:创建交易策略</h2><p id="5255" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">在这一步中，我们将在python中实现所讨论的差异指数调整的零线交叉交易策略。</p><p id="f3e1" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> Python实现:</strong></p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="6f9d" class="lm kl hi li b fi ln lo l lp lq"><strong class="li hj"># DISPARITY INDEX STRATEGY<br/></strong><br/>def implement_di_strategy(prices, di):<br/>    buy_price = []<br/>    sell_price = []<br/>    di_signal = []<br/>    signal = 0<br/>    <br/>    for i in range(len(prices)):<br/>        if di[i-4] &lt; 0 and di[i-3] &lt; 0 and di[i-2] &lt; 0 and di[i-1] &lt; 0 and di[i] &gt; 0:<br/>            if signal != 1:<br/>                buy_price.append(prices[i])<br/>                sell_price.append(np.nan)<br/>                signal = 1<br/>                di_signal.append(signal)<br/>            else:<br/>                buy_price.append(np.nan)<br/>                sell_price.append(np.nan)<br/>                di_signal.append(0)<br/>        elif di[i-4] &gt; 0 and di[i-3] &gt; 0 and di[i-2] &gt; 0 and di[i-1] &gt; 0 and di[i] &lt; 0:<br/>            if signal != -1:<br/>                buy_price.append(np.nan)<br/>                sell_price.append(prices[i])<br/>                signal = -1<br/>                di_signal.append(signal)<br/>            else:<br/>                buy_price.append(np.nan)<br/>                sell_price.append(np.nan)<br/>                di_signal.append(0)<br/>        else:<br/>            buy_price.append(np.nan)<br/>            sell_price.append(np.nan)<br/>            di_signal.append(0)<br/>            <br/>    return buy_price, sell_price, di_signal<br/><br/>buy_price, sell_price, di_signal = implement_di_strategy(googl['close'], googl['di_14'])</span></pre><p id="ac56" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">代码解释:</strong>首先，我们定义一个名为“implement_di_strategy”的函数，它将股票价格(“prices”)和差异指数(“di”)的读数作为参数。</p><p id="9210" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在该函数中，我们创建了三个空列表(buy_price、sell_price和di_signal ),在创建交易策略时，将在这些列表中追加值。</p><p id="4910" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">之后，我们通过for循环实施交易策略。在for循环内部，我们传递某些条件，如果条件得到满足，相应的值将被追加到空列表中。如果购买股票的条件得到满足，买入价将被追加到“buy_price”列表中，信号值将被追加为1，表示购买股票。类似地，如果卖出股票的条件得到满足，卖价将被追加到“sell_price”列表中，信号值将被追加为-1，表示卖出股票。</p><p id="98a5" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">最后，我们返回附加了值的列表。然后，我们调用创建的函数并将值存储到各自的变量中。除非我们画出这些值，否则这个列表没有任何意义。所以，让我们画出创建的交易列表的值。</p><h2 id="f20c" class="lm kl hi bd km lt lu lv kq lw lx ly ku jx lz ma kw kb mb mc ky kf md me la mf bi translated">第五步:绘制交易信号</h2><p id="f57d" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">在这一步，我们将绘制已创建的交易列表，以使它们有意义。</p><p id="978d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> Python实现:</strong></p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="6dd9" class="lm kl hi li b fi ln lo l lp lq"><strong class="li hj"># DISPARITY INDEX TRADING SIGNALS PLOT<br/></strong><br/>ax1 = plt.subplot2grid((11,1), (0,0), rowspan = 5, colspan = 1)<br/>ax2 = plt.subplot2grid((11,1), (6,0), rowspan = 5, colspan = 1)<br/>ax1.plot(googl['close'], linewidth = 2, color = '#1976d2')<br/>ax1.plot(googl.index, buy_price, marker = '^', markersize = 12, linewidth = 0, label = 'BUY SIGNAL', color = 'green')<br/>ax1.plot(googl.index, sell_price, marker = 'v', markersize = 12, linewidth = 0, label = 'SELL SIGNAL', color = 'r')<br/>ax1.legend()<br/>ax1.set_title('GOOGL CLOSING PRICES')<br/>for i in range(len(googl)):<br/>    if googl.iloc[i, 5] &gt;= 0:<br/>        ax2.bar(googl.iloc[i].name, googl.iloc[i, 5], color = '#26a69a')<br/>    else:    <br/>        ax2.bar(googl.iloc[i].name, googl.iloc[i, 5], color = '#ef5350')<br/>ax2.set_title('GOOGL DISPARITY INDEX 14')<br/>plt.show()</span></pre><p id="c860" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">输出:</strong></p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ls"><img src="../Images/49cdd53fd5662b2b911a49628f34d6c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XC2v2ock2wV0MwunBEMr4g.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">作者图片</figcaption></figure><p id="b698" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">代码解释:</strong>我们正在绘制差异指数的读数，以及由调整后的零线交叉交易策略产生的买入和卖出信号。我们可以观察到，每当差异指数的前四个读数低于零线，而当前读数高于零线时，就会在图表中绘制绿色的买入信号。类似地，每当差异指数的前四个读数高于零线，而当前读数低于零线时，图表中就会显示红色的卖出信号。</p><h2 id="15b1" class="lm kl hi bd km lt lu lv kq lw lx ly ku jx lz ma kw kb mb mc ky kf md me la mf bi translated">步骤6:创建我们的职位</h2><p id="733c" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">在这一步中，我们将创建一个列表，如果我们持有股票，该列表将指示1；如果我们不拥有或持有股票，该列表将指示0。</p><p id="f381" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> Python实现:</strong></p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="a140" class="lm kl hi li b fi ln lo l lp lq"><strong class="li hj"># STOCK POSITION<br/></strong><br/>position = []<br/>for i in range(len(di_signal)):<br/>    if di_signal[i] &gt; 1:<br/>        position.append(0)<br/>    else:<br/>        position.append(1)<br/>        <br/>for i in range(len(googl['close'])):<br/>    if di_signal[i] == 1:<br/>        position[i] = 1<br/>    elif di_signal[i] == -1:<br/>        position[i] = 0<br/>    else:<br/>        position[i] = position[i-1]<br/>        <br/>close_price = googl['close']<br/>di = googl['di_14']<br/>di_signal = pd.DataFrame(di_signal).rename(columns = {0:'di_signal'}).set_index(googl.index)<br/>position = pd.DataFrame(position).rename(columns = {0:'di_position'}).set_index(googl.index)<br/><br/>frames = [close_price, di, di_signal, position]<br/>strategy = pd.concat(frames, join = 'inner', axis = 1)<br/><br/>strategy.head()</span></pre><p id="e051" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">输出:</strong></p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mi"><img src="../Images/54ee4b3613b992001215f4a0f5f256bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JarLzMUz4EG8qgm4LK5maA.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">作者图片</figcaption></figure><p id="68c4" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">代码解释:</strong>首先，我们创建一个名为‘position’的空列表。我们传递两个for循环，一个是为“位置”列表生成值，以匹配“信号”列表的长度。另一个for循环是我们用来生成实际位置值的循环。在第二个for循环中，我们对“signal”列表的值进行迭代，而“position”列表的值被附加到满足哪个条件上。如果我们持有股票，头寸的价值仍为1；如果我们卖出或不持有股票，头寸的价值仍为0。最后，我们正在进行一些数据操作，将所有创建的列表合并到一个数据帧中。</p><p id="fe2d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">从显示的输出中，我们可以看到，在前三行中，我们在股票中的位置保持为1(因为差异指数信号没有任何变化)，但当差异指数交易信号代表卖出信号(-1)时，我们的位置突然变为-1。我们的头寸将保持为0，直到交易信号发生一些变化。现在是时候实现一些回溯测试过程了！</p><h2 id="0a56" class="lm kl hi bd km lt lu lv kq lw lx ly ku jx lz ma kw kb mb mc ky kf md me la mf bi translated">步骤7:回溯测试</h2><p id="4215" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">在继续之前，有必要知道什么是回溯测试。回溯测试是查看我们的交易策略在给定股票数据上表现如何的过程。在我们的例子中，我们将对Google股票数据的差异指数交易策略实施回溯测试过程。</p><p id="e44c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> Python实现:</strong></p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="2049" class="lm kl hi li b fi ln lo l lp lq"><strong class="li hj"># BACKTESTING<br/></strong><br/>googl_ret = pd.DataFrame(np.diff(googl['close'])).rename(columns = {0:'returns'})<br/>di_strategy_ret = []<br/><br/>for i in range(len(googl_ret)):<br/>    returns = googl_ret['returns'][i]*strategy['di_position'][i]<br/>    di_strategy_ret.append(returns)<br/>    <br/>di_strategy_ret_df = pd.DataFrame(di_strategy_ret).rename(columns = {0:'di_returns'})<br/>investment_value = 100000<br/>number_of_stocks = floor(investment_value/googl['close'][0])<br/>di_investment_ret = []<br/><br/>for i in range(len(di_strategy_ret_df['di_returns'])):<br/>    returns = number_of_stocks*di_strategy_ret_df['di_returns'][i]<br/>    di_investment_ret.append(returns)<br/><br/>di_investment_ret_df = pd.DataFrame(di_investment_ret).rename(columns = {0:'investment_returns'})<br/>total_investment_ret = round(sum(di_investment_ret_df['investment_returns']), 2)<br/>profit_percentage = floor((total_investment_ret/investment_value)*100)<br/>print(cl('Profit gained from the DI strategy by investing $100k in GOOGL : {}'.format(total_investment_ret), attrs = ['bold']))<br/>print(cl('Profit percentage of the DI strategy : {}%'.format(profit_percentage), attrs = ['bold']))</span></pre><p id="d968" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">输出:</strong></p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="0d9d" class="lm kl hi li b fi ln lo l lp lq"><strong class="li hj">Profit gained from the DI strategy by investing $100k in GOOGL : 39933.68</strong><br/><strong class="li hj">Profit percentage of the DI strategy : 39%</strong></span></pre><p id="dc5d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">代码解释:</strong>首先，我们使用NumPy包提供的“diff”函数计算谷歌股票的回报，并将其作为数据帧存储到“googl_ret”变量中。接下来，我们传递一个for循环来迭代' googl_ret '变量的值，以计算我们从差异指数交易策略中获得的回报，这些回报值被附加到' di_strategy_ret '列表中。接下来，我们将“di_strategy_ret”列表转换为数据帧，并将其存储到“di_strategy_ret_df”变量中。</p><p id="6a41" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">接下来是回溯测试过程。我们将通过投资10万美元到我们的交易策略中来回测我们的策略。首先，我们将投资金额存储到“投资值”变量中。之后，我们正在计算使用投资金额可以购买的谷歌股票数量。你可以注意到，我使用了Math软件包提供的“下限”函数，因为当投资金额除以谷歌股票的收盘价时，它会输出一个十进制数。股票数量应该是整数，而不是小数。使用“底数”函数，我们可以去掉小数。请记住,“floor”函数比“round”函数要复杂得多。然后，我们传递一个for循环来查找投资回报，后面是一些数据操作任务。</p><p id="1ca5" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">最后，我们打印了我们通过投资10万到我们的交易策略中得到的总回报，并且显示我们在一年中获得了大约38，000美元的利润。那还不错！现在，让我们将我们的回报与SPY ETF(一种旨在跟踪标准普尔500股票市场指数的ETF)的回报进行比较。</p><h2 id="d7b3" class="lm kl hi bd km lt lu lv kq lw lx ly ku jx lz ma kw kb mb mc ky kf md me la mf bi translated">第八步:间谍ETF对比</h2><p id="f54d" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">这一步是可选的，但强烈推荐，因为我们可以了解我们的交易策略相对于基准(间谍ETF)的表现如何。在这一步中，我们将使用我们创建的“get_historical_data”函数提取SPY ETF数据，并将我们从SPY ETF获得的回报与我们在Google上调整的差异指数零线交叉交易策略回报进行比较。</p><p id="7e37" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">你可能已经注意到，在我所有的算法交易文章中，我没有将策略结果与标准普尔500市场指数本身进行比较，而是与SPY ETF进行比较，这是因为大多数股票数据提供商(如12 Data)不提供标准普尔500指数数据。所以，我别无选择，只能选择间谍ETF。如果你有幸得到标准普尔500市场指数数据，建议用它来做比较，而不是任何ETF。</p><p id="cd91" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> Python实现:</strong></p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="a84a" class="lm kl hi li b fi ln lo l lp lq"><strong class="li hj"># SPY ETF COMPARISON<br/></strong><br/>def get_benchmark(start_date, investment_value):<br/>    spy = get_historical_data('SPY', start_date)['close']<br/>    benchmark = pd.DataFrame(np.diff(spy)).rename(columns = {0:'benchmark_returns'})<br/>    <br/>    investment_value = investment_value<br/>    number_of_stocks = floor(investment_value/spy[-1])<br/>    benchmark_investment_ret = []<br/>    <br/>    for i in range(len(benchmark['benchmark_returns'])):<br/>        returns = number_of_stocks*benchmark['benchmark_returns'][i]<br/>        benchmark_investment_ret.append(returns)<br/><br/>    benchmark_investment_ret_df = pd.DataFrame(benchmark_investment_ret).rename(columns = {0:'investment_returns'})<br/>    return benchmark_investment_ret_df<br/><br/>benchmark = get_benchmark('2020-01-01', 100000)<br/>investment_value = 100000<br/>total_benchmark_investment_ret = round(sum(benchmark['investment_returns']), 2)<br/>benchmark_profit_percentage = floor((total_benchmark_investment_ret/investment_value)*100)<br/>print(cl('Benchmark profit by investing $100k : {}'.format(total_benchmark_investment_ret), attrs = ['bold']))<br/>print(cl('Benchmark Profit percentage : {}%'.format(benchmark_profit_percentage), attrs = ['bold']))<br/>print(cl('DI Strategy profit is {}% higher than the Benchmark Profit'.format(profit_percentage - benchmark_profit_percentage), attrs = ['bold']))</span></pre><p id="864d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">输出:</strong></p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="220c" class="lm kl hi li b fi ln lo l lp lq"><strong class="li hj">Benchmark profit by investing $100k : 23026.52</strong><br/><strong class="li hj">Benchmark Profit percentage : 23%</strong><br/><strong class="li hj">DI Strategy profit is 16% higher than the Benchmark Profit</strong></span></pre><p id="3594" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">代码解释:</strong>此步骤中使用的代码几乎与前一个回溯测试步骤中使用的代码相似，但我们不是投资谷歌，而是通过不实施任何交易策略来投资SPY ETF。从输出可以看出，我们的视差指数调优零线交叉交易策略已经跑赢SPY ETF 16%。太好了！</p><h1 id="bb44" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">最后的想法！</h1><p id="08ee" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">在彻底粉碎了理论和编程部分之后，我们已经成功地了解了差异指数是什么，它背后的数学原理，最后，如何从零开始构建该指标用Python构建了一个基于它的调整过的零线交叉交易策略。尽管我们设法建立了一个盈利的策略，但这篇文章仍有许多可以改进的地方，其中一个重要的地方就是构建一个更现实的策略。</p><p id="b20b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们在本文中实现的程序、步骤和代码可能适用于虚拟交易，但现实世界的市场不会以同样的方式运行，为了在这种情况下蓬勃发展，有必要通过考虑更多外部因素来构建我们的策略，如每次交易涉及的风险、每次交易收取的佣金或费用，以及最重要的市场情绪。</p><p id="7559" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">即使建立了一个现实的策略，这个过程也没有结束，但是有必要知道这个策略是否是一个有利可图的策略或者仅仅是浪费时间。为了确定战略的盈利能力和绩效，必须用各种度量标准对其进行回溯测试和评估。这将是文章可以改进的下一个空间。</p><p id="3104" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">如果你完成了这些即兴创作，你就可以将它们应用到现实世界的市场中，你盈利的可能性很高。话虽如此，你已经到了文章的结尾。如果您忘记了遵循任何编码部分，不要担心。我在最后提供了完整的源代码。希望你能从这篇文章中学到一些新的有用的东西。</p><h2 id="f9f6" class="lm kl hi bd km lt lu lv kq lw lx ly ku jx lz ma kw kb mb mc ky kf md me la mf bi translated">完整代码:</h2><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="65b1" class="lm kl hi li b fi ln lo l lp lq"># IMPORTING PACKAGES<br/><br/>import numpy as np<br/>import requests<br/>import pandas as pd<br/>import matplotlib.pyplot as plt<br/>from math import floor<br/>from termcolor import colored as cl<br/><br/>plt.style.use('fivethirtyeight')<br/>plt.rcParams['figure.figsize'] = (20,10)<br/><br/><br/># EXTRACTING STOCK DATA<br/><br/>def get_historical_data(symbol, start_date):<br/>    api_key = 'YOUr API KEY'<br/>    api_url = f'https://api.twelvedata.com/time_series?symbol={symbol}&amp;interval=1day&amp;outputsize=5000&amp;apikey={api_key}'<br/>    raw_df = requests.get(api_url).json()<br/>    df = pd.DataFrame(raw_df['values']).iloc[::-1].set_index('datetime').astype(float)<br/>    df = df[df.index &gt;= start_date]<br/>    df.index = pd.to_datetime(df.index)<br/>    return df<br/><br/>googl = get_historical_data('GOOGL', '2020-01-01')<br/>print(googl.tail())<br/><br/><br/># DISPARITY INDEX CALCULATION<br/><br/>def get_di(data, lookback):<br/>    ma = data.rolling(lookback).mean()<br/>    di = ((data - ma) / ma) * 100<br/>    return di<br/><br/>googl['di_14'] = get_di(googl['close'], 14)<br/>googl = googl.dropna()<br/>print(googl.tail())<br/><br/><br/># DISPARITY INDEX PLOT<br/><br/>ax1 = plt.subplot2grid((11,1), (0,0), rowspan = 5, colspan = 1)<br/>ax2 = plt.subplot2grid((11,1), (6,0), rowspan = 5, colspan = 1)<br/>ax1.plot(googl['close'], linewidth = 2, color = '#1976d2')<br/>ax1.set_title('GOOGL CLOSING PRICES')<br/>for i in range(len(googl)):<br/>    if googl.iloc[i, 5] &gt;= 0:<br/>        ax2.bar(googl.iloc[i].name, googl.iloc[i, 5], color = '#26a69a')<br/>    else:    <br/>        ax2.bar(googl.iloc[i].name, googl.iloc[i, 5], color = '#ef5350')<br/>ax2.set_title('GOOGL DISPARITY INDEX 14')<br/>plt.show()<br/><br/><br/># DISPARITY INDEX STRATEGY<br/><br/>def implement_di_strategy(prices, di):<br/>    buy_price = []<br/>    sell_price = []<br/>    di_signal = []<br/>    signal = 0<br/>    <br/>    for i in range(len(prices)):<br/>        if di[i-4] &lt; 0 and di[i-3] &lt; 0 and di[i-2] &lt; 0 and di[i-1] &lt; 0 and di[i] &gt; 0:<br/>            if signal != 1:<br/>                buy_price.append(prices[i])<br/>                sell_price.append(np.nan)<br/>                signal = 1<br/>                di_signal.append(signal)<br/>            else:<br/>                buy_price.append(np.nan)<br/>                sell_price.append(np.nan)<br/>                di_signal.append(0)<br/>        elif di[i-4] &gt; 0 and di[i-3] &gt; 0 and di[i-2] &gt; 0 and di[i-1] &gt; 0 and di[i] &lt; 0:<br/>            if signal != -1:<br/>                buy_price.append(np.nan)<br/>                sell_price.append(prices[i])<br/>                signal = -1<br/>                di_signal.append(signal)<br/>            else:<br/>                buy_price.append(np.nan)<br/>                sell_price.append(np.nan)<br/>                di_signal.append(0)<br/>        else:<br/>            buy_price.append(np.nan)<br/>            sell_price.append(np.nan)<br/>            di_signal.append(0)<br/>            <br/>    return buy_price, sell_price, di_signal<br/><br/>buy_price, sell_price, di_signal = implement_di_strategy(googl['close'], googl['di_14'])<br/><br/><br/># DISPARITY INDEX TRADING SIGNALS PLOT<br/><br/>ax1 = plt.subplot2grid((11,1), (0,0), rowspan = 5, colspan = 1)<br/>ax2 = plt.subplot2grid((11,1), (6,0), rowspan = 5, colspan = 1)<br/>ax1.plot(googl['close'], linewidth = 2, color = '#1976d2')<br/>ax1.plot(googl.index, buy_price, marker = '^', markersize = 12, linewidth = 0, label = 'BUY SIGNAL', color = 'green')<br/>ax1.plot(googl.index, sell_price, marker = 'v', markersize = 12, linewidth = 0, label = 'SELL SIGNAL', color = 'r')<br/>ax1.legend()<br/>ax1.set_title('GOOGL CLOSING PRICES')<br/>for i in range(len(googl)):<br/>    if googl.iloc[i, 5] &gt;= 0:<br/>        ax2.bar(googl.iloc[i].name, googl.iloc[i, 5], color = '#26a69a')<br/>    else:    <br/>        ax2.bar(googl.iloc[i].name, googl.iloc[i, 5], color = '#ef5350')<br/>ax2.set_title('GOOGL DISPARITY INDEX 14')<br/>plt.show()<br/><br/><br/># STOCK POSITION<br/><br/>position = []<br/>for i in range(len(di_signal)):<br/>    if di_signal[i] &gt; 1:<br/>        position.append(0)<br/>    else:<br/>        position.append(1)<br/>        <br/>for i in range(len(googl['close'])):<br/>    if di_signal[i] == 1:<br/>        position[i] = 1<br/>    elif di_signal[i] == -1:<br/>        position[i] = 0<br/>    else:<br/>        position[i] = position[i-1]<br/>        <br/>close_price = googl['close']<br/>di = googl['di_14']<br/>di_signal = pd.DataFrame(di_signal).rename(columns = {0:'di_signal'}).set_index(googl.index)<br/>position = pd.DataFrame(position).rename(columns = {0:'di_position'}).set_index(googl.index)<br/><br/>frames = [close_price, di, di_signal, position]<br/>strategy = pd.concat(frames, join = 'inner', axis = 1)<br/><br/>print(strategy.head())<br/><br/><br/># BACKTESTING<br/><br/>googl_ret = pd.DataFrame(np.diff(googl['close'])).rename(columns = {0:'returns'})<br/>di_strategy_ret = []<br/><br/>for i in range(len(googl_ret)):<br/>    returns = googl_ret['returns'][i]*strategy['di_position'][i]<br/>    di_strategy_ret.append(returns)<br/>    <br/>di_strategy_ret_df = pd.DataFrame(di_strategy_ret).rename(columns = {0:'di_returns'})<br/>investment_value = 100000<br/>number_of_stocks = floor(investment_value/googl['close'][0])<br/>di_investment_ret = []<br/><br/>for i in range(len(di_strategy_ret_df['di_returns'])):<br/>    returns = number_of_stocks*di_strategy_ret_df['di_returns'][i]<br/>    di_investment_ret.append(returns)<br/><br/>di_investment_ret_df = pd.DataFrame(di_investment_ret).rename(columns = {0:'investment_returns'})<br/>total_investment_ret = round(sum(di_investment_ret_df['investment_returns']), 2)<br/>profit_percentage = floor((total_investment_ret/investment_value)*100)<br/>print(cl('Profit gained from the DI strategy by investing $100k in GOOGL : {}'.format(total_investment_ret), attrs = ['bold']))<br/>print(cl('Profit percentage of the DI strategy : {}%'.format(profit_percentage), attrs = ['bold']))<br/><br/><br/># SPY ETF COMPARISON<br/><br/>def get_benchmark(start_date, investment_value):<br/>    spy = get_historical_data('SPY', start_date)['close']<br/>    benchmark = pd.DataFrame(np.diff(spy)).rename(columns = {0:'benchmark_returns'})<br/>    <br/>    investment_value = investment_value<br/>    number_of_stocks = floor(investment_value/spy[-1])<br/>    benchmark_investment_ret = []<br/>    <br/>    for i in range(len(benchmark['benchmark_returns'])):<br/>        returns = number_of_stocks*benchmark['benchmark_returns'][i]<br/>        benchmark_investment_ret.append(returns)<br/><br/>    benchmark_investment_ret_df = pd.DataFrame(benchmark_investment_ret).rename(columns = {0:'investment_returns'})<br/>    return benchmark_investment_ret_df<br/><br/>benchmark = get_benchmark('2020-01-01', 100000)<br/><br/>investment_value = 100000<br/>total_benchmark_investment_ret = round(sum(benchmark['investment_returns']), 2)<br/>benchmark_profit_percentage = floor((total_benchmark_investment_ret/investment_value)*100)<br/>print(cl('Benchmark profit by investing $100k : {}'.format(total_benchmark_investment_ret), attrs = ['bold']))<br/>print(cl('Benchmark Profit percentage : {}%'.format(benchmark_profit_percentage), attrs = ['bold']))<br/>print(cl('DI Strategy profit is {}% higher than the Benchmark Profit'.format(profit_percentage - benchmark_profit_percentage), attrs = ['bold']))</span></pre></div></div>    
</body>
</html>