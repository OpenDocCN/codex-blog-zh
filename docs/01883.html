<html>
<head>
<title>Ruby Refinements — a use case</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Ruby精化——一个用例</h1>
<blockquote>原文：<a href="https://medium.com/codex/ruby-refinements-a-use-case-184f905e39ee?source=collection_archive---------2-----------------------#2021-06-11">https://medium.com/codex/ruby-refinements-a-use-case-184f905e39ee?source=collection_archive---------2-----------------------#2021-06-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/ad5c99080f02d992663750337cb94161.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I2EgfoSmrMBW9Q-OUtsa6A.jpeg"/></div></div></figure><h1 id="5626" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">方案</h1><p id="4ddb" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">在这个特定的场景中，我们有一组Ruby构造来处理存储在YAML文件中的域常量(业务值)。我肯定你见过类似的。对于这个例子，假设我们有一个文件，它定义了许多货币常量，用于Money gem。该构造的接口有点笨拙，要获得特定货币的底层“代码”——在领域语言中缩写为<code class="du km kn ko kp b">foo</code>——您需要做以下事情:</p><pre class="kq kr ks kt fd ku kp kv kw aw kx bi"><span id="a44c" class="ky ir hi kp b fi kz la l lb lc">DomainConstants.generic_types.currencies.foo</span></pre><p id="e0a8" class="pw-post-body-paragraph jo jp hi jq b jr ld jt ju jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl hb bi translated">确切的命名和层次结构并不重要——这只是一个例子——重要的是它有点笨拙。</p><p id="bc94" class="pw-post-body-paragraph jo jp hi jq b jr ld jt ju jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl hb bi translated">碰巧的是，还有另外两种“通用”货币类型叫做<code class="du km kn ko kp b">bar</code>和<code class="du km kn ko kp b">baz</code>:</p><pre class="kq kr ks kt fd ku kp kv kw aw kx bi"><span id="8ee1" class="ky ir hi kp b fi kz la l lb lc">DomainConstants.generic_types.currencies.bar</span><span id="269c" class="ky ir hi kp b fi li la l lb lc">DomainConstants.generic_types.currencies.baz</span></pre><p id="84e5" class="pw-post-body-paragraph jo jp hi jq b jr ld jt ju jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl hb bi translated">在整个代码中，每当处理货币实例化和定义<code class="du km kn ko kp b">Money</code>属性时，都会引用这些通用货币:</p><figure class="kq kr ks kt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lj"><img src="../Images/c4297fd9ebd0b8d7eebd3a608d7e06c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TFMbw9h4UiMHWHwwVZhajQ.png"/></div></div><figcaption class="lk ll et er es lm ln bd b be z dx translated">我在这里使用了一个图像来演示没有换行的代码</figcaption></figure><p id="bd07" class="pw-post-body-paragraph jo jp hi jq b jr ld jt ju jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl hb bi translated">…坦白地说，这很难看。此外，在Rubocop对你摇手指来修正你的行长度之前，只需要在一行上进行几次货币操作。</p><h1 id="1838" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">给我一些糖…</h1><p id="a8d9" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">这里真正好的是一些语法糖来整理一些东西:</p><ul class=""><li id="e789" class="lo lp hi jq b jr ld jv le jz lq kd lr kh ls kl lt lu lv lw bi translated">首先，<code class="du km kn ko kp b">DomainConstants.generic_types.currencies.foo</code>需要更加简洁。<code class="du km kn ko kp b">currency_foo</code>将会很好地解决这个问题，同时保留这个术语的“可搜索性”。</li><li id="c9c8" class="lo lp hi jq b jr lx jv ly jz lz kd ma kh mb kl lt lu lv lw bi translated">第二，所有这些数字类型到特定货币的转换会容易得多。Ruby是一种动态的OO语言，难道不能这样做:<code class="du km kn ko kp b">123.to_foo</code>？</li></ul><h2 id="aa05" class="ky ir hi bd is mc md me iw mf mg mh ja jz mi mj je kd mk ml ji kh mm mn jm mo bi translated">实现“currency_foo”</h2><p id="f345" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">实现货币方法的第一步可能是创建一个模块，它可以包含在需要这些方法的任何地方:</p><pre class="kq kr ks kt fd ku kp kv kw aw kx bi"><span id="ecd7" class="ky ir hi kp b fi kz la l lb lc">class MyModel<br/>  monetize :amount_pennies, with_currency: DomainConstants.generic_types.currencies.foo<br/>  <br/>  def some_method<br/>    123.to_money(DomainConstants.generic_types.currencies.foo)<br/>  end<br/>end</span></pre><p id="5995" class="pw-post-body-paragraph jo jp hi jq b jr ld jt ju jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl hb bi translated">可能会变成:</p><pre class="kq kr ks kt fd ku kp kv kw aw kx bi"><span id="e98a" class="ky ir hi kp b fi kz la l lb lc">module GenericCurrencies<br/>  DomainConstants.generic_types.currencies.each do |name, cur_id|<br/>    define_method "currency_#{name}" do<br/>      Money::Currency.new(cur_id)<br/>    end<br/>  end<br/>end</span><span id="e835" class="ky ir hi kp b fi li la l lb lc"><br/>class MyModel<br/><strong class="kp hj">  include GenericCurrencies</strong><br/><br/>  monetize :amount_pennies, with_currency: <strong class="kp hj">currency_foo</strong><br/>  def some_method<br/>    123.to_money(<strong class="kp hj">currency_foo</strong>)<br/>  end<br/>end</span></pre><p id="341f" class="pw-post-body-paragraph jo jp hi jq b jr ld jt ju jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl hb bi translated">那已经看起来好多了！</p><p id="6b17" class="pw-post-body-paragraph jo jp hi jq b jr ld jt ju jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl hb bi translated">但是有一个问题:<code class="du km kn ko kp b">monetize :amount_pennies, with_currency: currency_foo</code>导致了<code class="du km kn ko kp b">NameError</code>，因为新的货币方法只在<em class="mp">实例</em>上可用。如果我们使用的是ActiveSupport，那么这个问题很容易解决。否则，我们需要稍微修改一下，让这些方法也进入类范围，但这是一个已经解决的问题，没什么大不了的。</p><h2 id="3fa3" class="ky ir hi bd is mc md me iw mf mg mh ja jz mi mj je kd mk ml ji kh mm mn jm mo bi translated">我们的‘to _ foo’方法怎么样？</h2><p id="8c74" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">这样我们就可以:</p><pre class="kq kr ks kt fd ku kp kv kw aw kx bi"><span id="3c09" class="ky ir hi kp b fi kz la l lb lc">def some_method<br/>  123.<strong class="kp hj">to_foo</strong><br/>end</span></pre><p id="13ad" class="pw-post-body-paragraph jo jp hi jq b jr ld jt ju jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl hb bi translated">嗯，我们可以通过扩展<code class="du km kn ko kp b">Numeric</code>很容易地实现这一点:</p><pre class="kq kr ks kt fd ku kp kv kw aw kx bi"><span id="9eaa" class="ky ir hi kp b fi kz la l lb lc">class Numeric<br/>  DomainConstants.generic_types.currencies.each do |name, value|<br/>    define_method “to_#{name}” do<br/>      to_money(value)<br/>    end<br/>  end<br/>end</span></pre></div><div class="ab cl mq mr gp ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="hb hc hd he hf"><p id="5297" class="pw-post-body-paragraph jo jp hi jq b jr ld jt ju jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl hb bi translated">那么我们如何看待我们的第一次尝试呢？</p><p id="0319" class="pw-post-body-paragraph jo jp hi jq b jr ld jt ju jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl hb bi translated">从好的方面来看，我们已经(在某种程度上)解决了这个问题。</p><p id="1bb5" class="pw-post-body-paragraph jo jp hi jq b jr ld jt ju jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl hb bi translated">不利的一面是，我们不得不扩展<code class="du km kn ko kp b">Numeric</code>,使这些货币方法在应用程序中的所有数字上都可用。也许没关系，但是我觉得有点脏。</p><p id="7ec0" class="pw-post-body-paragraph jo jp hi jq b jr ld jt ju jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl hb bi translated">此外，包含一个模块并不总是给我们预期的行为。例如，在这段代码中:</p><pre class="kq kr ks kt fd ku kp kv kw aw kx bi"><span id="b5a0" class="ky ir hi kp b fi kz la l lb lc">class MyModel<br/>  include GenericCurrencies<br/><br/>  monetize :amount_pennies, with_currency: currency_foo</span><span id="96cc" class="ky ir hi kp b fi li la l lb lc"><strong class="kp hj">  tricksy_type :gotcha do<br/>    currency_bar<br/>  end</strong></span><span id="5718" class="ky ir hi kp b fi li la l lb lc">  def some_method<br/>    123.to_foo<br/>  end<br/>end</span></pre><p id="6bad" class="pw-post-body-paragraph jo jp hi jq b jr ld jt ju jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl hb bi translated">从表面上看，这似乎是可行的。但是当代码运行时，我们在传递给<code class="du km kn ko kp b">tricksy_type</code>的块中得到一个<code class="du km kn ko kp b">NameError</code>。结果是，<code class="du km kn ko kp b">tricksy_type</code>使用一些元编程来评估它自己上下文中的给定块，所以<code class="du km kn ko kp b">currency_foo</code>不可用。解决这个问题将是一件令人头疼的事情。这就是使用模块来提供语法糖的根本缺点。</p><h1 id="b5f7" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">为什么应该避免模块</h1><p id="deaf" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">从上面的例子可以看出，包含一个模块会带来一些问题。将模块包含到类中会将其方法引入到该类的任何实例中。在这些实例中，可以在没有显式接收者的情况下调用方法，例如:</p><pre class="kq kr ks kt fd ku kp kv kw aw kx bi"><span id="cdc2" class="ky ir hi kp b fi kz la l lb lc"> currency_foo</span></pre><p id="8494" class="pw-post-body-paragraph jo jp hi jq b jr ld jt ju jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl hb bi translated">除非它们是私有的，否则这些方法也可以从实例外部、从代码中的任何地方调用，例如:</p><pre class="kq kr ks kt fd ku kp kv kw aw kx bi"><span id="a762" class="ky ir hi kp b fi kz la l lb lc">model_instance.currency_foo</span></pre><p id="3851" class="pw-post-body-paragraph jo jp hi jq b jr ld jt ju jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl hb bi translated">虽然这是相当无害的，但它仍然是我们不希望看到的副作用。<strong class="jq hj">我们不打算在模型中添加行为；仅在代码</strong>中提供一种DSL。</p><p id="7e60" class="pw-post-body-paragraph jo jp hi jq b jr ld jt ju jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl hb bi translated">此外，从上面的<code class="du km kn ko kp b">monetize</code>和<code class="du km kn ko kp b">tricksy_type</code>情况可以看出，在作用域的顶部包含一个模块并不一定会使它的方法在需要的地方可用。我们希望在词法范围内得到一些语法上的好处，但最终我们不得不与运行时上下文和Ruby复杂的对象模型搏斗。</p><h1 id="5f1b" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">输入细化</h1><p id="181b" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">事不宜迟，让我们直接进入代码；解决方案已经摆在我们面前，解释起来会更容易:</p><pre class="kq kr ks kt fd ku kp kv kw aw kx bi"><span id="d50b" class="ky ir hi kp b fi kz la l lb lc">module GenericCurrencies<br/>  DomainConstants.generic_types.currencies.each do |name, cur_id|<br/>    currency = Money::Currency.new(cur_id) # N.B. a closure<br/><br/>    <strong class="kp hj">refine Object</strong> do<br/>      define_method "currency_#{name}" do<br/>        currency<br/>      end<br/>    end<br/><br/>    <strong class="kp hj">refine Numeric</strong> do<br/>      define_method "to_#{name}" do<br/>        to_money(currency)<br/>      end<br/>    end<br/>  end<br/>end</span></pre><p id="0ed1" class="pw-post-body-paragraph jo jp hi jq b jr ld jt ju jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl hb bi translated">这是它使用时的样子:</p><pre class="kq kr ks kt fd ku kp kv kw aw kx bi"><span id="06b0" class="ky ir hi kp b fi kz la l lb lc">class MyModel<br/>  <strong class="kp hj">using GenericCurrencies</strong><br/><br/>  monetize :amount_pennies, with_currency: currency_foo <strong class="kp hj"># works fine</strong></span><span id="48ba" class="ky ir hi kp b fi li la l lb lc">  tricksy_type :gotcha do<br/>    currency_bar <strong class="kp hj"># works fine</strong><br/>  end</span><span id="25cf" class="ky ir hi kp b fi li la l lb lc">  def some_method<br/>    123.to_foo <strong class="kp hj"># works fine</strong><br/>  end</span><span id="64fa" class="ky ir hi kp b fi li la l lb lc"><strong class="kp hj">  </strong>def self.<em class="mp">baz_other</em>(<em class="mp">other</em>)<br/>    <em class="mp">other</em>.currency_baz<strong class="kp hj"> # works fine</strong><br/>  end<br/>end</span><span id="3d3f" class="ky ir hi kp b fi li la l lb lc"><em class="mp">model </em>= <em class="mp">MyModel</em>.new<br/><em class="mp">model</em>.some_method        # works fine<br/><em class="mp">MyModel</em>.baz_other(<em class="mp">model</em>) # works fine<br/><br/><em class="mp">model</em>.currency_baz       # ERROR! `currency_baz` not defined!<br/>123.to_foo               # ERROR! `to_foo` not defined!</span></pre><p id="9b57" class="pw-post-body-paragraph jo jp hi jq b jr ld jt ju jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl hb bi translated">简单地通过在类的顶部引入<code class="du km kn ko kp b">using GenericCurrencies</code>，我们似乎已经满足了我们所有的语法糖渴望。更重要的是，我们已经设法不在代码中的任何地方用非预期的方法污染任何对象！</p><p id="b53c" class="pw-post-body-paragraph jo jp hi jq b jr ld jt ju jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl hb bi translated">我们是怎么做到的？</p><p id="b1a6" class="pw-post-body-paragraph jo jp hi jq b jr ld jt ju jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl hb bi translated">精化的奇妙之处在于它们有<strong class="jq hj">词法范围</strong>。词法范围与<em class="mp">编写的</em>代码的结构有关；而不是执行代码的<em class="mp">的结构。所以无论你打电话到哪里:</em></p><pre class="kq kr ks kt fd ku kp kv kw aw kx bi"><span id="f2d2" class="ky ir hi kp b fi kz la l lb lc">using GenericCurrencies</span></pre><p id="e070" class="pw-post-body-paragraph jo jp hi jq b jr ld jt ju jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl hb bi translated">…然后在<code class="du km kn ko kp b">GenericCurrencies</code>中定义的细化在包含的词法范围内(在<code class="du km kn ko kp b">using</code>调用之后)变得活跃，无论它是一个类、一个模块还是一个完整的文件！(注意:细化不能在方法范围内激活)。</p><p id="9e52" class="pw-post-body-paragraph jo jp hi jq b jr ld jt ju jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl hb bi translated">让我们从<code class="du km kn ko kp b">to_foo</code>方法开始(减去元编程):</p><pre class="kq kr ks kt fd ku kp kv kw aw kx bi"><span id="f9b4" class="ky ir hi kp b fi kz la l lb lc"><strong class="kp hj">refine Numeric</strong> do<br/>  def <strong class="kp hj">to_foo</strong><br/>    to_money(:foo)<br/>  end<br/>end</span></pre><p id="afd1" class="pw-post-body-paragraph jo jp hi jq b jr ld jt ju jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl hb bi translated">这意味着，对于该细化活动范围内的任何代码，从<code class="du km kn ko kp b">Numeric</code>(即<code class="du km kn ko kp b">Integer</code>、<code class="du km kn ko kp b">Float</code>等)开始下降的任何类型的对象。)将响应<code class="du km kn ko kp b">to_foo</code>并返回它的<code class="du km kn ko kp b">Money</code>等价物。</p><p id="a90e" class="pw-post-body-paragraph jo jp hi jq b jr ld jt ju jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl hb bi translated">在这个精化活动的范围之外，这个方法消失了！</p><p id="7011" class="pw-post-body-paragraph jo jp hi jq b jr ld jt ju jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl hb bi translated">那<code class="du km kn ko kp b">currency_foo</code>呢？</p><pre class="kq kr ks kt fd ku kp kv kw aw kx bi"><span id="6c07" class="ky ir hi kp b fi kz la l lb lc"><strong class="kp hj">refine Object</strong> do<br/>  def <strong class="kp hj">currency_foo</strong><br/>    :foo<br/>  end<br/>end</span></pre><p id="84a1" class="pw-post-body-paragraph jo jp hi jq b jr ld jt ju jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl hb bi translated">通过细化<code class="du km kn ko kp b">Object</code>，任何从<code class="du km kn ko kp b">Object</code>下降的类型的对象都会响应<code class="du km kn ko kp b">currency_foo</code>，也就是所有对象……包括<code class="du km kn ko kp b">Class</code>！(除了少数从<code class="du km kn ko kp b">BasicObject</code>下来的。)这就是为什么我们能够在类和实例范围内调用<code class="du km kn ko kp b">currency_foo</code>。</p><p id="d9bb" class="pw-post-body-paragraph jo jp hi jq b jr ld jt ju jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl hb bi translated">当在没有显式接收者的情况下调用<code class="du km kn ko kp b">currency_foo</code>时，它被解释为对<code class="du km kn ko kp b">self</code>的方法调用，然后沿着祖先链向上寻找定义；当它遇到<code class="du km kn ko kp b">Object</code>细化时找到它。包含一个模块做了一件非常类似的事情——它将方法定义添加到祖先链中——只是稍微低一点，并且是针对该对象的生命周期。</p><p id="b2f2" class="pw-post-body-paragraph jo jp hi jq b jr ld jt ju jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl hb bi translated">但是给<code class="du km kn ko kp b">Object</code>添加方法难道不是一件<em class="mp">坏事</em>吗？</p><p id="bedf" class="pw-post-body-paragraph jo jp hi jq b jr ld jt ju jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl hb bi translated">在我看来，对于这个用例，<em class="mp">没有</em>。每件事都有时间和地点，对我来说，能够将简单的DSL引入一段代码的优势——直观且具有可预测的效果——超过了我可能对<code class="du km kn ko kp b">Object</code>的任何轻微担忧。</p></div><div class="ab cl mq mr gp ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="hb hc hd he hf"><p id="f513" class="pw-post-body-paragraph jo jp hi jq b jr ld jt ju jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl hb bi translated">如果你还没有发现精化的用途，那么我希望这能给你一些启发。有时候你会发现一种模式。这个对我来说就是。</p></div></div>    
</body>
</html>