<html>
<head>
<title>East-West (service-to-service) Communication — What is Service Mesh? And why do we need it over Kubernetes?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">东西方(服务到服务)通信—什么是服务网格？为什么我们需要它而不是Kubernetes？</h1>
<blockquote>原文：<a href="https://medium.com/codex/east-west-service-to-service-communication-what-is-service-mesh-4e56f94bc89c?source=collection_archive---------2-----------------------#2022-07-31">https://medium.com/codex/east-west-service-to-service-communication-what-is-service-mesh-4e56f94bc89c?source=collection_archive---------2-----------------------#2022-07-31</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="e549" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">根据2022年5月发布的<a class="ae ix" href="https://www.cncf.io/wp-content/uploads/2022/05/CNCF_Service_Mesh_MicroSurvey_Final.pdf" rel="noopener ugc nofollow" target="_blank"> CNCF调查</a>——服务网格正在增加，但需要更多的了解。这篇文章试图阐明服务网格如何支持服务间通信&amp;为什么它们如此受欢迎。</h2></div><figure class="iz ja jb jc fd jd er es paragraph-image"><div role="button" tabindex="0" class="je jf di jg bf jh"><div class="er es iy"><img src="../Images/ef54a020847f767dde019a6a7fafc02f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dJuZ9qAlHdbiwsn4HewpUA.png"/></div></div><figcaption class="jk jl et er es jm jn bd b be z dx translated">显示服务呼叫的服务网格(Linkerd)仪表板</figcaption></figure><p id="f81a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在我以前的文章“<a class="ae ix" rel="noopener" href="/codex/east-west-communication-in-kubernetes-how-do-services-communicate-within-a-cluster-310e9dc9dd53">Kubernetes中的东西(服务到服务)通信——集群中的服务如何通信？</a>“我写了Kubernetes对使用服务发现的服务到服务通信的本地支持，pods的持久抽象&amp;基本负载平衡。虽然它可能适用于一些较简单的工作负载，但对于安全性、性能&amp;可用性至关重要的许多其他工作负载来说，它可能不是理想的解决方案。因此，许多组织要么建立自己的平台，要么寻求现成的产品。</p><blockquote class="kk kl km"><p id="e438" class="jo jp kn jq b jr js ij jt ju jv im jw ko jy jz ka kp kc kd ke kq kg kh ki kj hb bi translated">正如云计算领导者Kelsey Hightower所言——“Kubernetes是一个用于构建平台的平台。这是一个更好的起点；而不是最后阶段。”</p></blockquote><figure class="iz ja jb jc fd jd"><div class="bz dy l di"><div class="kr ks l"/></div></figure><p id="a3b9" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">因此，让我们看看服务网格是如何使它成为服务到服务通信的最终目标的。</p><h2 id="0c71" class="kt ku hi bd kv kw kx ky kz la lb lc ld jx le lf lg kb lh li lj kf lk ll lm ln bi translated">什么是服务网格？</h2><p id="f29c" class="pw-post-body-paragraph jo jp hi jq b jr lo ij jt ju lp im jw jx lq jz ka kb lr kd ke kf ls kh ki kj hb bi translated">顾名思义，它是服务的网络/网格。它通过消除服务的连接性问题，使网络更加智能。因此，服务可以专注于他们的主要业务，而不必担心诸如流量管理、传输中的安全性、弹性和可观察性等问题。<strong class="jq hj">把它当成一个可编程的网络。</strong></p><p id="5050" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">就层而言，可以认为它位于网络层和应用程序编程层之间。</p><figure class="iz ja jb jc fd jd er es paragraph-image"><div role="button" tabindex="0" class="je jf di jg bf jh"><div class="er es lt"><img src="../Images/5606b2f1b384ed5fd05531731f679cf3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NMSzBydo1n9RNobfA-ydaQ.png"/></div></div><figcaption class="jk jl et er es jm jn bd b be z dx translated"><strong class="bd kv">可编程网络— </strong>服务网格的分层放置</figcaption></figure><h2 id="55a5" class="kt ku hi bd kv kw kx ky kz la lb lc ld jx le lf lg kb lh li lj kf lk ll lm ln bi translated">服务网格是如何工作的？</h2><p id="cb0a" class="pw-post-body-paragraph jo jp hi jq b jr lo ij jt ju lp im jw jx lq jz ka kb lr kd ke kf ls kh ki kj hb bi translated">服务网格在<strong class="jq hj">分布式代理</strong>上工作(与边缘代理或中央代理相对)，其中代理与应用/服务(或微服务)的每个实例一起运行。该代理的目的是拦截进出应用/服务<strong class="jq hj">的所有流量。</strong>如果服务内的所有通信都通过这样的代理发生，那么所有的通信都是可观察和可操作的。</p><figure class="iz ja jb jc fd jd er es paragraph-image"><div role="button" tabindex="0" class="je jf di jg bf jh"><div class="er es lu"><img src="../Images/36c55cd8252e12f52047279fb6aebdc0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fKri6AYO8YZXOBU9qX3K7A.png"/></div></div><figcaption class="jk jl et er es jm jn bd b be z dx translated">服务网格代理拦截进出服务的流量，使其安全、可观察和可操作。</figcaption></figure><p id="3b57" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在一个容器化的世界中(比如Kubernetes)，服务的每个实例都运行在独立的容器中，而容器本身也在一个Pod中。服务网格沿着同一pod中的服务容器注入其代理容器(称为<strong class="jq hj">边车代理</strong>)。这个过程叫做<strong class="jq hj">啮合一个豆荚</strong>。</p><figure class="iz ja jb jc fd jd er es paragraph-image"><div class="er es lv"><img src="../Images/1acaf9f462c9f2d0d9f6c6b82ef938c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/format:webp/1*s7Kdfaxo3ExVsgel8CEd2w.png"/></div><figcaption class="jk jl et er es jm jn bd b be z dx translated">网状Pod —服务网状边车代理，充当拦截传入和传出流量的大使。</figcaption></figure><p id="3bfb" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">Sidecar代理是协同定位、共同管理的，并且具有与服务本身相同的生命周期。但是它产生了优雅的<strong class="jq hj">“进程外”架构</strong>，因此代理对服务是透明的。这也使得代理能够在与服务完全不同的技术中实现(例如，envoy代理在AWS应用网格中使用，Istio在C++中实现&amp; Linkerd的微代理在Rust中实现)。</p><p id="f443" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">如果你对“进程内”和“进程外”的设计感兴趣，我在之前的文章<a class="ae ix" rel="noopener" href="/codex/communication-inside-a-kubernetes-pod-why-do-we-need-multi-container-pods-3d8d0d64c2c9">中提到过。</a></p><p id="6fbd" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">分布式代理构成了服务网格的数据平面，而治理由控制平面提供。</p><h2 id="3b59" class="kt ku hi bd kv kw kx ky kz la lb lc ld jx le lf lg kb lh li lj kf lk ll lm ln bi translated">我们为什么需要它？</h2><figure class="iz ja jb jc fd jd er es paragraph-image"><div role="button" tabindex="0" class="je jf di jg bf jh"><div class="er es lw"><img src="../Images/f8b704b742ee5dc1709035fe16b89ad5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Kp5zLm4vxdCEGfCAoOAM9g.png"/></div></div><figcaption class="jk jl et er es jm jn bd b be z dx translated">服务网格通过运行代理将流量管理从Kubernetes中分离出来，从而通过提供更接近服务/应用层的抽象来管理服务间的流量、安全性和可观察性。</figcaption></figure><ol class=""><li id="af04" class="lx ly hi jq b jr js ju jv jx lz kb ma kf mb kj mc md me mf bi translated"><strong class="jq hj">安全性</strong> —在某些业务领域(如银行业)，源服务和目标服务都可以验证彼此的身份(即使它们在同一个集群中)，同时保持通信加密，这是一项安全义务。服务网格使用开箱即用的相互TLS和服务到服务的访问控制策略来减轻这种要求。</li><li id="5dbf" class="lx ly hi jq b jr mg ju mh jx mi kb mj kf mk kj mc md me mf bi translated"><strong class="jq hj">性能</strong> —更多的网络跳数并不意味着更多的延迟，神奇！在源和目的地的网状单元在单元到单元的通信中引入了2个额外的跳跃。但是与让它变慢的预期相反，实验表明使用<strong class="jq hj">智能路由算法的服务网格可以更快</strong>。下面是一个实验<a class="ae ix" href="https://linkerd.io/2017/02/01/making-things-faster-by-adding-more-steps/" rel="noopener ugc nofollow" target="_blank">https://linkerd . io/2017/02/01/making-things-fast-by-adding-more-steps/</a>。这无法与Kubernetes的循环负载平衡相比。</li><li id="96fe" class="lx ly hi jq b jr mg ju mh jx mi kb mj kf mk kj mc md me mf bi translated"><strong class="jq hj">审核和监控</strong> —因为所有流量都流经侧车代理。所有流量都是可以观察到的。服务网格可以将这些矩阵交付给仪表板，以显示实时和历史行为。</li><li id="6610" class="lx ly hi jq b jr mg ju mh jx mi kb mj kf mk kj mc md me mf bi translated"><strong class="jq hj">细粒度流量管理</strong> —在一个部署频繁的敏捷微服务世界&amp; canary版本中，服务网格实现了从旧版本到新版本服务的精确&amp;渐进流量转移。</li><li id="bd5e" class="lx ly hi jq b jr mg ju mh jx mi kb mj kf mk kj mc md me mf bi translated"><strong class="jq hj">多集群&amp;混合集群</strong> —对于服务网格，我们确实需要缝合网络。一旦连接了网络层，服务网格就从服务中抽象出集群(这是我打算在以后的文章中讨论的主题)。</li><li id="5037" class="lx ly hi jq b jr mg ju mh jx mi kb mj kf mk kj mc md me mf bi translated"><strong class="jq hj">弹性通信</strong> —服务网格带有重试策略，可以克服故障，使分布式服务工作。</li></ol><h2 id="ceb4" class="kt ku hi bd kv kw kx ky kz la lb lc ld jx le lf lg kb lh li lj kf lk ll lm ln bi translated">考虑</h2><p id="ce78" class="pw-post-body-paragraph jo jp hi jq b jr lo ij jt ju lp im jw jx lq jz ka kb lr kd ke kf ls kh ki kj hb bi translated">更多内存和CPU利用率——每个sidecar代理都需要资源。而一个边车的资源可能很少。当预期运行数千个代理时，需要进行适当的考虑。考虑到需求、未来预测和nfr，这是考虑是否应该选择一种服务网格产品而不是另一种产品的合适地方。此外，某些事件可能会触发每个侧车代理的资源利用率的临时峰值。</p><blockquote class="kk kl km"><p id="5f87" class="jo jp kn jq b jr js ij jt ju jv im jw ko jy jz ka kp kc kd ke kq kg kh ki kj hb bi translated">对于每秒通过代理的1000个请求，Envoy代理使用0.35 vCPU和40 MB内存。特使代理将2.65毫秒增加到第90个百分位数的延迟。<a class="ae ix" href="https://istio.io/latest/docs/ops/deployment/performance-and-scalability/" rel="noopener ugc nofollow" target="_blank">https://istio . io/latest/docs/ops/deployment/performance-and-scalability/</a></p></blockquote><div class="ml mm ez fb mn mo"><a href="https://linkerd.io/2021/11/29/linkerd-vs-istio-benchmarks-2021/" rel="noopener  ugc nofollow" target="_blank"><div class="mp ab dw"><div class="mq ab mr cl cj ms"><h2 class="bd hj fi z dy mt ea eb mu ed ef hh bi translated">基准测试Linkerd和Istio: 2021 Redux</h2><div class="mv l"><h3 class="bd b fi z dy mt ea eb mu ed ef dx translated">今年早些时候，我们发布了Linkerd与Istio性能指标评测，比较了…</h3></div><div class="mw l"><p class="bd b fp z dy mt ea eb mu ed ef dx translated">linkerd.io</p></div></div><div class="mx l"><div class="my l mz na nb mx nc ji mo"/></div></div></a></div><p id="c378" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">选择一种服务网格产品而不是另一种产品的其他考虑因素可能是跨多个集群、混合环境和托管服务产品的需求。</p><h2 id="2cec" class="kt ku hi bd kv kw kx ky kz la lb lc ld jx le lf lg kb lh li lj kf lk ll lm ln bi translated">摘要</h2><p id="88f3" class="pw-post-body-paragraph jo jp hi jq b jr lo ij jt ju lp im jw jx lq jz ka kb lr kd ke kf ls kh ki kj hb bi translated">Kubernetes提供资源和服务(或微服务)的生命周期，而服务网格控制服务之间的通信。服务网格不是Kubernetes特有的技术。</p><p id="8ea5" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">值得一提的是，根据对KubeKon 2020 的一些问题的回答，Kubernetes似乎可能会获得更丰富的L7功能，与服务网格的功能集有些重叠。因此，关注Kubernetes的演变是有好处的。但这仍然意味着，如果使用了诸如Istio或Linkerd之类的实现，它们将仍然有效。</p><p id="0130" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">CNCF调查的链接是<a class="ae ix" href="https://www.cncf.io/wp-content/uploads/2022/05/CNCF_Service_Mesh_MicroSurvey_Final.pdf" rel="noopener ugc nofollow" target="_blank">这里是</a>。</p></div><div class="ab cl nd ne gp nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="hb hc hd he hf"><p id="d6f0" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我希望你喜欢这篇文章，我试图使它简洁，同时涵盖了主题的广度。请让我知道你的想法。</p><p id="69de" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我在Kubernetes上的其他文章</p><p id="4e77" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><a class="ae ix" rel="noopener" href="/codex/east-west-communication-in-kubernetes-how-do-services-communicate-within-a-cluster-310e9dc9dd53">集群内的服务如何通信？</a></p><p id="f594" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><a class="ae ix" rel="noopener" href="/codex/communication-inside-a-kubernetes-pod-why-do-we-need-multi-container-pods-3d8d0d64c2c9">为什么我们需要多容器箱？</a></p><p id="3452" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><a class="ae ix" rel="noopener" href="/codex/north-south-communication-in-kubernetes-exposing-non-http-services-to-the-outside-world-4ebba4217443">在Kubernetes集群之外公开非HTTP服务的可能性有多大？</a></p><p id="8c9e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">Kubernetes中的南北沟通——客户端如何与集群内部的服务进行交流？</p></div></div>    
</body>
</html>