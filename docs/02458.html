<html>
<head>
<title>Your GraphQL starter kit</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">您的GraphQL入门套件</h1>
<blockquote>原文：<a href="https://medium.com/codex/your-graphql-starter-kit-e4aa87d84463?source=collection_archive---------13-----------------------#2021-07-21">https://medium.com/codex/your-graphql-starter-kit-e4aa87d84463?source=collection_archive---------13-----------------------#2021-07-21</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/77cf0805d00737286719f49a709d3dbf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hzbUjJqtiNOu-t8gu5ztdg.png"/></div></div></figure><p id="a61b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">前端和后端之间的通信是任何web应用程序的一个非常重要的方面。在这个例子中，我将向您展示为一个新项目实现GraphQL，甚至将它添加到一个现有项目中，并没有您想象的那么困难。</p><p id="d2a4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">使用GraphQL，可以在一次调用中获取前端特定部分所需的数据，即使数据是从多个源加载的。</p><p id="5df1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这个非常简单的小教程中，我将使用javascript，但是也支持所有主要的编程语言。</p></div><div class="ab cl jo jp gp jq" role="separator"><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt"/></div><div class="hb hc hd he hf"><p id="dc68" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">运行graphql查询需要什么？让我们用这个只有一个字段的非常简单的查询来找出答案:</p><pre class="jv jw jx jy fd jz ka kb kc aw kd bi"><span id="3eb3" class="ke kf hi ka b fi kg kh l ki kj">{<br/>  ping<br/>}</span></pre><p id="cb3a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">响应也将是单个字段:</p><pre class="jv jw jx jy fd jz ka kb kc aw kd bi"><span id="978f" class="ke kf hi ka b fi kg kh l ki kj">{<br/>  "data": {<br/>    "ping": "pong"<br/>  }<br/>}</span></pre><p id="6e1a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们需要做的第一件事是建立一个web服务器，这里我将使用<a class="ae kk" href="https://www.npmjs.com/package/express" rel="noopener ugc nofollow" target="_blank"> express </a>框架。</p><p id="465e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了允许服务器处理graphql请求，我们需要定义<em class="kl">类型</em>、<em class="kl">解析器</em>，当然，还要安装一些graphql库。</p><ol class=""><li id="c789" class="km kn hi is b it iu ix iy jb ko jf kp jj kq jn kr ks kt ku bi translated"><strong class="is hj">类型定义</strong></li></ol><p id="a3e4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">查询中的每个字段都必须与类型定义中的字段相匹配。<em class="kl">查询类型</em>对象保存所有顶级字段，这是“根”对象，我们必须定义的第一个对象。</p><pre class="jv jw jx jy fd jz ka kb kc aw kd bi"><span id="5ad3" class="ke kf hi ka b fi kg kh l ki kj">const typeDefs = gql`</span><span id="f1b8" class="ke kf hi ka b fi kv kh l ki kj">type Query {</span><span id="c5fd" class="ke kf hi ka b fi kv kh l ki kj">  ping:String</span><span id="0445" class="ke kf hi ka b fi kv kh l ki kj">}</span><span id="0d47" class="ke kf hi ka b fi kv kh l ki kj">`;</span></pre><p id="1f0c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Graphql现在知道查询“ping”应该返回一个字符串，下一步是使用解析器定义这个字符串的值。</p><p id="569b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> 2。解析器</strong></p><p id="3d98" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">解析器是一个函数，它返回要分配给特定字段的值:</p><pre class="jv jw jx jy fd jz ka kb kc aw kd bi"><span id="4c77" class="ke kf hi ka b fi kg kh l ki kj">const resolvers = {</span><span id="5b64" class="ke kf hi ka b fi kv kh l ki kj">  Query: {</span><span id="8160" class="ke kf hi ka b fi kv kh l ki kj">    ping: () =&gt; 'pong'</span><span id="8bfd" class="ke kf hi ka b fi kv kh l ki kj">  }</span><span id="d6db" class="ke kf hi ka b fi kv kh l ki kj">};</span></pre><p id="2b6b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一个解析器函数最多可以有4个参数，但是在我们的简单例子中，它们是不需要的，所以我们只使用一个箭头函数。</p><p id="07e9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> 3。Graphql服务器</strong></p><p id="3d8c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们需要安装npm包<a class="ae kk" href="https://www.npmjs.com/package/apollo-server-express" rel="noopener ugc nofollow" target="_blank"> apollo-server-express </a>和<a class="ae kk" href="https://www.npmjs.com/package/graphql" rel="noopener ugc nofollow" target="_blank"> graphql </a>。</p><pre class="jv jw jx jy fd jz ka kb kc aw kd bi"><span id="4f9c" class="ke kf hi ka b fi kg kh l ki kj">const express = require('express');</span><span id="05fd" class="ke kf hi ka b fi kv kh l ki kj">const { ApolloServer, gql } = require('apollo-server-express');</span><span id="c949" class="ke kf hi ka b fi kv kh l ki kj">const gpserver = new ApolloServer({ typeDefs, resolvers });</span><span id="b85f" class="ke kf hi ka b fi kv kh l ki kj">await gpserver.start();<br/><br/>const app = express();</span><span id="0b3f" class="ke kf hi ka b fi kv kh l ki kj">gpserver.applyMiddleware({ app });<br/><br/>await new Promise(resolve =&gt; app.listen({ port: 4000 }, resolve));</span><span id="ca3f" class="ke kf hi ka b fi kv kh l ki kj">console.log(`🚀 Server ready at <a class="ae kk" href="http://localhost:4000${server.graphqlPath}`);" rel="noopener ugc nofollow" target="_blank">http://localhost:4000${gpserver.graphqlPath}`);</a></span></pre><p id="77f3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一旦服务器启动，你可以使用工具<a class="ae kk" href="https://studio.apollographql.com/" rel="noopener ugc nofollow" target="_blank">studio.apollographql.com</a>开始发送查询。</p></div><div class="ab cl jo jp gp jq" role="separator"><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt"/></div><div class="hb hc hd he hf"><p id="c9a5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">对象vs标量</strong></p><p id="13b8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">标量是单字段数据:<em class="kl"> String </em>，<em class="kl"> Boolean </em>，<em class="kl"> ID </em>，<em class="kl"> Int </em>和<em class="kl"> Float </em>。</p><p id="47c4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一个对象可以由多个字段组成。假设我们想要创建一个杂货店的购物收据。这里，<em class="kl"> ShoppingBag </em>和<em class="kl"> ShopItem是</em>两个GraphQL对象类型，每个都有两个字段<em class="kl">。</em></p><p id="9cde" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们在根查询对象中添加一个新字段:<em class="kl"> receipt </em>，类型为<em class="kl"> ShoppingBag: </em>我们现在可以在查询中请求字段<em class="kl"> shop </em>和<em class="kl"> items </em>。</p><p id="00fb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">请注意，字段<em class="kl"> items </em>需要一个<em class="kl"> ShopItem </em>对象数组。</p><pre class="jv jw jx jy fd jz ka kb kc aw kd bi"><span id="4bf1" class="ke kf hi ka b fi kg kh l ki kj">const typeDefs = gql`<br/></span><span id="d582" class="ke kf hi ka b fi kv kh l ki kj">  type ShoppingBag {</span><span id="e4b8" class="ke kf hi ka b fi kv kh l ki kj">    shop: String</span><span id="2d71" class="ke kf hi ka b fi kv kh l ki kj">    items:[ShopItem]</span><span id="9c0a" class="ke kf hi ka b fi kv kh l ki kj">  }</span><span id="bd0c" class="ke kf hi ka b fi kv kh l ki kj">  type ShopItem {</span><span id="b92f" class="ke kf hi ka b fi kv kh l ki kj">    name: String</span><span id="0d60" class="ke kf hi ka b fi kv kh l ki kj">    price: Float</span><span id="e101" class="ke kf hi ka b fi kv kh l ki kj">  }</span><span id="8388" class="ke kf hi ka b fi kv kh l ki kj">  type Query {</span><span id="cecb" class="ke kf hi ka b fi kv kh l ki kj">    ping: String</span><span id="7699" class="ke kf hi ka b fi kv kh l ki kj">    receipt: ShoppingBag</span><span id="4bca" class="ke kf hi ka b fi kv kh l ki kj">  }</span><span id="f3c8" class="ke kf hi ka b fi kv kh l ki kj">`;</span></pre><p id="6fac" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当字段是对象类型时，Graphql总是寻找附加的解析器。这里我们需要一组ShoppingBag对象的解析器:</p><pre class="jv jw jx jy fd jz ka kb kc aw kd bi"><span id="b093" class="ke kf hi ka b fi kg kh l ki kj">const resolvers = {<br/></span><span id="84b8" class="ke kf hi ka b fi kv kh l ki kj">  Query: {</span><span id="4e57" class="ke kf hi ka b fi kv kh l ki kj">    ping: () =&gt; 'pong',</span><span id="07f8" class="ke kf hi ka b fi kv kh l ki kj">    receipt: () =&gt; {</span><span id="77b4" class="ke kf hi ka b fi kv kh l ki kj">      return { shop:"Wallmart" };</span><span id="9b5d" class="ke kf hi ka b fi kv kh l ki kj">    }</span><span id="07bf" class="ke kf hi ka b fi kv kh l ki kj">  },<br/></span><span id="bc2b" class="ke kf hi ka b fi kv kh l ki kj">  ShoppingBag: {</span><span id="247a" class="ke kf hi ka b fi kv kh l ki kj">    shop(obj){</span><span id="a993" class="ke kf hi ka b fi kv kh l ki kj">      return obj.shop;</span><span id="1234" class="ke kf hi ka b fi kv kh l ki kj">    },</span><span id="3126" class="ke kf hi ka b fi kv kh l ki kj">    items(obj){</span><span id="860d" class="ke kf hi ka b fi kv kh l ki kj">      return [ { name:"Water", price:20.5 },</span><span id="05cf" class="ke kf hi ka b fi kv kh l ki kj">               { name:"Milk", price:30.5 } ] ;</span><span id="8112" class="ke kf hi ka b fi kv kh l ki kj">    }</span><span id="e5f2" class="ke kf hi ka b fi kv kh l ki kj">  }</span><span id="426a" class="ke kf hi ka b fi kv kh l ki kj">};</span></pre><p id="f909" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">以下是我们对“购物小票”的查询:</p><pre class="jv jw jx jy fd jz ka kb kc aw kd bi"><span id="ce0d" class="ke kf hi ka b fi kg kh l ki kj">{<br/>  receipt{</span><span id="20f0" class="ke kf hi ka b fi kv kh l ki kj">    shop</span><span id="f47f" class="ke kf hi ka b fi kv kh l ki kj">    items{</span><span id="13f2" class="ke kf hi ka b fi kv kh l ki kj">      name</span><span id="0f23" class="ke kf hi ka b fi kv kh l ki kj">      price</span><span id="570d" class="ke kf hi ka b fi kv kh l ki kj">    }</span><span id="6024" class="ke kf hi ka b fi kv kh l ki kj">  }</span><span id="e2e5" class="ke kf hi ka b fi kv kh l ki kj">}</span></pre><p id="29c6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">以下是graphql的回复:</p><pre class="jv jw jx jy fd jz ka kb kc aw kd bi"><span id="9954" class="ke kf hi ka b fi kg kh l ki kj">{   <br/>  "data": {     <br/>    "receipt": {       <br/>      "shop": "Wallmart",       <br/>      "items": [         <br/>                 { "name": "Water", "price": 20.5 },<br/>                 { "name": "Milk", "price": 30.5 }       <br/>               ]    <br/>    }   <br/>  } <br/>}</span></pre><p id="106d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果有错误，它们将显示在<em class="kl">错误</em>键下，在<em class="kl">数据</em>之前。</p><p id="1879" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">数据库</strong></p><p id="910d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果您的数据存储在数据库中，您可以使用<em class="kl"> context </em>构造函数来链接您的数据库客户机，以便您可以在解析器中使用它。</p><p id="d314" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">记住:不要在解析器中使用回调，只使用承诺。</p><pre class="jv jw jx jy fd jz ka kb kc aw kd bi"><span id="5cd5" class="ke kf hi ka b fi kg kh l ki kj">const gpserver = new ApolloServer({ typeDefs, resolvers, context: async ()=&gt;({ db: dbcli }) });</span></pre><p id="83f8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">前端部分</strong></p><p id="a7f0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一旦服务器端一切就绪，您就可以使用<a class="ae kk" href="https://www.apollographql.com/docs/react/get-started/" rel="noopener ugc nofollow" target="_blank"> Apollo客户机</a>并访问react钩子来执行graphql查询。将react的强大功能与graphql相结合将允许您轻松地添加新功能。</p><p id="67fa" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">感谢您的阅读！您现在已经准备好运行您的第一个graphql查询，甚至可以开始创建您自己的类型和解析器。</p></div></div>    
</body>
</html>