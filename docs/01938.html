<html>
<head>
<title>Kotlin: Sealed Classes for better handling of API Response</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kotlin:更好处理API响应的密封类</h1>
<blockquote>原文：<a href="https://medium.com/codex/kotlin-sealed-classes-for-better-handling-of-api-response-6aa1fbd23c76?source=collection_archive---------0-----------------------#2021-06-17">https://medium.com/codex/kotlin-sealed-classes-for-better-handling-of-api-response-6aa1fbd23c76?source=collection_archive---------0-----------------------#2021-06-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/e376e2f511d243fe7b6a046f80ceef28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*pbRxWXIjCkSLkCkA"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated"><a class="ae iu" href="https://unsplash.com/@steve_j?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">斯蒂夫·约翰森</a>在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</figcaption></figure><p id="988c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在Java中表示一组固定的常数时，一个经典的选择是使用枚举。一个<strong class="ix hj">枚举</strong>类型是一个特殊的数据类型，它使一个变量成为一组预定义的常量。变量必须等于为其预定义的值之一。</p><p id="e7aa" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">例如，一副牌中的花色(梅花、方块、红心、黑桃)、API的响应(成功、错误、装入)等。</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="15f7" class="kc kd hi jy b fi ke kf l kg kh">public enum Response {<br/>    <em class="ki">SUCCESS</em>, <br/>    <em class="ki">ERROR</em>, <br/>    <em class="ki">LOADING</em><br/>}</span></pre><p id="66e5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">同样，在科特林我们也可以有枚举，</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="dd35" class="kc kd hi jy b fi ke kf l kg kh">enum class Response {<br/>    <em class="ki">SUCCESS</em>,<br/>    <em class="ki">ERROR</em>,<br/>    <em class="ki">LOADING<br/></em>}</span></pre><p id="7e85" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，在处理固定数量的常量时，枚举非常方便，但也有一些限制。在枚举中，每种类型只有一个对象，因此枚举只能是常量，没有状态，这就给我们带来了Kotlin中的密封类。</p><h2 id="2ff7" class="kc kd hi bd kj kk kl km kn ko kp kq kr jg ks kt ku jk kv kw kx jo ky kz la lb bi translated"><strong class="ak">密封类</strong></h2><p id="22d1" class="pw-post-body-paragraph iv iw hi ix b iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo lg jq jr js hb bi translated">密封类的概念与枚举非常相似，密封类表示受限的类层次结构，即我们的类可以有特定数量的子类，这提供了对继承的更多控制。密封类的所有子类在编译时都是已知的。密封类通过限制在编译时而不是运行时匹配的类型来确保类型安全。</p><p id="a028" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">与Enum类不同，密封类可以有状态，因为我们可以有同一个类的几个对象。</p><p id="2259" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">密封类有另一个明显的特征，它们的构造函数默认是私有的。密封类是隐式的<strong class="ix hj">抽象的</strong>，因此它不能被实例化。像抽象类一样，密封类允许我们表示层次结构，子类可以是任何类型，数据类，对象类，任何常规类，甚至是另一个密封类。但是与抽象类不同，我们需要在同一个文件中或者作为嵌套类来定义这些层次结构。</p><blockquote class="lh"><p id="03aa" class="li lj hi bd lk ll lm ln lo lp lq js dx translated">一个<code class="du lr ls lt jy b">sealed</code>类是“枚举类的扩展”</p></blockquote><h2 id="67fe" class="kc kd hi bd kj kk lu km kn ko lv kq kr jg lw kt ku jk lx kw kx jo ly kz la lb bi translated"><strong class="ak">密封类声明</strong></h2><p id="ba0c" class="pw-post-body-paragraph iv iw hi ix b iy lc ja jb jc ld je jf jg le ji jj jk lf jm jn jo lg jq jr js hb bi translated">密封类在类修饰符之前带有sealed关键字，</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="70a1" class="kc kd hi jy b fi ke kf l kg kh">sealed class NetworkResult</span></pre><p id="3746" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我现在将展示如何使用密封类来管理API响应，</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="683a" class="kc kd hi jy b fi ke kf l kg kh">sealed class NetworkResult&lt;T&gt;(<br/>    val data: T? = null,<br/>    val message: String? = null<br/>) {<br/><br/>    class Success&lt;T&gt;(data: T) : NetworkResult&lt;T&gt;(data)<br/><br/>    class Error&lt;T&gt;(message: String?, data: T? = null) : NetworkResult&lt;T&gt;(data, message)<br/><br/>    class Loading&lt;T&gt; : NetworkResult&lt;T&gt;()<br/><br/>}</span></pre><p id="cb64" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这里，我创建了一个密封的类，用<strong class="ix hj"> Success、Error和Loading </strong>作为子类。每个子类可以对应于不同的可能的API响应，并被相应地参数化。例如，如果API响应成功，我们将获得数据，并且不会有错误消息，如果出现错误，将没有数据，因此我对数据使用了可空类型。类似地，对于加载状态，我们不需要任何参数。</p><blockquote class="lh"><p id="1647" class="li lj hi bd lk ll lm ln lo lp lq js dx translated">我对这个类使用了泛型，这样它就可以被不同的响应类型重用。</p></blockquote><p id="b0ba" class="pw-post-body-paragraph iv iw hi ix b iy lz ja jb jc ma je jf jg mb ji jj jk mc jm jn jo md jq jr js hb bi translated">假设我们的模型类是<strong class="ix hj">结果</strong>，</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="69c0" class="kc kd hi jy b fi ke kf l kg kh">var response: MutableLiveData&lt;NetworkResult&lt;Result&gt;&gt; = MutableLiveData()</span></pre><p id="865c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们的响应变量将存储由NetworkResult类包装的响应，</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="2207" class="kc kd hi jy b fi ke kf l kg kh">private fun fetchResult(...) {<br/>    response.value = NetworkResult.Loading()<br/>    if (hasInternetConnection()) {<br/>        try {<br/>            val response = repository.getResult()<br/>            if (response.code() == 200) {<br/>                response.value = NetworkResult.Success(response)<br/>            } else {<br/>                response.value = NetworkResult.Error(response.message())<br/>            }<br/>        } catch (e: Exception) {<br/>            response.value = NetworkResult.Error(e.message())<br/>        }<br/>    } else {<br/>        response.value = NetworkResult.Error("No Internet connection !")<br/>    }<br/>}</span></pre><p id="d301" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当我们调用fetchResult(…)时，我将响应值设置为Loading，如果我收到一个成功的响应，我将它的值设置为获得的响应体，对于错误情况，我将根据错误设置不同的错误消息。这是一个可能的结果类型可以有不同状态的示例。<br/>现在在调用类中，我们可以观察我们的响应活动数据并呈现UI元素，基于响应，</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="e72a" class="kc kd hi jy b fi ke kf l kg kh">private fun requestApiData() {</span><span id="9cf9" class="kc kd hi jy b fi me kf l kg kh">    viewModel.response.observe(<em class="ki">viewLifecycleOwner</em>) <strong class="jy hj">{ </strong>response <strong class="jy hj">-&gt;<br/>        </strong>when (response) {<br/>            is NetworkResult.Success -&gt; {<br/>                response.data?.let <strong class="jy hj">{<br/>                    </strong>//bind the data to the ui<br/>                <strong class="jy hj">}<br/>            </strong>}</span><span id="8670" class="kc kd hi jy b fi me kf l kg kh">            is NetworkResult.Error -&gt; {<br/>                //show error message<br/>                Toast.makeText(<br/>                    requireContext(),<br/>                    response.message.toString(),<br/>                    Toast.<em class="ki">LENGTH_SHORT<br/>                </em>).show()<br/>            }<br/><br/>            is NetworkResult.Loading -&gt; {<br/>                //show loader, shimmer effect etc<br/>            }<br/>        }<br/>    <strong class="jy hj">}<br/></strong>}</span></pre><p id="969f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这就是我们如何在API响应中使用我们的密封类。</p><p id="c99c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里需要注意的另一件事是，</p><blockquote class="lh"><p id="ec96" class="li lj hi bd lk ll lm ln lo lp lq js dx translated"><strong class="ak">【当】</strong>对密封类的陈述是详尽的</p></blockquote><p id="62ac" class="pw-post-body-paragraph iv iw hi ix b iy lz ja jb jc ma je jf jg mb ji jj jk mc jm jn jo md jq jr js hb bi translated">如果我们漏掉任何子类，<strong class="ix hj">什么时候</strong>会抱怨？如果我们实现了所有这些，我们就不需要else语句了。一般来说，我们不会推荐这种方法，因为这样我们就能确定我们为他们做的是正确的事情。</p><p id="f842" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">希望你今天学到了一些东西，干杯！</p><figure class="jt ju jv jw fd ij"><div class="bz dy l di"><div class="mf mg l"/></div></figure></div></div>    
</body>
</html>