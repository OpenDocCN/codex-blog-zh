<html>
<head>
<title>The Hidden Power of Unix File Descriptors</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Unix文件描述符隐藏的力量</h1>
<blockquote>原文：<a href="https://medium.com/codex/the-hidden-power-of-unix-file-descriptors-d2e2bf27db84?source=collection_archive---------2-----------------------#2022-09-10">https://medium.com/codex/the-hidden-power-of-unix-file-descriptors-d2e2bf27db84?source=collection_archive---------2-----------------------#2022-09-10</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es im"><img src="../Images/712556a983a55bdc8bc2ce5534a193d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wyPZFv5oRNlDEbid"/></div></div><figcaption class="iy iz et er es ja jb bd b be z dx translated">照片由<a class="ae jc" href="https://unsplash.com/@erol?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">埃罗尔·艾哈迈德</a>在<a class="ae jc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><h1 id="8c8a" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">文件描述符</h1><p id="ffb8" class="pw-post-body-paragraph kb kc hi kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky hb bi translated">在Unix和类Unix操作系统中，<strong class="kd hj">文件描述符</strong>是文件的唯一标识符。例如，<code class="du kz la lb lc b">/etc/environment</code>是引用环境变量的系统级配置文件的描述符。目前为止没什么特别的。</p><h2 id="9cf0" class="ld je hi bd jf le lf lg jj lh li lj jn km lk ll jr kq lm ln jv ku lo lp jz lq bi translated">常规文件、符号链接、目录</h2><p id="d006" class="pw-post-body-paragraph kb kc hi kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky hb bi translated">但这还不是故事的全部。您可能知道，除了常规文件，文件描述符还可以引用其他文件类型，如符号链接和目录。</p><p id="f4ae" class="pw-post-body-paragraph kb kc hi kd b ke lr kg kh ki ls kk kl km lt ko kp kq lu ks kt ku lv kw kx ky hb bi translated"><strong class="kd hj">符号链接</strong>是指向文件的链接，其行为就像文件本身一样，但是你可以移动它们、复制它们和删除它们，而不会影响原始文件。如果您修改原始链接或符号链接的内容，两者会保持同步。例如，如果您想在不同用户之间共享文件或进行文件管理，这是非常方便的。例如，在我的机器上，我喜欢将我的工作项目放在<code class="du kz la lb lc b">home/tdeneire/work</code>附近，但这实际上只是一个到<code class="du kz la lb lc b">/home/tdeneire/backup/Dropbox/projects/work</code>的象征性链接(这是很难管理的)，这样整个目录就会自动备份到云中…</p><p id="0869" class="pw-post-body-paragraph kb kc hi kd b ke lr kg kh ki ls kk kl km lt ko kp kq lu ks kt ku lv kw kx ky hb bi translated">这个目录符号链接的例子展示了在Unix中，<strong class="kd hj">目录</strong>也是一种文件类型。许多对常规文件有效的操作(删除、复制、移动、重命名等)对目录也有效。同样，这是使用文件描述符完成的，例如主目录，在我的例子中是<code class="du kz la lb lc b">/home/tdeneire</code>。</p><h2 id="c8ca" class="ld je hi bd jf le lf lg jj lh li lj jn km lk ll jr kq lm ln jv ku lo lp jz lq bi translated">设备文件</h2><p id="a0f6" class="pw-post-body-paragraph kb kc hi kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky hb bi translated">POSIX标准还定义了更多的文件类型，可以用文件描述符来处理。例如，所谓的<a class="ae jc" href="https://en.wikipedia.org/wiki/Unix_domain_socket" rel="noopener ugc nofollow" target="_blank"> Unix域套接字</a>，它是一个数据通信端点，用于在内核中的进程间交换数据。另一个有趣的类别是<strong class="kd hj">设备文件</strong>，传统上安装在<code class="du kz la lb lc b">/dev</code>中，它们是设备驱动程序的接口，出现在文件系统中，就好像它们是普通文件一样。在这种情况下，最有趣的可能是所谓的<strong class="kd hj">伪设备文件</strong>。<strong class="kd hj"> </strong>这些并不对应物理硬件设备，而是为操作系统提供一定的工具。一个例子是<code class="du kz la lb lc b">/dev/null</code>，它接受并丢弃写入其中的所有输入，如果您希望某个进程安静地运行，这非常有用:</p><pre class="in io ip iq fd lw lc lx ly aw lz bi"><span id="5d8d" class="ld je hi lc b fi ma mb l mc md">my_command &gt; /dev/null</span></pre><p id="51b1" class="pw-post-body-paragraph kb kc hi kd b ke lr kg kh ki ls kk kl km lt ko kp kq lu ks kt ku lv kw kx ky hb bi translated">另一个方便的工具是<code class="du kz la lb lc b">/dev/random</code>，它公开了由内核所谓的<a class="ae jc" href="https://en.wikipedia.org/wiki/Cryptographically_secure_pseudorandom_number_generator" rel="noopener ugc nofollow" target="_blank">密码安全伪随机数发生器生成的随机字节流。</a>以下命令要求来自<code class="du kz la lb lc b">/dev/random</code>的八个字节以规范(<code class="du kz la lb lc b">-C</code>)表示的十六进制转储:</p><pre class="in io ip iq fd lw lc lx ly aw lz bi"><span id="b1a8" class="ld je hi lc b fi ma mb l mc md">hexdump -C -n 8 /dev/random</span><span id="e8e7" class="ld je hi lc b fi me mb l mc md"><em class="mf">00000000  95 c1 86 a8 b8 7c 42 ee                 |.....|B.|<br/>00000008</em></span></pre><h2 id="a989" class="ld je hi bd jf le lf lg jj lh li lj jn km lk ll jr kq lm ln jv ku lo lp jz lq bi translated">命名管道或FIFOs</h2><p id="e71d" class="pw-post-body-paragraph kb kc hi kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky hb bi translated">最后一种Unix文件类型是<strong class="kd hj">命名管道</strong>，它不是传统的匿名管道，而是为管道创建一个文件描述符，这样两个独立的进程就可以通过管道的名称访问同一个管道。使用命令<code class="du kz la lb lc b">mkfifo</code>创建一个命名管道。例如，您可以创建一个管道，并设置<code class="du kz la lb lc b">gzip</code>来压缩通过管道传输给它的任何东西:</p><pre class="in io ip iq fd lw lc lx ly aw lz bi"><span id="9854" class="ld je hi lc b fi ma mb l mc md">mkfifo my_pipe<br/>gzip &lt; my_pipe &gt; out.gz &amp;</span></pre><p id="5fa6" class="pw-post-body-paragraph kb kc hi kd b ke lr kg kh ki ls kk kl km lt ko kp kq lu ks kt ku lv kw kx ky hb bi translated"><code class="du kz la lb lc b">&amp;</code>将这个进程从shell中分离出来，然后允许在一个单独的进程shell中独立地发送要压缩的数据:</p><pre class="in io ip iq fd lw lc lx ly aw lz bi"><span id="156c" class="ld je hi lc b fi ma mb l mc md">cat file &gt; my_pipe</span></pre><p id="ccb1" class="pw-post-body-paragraph kb kc hi kd b ke lr kg kh ki ls kk kl km lt ko kp kq lu ks kt ku lv kw kx ky hb bi translated">之后，您可以像删除常规文件一样，用<code class="du kz la lb lc b">rm my_pipe</code>删除命名管道。</p><p id="4e6a" class="pw-post-body-paragraph kb kc hi kd b ke lr kg kh ki ls kk kl km lt ko kp kq lu ks kt ku lv kw kx ky hb bi translated">当然，您可以通过使用一个临时文件来完成同样的任务，但是请记住，写一个临时文件既费时又会导致更多的I/O和硬盘上更少的可用空间。对于一些操作，比如将数据加载到数据库中(MySQL和PostgreSQL都支持使用命名管道)，如果数据不需要先写入文件，就会有很大的不同…</p><h1 id="2c8f" class="jd je hi bd jf jg mg ji jj jk mh jm jn jo mi jq jr js mj ju jv jw mk jy jz ka bi translated">一切都是一个文件</h1><p id="ced2" class="pw-post-body-paragraph kb kc hi kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky hb bi translated">上述所有文件描述符的使用解释了为什么人们说在Unix <a class="ae jc" href="https://en.wikipedia.org/wiki/Everything_is_a_file" rel="noopener ugc nofollow" target="_blank"> <strong class="kd hj">中一切都是文件</strong> </a>。事实上，正如维基百科所说，</p><blockquote class="ml mm mn"><p id="3a2e" class="kb kc mf kd b ke lr kg kh ki ls kk kl mo lt ko kp mp lu ks kt mq lv kw kx ky hb bi translated">Unix及其衍生产品的一个定义特性是，大量的输入/输出资源，如文档、目录、硬盘、调制解调器、键盘、打印机，甚至一些进程间和网络通信，都是通过文件系统名称空间公开的简单字节流。</p></blockquote><h2 id="607c" class="ld je hi bd jf le lf lg jj lh li lj jn km lk ll jr kq lm ln jv ku lo lp jz lq bi translated">/proc</h2><p id="f763" class="pw-post-body-paragraph kb kc hi kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky hb bi translated">以上例子说明，说一切都是文件<em class="mf">描述符</em>更准确。即使有些东西看起来像文件，你可以把它们当作文件来处理，但它们不一定是文件。例如，前面提到的伪设备文件就是这种情况，而<code class="du kz la lb lc b">/proc</code>下的纯虚拟文件系统将许多系统属性公开为文件。在这里您可以找到文件，或者更确切地说是文件描述符，比如<code class="du kz la lb lc b">/proc/cpuinfo</code>、<code class="du kz la lb lc b">/proc/partitions</code>、<code class="du kz la lb lc b">/proc/uptime</code>和<code class="du kz la lb lc b">/proc/version</code>，它们都是不言自明的。</p><p id="4525" class="pw-post-body-paragraph kb kc hi kd b ke lr kg kh ki ls kk kl km lt ko kp kq lu ks kt ku lv kw kx ky hb bi translated"><code class="du kz la lb lc b">/proc</code>中另一个有趣的例子是<code class="du kz la lb lc b">stdin</code>、<code class="du kz la lb lc b">stdout</code>和<code class="du kz la lb lc b">stderr</code>的文件描述符。你看，每个进程都有自己的文件描述符，你可以在<code class="du kz la lb lc b">/proc/{PID}/fd</code>下面找到，后面是<code class="du kz la lb lc b">0</code>代表<code class="du kz la lb lc b">stdout</code>，<code class="du kz la lb lc b">1</code>代表<code class="du kz la lb lc b">stdin</code>和<code class="du kz la lb lc b">2</code>代表<code class="du kz la lb lc b">stderr</code>。例如，您可以启动一个进程，再次将其分离，以便向您显示其PID:</p><pre class="in io ip iq fd lw lc lx ly aw lz bi"><span id="a2f0" class="ld je hi lc b fi ma mb l mc md">sleep 30 &amp;&amp; echo "hello" &amp;</span><span id="8b57" class="ld je hi lc b fi me mb l mc md"><em class="mf">[1] 41985</em></span></pre><p id="ab64" class="pw-post-body-paragraph kb kc hi kd b ke lr kg kh ki ls kk kl km lt ko kp kq lu ks kt ku lv kw kx ky hb bi translated">然后，您可以查看针对该流程向<code class="du kz la lb lc b">stdout</code>写入了什么:</p><pre class="in io ip iq fd lw lc lx ly aw lz bi"><span id="d7d6" class="ld je hi lc b fi ma mb l mc md">cat /proc/41985/fd/1</span></pre><p id="fcba" class="pw-post-body-paragraph kb kc hi kd b ke lr kg kh ki ls kk kl km lt ko kp kq lu ks kt ku lv kw kx ky hb bi translated">三十秒延迟结束后，您会看到<code class="du kz la lb lc b">hello</code>出现。在这之后，你需要用<code class="du kz la lb lc b">CTRL+C</code>终止这个进程，因为<code class="du kz la lb lc b">cat</code>没有到达EOF(文件结束)，所以它不知道什么时候停止。</p><p id="bb2b" class="pw-post-body-paragraph kb kc hi kd b ke lr kg kh ki ls kk kl km lt ko kp kq lu ks kt ku lv kw kx ky hb bi translated">尽管使用进程的特定PID可能很有趣(例如，您可以检查没有响应的进程)，但是您也可以省略PID，使用通用的数字描述符<code class="du kz la lb lc b">0</code>、<code class="du kz la lb lc b">1</code>和<code class="du kz la lb lc b">2</code>。例如，下面的命令将<code class="du kz la lb lc b">stderr</code>重定向到<code class="du kz la lb lc b">stdout</code>，这样您就可以捕获流程的输出和/或可能的错误:</p><pre class="in io ip iq fd lw lc lx ly aw lz bi"><span id="5250" class="ld je hi lc b fi ma mb l mc md">cat this_file_does_not_exist &gt; result 2&gt;&amp;1<br/>cat result</span><span id="4236" class="ld je hi lc b fi me mb l mc md"><em class="mf">cat: this_file_does_not_exist: No such file or directory</em></span></pre><h2 id="06c7" class="ld je hi bd jf le lf lg jj lh li lj jn km lk ll jr kq lm ln jv ku lo lp jz lq bi translated">/sys</h2><p id="3860" class="pw-post-body-paragraph kb kc hi kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky hb bi translated">Unix文件描述符的最后一个有趣的类别可以在<code class="du kz la lb lc b">/sys</code>中找到。一些可能会让您感到惊讶的显著示例是电池状态、容量(%)，等等:</p><pre class="in io ip iq fd lw lc lx ly aw lz bi"><span id="aa23" class="ld je hi lc b fi ma mb l mc md">cat /sys/class/power_supply/BAT0/status</span><span id="ce9b" class="ld je hi lc b fi me mb l mc md"><em class="mf">Discharging</em></span><span id="0d61" class="ld je hi lc b fi me mb l mc md">cat /sys/class/power_supply/BAT0/capacity</span><span id="84ff" class="ld je hi lc b fi me mb l mc md"><em class="mf">46</em></span></pre><p id="042e" class="pw-post-body-paragraph kb kc hi kd b ke lr kg kh ki ls kk kl km lt ko kp kq lu ks kt ku lv kw kx ky hb bi translated">甚至是关于你的机器温度的信息！看看我在某个地方找到的这个漂亮的一行程序(虽然我想不起在哪里了):</p><pre class="in io ip iq fd lw lc lx ly aw lz bi"><span id="5d39" class="ld je hi lc b fi ma mb l mc md">paste &lt;(cat /sys/class/thermal/thermal_zone*/type) &lt;(cat /sys/class/thermal/thermal_zone*/temp) | column -s $'\t' -t | sed 's/\(.\)..$/.\1°C/'</span><span id="c247" class="ld je hi lc b fi me mb l mc md"><em class="mf">acpitz           25.0°C<br/>x86_pkg_temp     48.0°C<br/>GEN1             38.0°C<br/>INT3400 Thermal  20.0°C<br/>SEN1             41.0°C<br/>SEN2             35.0°C<br/>SEN3             37.0°C<br/>SEN4             40.0°C<br/>TMEM             39.0°C<br/>pch_skylake      45.5°C<br/>B0D4             48.0°C</em></span></pre><p id="5cf6" class="pw-post-body-paragraph kb kc hi kd b ke lr kg kh ki ls kk kl km lt ko kp kq lu ks kt ku lv kw kx ky hb bi translated">我不确定最后这些例子是普通文件，还是像<code class="du kz la lb lc b">/proc</code>一样，可以通过文件描述符访问的系统数据。但关键是，这根本不重要。通过文件描述符，Unix系统以统一的方式通过文件系统公开数据，这意味着您可以在各种资源上使用相同的工具、实用程序和API。</p><p id="c430" class="pw-post-body-paragraph kb kc hi kd b ke lr kg kh ki ls kk kl km lt ko kp kq lu ks kt ku lv kw kx ky hb bi translated">这就是Unix文件描述符真正隐藏的力量！</p></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><p id="f634" class="pw-post-body-paragraph kb kc hi kd b ke lr kg kh ki ls kk kl km lt ko kp kq lu ks kt ku lv kw kx ky hb bi translated"><em class="mf">嗨！</em>👋我是汤姆。我是一名软件工程师、技术作家和IT倦怠教练。如果想取得联系，可以查看<a class="ae jc" href="https://tomdeneire.github.io/" rel="noopener ugc nofollow" target="_blank"><em class="mf">https://tomdeneire . github . io</em></a></p></div></div>    
</body>
</html>