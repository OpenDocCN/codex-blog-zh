<html>
<head>
<title>Deploying a Rails API/React App with Sessions and CSRF Tokens</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用会话和CSRF令牌部署Rails API/React应用程序</h1>
<blockquote>原文：<a href="https://medium.com/codex/deploying-a-rails-api-react-app-with-sessions-and-csrf-tokens-d33d2924639?source=collection_archive---------2-----------------------#2021-09-21">https://medium.com/codex/deploying-a-rails-api-react-app-with-sessions-and-csrf-tokens-d33d2924639?source=collection_archive---------2-----------------------#2021-09-21</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/d69c5da3934f24b974deb4cbf153d6c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1ddIM82hYlOh6n64n4XDEg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">我盯着看了无数个小时的东西</figcaption></figure><p id="2d65" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在部署React/Rails API应用程序的过程中，我获得了多么好的学习体验啊！这个过程比我预想的要困难得多，我花了几十个小时在谷歌上搜索问题。我遇到的主要问题包括如何正确地构建和配置我的项目，以使用Rails会话和CSRF令牌。</p><p id="05cb" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我的问题都是从分开部署后端和前端的天真想法开始的…</p><h1 id="ce24" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">问题#1:项目结构</h1><p id="2e72" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">因此，我决定将我的Rails API部署到Heroku，将我的React前端部署到Netlify。毕竟，让后端和前端在不同的端口上本地运行就很好，那么部署到不同的主机提供商又有什么不同呢？</p><p id="5590" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">嗯，事实证明，这实际上是很不一样的，尤其是当涉及到用户认证的时候！部署后，我发现Rails会话完全停止工作，这破坏了我的应用程序。用户可以“登录”，但是如果他们刷新页面，他们会立即被注销。用户无法向我的一个资源发出成功的POST请求，因为<code class="du kv kw kx ky b">session_id</code>是空的。</p><p id="8977" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这是为什么？在最初的谷歌搜索之后，发现Rails将<code class="du kv kw kx ky b">session_id</code>存储在一个cookie中，并且cookie不会跨域传输。这意味着，如果我想使用会话，我的前端和后端需要一起部署，而不是在单独的托管平台上。</p><p id="c17d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我没有重组我的回购协议，而是在我的前端目录中运行<code class="du kv kw kx ky b">npm run build</code>，并将生成的<code class="du kv kw kx ky b">/build</code>文件夹的内容复制到我后端的<code class="du kv kw kx ky b">/public</code>目录中。因为我在我的项目中使用了React Router，所以我不得不在我的<code class="du kv kw kx ky b">application_controller.rb</code>文件和Rails的<code class="du kv kw kx ky b">config/routes.rb</code>文件中调整一些代码，以呈现React生成的<code class="du kv kw kx ky b">index.html</code>(感谢Heroku的Charlie Gleason编写了<a class="ae kz" href="https://blog.heroku.com/a-rock-solid-modern-web-stack" rel="noopener ugc nofollow" target="_blank">一个惊人的教程</a>，它在这里极大地帮助了我！)</p><pre class="la lb lc ld fd le ky lf lg aw lh bi"><span id="b9a5" class="li jt hi ky b fi lj lk l ll lm"># application_controller.rb</span><span id="fcb0" class="li jt hi ky b fi ln lk l ll lm"># NOTE: ActionController needs to inherit from ::Base, NOT ::API, in order to render the index.html file:<br/># <a class="ae kz" href="https://stackoverflow.com/a/59387177/11860889" rel="noopener ugc nofollow" target="_blank">https://stackoverflow.com/a/59387177/11860889</a></span><span id="9e08" class="li jt hi ky b fi ln lk l ll lm">class ApplicationController &lt; ActionController::Base<br/>  include ActionController::Cookies</span><span id="4096" class="li jt hi ky b fi ln lk l ll lm">  def fallback_index_html<br/>    render file: 'public/index.html'<br/>  end<br/>end</span><span id="c560" class="li jt hi ky b fi ln lk l ll lm"># config/routes.rb</span><span id="8260" class="li jt hi ky b fi ln lk l ll lm">...</span><span id="1707" class="li jt hi ky b fi ln lk l ll lm">get '*path', to: "application#fallback_index_html", constraints: -&gt;(request) do<br/>  !request.xhr? &amp;&amp; request.format.html?<br/>end</span></pre><p id="2f82" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">好的，完美！现在，我已经准备好把这个回购重新部署到Heroku！</p><p id="4bf8" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">或者是我吗？</p><h1 id="ae80" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">问题#2:无法验证CSRF令牌的真实性</h1><p id="d457" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">在Heroku上将我的项目重新部署为一个repo之后，我遇到了一个问题，我无法执行任何类型的非GET请求。相反，迎接我的是一个可爱的<code class="du kv kw kx ky b">422 Unprocessable Entity</code>错误，详情如下:</p><pre class="la lb lc ld fd le ky lf lg aw lh bi"><span id="e00f" class="li jt hi ky b fi lj lk l ll lm">Can't verify CSRF token authenticity<br/>Completed 422 Unprocessable Entity in 1ms (Active Record: 0.0s)</span><span id="314d" class="li jt hi ky b fi ln lk l ll lm">ActionController::InvalidAuthenticityToken (ActionController::InvalidAuthenticityToken)</span></pre><p id="cc31" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">因为我的ActionController现在是从::Base继承的，所以Rails期望任何非GET请求在头中包含一个CSRF令牌。</p><p id="e15a" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我找到了一个快速的“修复”方法，通过在我的<code class="du kv kw kx ky b">application_controller.rb</code>文件中添加下面一行来禁用CSRF保护:</p><pre class="la lb lc ld fd le ky lf lg aw lh bi"><span id="3820" class="li jt hi ky b fi lj lk l ll lm">skip_before_action :verify_authenticity_token</span></pre><p id="1ba8" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我的应用程序现在可以像在本地一样工作了！但我并不满意，因为我认为让我的应用程序工作而禁用安全性是一种懒惰。所以回到谷歌搜索！</p><h2 id="9647" class="li jt hi bd ju lo lp lq jy lr ls lt kc jf lu lv kg jj lw lx kk jn ly lz ko ma bi translated">一点CSRF的背景</h2><p id="6d2a" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">CSRF代表跨站点请求伪造，这是一种通常被称为“一次点击攻击”的安全攻击。例如，假设您在一个没有CSRF保护的网站上有一个帐户，例如www.my-bank.com。你登录后，一个带有你的<code class="du kv kw kx ky b">session_id</code>的cookie存储在你的浏览器中，当你浏览网站时，它会让你保持登录状态。然后，在没有注销的情况下，你碰巧访问了一个恶意网站，里面有一些隐藏代码；当单击一个链接或当页面简单加载时，可能会触发此代码。嵌入的代码向www.my-bank.com发出一个非GET请求(比如更改你的电子邮件地址或者把你的钱转出你的账户)，而且，因为包含你在www.my-bank.com的<code class="du kv kw kx ky b">session_id</code>的cookie仍然在你的浏览器中，www.my-bank.com被骗以为发出了一个有效的请求。你的账户在你不知情的情况下被盗用了！</p><p id="3a7a" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">CSRF令牌是对此类攻击的一种对策。本质上，令牌是在后端创建的，并发送给浏览器。然后，每当浏览器向后端发送非GET请求时，CSRF令牌就在请求的报头中发送，后端可以在报头中验证其真实性。恶意网站无法访问此令牌，因此当您浏览此类网站时触发的任何非GET请求都不会影响您的www.my-bank.com帐户。</p><h1 id="ec10" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">第三个问题:让CSRF代币玩好会话</h1><p id="9ad5" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">现在的挑战是通过会话启用CSRF保护。我尝试了许多启用CSRF保护的方法，但是许多解决方案要么使用Axios在React前端获取数据，要么需要全栈Rails应用程序。以下是唯一对我有效的解决方案(感谢托马斯·瓦伦特关于Rails中CSRF令牌的精彩博文<a class="ae kz" href="https://blog.eq8.eu/article/rails-api-authentication-with-spa-csrf-tokens.html" rel="noopener ugc nofollow" target="_blank">；它拯救了我的理智！).</a></p><p id="6f74" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我编辑了我的<code class="du kv kw kx ky b">application_controller.rb</code>文件，如下所示:</p><pre class="la lb lc ld fd le ky lf lg aw lh bi"><span id="ff97" class="li jt hi ky b fi lj lk l ll lm"># application_controller.rb</span><span id="df69" class="li jt hi ky b fi ln lk l ll lm">class ApplicationController &lt; ActionController::Base<br/>  include ActionController::Cookies<br/>  after_action :set_csrf_cookie</span><span id="747a" class="li jt hi ky b fi ln lk l ll lm">  def fallback_index_html<br/>    render file: 'public/index.html'<br/>  end</span><span id="f099" class="li jt hi ky b fi ln lk l ll lm">  private</span><span id="7fe6" class="li jt hi ky b fi ln lk l ll lm">  def set_csrf_cookie<br/>    cookies["CSRF-TOKEN"] = {<br/>      value: form_authenticity_token,<br/>      secure: true,<br/>      same_site: :strict<br/>      domain: 'life-lister.herokuapp.com'<br/>    }<br/>  end<br/>end</span></pre><p id="0a11" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">你会注意到我确实创建了CSRF令牌并将其存储在cookie中，这从理论上意味着恶意站点可以使用它，就像它可以使用<code class="du kv kw kx ky b">session_id</code>来危害某人一样。然而，当Rails收到请求时，它不会从cookie中读取令牌，而是从请求头中读取。</p><p id="70bd" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在为我的CSRF令牌创建cookie时，我还使用了一些设置来增强安全性。如果请求是通过不太安全的HTTP协议(而不是HTTPS)发出的，设置<code class="du kv kw kx ky b">secure: true</code>会阻止我的Rails后端接受令牌。此外，我设置了<code class="du kv kw kx ky b">same_site: :strict</code>，这意味着令牌将只接受来自我的域的令牌(我也在cookie中定义了这个域)。我可以设置<code class="du kv kw kx ky b">httponly: true</code>，这将阻止恶意网站读取我的CSRF令牌，但这样做也将阻止我的前端读取它！(我的前端需要读取令牌以在请求头中发送它)。</p><p id="2c1e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在，在我的前端，我不得不调整一些代码。我创建了一个新文件来处理从CSRF令牌读取和获取值的逻辑。</p><pre class="la lb lc ld fd le ky lf lg aw lh bi"><span id="0c93" class="li jt hi ky b fi lj lk l ll lm"># cookies.js</span><span id="d6e6" class="li jt hi ky b fi ln lk l ll lm">function CSRFToken(cookies) {<br/>  const splitCookies = cookies.split('; ');<br/>  return splitCookies.find(cookie =&gt; cookie.startsWith("CSRF-TOKEN=")).split('=')[1];<br/>}</span><span id="cc09" class="li jt hi ky b fi ln lk l ll lm">export default CSRFToken;</span></pre><p id="8df6" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">然后，在任何发出非GET请求的React组件中，我导入了该函数，并在请求头中使用它:</p><pre class="la lb lc ld fd le ky lf lg aw lh bi"><span id="2029" class="li jt hi ky b fi lj lk l ll lm"># Component that needs to send a non-GET request</span><span id="ac6b" class="li jt hi ky b fi ln lk l ll lm">import CSRFToken from './cookies';</span><span id="f345" class="li jt hi ky b fi ln lk l ll lm">...</span><span id="f987" class="li jt hi ky b fi ln lk l ll lm">function handleSubmit(e) {<br/>  e.preventDefault();<br/>  fetch("/login", {<br/>    method: "POST",<br/>    headers: {<br/>      "Content-Type": "application/json",<br/>      "X-CSRF-Token": CSRFToken(document.cookie)<br/>    },<br/>    body: ...<br/>  }<br/>  ...<br/>}</span></pre><p id="5314" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在这里，我将<code class="du kv kw kx ky b">document.cookie</code>作为参数传递给我的<code class="du kv kw kx ky b">CSRFToken()</code>函数，该函数获取存储在我的应用程序的域中的所有cookies。然后，这个函数解析出CSRF令牌的值并返回它，它被设置在<code class="du kv kw kx ky b">“X-CSRF-Token”</code>头中。</p><p id="3eff" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在，经过另一次重新部署，我的应用程序工作正常，没有禁用CSRF保护！:)</p><h2 id="ad0f" class="li jt hi bd ju lo lp lq jy lr ls lt kc jf lu lv kg jj lw lx kk jn ly lz ko ma bi translated">资源</h2><ul class=""><li id="ac94" class="mb mc hi iw b ix kq jb kr jf md jj me jn mf jr mg mh mi mj bi translated"><a class="ae kz" href="https://blog.heroku.com/a-rock-solid-modern-web-stack" rel="noopener ugc nofollow" target="_blank">一个坚如磐石的现代Web堆栈——Rails 5 API+active admin+Heroku上的Create React App</a></li><li id="e57c" class="mb mc hi iw b ix mk jb ml jf mm jj mn jn mo jr mg mh mi mj bi translated"><a class="ae kz" href="https://blog.eq8.eu/article/rails-api-authentication-with-spa-csrf-tokens.html" rel="noopener ugc nofollow" target="_blank">使用SPA CSRF令牌的Rails API认证</a></li><li id="2649" class="mb mc hi iw b ix mk jb ml jf mm jj mn jn mo jr mg mh mi mj bi translated"><a class="ae kz" rel="noopener" href="/@zayneabraham/ruby-on-rails-csrf-protection-with-react-js-65dd84b8edad"> Ruby on Rails CSRF保护用React.js &amp; Webpacker </a></li><li id="3205" class="mb mc hi iw b ix mk jb ml jf mm jj mn jn mo jr mg mh mi mj bi translated">stack overflow:<a class="ae kz" href="https://stackoverflow.com/questions/56863391/rails-with-react-app-on-heroku-routes-dont-work-on-refresh" rel="noopener ugc nofollow" target="_blank">Heroku路线上带有React应用程序的Rails在刷新时不起作用</a></li><li id="9a6c" class="mb mc hi iw b ix mk jb ml jf mm jj mn jn mo jr mg mh mi mj bi translated">StackOverflow: <a class="ae kz" href="https://stackoverflow.com/questions/35181340/rails-cant-verify-csrf-token-authenticity-when-making-a-post-request" rel="noopener ugc nofollow" target="_blank"> Rails:发出POST请求时无法验证CSRF令牌的真实性</a></li></ul></div></div>    
</body>
</html>