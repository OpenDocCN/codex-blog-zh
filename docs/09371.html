<html>
<head>
<title>How to effectively structure your software components?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何有效地组织你的软件组件？</h1>
<blockquote>原文：<a href="https://medium.com/codex/how-to-effectively-structure-your-software-components-9fa10bec7f23?source=collection_archive---------7-----------------------#2022-10-16">https://medium.com/codex/how-to-effectively-structure-your-software-components-9fa10bec7f23?source=collection_archive---------7-----------------------#2022-10-16</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/0eff18838f3a176d51e0f076dcad08f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XZqmsMoWnX9nnp7jLSSL6w.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">由vectorjuice/Freepik设计</figcaption></figure><p id="8df8" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">设计软件架构时，最重要的挑战之一是有效地定义您的软件组件，使它们可以轻松地重用和部署。</p><p id="6c1b" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">但是在我们深入细节之前，让我们从定义一个软件组件开始。</p><p id="7364" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">软件组件可以定义为可以独立部署的最小实体。它可以是一个软件包或web服务，一个作为软件开发工具包(SDK)提供的模块，或者只是一个DLL。所以组件是一组功能，语义相关的数据。每个组件都提供了与它交互的接口，而不用担心封装的逻辑。</p><p id="6767" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在他的书<strong class="iw hj"> Clean Architecture，软件结构和设计的工匠指南</strong>中，著名程序员罗伯特·C·马丁(Robert C.Martin)被称为<strong class="iw hj">、【鲍勃叔叔】、</strong>展示了他多年来积累的知识的多个方面，从坚实的原则到架构原则和测试。但在这篇文章中，我们将重点介绍解决我们问题的3个原则，它们是:</p><ul class=""><li id="a073" class="js jt hi iw b ix iy jb jc jf ju jj jv jn jw jr jx jy jz ka bi translated"><strong class="iw hj">记者:</strong>重用/发布等价原则。</li><li id="ccaf" class="js jt hi iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated"><strong class="iw hj"> CCP: </strong>常见的闭合原理。</li><li id="78f3" class="js jt hi iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated"><strong class="iw hj"> CRP: </strong>通用重用原则。</li></ul><p id="85e3" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">重用/发布等价原则(REP): </strong></p><p id="546d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">简而言之，罗伯特·C·马丁将这一原则定义为:</p><blockquote class="kg kh ki"><p id="8db6" class="iu iv kj iw b ix iy iz ja jb jc jd je kk jg jh ji kl jk jl jm km jo jp jq jr hb bi translated">“重用的颗粒就是发布的颗粒”</p></blockquote><p id="56c4" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">因此，倾向于一起交付的类应该被分组到同一个组件中，它们也应该用版本号来跟踪，并且有适当的文档以清晰的方式描述变更日志。否则依赖于该组件的其他人就不可能使用它们。</p><p id="d92e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">普通闭合原理(CCP) </strong></p><p id="c078" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这个原则包括将在同一个组件中一起改变的类分组。因此，给定组件中某些类的变化不应该迫使其他组件发生变化。</p><p id="a550" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这一原则与单一责任原则有相似之处，即一个组件应该只有一个改变的理由。因此，如果两个类有不同的更改原因，那么它们应该被分派到两个独立的组件中。</p><p id="8e9d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这个原则将增加代码的可维护性，因为一个组件内部会发生变化。</p><p id="f382" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">通用重用原则(CRP) </strong></p><p id="9686" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">简而言之，这一原则规定，倾向于一起使用的类应该放在同一个组件中。这意味着驻留在给定组件中的类应该是不可分的。因此，如果你依赖于一个给定的组件，那么你应该依赖于它的所有类，而不仅仅是几个方法。</p><p id="075f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">CRP旨在减少组件之间不必要的强链接。如果一个组件依赖于另一个组件中的单个方法。那么后者中的任何改变或新发布意味着兼容性检查和依赖组件的新交付。</p><p id="b7d9" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">那么应该应用哪些原则呢？</p><p id="10d6" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">上面的原则似乎在它们之间有一些冲突，因为REP和CRP推动具有多个类的更大的组件，这些类在语义上和逻辑上是链接的，并且这些类应该被一起发布和使用。而CCP试图将组件变得更小，这样一个组件就只包含几个必须一起改变的类。所以你不能把它们都用在一起。</p><p id="680d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如果架构师只关注CCP和REP，那么团队将会被太多不必要的发布所拖累，如果他只关注REP和CRP，那么一个简单的变更将会影响太多的组件。</p><p id="0acf" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">由于在所有这些原则之间做出选择似乎是不可能的，那么我们应该将团队现状和项目成熟度考虑在内。因为早期阶段的项目倾向于将可发布性推向更高级的阶段，因为主要的焦点被转移到简单的变更上，以使项目进展得更快。随着项目越来越成熟，重点可以转移到销售代表身上。</p><p id="8e74" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">来源:<strong class="iw hj">干净的架构:软件结构和设计的工匠指南(罗伯特·C·马丁)</strong></p><p id="8423" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">感谢阅读:)</p></div></div>    
</body>
</html>