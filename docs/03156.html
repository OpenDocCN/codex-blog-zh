<html>
<head>
<title>Parallel Programming in Python — Lesson 4. Multi-processing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的并行编程——第4课。多重处理</h1>
<blockquote>原文：<a href="https://medium.com/codex/parallel-programming-in-python-lesson-4-multi-processing-90f597da89ba?source=collection_archive---------14-----------------------#2021-08-20">https://medium.com/codex/parallel-programming-in-python-lesson-4-multi-processing-90f597da89ba?source=collection_archive---------14-----------------------#2021-08-20</a></blockquote><div><div class="dt gx gy gz ha hb"/><div class="hc hd he hf hg"><figure class="hi hj fa fc hk hl es et paragraph-image"><div role="button" tabindex="0" class="hm hn di ho bf hp"><div class="es et hh"><img src="../Images/e528ebd9f3ea1a80ff179c57af1bbe8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BpEYnHZPiK7cpnFloHeusQ.jpeg"/></div></div></figure><div class=""/><p id="c842" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated">这是系列课程的第四部分，涵盖了Python编程语言为并行编程提供的各种工具，以及使用每种工具的动机。在之前的课程中，我们探索了<em class="jp">事件驱动</em>设计的应用需求，并学习了如何区分真正需要并行代码的需求(例如通过多线程)。我们详细研究了Python线程工具，并讨论了(线程之间)同步的需要以及各种可用的同步原语。在这一课中，我们来看看Python light <em class="jp">多处理</em>的替代方案(多线程)。</p><p id="ce8b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated"><em class="jp">本课章节:</em></p><ol class=""><li id="ab52" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo jv jw jx jy bi translated">线程的交易流程</li><li id="d484" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">将事件用作同步布尔值</li><li id="9fed" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">在进程间共享数据</li><li id="6c84" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">在进程间序列化数据</li><li id="30ec" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">额外的多重处理功能</li><li id="906c" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">调用另一个程序，被阻止</li><li id="c2a9" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">处理失败的调用程序执行</li><li id="1ece" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">收集调用的程序输出</li></ol></div><div class="ab cl ke kf gq kg" role="separator"><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj"/></div><div class="hc hd he hf hg"><h2 id="0ed3" class="kl km hu bd kn ko kp kq kr ks kt ku kv jc kw kx ky jg kz la lb jk lc ld le lf bi translated">1.线程的交易流程</h2><p id="a5dd" class="pw-post-body-paragraph ir is hu it b iu lg iw ix iy lh ja jb jc li je jf jg lj ji jj jk lk jm jn jo hc bi translated">以Python的<em class="jp">多处理</em>模块为特色的<em class="jp">进程</em>非常类似于以Python的<em class="jp">线程</em>模块为特色的<em class="jp">线程</em>(我们已经在前面的课程中学习过了)，但是由于操作系统提供的进程，它位于一个单独的内存空间中。它具有相似的同步原语(在接口级)，外加一些额外的功能。但是，在表面之下，实现考虑了所涉及的不同存储空间，这一点我们马上就会看到。</p><p id="f7bc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated">让我们从调整前一课中的<em class="jp">生产者/消费者</em>示例(确切地说:由<em class="jp">消息队列同步的版本)</em>开始，并将其调整为使用<em class="jp">进程</em>而不是<em class="jp">线程、</em>，看看这是否可行。除此之外，程序几乎没有变化！</p><figure class="ll lm ln lo fe hl"><div class="bz dz l di"><div class="lp lq l"/></div></figure><p id="30f6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated"><em class="jp">注释(对应于已注释的数字):</em></p><ol class=""><li id="dc15" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo jv jw jx jy bi translated">这次我们使用的是<em class="jp">多处理</em>模块。为了维护我们的线程示例的逻辑，我们导入了<em class="jp">可连接的</em>队列。(由于某种原因，这里的默认消息队列是不可加入的)。</li><li id="55b7" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">这一次，生产者继承了多重处理</li><li id="3734" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">消费者(这是一个普通的函数，不像生产者那样封装)在流程中显式启动。</li><li id="373c" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">生产者使用消费者的队列进行初始化。</li></ol><p id="5fa5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated"><em class="jp">输出:(如果你的IDE没有显示另一个进程的输出，从命令行运行！)</em></p><pre class="ll lm ln lo fe lr ls lt lu aw lv bi"><span id="946a" class="kl km hu ls b fj lw lx l ly lz">Round 1 <br/>Round 2 <br/>Round 3 <br/>Round 4 <br/>Round 5 <br/>Round 6 <br/>Round 7 <br/>Round 8 <br/>Round 9 <br/>Round 10 <br/>Round 11 <br/>Round 12 <br/>...</span></pre><p id="06ac" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated">出事了！程序继续运行超过第十条消息，必须终止。哪里出了问题？以下调试消息可能有助于澄清错误。</p><figure class="ll lm ln lo fe hl"><div class="bz dz l di"><div class="lp lq l"/></div></figure><ol class=""><li id="3c4f" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo jv jw jx jy bi translated">程序仍在运行。结束标志必须为假。</li><li id="8940" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">这个程序不再运行了。结束标志必须为真。</li></ol><p id="b80c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated"><em class="jp">输出:(如果你的IDE没有显示另一个进程的输出，从命令行运行！)</em></p><pre class="ll lm ln lo fe lr ls lt lu aw lv bi"><span id="966e" class="kl km hu ls b fj lw lx l ly lz">... <br/>Round 7 <br/>Running: flag = False <br/>Round 8 <br/>Running: flag = False <br/>Round 9 <br/>Running: flag = False <br/>Round 10 <br/>Stopping: flag = True <br/>Running: flag = False <br/>Round 11 <br/>...</span></pre><p id="5962" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated">程序在<em class="jp">应该停止后继续运行。</em>显然，<em class="jp">看到的结束标志</em>仍然是<em class="jp">假的</em>，尽管(已验证！)的事实，它被设置为<em class="jp">真</em>早一分钟！</p><p id="e11b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated">为什么结束标志<em class="jp">被设置为真</em>(已被验证)，但<em class="jp">仍然为假？</em>解决方案很简单:它不是同一个<em class="jp">结束标志！结束标志位于生产者对象中，在这个故事中有两个生产者。为什么会有两个制作人？因为有两个过程(“多重处理”，记得吗？).事情是这样的:</em></p><ol class=""><li id="41a6" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo jv jw jx jy bi translated">主进程创建一个生产者，它将其end-flag初始化为false。</li><li id="7cf6" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">生产者(被声明为<em class="jp">进程</em>)名副其实，在后台启动另一个进程，并在那里默默地创建自己的副本。</li><li id="f12d" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">当请求<em class="jp">启动</em>时，生产者的主循环启动，但在生产者的进程中。发生在该生产者身上的任何事情(例如，其结束标志的值)都与留在主进程中的生产者无关。</li><li id="7c8b" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">主程序命令它的生产者停止。因为这个方法调用是<em class="jp">同步的</em>，它影响本地生产者中的结束标志。真正的生产者(进程中的生产者)没有理由意识到这一点，因此，将继续无限期地运行。</li></ol><p id="8ac2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated">当生产者是一根线时，为什么这种伎俩会奏效呢？因为只有一个生产者(线程),而且它和它的客户在同一个内存空间。在这种配置中，我们可以异步和同步地与生产者通信。</p><p id="5834" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated">通过打印进程ID和生产者的地址，两个单独的对象(并且在两个单独的进程中)的事实无疑得到了证明:</p><figure class="ll lm ln lo fe hl"><div class="bz dz l di"><div class="lp lq l"/></div></figure><p id="b677" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated"><em class="jp">输出:(如果你的IDE没有显示另一个进程的输出，从命令行运行！)</em></p><pre class="ll lm ln lo fe lr ls lt lu aw lv bi"><span id="3004" class="kl km hu ls b fj lw lx l ly lz">Main program. Process: 5884 <br/>Producer constructor. Process: 5884 <br/>Producer main loop. Process: 7372 <br/>Round 1 <br/>Round 2 <br/>Round 3 <br/>Round 4 <br/>Round 5 <br/>Round 6 <br/>Round 7 <br/>Round 8 <br/>Round 9 <br/>Round 10 <br/>Producer stop method. Process: 5884 <br/>Round 11 <br/>Round 12<br/>...</span></pre><p id="218b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated">正如我们可以从进程id看出的，生产者是在主程序中初始化的。对于子进程中的生产者，构造函数<em class="jp">不再被调用</em>(因为，一旦被初始化，它就被悄悄地复制到那里——被酸洗和去酸洗)。停止请求被发送到主程序中的制作人。生产者主循环发生在另一个进程中！</p><p id="0336" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated"><em class="jp">士气:</em>与一个流程的通信一定是<em class="jp">异步的！</em>我们不能使用<em class="jp">变量</em>在进程间通信(因为相对于另一个进程，该变量位于错误的内存空间)。Python的多重处理为我们提供了两种解决方案:</p><ol class=""><li id="0088" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo jv jw jx jy bi translated">使用<em class="jp">同步原语</em>(多处理版本)来代替。</li><li id="9c51" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">使用一个<em class="jp">同步变量</em>(并让多处理模块在进程间编组值)。</li></ol></div><div class="ab cl ke kf gq kg" role="separator"><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj"/></div><div class="hc hd he hf hg"><h2 id="96c1" class="kl km hu bd kn ko kp kq kr ks kt ku kv jc kw kx ky jg kz la lb jk lc ld le lf bi translated">2.将事件用作同步布尔值</h2><p id="41a7" class="pw-post-body-paragraph ir is hu it b iu lg iw ix iy lh ja jb jc li je jf jg lj ji jj jk lk jm jn jo hc bi translated">这个例子将布尔结束标志升级为一个<em class="jp">事件，</em>作为一个全局布尔，它的值可以被两个进程访问。(但它不是用来实际持有和释放任何人的，这是真实事件应该做的)。</p><figure class="ll lm ln lo fe hl"><div class="bz dz l di"><div class="lp lq l"/></div></figure><ol class=""><li id="e700" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo jv jw jx jy bi translated">该程序使用多重处理。</li><li id="9f5c" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">生产者从外部接收事件。生产者被简化为一个函数，因为它不再有<em class="jp">状态</em>(结束标志)，并且不再需要“停止”设置器(它拥有的唯一可寻址方法)。</li><li id="b61a" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">非阻塞地查询事件的值。</li><li id="9f6b" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">生产者功能是使用事件(主程序的本地事件)启动的。</li><li id="dcc2" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">主程序发出事件信号。</li></ol><p id="e719" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated"><em class="jp">输出:(如果你的IDE没有显示另一个进程的输出，从命令行运行！)</em></p><pre class="ll lm ln lo fe lr ls lt lu aw lv bi"><span id="24d2" class="kl km hu ls b fj lw lx l ly lz">Round 1 <br/>Round 2 <br/>Round 3 <br/>Round 4 <br/>Round 5 <br/>Round 6 <br/>Round 7 <br/>Round 8 <br/>Round 9 <br/>Round 10 <br/>[End of input]</span></pre></div><div class="ab cl ke kf gq kg" role="separator"><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj"/></div><div class="hc hd he hf hg"><h2 id="4c15" class="kl km hu bd kn ko kp kq kr ks kt ku kv jc kw kx ky jg kz la lb jk lc ld le lf bi translated">3.在进程间共享数据</h2><p id="2dc4" class="pw-post-body-paragraph ir is hu it b iu lg iw ix iy lh ja jb jc li je jf jg lj ji jj jk lk jm jn jo hc bi translated">由于多重处理模块的缘故，我们可以使用一个适当的布尔值，而不是使用布尔类型的事件。出于某种原因(可能是性能)，进程间共享的变量库仅限于Python/C接口中定义的C语言<em class="jp">基本类型</em>(与Python习惯相反，是<em class="jp">强类型的！)</em>。</p><figure class="ll lm ln lo fe hl"><div class="bz dz l di"><div class="lp lq l"/></div></figure><ol class=""><li id="60d1" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo jv jw jx jy bi translated">我们将使用多重处理。价值</li><li id="5443" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">该程序使用了<em class="jp"> ctypes </em> (C语言接口)模块。</li><li id="3ba8" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">生产者被升级回一个类(因为它有状态并有一个setter)。</li><li id="ace0" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">多重处理。Value封装了一个C变量，其值在进程间自动共享。</li><li id="7d6c" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">值的真值返回内部变量的真值(本例中为布尔值)。</li><li id="a1d8" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">存储在value对象内部的值被赋为True (python风格，而不是C风格的“True”)。这里一个灾难性的程序错误是将新值赋给值持有者，而不是它的内容(Python会默默地服从，但结果可能不符合您的意图！)如:<strong class="it hv"> self.toStop = True </strong>。这将取代多重处理。值，这在语法上是正确的，但是会终止同步！</li><li id="7e4a" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">结束标志同步不再涉及主程序。</li></ol><p id="1ea7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated"><em class="jp">附加共享值功能:</em></p><ul class=""><li id="761c" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo ma jw jx jy bi translated">标量值可以是任何熟悉的C语言类型，如<em class="jp"> bool、char、int、uint、long、double、</em>等。)</li><li id="ee33" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo ma jw jx jy bi translated">对于多个值，使用共享(同类)数组。</li><li id="b1c1" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo ma jw jx jy bi translated">值类型也可以由单字母代码指定，例如“c”(代表字符)，“I”代表有符号整数，等等。</li><li id="8a50" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo ma jw jx jy bi translated">(一些)Python类型(包括dict和list)也可以共享，需要启动一个<em class="jp">管理器</em>进程。</li></ul></div><div class="ab cl ke kf gq kg" role="separator"><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj"/></div><div class="hc hd he hf hg"><h2 id="d252" class="kl km hu bd kn ko kp kq kr ks kt ku kv jc kw kx ky jg kz la lb jk lc ld le lf bi translated">4.在进程间序列化数据</h2><p id="e8ad" class="pw-post-body-paragraph ir is hu it b iu lg iw ix iy lh ja jb jc li je jf jg lj ji jj jk lk jm jn jo hc bi translated">在通信被限制在<em class="jp">两个进程之间的<em class="jp">稳定流</em>的情况下，</em>基于队列的同步可以通过<em class="jp">管道得到某种程度的简化。</em></p><figure class="ll lm ln lo fe hl"><div class="bz dz l di"><div class="lp lq l"/></div></figure><p id="505e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated"><em class="jp">备注:</em></p><ol class=""><li id="12e5" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo jv jw jx jy bi translated">该程序使用多重处理。</li><li id="488c" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">使用管道(的一端)初始化生成器。</li><li id="6fb7" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">生产者通过管道发送消息。</li><li id="194d" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">这个解决方案用<em class="jp"> ack </em>代替了类似消息队列事件的行为。发送消息后，生产者等待ack(来自同一个管道)，阻塞。</li><li id="1f1c" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">远程连接必须显式关闭(在生成器端)，以释放另一端。</li><li id="acb0" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">使用管道(的另一端)初始化使用者。</li><li id="64e2" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">消费者等待来自管道的消息，阻塞。</li><li id="d523" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">尝试从关闭的连接(在另一端)接收会导致错误，使用者将其解释为消息流的合法结尾</li><li id="1fd7" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">消费者等待两秒钟，然后发送ack。(在这里，消费者设定速度)。</li><li id="31ca" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">远程连接在消费者端也是显式关闭的。</li><li id="9308" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">主程序打开一个管道，给出两个连接(从一个二元组解包)。</li><li id="19a7" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">使用管道的一个<em class="jp">连接</em>端初始化消费者。</li><li id="1a9f" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">使用管道的另一个<em class="jp">连接</em>端初始化生成器。</li><li id="92aa" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">本地连接也需要显式关闭，以正确处理管道！</li></ol><p id="52b5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated"><em class="jp">附加管道功能:</em></p><ul class=""><li id="ba5f" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo ma jw jx jy bi translated">默认情况下，管道是<em class="jp">全双工</em>(两种连接都可以用于发送和接收)。这可能是受约束的(例如左侧的<em class="jp">仅接收</em>，右侧的<em class="jp">仅发送</em>)。</li><li id="e3e9" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo ma jw jx jy bi translated">除了Python字符串，管道还可以传输原始字节数组和任意Python对象，只要它们是<em class="jp"> pickle-able </em>(使用Python的<em class="jp"> pickle </em>工具可以序列化)。</li></ul></div><div class="ab cl ke kf gq kg" role="separator"><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj"/></div><div class="hc hd he hf hg"><h2 id="8f35" class="kl km hu bd kn ko kp kq kr ks kt ku kv jc kw kx ky jg kz la lb jk lc ld le lf bi translated">5.额外的多重处理功能</h2><p id="710d" class="pw-post-body-paragraph ir is hu it b iu lg iw ix iy lh ja jb jc li je jf jg lj ji jj jk lk jm jn jo hc bi translated">使用多处理功能(作为多线程的替代)涉及启动额外进程和上下文切换的明显开销，但这被认为是可以忽略的，特别是与优势相比时，优势主要是:</p><ul class=""><li id="60f6" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo ma jw jx jy bi translated">不容易出现共享资源损坏和竞争情况。</li><li id="048f" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo ma jw jx jy bi translated">获得<em class="jp">同时性</em>(需要的地方)<em class="jp">，</em>从臭名昭著的GIL的暴政下解放出来(Python的全局解释器锁)。</li></ul><p id="c662" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated">普遍的共识是继续对I/O密集型应用程序使用多线程，对CPU密集型应用程序使用多处理。</p><p id="c66c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated">多处理模块的另一个有用的特性(但不适用于我们的生产者/消费者示例)是一个<em class="jp">工作进程池</em>，它可以用于调用多个值上的函数，并使用<em class="jp"> asyncResult </em>收集结果——一种未来值。</p></div><div class="ab cl ke kf gq kg" role="separator"><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj"/></div><div class="hc hd he hf hg"><h2 id="0a8d" class="kl km hu bd kn ko kp kq kr ks kt ku kv jc kw kx ky jg kz la lb jk lc ld le lf bi translated">6.调用另一个程序，被阻止</h2><p id="ac6d" class="pw-post-body-paragraph ir is hu it b iu lg iw ix iy lh ja jb jc li je jf jg lj ji jj jk lk jm jn jo hc bi translated">该模块的名称“多重处理”有点让人误解。所指的进程是自动启动的，虽然可以通过操作系统进程列表看到它们，但它们并不被视为真正的进程。如果这是您所需要的(显式启动一个进程，监控其进度，例如收集其输出)，您必须求助于与操作系统进程功能接口的<em class="jp">子进程</em>模块。</p><p id="00a5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated">子流程模块用一个统一简单的界面代替了各种系统调用。典型的功能是调用另一个程序<em class="jp">阻塞</em>(即等待它返回)并检索它的返回代码，或它的整个控制台输出，post fact。显然，这个工具不适合我们的生产者/消费者测试用例，它需要逐个处理消息。</p><p id="fb1e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated">下面是一个调用<em class="jp"> shell命令</em>(一个程序，在单独的进程中运行)并检索其<em class="jp">返回代码的例子:</em></p><pre class="ll lm ln lo fe lr ls lt lu aw lv bi"><span id="77d3" class="kl km hu ls b fj lw lx l ly lz">&gt;&gt;&gt; rc = subprocess.call( ['dir', 'C:\\python27'], shell=True )<br/>Volume in drive C has no label. Volume Serial Number is 3AC3-56FA Directory of C:\\python27 <br/>19-Aug-16 21:19 &lt;DIR&gt; . <br/>19-Aug-16 21:19 &lt;DIR&gt; .. <br/>19-Aug-16 21:19 &lt;DIR&gt; DLLs <br/>19-Aug-16 21:19 &lt;DIR&gt; Doc <br/>19-Aug-16 21:19 &lt;DIR&gt; include <br/>12-Nov-16 19:18 &lt;DIR&gt; Lib <br/>19-Aug-16 21:19 &lt;DIR&gt; libs <br/>27-Jun-16 14:22 38,591 <br/>LICENSE.txt <br/>26-Jun-16 21:27 460,946 <br/>NEWS.txt 08-Nov-15 19:05 12,139 <br/>py2exe-wininst.log 27-Jun-16 14:20 27,136 <br/>python.exe 27-Jun-16 14:20 27,648 <br/>pythonw.exe ... <br/>12 File(s) 1,328,385 bytes 10 Dir(s) 99,487,002,624 bytes free <br/>&gt;&gt;&gt; rc 0</span></pre></div><div class="ab cl ke kf gq kg" role="separator"><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj"/></div><div class="hc hd he hf hg"><h2 id="b7fe" class="kl km hu bd kn ko kp kq kr ks kt ku kv jc kw kx ky jg kz la lb jk lc ld le lf bi translated">7.处理失败的程序执行</h2><p id="f48c" class="pw-post-body-paragraph ir is hu it b iu lg iw ix iy lh ja jb jc li je jf jg lj ji jj jk lk jm jn jo hc bi translated"><em class="jp">下面的例子调用一个shell命令并捕获它的异常(实际上，非零返回代码):</em></p><pre class="ll lm ln lo fe lr ls lt lu aw lv bi"><span id="055e" class="kl km hu ls b fj lw lx l ly lz">&gt;&gt;&gt; try: <br/>    rc = subprocess.check_call( ['dir', 'C:\\python270'], shell=True ) <br/>except subprocess.CalledProcessError as error: <br/>    print('Command failed. rc:', error.returncode) <br/>Volume in drive C has no label. Volume Serial Number is 3AC3-56FA <br/>Directory of C:\ <br/>File Not Found <br/>Command failed. <br/>rc: 1</span></pre></div><div class="ab cl ke kf gq kg" role="separator"><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj"/></div><div class="hc hd he hf hg"><h2 id="1862" class="kl km hu bd kn ko kp kq kr ks kt ku kv jc kw kx ky jg kz la lb jk lc ld le lf bi translated">8.收集调用的程序输出</h2><p id="ca5a" class="pw-post-body-paragraph ir is hu it b iu lg iw ix iy lh ja jb jc li je jf jg lj ji jj jk lk jm jn jo hc bi translated">以下示例调用一个shell命令，并将它的整个控制台输出(一部分)收集为一个字符串:*</p><pre class="ll lm ln lo fe lr ls lt lu aw lv bi"><span id="5c69" class="kl km hu ls b fj lw lx l ly lz">try: <br/>    data = subprocess.check_output( ['dir', 'C:\\python27'], shell=True) <br/>    print(f'received {len(data.split('\n'))} lines') <br/>except subprocess.CalledProcessError as error: <br/>    print('command failed. rc:', error.returncode) <br/>received 30 lines</span></pre></div><div class="ab cl ke kf gq kg" role="separator"><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj"/></div><div class="hc hd he hf hg"><h2 id="f44c" class="kl km hu bd kn ko kp kq kr ks kt ku kv jc kw kx ky jg kz la lb jk lc ld le lf bi translated">接下来呢？</h2><p id="c509" class="pw-post-body-paragraph ir is hu it b iu lg iw ix iy lh ja jb jc li je jf jg lj ji jj jk lk jm jn jo hc bi translated">在接下来的课程中，我们将考虑Python中传统多线程/处理的替代并行解决方案:具有拉和推迭代器的协作处理和基于分派的协作处理(<em class="jp">异步</em>执行)。</p><ol class=""><li id="d8ba" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo jv jw jx jy bi translated"><a class="ae mb" rel="noopener" href="/codex/parallel-programming-in-python-lesson-1-introduction-210e33d02ea6?source=friends_link&amp;sk=5273e19224913fbd6a3b74f41871a754">简介</a></li><li id="9a2f" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated"><a class="ae mb" rel="noopener" href="/codex/parallel-programming-in-python-lesson-2-the-thread-b3986e215d4f?source=friends_link&amp;sk=5ad6a9c99ce8947be53af4949ce6f086">螺纹</a></li><li id="5c5c" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated"><a class="ae mb" rel="noopener" href="/@Avner_17989/parallel-programming-in-python-lesson-3-synchronization-primitives-78ac09befc43">同步原语(多线程)</a></li><li id="99a5" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">同步原语(多处理)——<em class="jp">(你来了！)</em></li><li id="a8a7" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">协作处理—同步</li><li id="66dd" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy bi translated">协作处理—异步</li></ol></div></div>    
</body>
</html>