<html>
<head>
<title>Asynchronous Processing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">异步处理</h1>
<blockquote>原文：<a href="https://medium.com/codex/asynchronous-processing-the-fundamentals-2d7d0a564d00?source=collection_archive---------5-----------------------#2021-07-02">https://medium.com/codex/asynchronous-processing-the-fundamentals-2d7d0a564d00?source=collection_archive---------5-----------------------#2021-07-02</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="c593" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">将高强度任务转移到后台的基本原则</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/8868dbb138ec8b907f7921b2f4cb4d3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dvJJTF-M3QNU7ra_QJwz2A.png"/></div></div></figure><h1 id="b1f7" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">它是如何工作的</h1><h2 id="5ca6" class="kb jk hi bd jl kc kd ke jp kf kg kh jt ki kj kk jv kl km kn jx ko kp kq jz kr bi translated">信息</h2><p id="271a" class="pw-post-body-paragraph ks kt hi ku b kv kw ij kx ky kz im la ki lb lc ld kl le lf lg ko lh li lj lk hb bi translated">PDF服务不是在响应客户端之前等待任务完成，而是简单地接收一个请求，将其转化为一条消息(通常是JSON或XML ),并将其放入队列中。此消息包含对消费者的说明。</p><p id="1a5b" class="pw-post-body-paragraph ks kt hi ku b kv ll ij kx ky lm im la ki ln lc ld kl lo lf lg ko lp li lj lk hb bi translated">然后，服务可以对客户端做出响应，可能带有一个消息标识符，该标识符允许客户端监视挂起的进程。</p><h2 id="6376" class="kb jk hi bd jl kc kd ke jp kf kg kh jt ki kj kk jv kl km kn jx ko kp kq jz kr bi translated">队列</h2><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lq"><img src="../Images/935b48f2d5599534d491d4d8d7022f7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b7gVjkyI7H0UQJiFTG-DTg.png"/></div></div></figure><p id="11a9" class="pw-post-body-paragraph ks kt hi ku b kv ll ij kx ky lm im la ki ln lc ld kl lo lf lg ko lp li lj lk hb bi translated">队列可以通过多种方式实现，从单个文件到功能丰富的消息代理。不管实现如何，主要职责是缓冲和分发异步请求。</p><h2 id="7550" class="kb jk hi bd jl kc kd ke jp kf kg kh jt ki kj kk jv kl km kn jx ko kp kq jz kr bi translated">消费者</h2><p id="b1f1" class="pw-post-body-paragraph ks kt hi ku b kv kw ij kx ky kz im la ki lb lc ld kl le lf lg ko lh li lj lk hb bi translated">一旦进入队列，消息就会等待。当时机成熟时，消费者将从队列中取出一条消息并开始处理。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lr"><img src="../Images/da0ad220241df09c6d71a7448b0ed936.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VGS2LdKl22LtSFvrPBV0vg.png"/></div></div></figure><p id="2b44" class="pw-post-body-paragraph ks kt hi ku b kv ll ij kx ky lm im la ki ln lc ld kl lo lf lg ko lp li lj lk hb bi translated">围绕消息消费的<em class="ls">何时</em>由消费者的执行模型决定。这些模型通常是类似于<em class="ls">的编年史或守护进程。</em>在chron <em class="ls"> </em>模型中，消费者定期检查消息队列，可能每5秒、5分钟或5小时一次。在守护进程模型中，消费者不断地重新访问新消息的队列。</p><p id="9de1" class="pw-post-body-paragraph ks kt hi ku b kv ll ij kx ky lm im la ki ln lc ld kl lo lf lg ko lp li lj lk hb bi translated">除了各种执行模型之外，消费者可以使用不同的订阅模型来声明他们感兴趣的消息。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lt"><img src="../Images/47f32698c5377e65e528c45dcb6cf97e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NKG0YFd3pAN8gUn5jxZ8kA.png"/></div></div></figure><p id="c51c" class="pw-post-body-paragraph ks kt hi ku b kv ll ij kx ky lm im la ki ln lc ld kl lo lf lg ko lp li lj lk hb bi translated">两种常见的订阅模型是<em class="ls">直接工作队列</em>和<em class="ls">发布订阅</em>。</p><p id="26ce" class="pw-post-body-paragraph ks kt hi ku b kv ll ij kx ky lm im la ki ln lc ld kl lo lf lg ko lp li lj lk hb bi translated">在直接工作队列方法中，生产者和消费者只知道队列的名称。由生产者排队的每个消息被添加到按名称定位的单个工作队列中。队列的另一端是等待消息的消费者的数量。</p><p id="496b" class="pw-post-body-paragraph ks kt hi ku b kv ll ij kx ky lm im la ki ln lc ld kl lo lf lg ko lp li lj lk hb bi translated">在发布/订阅模型中，消息可以传递给多个消费者。生产者将消息推送到一个主题而不是一个队列。然后，主题为每个订阅者/消费者克隆消息，并将其放入私有队列中，由消费者独立处理。</p><h2 id="d468" class="kb jk hi bd jl kc kd ke jp kf kg kh jt ki kj kk jv kl km kn jx ko kp kq jz kr bi translated">协议</h2><p id="c639" class="pw-post-body-paragraph ks kt hi ku b kv kw ij kx ky kz im la ki lb lc ld kl le lf lg ko lh li lj lk hb bi translated">为了让异步系统的不同组件进行通信，需要一个协议。异步处理中比较常用的三种协议是AMQP、STOMP和JMS。</p><p id="4e2c" class="pw-post-body-paragraph ks kt hi ku b kv ll ij kx ky lm im la ki ln lc ld kl lo lf lg ko lp li lj lk hb bi translated">AMQP(高级消息队列协议)是一种行业标准。它的特性非常丰富，比如可靠的消息传递、交付保证和事务。但是这个功能带来了更多的开销。</p><p id="edd5" class="pw-post-body-paragraph ks kt hi ku b kv ll ij kx ky lm im la ki ln lc ld kl lo lf lg ko lp li lj lk hb bi translated">STOMP(面向文本的流消息协议)是一种无状态的、基于文本的协议，类似于HTTP。它支持大约12种操作，是一个极简协议，其主要优点是简单。但是，当需要更高级的功能时，这种简单性会带来问题。任何高级功能都需要使用头文件作为扩展来实现。这通常会导致互操作性问题，因为做某件事情没有标准的方法。</p><p id="fb1e" class="pw-post-body-paragraph ks kt hi ku b kv ll ij kx ky lm im la ki ln lc ld kl lo lf lg ko lp li lj lk hb bi translated">JMS(Java消息服务)是一个具有良好特性集的Java消息传递标准。不幸的是，它纯粹是一个Java标准，这使得它很难与基于非JVM(Java虚拟机)的技术集成。</p><h1 id="fa5a" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">利益</h1><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lu"><img src="../Images/e92b1a3be17f8e1c1cee823275539ca8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1ehLmOhwfeZtziEOEsMp7Q.png"/></div></div></figure><p id="42b2" class="pw-post-body-paragraph ks kt hi ku b kv ll ij kx ky lm im la ki ln lc ld kl lo lf lg ko lp li lj lk hb bi translated">异步处理对最终用户和整个系统都有好处。在这里，我们能够快速清除主线程，允许用户在后台工作的同时继续与我们的应用程序进行交互。系统很容易扩展，因为随着排队消息数量的增加，我们可以将更多的消费者添加到队列的末尾。如果我们的系统看到一个意外的请求高峰，任务可能会被延迟，但消费者永远不会被淹没，他们只是继续处理队列中积压的任务。在处理过程中，任何故障都会被隔离。由于诸如格式错误的消息等原因而失败的任务将被删除，并放入死信队列中进行相应的处理。所有这些都发生在一个分离的系统中，生产者和消费者对彼此一无所知。</p><h1 id="33c5" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">挑战</h1><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lv"><img src="../Images/cc813bf8598a10cc2c165807fae8ec9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XaaC4AaBrFWbShSZOrYxJA.png"/></div></div></figure><p id="15e1" class="pw-post-body-paragraph ks kt hi ku b kv ll ij kx ky lm im la ki ln lc ld kl lo lf lg ko lp li lj lk hb bi translated">但是伴随这些好处而来的是挑战，我们必须做好应对的准备。因为我们是并行处理消息的，消费者之间没有同步。异步处理不保证消息排序。</p><p id="2855" class="pw-post-body-paragraph ks kt hi ku b kv ll ij kx ky lm im la ki ln lc ld kl lo lf lg ko lp li lj lk hb bi translated">解决这个问题的一个方法是限制一个队列中一个消费者的数量。但是，这种解决方案无法扩展。另一个选择可能是构建我们的系统，假设消息将无序到达。最后，我们尝试利用支持部分消息排序的消息代理。</p><p id="6bca" class="pw-post-body-paragraph ks kt hi ku b kv ll ij kx ky lm im la ki ln lc ld kl lo lf lg ko lp li lj lk hb bi translated">任何系统都可能出现故障，异步系统也不例外。这些失败通常会导致重新排队，这又会导致意外的结果，因为任务最终会被执行多次。</p><p id="cad7" class="pw-post-body-paragraph ks kt hi ku b kv ll ij kx ky lm im la ki ln lc ld kl lo lf lg ko lp li lj lk hb bi translated">为了处理这个挑战，我们可以构建我们的系统来期望至少一个交付，而不是正好一个。但是，这样做是困难的，因为它要求消费者是幂等的。在某些情况下，这是可能的，但这也带来了让我们的消费者对无序消息更加敏感的可能性。</p><p id="7d52" class="pw-post-body-paragraph ks kt hi ku b kv ll ij kx ky lm im la ki ln lc ld kl lo lf lg ko lp li lj lk hb bi translated">这种不可预测性导致异步流程的复杂性增加。当理解消息如何在系统中流动并创建一个各部分如何组合在一起的心智模型时，文档是关键。</p><h1 id="8475" class="jj jk hi bd jl jm jn jo jp jq jr js jt io ju ip jv ir jw is jx iu jy iv jz ka bi translated">结论</h1><p id="8124" class="pw-post-body-paragraph ks kt hi ku b kv kw ij kx ky kz im la ki lb lc ld kl le lf lg ko lh li lj lk hb bi translated">异步处理是动态的、强大的，并且有点不可预测。但是，通过对局限性的深入了解，我们可以构建更健壮、高可用性的系统来改善用户体验。</p></div></div>    
</body>
</html>