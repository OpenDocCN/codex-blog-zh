<html>
<head>
<title>Choosing between REST, gRPC, GraphQL, Websockets</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在REST、gRPC、GraphQL、Websockets之间选择</h1>
<blockquote>原文：<a href="https://medium.com/codex/choosing-between-rest-grpc-graphql-websockets-aac53bc102a2?source=collection_archive---------5-----------------------#2022-10-17">https://medium.com/codex/choosing-between-rest-grpc-graphql-websockets-aac53bc102a2?source=collection_archive---------5-----------------------#2022-10-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/7e7b2f88166963eb206061ced2ee7ff5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AQ9UPMRFBhfB3PxlgDEJlQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">前端和服务器之间的通信</figcaption></figure><p id="edee" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">您在应用或后端和后端之间选择的网络协议对于安全性、可靠性、速度和良好的开发人员体验非常重要。</p><p id="ecce" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj"> <em class="js">免责声明</em> </strong> <em class="js">:在本文中，我们只讨论智能手机和平板电脑应用程序用于与其后端通信的网络协议；这是为了同步和面向连接的通信，本质上是基于TCP的通信。</em></p><h1 id="d850" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">背景</h1><p id="82c6" class="pw-post-body-paragraph iu iv hi iw b ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr hb bi translated">当今世界上大中型技术系统中API使用的最流行的网络协议是四大协议——REST、gRPC、GraphQL和Websockets。除了这些，显然还有其他的，比如SOAP、MQTT等等。大多数应用程序和网络前端的通信模式，包括某种类型的<em class="js">数据</em>流量，通常是基于TCP的。出现这种情况的主要原因是:</p><ul class=""><li id="e5ec" class="kw kx hi iw b ix iy jb jc jf ky jj kz jn la jr lb lc ld le bi translated">保证通信是面向连接的，</li><li id="94ff" class="kw kx hi iw b ix lf jb lg jf lh jj li jn lj jr lb lc ld le bi translated">如果移动设备向后端发送消息，它至少应该及时知道服务器是否接收到该消息</li><li id="92bd" class="kw kx hi iw b ix lf jb lg jf lh jj li jn lj jr lb lc ld le bi translated">如果没有接收到该分组，该协议使移动设备能够重新尝试发送它。</li></ul><p id="fce8" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">TCP还有助于比UDP更容易地建立更高层的安全特性。</p><h1 id="8e26" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">休息</h1><p id="4f00" class="pw-post-body-paragraph iu iv hi iw b ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr hb bi translated">代表性状态传输协议建立在HTTP/1.1之上，依赖于简单的请求/响应模型。这里，手机或平板电脑发送请求，服务器响应请求；请求可以是获取数据、发布数据更新、放置新数据或更新现有数据，等等。REST请求和响应消息体(或内容)通常采用JSON或YAML格式，但也支持包括序列化二进制数据在内的各种其他格式。</p><p id="3b70" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在这个模型中，服务器通常被期望成为响应者，并且在前端和后端服务器之间也有相对松散的绑定；也就是说，服务器不一定“仅仅”响应移动设备的请求，但通常会更多。因此，REST对于服务器之间的通信也非常有用，比如将后端服务公开给第三方。</p><p id="50fa" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">REST构建在HTTP之上，因此通过所有基于HTTP的身份验证和授权安全措施来保护它。</p><p id="a2de" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">休息很好理解；REST调用类型的区别只是一个字符串代码；内容是人类可读的普通数据，除此之外没有其他复杂之处。对于第一次使用的人来说，您编写的第一个HTTP服务器很可能会返回一些最小版本的REST。</p><p id="6af1" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">谈到REST 的<strong class="iw hj">缺点，最大的缺点是通信双方之间请求/响应数据的松耦合。在另一端，没有预期数据格式的约定，因此如果您的前端和后端团队是松散耦合的，这可能会成为一个令人头痛的问题；当一方改变格式而另一方没有改变时，通信路径就中断了。一个类似的大缺点是缺乏对API流数据的本地支持。</strong></p><h1 id="6340" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">GraphQL</h1><p id="d7f6" class="pw-post-body-paragraph iu iv hi iw b ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr hb bi translated">GraphQL是最流行的通信协议之一，由于前端和后端系统之间的紧密耦合，它近年来越来越受欢迎。它构建在HTTP/1.1之上，最初是为了克服REST的一些缺点，同时使其适用于与后端高度耦合的前端。典型的用例是web和移动应用程序与其后端进行通信。API端点将是专用的，因此永远不需要用绝对必要的更多信息来响应。请求者可以询问一个人的名字，得到的响应就是这个名字。</p><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="b75a" class="lt ju hi lp b fi lu lv l lw lx">user {<br/>  name: "Tom Brady"<br/>}</span></pre><p id="70ab" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">将没有额外的信息，如时间戳，位置等。你会得到你想要的。这种对内容数据的细化使得GraphQL比REST快得多。</p><p id="a982" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">此外，GraphQL提供了一种简单的方法，可以在后端将来自不同来源的数据聚集在一起并返回，这使得graph QL成为REST上单块系统升级的首选协议。</p><p id="5b24" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">GraphQL调用中的数据已经是结构良好的，因此可以很容易地分成层次结构，并通过前端或后端的组件分发。举个例子:这样的回答:</p><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="d66d" class="lt ju hi lp b fi lu lv l lw lx">user {<br/>  userId: 1234,<br/>  userInfo: {<br/>    name : "Tom Brady",<br/>    profilePic: "https://imgur.com/abcdxyz",<br/>  },<br/>  transactions: [<br/>  {<br/>    txnId: "abxc",<br/>    value: 50,<br/>  },<br/>  {<br/>    txnId: "zxcv",<br/>    value: 100,<br/>  }<br/>  ]<br/>}</span></pre><p id="40f7" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">前端的这个响应可以很容易地(自然地)分解成子“userInfo”和“transactions ”,并路由到不同的组件，而不需要额外的代码来分解它并进行路由。</p><p id="0342" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">HTTP/1.1不提供对缓存的本机支持；GraphQL确实通过各种编写良好的库得到了解决这个问题的支持，例如Apollo for React。</p><p id="9c01" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">与REST的动态类型特性相比，内容的强类型特性也为API用户提供了很大的帮助，使他们在代码中使用它时能够准确地知道API层次字段是什么，而不是像REST一样在运行时知道。</p><p id="f56f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">GraphQL解决了REST的许多问题，但是像聚合调用的行首阻塞这样的固有问题仍然存在。此外，GraphQL在处理大量嵌套的数据格式时表现不佳。众所周知，它的性能通常会随着查询的复杂性而降低。</p><p id="a258" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">第三方服务器服务器通信不容易采用GraphQL的一个原因是缺乏对速率限制(每天/每小时/等等的请求数)的本地支持。</p><h1 id="1927" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">Websockets</h1><p id="5cd3" class="pw-post-body-paragraph iu iv hi iw b ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr hb bi translated">随着互联网的蓬勃发展，HTTP/1.1中缺乏对流的本地支持或前端和后端系统之间基本上持久的双向通信日益成为一个大问题。2011年，Websockets在<a class="ae ly" href="https://datatracker.ietf.org/doc/html/rfc6455" rel="noopener ugc nofollow" target="_blank"> RFC6455 </a>中被标准化，以解决这个特定的问题。</p><p id="bafa" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">解决方案很简单-&gt;使用HTTP进行初始连接设置，然后在相同的底层TCP连接上切换到不同的(新的)协议。用开发人员的话来说，将HTTP连接“升级”为使用WebSocket协议。</p><p id="5546" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">Websocket协议的建立是为了解决一个棘手的问题-&gt;基于HTTP的系统的本地双向数据流。一旦通信转移到Websocket协议上，它还消除了HTTP调用的巨大开销(与HTTP/1.1的2000字节相比，只有2字节)。前端应用程序不再需要“长时间轮询”服务器来获取状态或通知。向移动应用程序发送推送通知几乎成为了原生支持。</p><p id="3f1f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">但它也有自己的缺点，包括没有边缘缓存的可能性，复杂的前端编码体验，如果你想构建一个没有流需求的简单前端，它为特定目的构建的扩展性不好。</p></div><div class="ab cl lz ma gp mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="hb hc hd he hf"><blockquote class="mg"><p id="5e38" class="mh mi hi bd mj mk ml mm mn mo mp jr dx translated">到目前为止，所有协议都只是在HTTP/1.1基础上的改进或增强，HTTP/1.1是在2000年左右标准化的，在几年内被证明不足以满足互联网上快速增长的服务的复杂要求。在HTTP/2(现在是HTTP/3)出现之前，这些协议只是在HTTP/1.1基础上的更高层次的改进，以解决所有这些问题以及在不断增长的互联网上使用的长期可伸缩性。</p></blockquote></div><div class="ab cl lz ma gp mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="hb hc hd he hf"><h1 id="91ff" class="jt ju hi bd jv jw mq jy jz ka mr kc kd ke ms kg kh ki mt kk kl km mu ko kp kq bi translated">gRPC</h1><p id="a19d" class="pw-post-body-paragraph iu iv hi iw b ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr hb bi translated">gRPC由Google很好地维护，并且主要建立在远程过程调用的概念上，它重新思考了整个请求/响应范式。gRPC建立在HTTP/2之上，为流提供本地支持。在gRPC中，在任何人在他们的代码中使用API之前，在前端和后端之间预先定义了一个明确的契约。契约以模块或包的形式导入到您的代码中，并为前端和后端之间的契约中支持的函数和流提供一流的支持。在API上不能做任何其他事情；更好的是在编码时就知道了。</p><p id="05a8" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在gRPC中，当从后端获取信息时，前端代码几乎等同于从应用程序中的另一个包获取信息。你不能打电话等着。你只需要调用一个函数，并使用该函数的返回信息。这样的函数存在于“契约文件”中，它是为在前端和后端使用而预先编译的。</p><p id="66d5" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">gRPC具有对流的本地支持:服务器端流(下游)、客户端流(上游)和双向流。</p><p id="754a" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">gRPC中交换的消息使用协议缓冲区，而不是XML、YAML和JSON。众所周知，协议缓冲区中传输的数据的序列化速度比REST快2/4/8倍，这使得gRPC比REST具有巨大的性能优势。</p><p id="9f44" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">gRPC对流、轻量级消息、更快的序列化和消息交换的硬协议提供了本机支持，是机器之间最快的通信方法之一。数据的紧密耦合也使得开发这样的API端点成为开发人员的乐趣。</p><p id="9a43" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">因为gRPC是建立在HTTP/2之上的，所以它具有对并行请求/响应通道的本地支持。这意味着，您可以在同一个TCP流中从同一个前端向同一个后端发出多个请求，每个单独的请求都将从TCP流中自己的成帧层被解析，并被并行处理；从而防止行首阻塞。如果第一个请求由于某种原因变得很慢，它不会影响第二个请求，甚至会给它带来更大的性能提升。</p></div><div class="ab cl lz ma gp mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="hb hc hd he hf"><p id="3da2" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如果你喜欢我的文章，请在Medium上关注我，阅读更多关于技术及其用途的精彩文章。</p><p id="3e61" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我定期撰写不同的技术主题，包括职业指导、最新消息、即将到来的技术等等。这篇博客最初发表在<a class="ae ly" href="https://www.anirban-mukherjee.com/choosing-between-rest-grpc-graphql-websockets/" rel="noopener ugc nofollow" target="_blank">我在anirban-mukherjee.com的博客</a></p></div></div>    
</body>
</html>