<html>
<head>
<title>Service Mesh — Are there any alternatives to it?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">服务网格——有什么替代方案吗？</h1>
<blockquote>原文：<a href="https://medium.com/codex/service-mesh-are-there-any-alternatives-to-it-c4eabd1329e0?source=collection_archive---------5-----------------------#2022-12-24">https://medium.com/codex/service-mesh-are-there-any-alternatives-to-it-c4eabd1329e0?source=collection_archive---------5-----------------------#2022-12-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/39580a2ef166e7c2da126653fc6f770d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K-l7fVjz3wz9ld-v8pqUeg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">服务网格的替代方案，以满足安全性、弹性、A/B测试和监控的目标</figcaption></figure><p id="e835" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">每种工具在适当的环境下都能发挥最佳作用。服务网格也不例外。</p><p id="16b5" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我在以前的文章中写过“进程外”设计以及为什么服务网格如此受欢迎。然而，<strong class="iw hj">了解备选方案以做出适合环境并满足目标的决策是很重要的，</strong>这就是本文的目的。</p><h1 id="600d" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">它解决的问题和它带来的特性</h1><p id="7752" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">服务网格在隐藏大规模<strong class="iw hj">同步服务到服务通信的复杂性方面做得非常出色</strong>，这就是为什么它的采用率在上升。</p><p id="ef20" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">它带来的功能包括</p><ol class=""><li id="ffe6" class="kv kw hi iw b ix iy jb jc jf kx jj ky jn kz jr la lb lc ld bi translated"><strong class="iw hj">安全- </strong>加密和相互认证。</li><li id="d49e" class="kv kw hi iw b ix le jb lf jf lg jj lh jn li jr la lb lc ld bi translated"><strong class="iw hj">弹性通信— </strong>能够克服网络故障的重试策略。</li><li id="816b" class="kv kw hi iw b ix le jb lf jf lg jj lh jn li jr la lb lc ld bi translated"><strong class="iw hj">可观察性</strong> —因为所有的交通都流经侧车代理。所有流量都是可以观察到的。</li><li id="a25b" class="kv kw hi iw b ix le jb lf jf lg jj lh jn li jr la lb lc ld bi translated"><strong class="iw hj">路由/流量整形</strong>支持A/B测试和canary发布。</li></ol><h1 id="d32b" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">考虑</h1><p id="50ee" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">学习新技术，更多移动部件的技术复杂性，以及每个pod的额外内存和CPU利用率。和支持服务网格的基础设施。</p><h1 id="20f9" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">替代品:</h1><h2 id="9d8f" class="lj jt hi bd ju lk ll lm jy ln lo lp kc jf lq lr kg jj ls lt kk jn lu lv ko lw bi translated">1) SDK库</h2><figure class="ly lz ma mb fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lx"><img src="../Images/b8a9a7de7a9262437957bc227f60006c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g1u8mAXCMM2WcCJWndaCdw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">进程内架构与进程外架构</figcaption></figure><p id="11a7" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">与服务网格代理所遵循的“进程外”架构不同，将库用于基础设施和横切关注点(如日志记录、弹性、配置)是传统的方法，其中应用程序由具有业务逻辑以及横切和基础设施关注点的单个流程组成。</p><p id="6b2a" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">作为单个进程有其缺点，因为这意味着SDK的运行时必须与应用程序的运行时兼容。以及高耦合低内聚设计的问题。</p><p id="3ac8" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">但是这种“过程中”的设计也有它的好处—</p><ol class=""><li id="b3e9" class="kv kw hi iw b ix iy jb jc jf kx jj ky jn kz jr la lb lc ld bi translated">简单的实现和调试。</li><li id="157f" class="kv kw hi iw b ix le jb lf jf lg jj lh jn li jr la lb lc ld bi translated">简单的部署和监控。</li><li id="ea34" class="kv kw hi iw b ix le jb lf jf lg jj lh jn li jr la lb lc ld bi translated">可能导致故障的连接/移动部件更少。</li><li id="dc45" class="kv kw hi iw b ix le jb lf jf lg jj lh jn li jr la lb lc ld bi translated">极低的延迟。根据另一个进程运行的位置(同一台机器或远程机器)，会有一定程度的延迟。</li></ol><p id="7c71" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在我之前的文章中有更多关于进程外架构和侧车模式的内容。</p><h2 id="ea53" class="lj jt hi bd ju lk ll lm jy ln lo lp kc jf lq lr kg jj ls lt kk jn lu lv ko lw bi translated">2)使用异步通信(消息传递)代替同步的服务到服务调用。</h2><figure class="ly lz ma mb fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mc"><img src="../Images/b623846c35c77159b2372867bfc4b87a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TXPMYepvE3zeRI2-W8lSwg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">服务到服务通信与基于事件的异步通信</figcaption></figure><p id="0c9c" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">服务网格支持同步的服务到服务通信。后端服务之间的同步通信被认为是利用超大规模云资源的障碍。因为它可以形成长的网络链，依赖于其他服务的可用性，并促进低内聚服务集成设计。</p><figure class="ly lz ma mb fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es md"><img src="../Images/134f625ecdbd76f4dd18300337a074d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zD2YHBIBUH9eXYe_bbI91A.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">反模式——在服务客户端请求时，在后端服务之间创建的请求链。</figcaption></figure><p id="6e1e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">另一方面，服务之间的异步通信促进了去耦服务(通过打破时间耦合),这进一步导致了独立的可伸缩性、可用性和性能。异步通信是通过消息代理或事件流完成的，消息代理或事件流向消费者服务交付小而频繁的信息包(但是也可以通过HTTP对异步通信建模&amp;我将留下一篇文章的链接)。</p><p id="95f8" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">同步调用在系统集成中有一席之地，但它需要在评估事件后有意识地做出决定</p><h2 id="2c30" class="lj jt hi bd ju lk ll lm jy ln lo lp kc jf lq lr kg jj ls lt kk jn lu lv ko lw bi translated"><strong class="ak">总结</strong></h2><p id="5942" class="pw-post-body-paragraph iu iv hi iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr hb bi translated">服务网格可以解决很多挑战。如果组织内部已经为它建立了基础设施，这将是一个不可抗拒的提议。然而，用于系统集成的异步消息传递仍然应该被考虑。</p><p id="ba71" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">此外，如果我们谈论的是数千个或数十个吊舱，那么考虑规模也很重要。</p><h2 id="4777" class="lj jt hi bd ju lk ll lm jy ln lo lp kc jf lq lr kg jj ls lt kk jn lu lv ko lw bi translated">相关文章</h2><ol class=""><li id="b8ed" class="kv kw hi iw b ix kq jb kr jf me jj mf jn mg jr la lb lc ld bi translated">流程外设计和侧车代理— <a class="ae mh" rel="noopener" href="/codex/communication-inside-a-kubernetes-pod-why-do-we-need-multi-container-pods-3d8d0d64c2c9">为什么我们需要多容器箱？</a></li></ol><p id="fc8c" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">2.服务网格- <a class="ae mh" rel="noopener" href="/codex/east-west-service-to-service-communication-what-is-service-mesh-4e56f94bc89c">什么是服务网格？为什么我们需要它而不是Kubernetes？</a></p><p id="a89f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">3.REST API上的异步通信—<a class="ae mh" rel="noopener" href="/aws-tip/asynchronous-client-server-communication-with-rest-apis-websockets-cbfe145c145e">REST API上的异步通信—客户端-服务器&amp; WebSockets </a></p></div></div>    
</body>
</html>