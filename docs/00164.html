<html>
<head>
<title>Go with some context</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">结合一些背景</h1>
<blockquote>原文：<a href="https://medium.com/codex/go-with-some-context-a4a55266c78?source=collection_archive---------0-----------------------#2020-12-25">https://medium.com/codex/go-with-some-context-a4a55266c78?source=collection_archive---------0-----------------------#2020-12-25</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="7344" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Go中的<code class="du jd je jf jg b">context</code>包相当简单，也是众所周知的。另一方面，在使用它的同时也存在一些误区。今天，我将尝试解释所有最受欢迎的问题，并更清楚地说明何时以及如何使用<code class="du jd je jf jg b">Context</code>。</p><p id="377e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">先说语境是什么。</p><blockquote class="jh ji jj"><p id="0597" class="if ig jk ih b ii ij ik il im in io ip jl ir is it jm iv iw ix jn iz ja jb jc hb bi translated"><em class="hi">包上下文定义了上下文类型，它携带截止日期、取消信号和其他跨API边界和进程间的请求范围值。参考:</em><a class="ae jo" href="https://golang.org/pkg/context/" rel="noopener ugc nofollow" target="_blank"><em class="hi">https://golang.org/pkg/context/</em></a></p></blockquote><p id="38c0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">换句话说，上下文用于停止goroutines，它携带请求范围的值。在实践中到底是什么意思？</p><p id="26a0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最流行的用例是当你有一个请求-响应模式时。该请求可以是HTTP请求或CLI命令。通常，为了完成工作，您必须进行数据库查询，向外部API发送请求，从redis集群中读取一些数据，或者将这些字节写入文件系统。一切都需要时间。</p><p id="fd88" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">按照惯例，上下文作为函数中的第一个参数传递。几乎在任何地方你都会发现称它为<code class="du jd je jf jg b">ctx</code>。</p><pre class="jp jq jr js fd jt jg ju jv aw jw bi"><span id="ac14" class="jx jy hi jg b fi jz ka l kb kc">func myFunc(ctx context.Context, param1 int) error }</span></pre><p id="f1ed" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">事实上，<code class="du jd je jf jg b">context.Context</code>是一个小界面，但非常强大。我们要讨论的第一种方法是<code class="du jd je jf jg b">Done()</code>。</p><pre class="jp jq jr js fd jt jg ju jv aw jw bi"><span id="2eed" class="jx jy hi jg b fi jz ka l kb kc">type Context interface {<br/>    Done() &lt;-chan struct{}</span></pre><p id="f6d9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">取消上下文可能有三个原因:</p><ul class=""><li id="2c6e" class="kd ke hi ih b ii ij im in iq kf iu kg iy kh jc ki kj kk kl bi translated">在父上下文或当前上下文的某个地方调用了一个<code class="du jd je jf jg b">cancel()</code>函数</li><li id="877a" class="kd ke hi ih b ii km im kn iq ko iu kp iy kq jc ki kj kk kl bi translated">截止日期已到</li><li id="beeb" class="kd ke hi ih b ii km im kn iq ko iu kp iy kq jc ki kj kk kl bi translated">已超时</li></ul><p id="9c52" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果设置了超时或截止日期，我们可以使用<code class="du jd je jf jg b">Deadline()</code>功能读取在取消截止日期之前我们还有多少时间。</p><pre class="jp jq jr js fd jt jg ju jv aw jw bi"><span id="c3c0" class="jx jy hi jg b fi jz ka l kb kc">type Context interface {<br/>    Done() &lt;-chan struct{}<br/>    Err() error<br/>    Deadline() (deadline time.Time, ok bool)</span></pre><p id="72c7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果<code class="du jd je jf jg b">ok</code>参数返回一个<code class="du jd je jf jg b">true</code>，这意味着截止日期或时间已经设定。第一个返回值将包含上下文将被取消的时间点。</p><p id="4eeb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du jd je jf jg b">context.Context</code>界面的最后一个功能是<code class="du jd je jf jg b">Value(key, value)</code>。您可以使用它来获取先前存储在上下文中的值。</p><h1 id="992b" class="kr jy hi bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">对上下文的操作</h1><p id="ae6c" class="pw-post-body-paragraph if ig hi ih b ii lo ik il im lp io ip iq lq is it iu lr iw ix iy ls ja jb jc hb bi translated">您可以使用两种方法之一创建上下文:<code class="du jd je jf jg b">context.Background()</code>和<code class="du jd je jf jg b">context.TODO()</code>。当接受来自客户端(HTTP、gRPC、TCP等)的新请求或在测试中，在<code class="du jd je jf jg b">main()</code>函数中启动新应用时，应始终使用第一种方法。每当你想把上下文添加到你的代码中，但是调用者函数还不支持的时候，你应该使用<code class="du jd je jf jg b">context.TODO()</code>。</p><pre class="jp jq jr js fd jt jg ju jv aw jw bi"><span id="a90f" class="jx jy hi jg b fi jz ka l kb kc">func foo(param1 int, param2 string) error {<br/>    // doing some work...<br/>    return bar(context.TODO(), param1, param2)<br/>}</span></pre><p id="3f70" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">三个next函数中的每一个都返回一个新的上下文(它是父上下文的副本，但有一点修改)和一个cancel函数。cancel函数立即取消上下文。</p><p id="c91b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du jd je jf jg b">context.WithCancel(ctx)</code>函数除了用cancel函数返回一个新的上下文之外什么也不做。</p><pre class="jp jq jr js fd jt jg ju jv aw jw bi"><span id="46c4" class="jx jy hi jg b fi jz ka l kb kc">func foo(ctx context.Context, second int, last string) error {<br/>    ctx, cancel := context.WithCancel(ctx)<br/>    defer cancel()<br/><br/>    // do your job here<br/>}</span></pre><p id="f7d4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">函数<code class="du jd je jf jg b">context.WithTimeout(ctx, timeout)</code>返回一个新的上下文，该上下文在指定的超时后被取消。让我解释下一个例子是如何工作的。</p><pre class="jp jq jr js fd jt jg ju jv aw jw bi"><span id="fa0e" class="jx jy hi jg b fi jz ka l kb kc">func slowOperationWithTimeout(ctx context.Context) (Result, error) {<br/>    ctx, cancel := context.WithTimeout(ctx, 100*time.Millisecond)<br/>    defer cancel()<br/>    return slowOperation(ctx)<br/>}</span></pre><p id="8a5f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们假设<code class="du jd je jf jg b">slowOperation()</code>可以非常慢。由于在上下文中添加了超时，我们可以确保操作时间不会超过100毫秒。</p><p id="981c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du jd je jf jg b">context.WithDeadline</code>的工作方式与前一个非常相似，但区别在于我们定义了想要取消上下文的时间点(在未来)。</p><pre class="jp jq jr js fd jt jg ju jv aw jw bi"><span id="d09a" class="jx jy hi jg b fi jz ka l kb kc">const shortDuration = 1 * time.Millisecond<br/><br/>func main() {<br/>    d := time.Now().Add(shortDuration)<br/>    ctx, cancel := context.WithDeadline(context.Background(), d)<br/>    defer cancel()<br/><br/>    select {<br/>    case &lt;-time.After(1 * time.Second):<br/>        fmt.Println("overslept")<br/>        case &lt;-ctx.Done():<br/>        fmt.Println(ctx.Err())<br/>    }<br/>}</span></pre><p id="5b49" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">代码的输出是<code class="du jd je jf jg b">context deadline exceeded</code>。为什么？截止时间设置为现在+ 1毫秒。早于计时器中定义的1秒。</p><p id="a48e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下一个可用的方法是<code class="du jd je jf jg b">context.WithValue:</code></p><pre class="jp jq jr js fd jt jg ju jv aw jw bi"><span id="b60b" class="jx jy hi jg b fi jz ka l kb kc">func WithValue(parent Context, key, val interface{}) Context</span></pre><p id="e215" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它基于设置了键值的父上下文返回一个新的上下文。键可以是任何东西，但是有一个惯例是创建一个自定义类型，而不是像<code class="du jd je jf jg b">int</code>或<code class="du jd je jf jg b">string</code>这样的内置类型。为什么？这有助于避免命名冲突。想象一下，两个包在同一个键中设置了不同的值。这可能会令人困惑，并导致很难找到错误。你可以只使用一个空的结构。</p><pre class="jp jq jr js fd jt jg ju jv aw jw bi"><span id="a4ea" class="jx jy hi jg b fi jz ka l kb kc">type myKey struct{}<br/><br/>func foo(ctx context.Context) {<br/>    // ctx = WithValue(ctx, "my key", "my awesome value") - it can lead to a naming conflicts<br/>   ctx = ctx.WithValue(ctx, myKey{}, "my awesome value")<br/>}</span></pre><h1 id="9a0f" class="kr jy hi bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">是否应该一直调用<code class="du jd je jf jg b">cancel()</code>函数？</h1><p id="2967" class="pw-post-body-paragraph if ig hi ih b ii lo ik il im lp io ip iq lq is it iu lr iw ix iy ls ja jb jc hb bi translated">函数<code class="du jd je jf jg b">WithTimeout</code>和<code class="du jd je jf jg b">WithDeadline</code>不仅设置取消上下文的时间点，还返回取消函数。您可以使用它在截止日期或超时之前取消上下文。问题是:即使上下文被取消了，你也应该总是取消吗？答案是:<strong class="ih hj">是的。</strong></p><pre class="jp jq jr js fd jt jg ju jv aw jw bi"><span id="b461" class="jx jy hi jg b fi jz ka l kb kc">func main() {<br/>    d := time.Now().Add(shortDuration)<br/>    ctx, _ := context.WithDeadline(context.Background(), d) // careful!<br/><br/>    // do what you have to do<br/>    foo(ctx)<br/>}</span></pre><p id="2bdb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">想象一下<code class="du jd je jf jg b">foo(ctx)</code>跨越了其他goroutines并包含了上下文。当<code class="du jd je jf jg b">foo()</code>完成它的工作时，那些goroutines仍然可以运行并等待截止日期。对于一两个gorutines来说，它可能不会有很大的影响，但是当你在一秒钟内跨越几百次时，它可能会很明显。</p><h1 id="07bf" class="kr jy hi bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">取消是如何工作的？</h1><p id="6ff7" class="pw-post-body-paragraph if ig hi ih b ii lo ik il im lp io ip iq lq is it iu lr iw ix iy ls ja jb jc hb bi translated">我想下面这张图会帮助你理解。</p><figure class="jp jq jr js fd lu er es paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="er es lt"><img src="../Images/5843930f5b274ca1d1c44f1afc600040.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*3xSDNuPtEIqVHDWs.png"/></div></div></figure><p id="2153" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在某些情况下，你可以用一种更有创造性的方式来使用这个包。您可以使用取消机制来削减一些指标的尾部。想象一种情况，您向外部API发送请求。一般来说，API发送响应的速度非常快。假设平均时间在50到100毫秒之间。然而，有时，API在一秒钟内发送响应，然后，一切都回到正常行为。</p><p id="6c64" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">较慢的外部API响应也会使您的API变慢，因为您正在等待来自其他地方的数据。让我们假设我们发送的请求是不可变的。这意味着ti不会改变任何东西——它只是获取一些数据。你可以用(至少)两种方法解决这个问题。</p><p id="9b2a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第一个是一次发送多个请求，当我们收到最快的请求时，取消每个请求。它有一些弱点。您增加了网络流量，也给其他人的服务带来了更大的压力。</p><p id="98af" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第二件事是为请求设置一个超时，比如说150毫秒，当它到达最后期限时，再次发送请求。每次重试都会有稍长的超时时间，在几次尝试后，您可能会使请求失败。</p><p id="95f5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我知道这些例子并不完美，而且非常具体，但是我希望我给了你一点提示，告诉你<code class="du jd je jf jg b">context.Context</code>如何在你的代码中有用。</p><h1 id="dfe2" class="kr jy hi bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">摘要</h1><p id="f47e" class="pw-post-body-paragraph if ig hi ih b ii lo ik il im lp io ip iq lq is it iu lr iw ix iy ls ja jb jc hb bi translated">我希望我在<code class="du jd je jf jg b">context</code>包如何工作的问题上帮助了你更多。如您所见，这是一个简单的工具，但对我们的代码行为有很大的控制。感谢它，你可以利用资源，使你的代码更有弹性。</p><p id="f063" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jo" href="https://www.buymeacoffee.com/bklimczak" rel="noopener ugc nofollow" target="_blank">给我买杯咖啡</a></p></div><div class="ab cl mb mc gp md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="hb hc hd he hf"><p id="4414" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">【https://developer20.com】最初发表于<a class="ae jo" href="https://developer20.com/go-context/" rel="noopener ugc nofollow" target="_blank"><em class="jk"/></a><em class="jk">。</em></p></div></div>    
</body>
</html>