<html>
<head>
<title>How to build a Google sign-in in Flutter without Firebase</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在没有Firebase的情况下在Flutter中构建一个Google登录</h1>
<blockquote>原文：<a href="https://medium.com/codex/how-to-build-a-google-sign-in-in-flutter-without-firebase-5d0d379b2f64?source=collection_archive---------1-----------------------#2022-07-25">https://medium.com/codex/how-to-build-a-google-sign-in-in-flutter-without-firebase-5d0d379b2f64?source=collection_archive---------1-----------------------#2022-07-25</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="9596" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用<a class="ae jd" href="https://pub.dev/packages/flutter_appauth" rel="noopener ugc nofollow" target="_blank"> Flutter AppAuth </a>，让你的Flutter应用用户通过GoogleOAuth2认证，并与你的后端连接。不限于Firebase。</p><p id="2644" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"><em class="je">TL；DR:这个项目的GitHub repo可以在这里</em> </strong>  <strong class="ih hj"> <em class="je">找到</em> </strong> <a class="ae jd" href="https://github.com/florianabel/social-auth-example-flutter" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj"> <em class="je">。</em>T15】</strong></a></p><figure class="jg jh ji jj fd jk er es paragraph-image"><div role="button" tabindex="0" class="jl jm di jn bf jo"><div class="er es jf"><img src="../Images/816da97f510ee6ebe244686e737041eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*9B0-abqgTRhdCFi_"/></div></div><figcaption class="jr js et er es jt ju bd b be z dx translated"><a class="ae jd" href="https://unsplash.com/@freestocks?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> freestocks </a>在<a class="ae jd" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="3ee4" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">介绍</h1><p id="28d4" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq kv is it iu kw iw ix iy kx ja jb jc hb bi translated">本文是在你的Flutter应用程序中使用GoogleOAuth2实现社交认证的分步指南，使用<a class="ae jd" href="https://pub.dev/packages/flutter_appauth" rel="noopener ugc nofollow" target="_blank"> Flutter AppAuth </a>。成功认证后，您将收到一个访问令牌，以便访问您的后端。我写了另一篇文章解释如何用Django应用程序处理后端。然而，你可以自由地使用任何你觉得最舒服的后端。</p><h1 id="1e81" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">使用OAuth2进行身份验证</h1><p id="920a" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq kv is it iu kw iw ix iy kx ja jb jc hb bi translated">OAuth2的身份验证基于不同的流程，这取决于您的应用程序所使用的特定设置。Aaron Parecki 和Auth0 的两篇文章很好地涵盖了基础知识以及为您的项目选择哪个流程。</p><h2 id="73d1" class="ky jw hi bd jx kz la lb kb lc ld le kf iq lf lg kj iu lh li kn iy lj lk kr ll bi translated">带有证明密钥的授权代码流(PKCE)</h2><p id="39b5" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq kv is it iu kw iw ix iy kx ja jb jc hb bi translated">在本例中，我们使用<a class="ae jd" href="https://oauth.net/2/pkce/" rel="noopener ugc nofollow" target="_blank">带有代码交换证明密钥的授权代码流(PKCE) </a>，这是公共客户端(如单页面和移动应用程序)向OAuth2提供者请求访问令牌时的推荐方式。提供者的身份验证过程发生在客户端。身份验证成功后，客户端将收到的访问令牌交换为来自后端的身份验证令牌。有了这个令牌，客户端就可以使用后端提供的受限端点。</p><p id="f152" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">关于这个流程的更多细节在这篇<a class="ae jd" href="https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow-with-proof-key-for-code-exchange-pkce" rel="noopener ugc nofollow" target="_blank"> Auth0文章</a>中有很好的解释。我们的例外是，我们直接连接到GoogleOAuth2，而不是Auth0。</p><h1 id="b33d" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">向GoogleOAuth2注册您的应用程序</h1><p id="df87" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq kv is it iu kw iw ix iy kx ja jb jc hb bi translated">为了让使用谷歌的社交登录功能，您的应用程序需要在<a class="ae jd" href="https://console.cloud.google.com/" rel="noopener ugc nofollow" target="_blank">谷歌云控制台</a>注册。</p><ol class=""><li id="d8f8" class="lm ln hi ih b ii ij im in iq lo iu lp iy lq jc lr ls lt lu bi translated">创建新项目</li><li id="884b" class="lm ln hi ih b ii lv im lw iq lx iu ly iy lz jc lr ls lt lu bi translated">定义您的<a class="ae jd" href="https://console.cloud.google.com/apis/credentials/consent" rel="noopener ugc nofollow" target="_blank"> OAuth同意屏幕</a></li><li id="4af8" class="lm ln hi ih b ii lv im lw iq lx iu ly iy lz jc lr ls lt lu bi translated">创建<a class="ae jd" href="https://console.cloud.google.com/apis/credentials" rel="noopener ugc nofollow" target="_blank">凭证</a></li></ol><h2 id="7911" class="ky jw hi bd jx kz la lb kb lc ld le kf iq lf lg kj iu lh li kn iy lj lk kr ll bi translated">创建凭据</h2><p id="8c11" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq kv is it iu kw iw ix iy kx ja jb jc hb bi translated"><em class="je">注意:我们需要创建两组凭证，一组用于iOS，一组用于Android。</em></p><p id="8c4d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们从<a class="ae jd" href="https://console.cloud.google.com/apis/credentials" rel="noopener ugc nofollow" target="_blank">全权证书开始——页面</a>:</p><ol class=""><li id="3ef0" class="lm ln hi ih b ii ij im in iq lo iu lp iy lq jc lr ls lt lu bi translated">选择页面顶部的<code class="du ma mb mc md b">+ Create Credentials</code></li><li id="b99e" class="lm ln hi ih b ii lv im lw iq lx iu ly iy lz jc lr ls lt lu bi translated">选择<code class="du ma mb mc md b">OAuth client ID</code></li><li id="e71f" class="lm ln hi ih b ii lv im lw iq lx iu ly iy lz jc lr ls lt lu bi translated">申请类型为<code class="du ma mb mc md b">iOS</code>或<code class="du ma mb mc md b">Android</code></li><li id="3516" class="lm ln hi ih b ii lv im lw iq lx iu ly iy lz jc lr ls lt lu bi translated">随你的便吧</li><li id="de10" class="lm ln hi ih b ii lv im lw iq lx iu ly iy lz jc lr ls lt lu bi translated">填写<code class="du ma mb mc md b">Bundle ID</code> (iOS)或<code class="du ma mb mc md b">Package Name</code> (Android)</li><li id="0a92" class="lm ln hi ih b ii lv im lw iq lx iu ly iy lz jc lr ls lt lu bi translated">创建并填写<code class="du ma mb mc md b">SHA-1 certificate fingerprint</code>(仅适用于Android)</li><li id="bd02" class="lm ln hi ih b ii lv im lw iq lx iu ly iy lz jc lr ls lt lu bi translated">复制并保存<code class="du ma mb mc md b">Client ID</code></li></ol><p id="9fb4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> Bundle ID和Package Name<br/>T24<a class="ae jd" href="https://developer.apple.com/documentation/appstoreconnectapi/bundle_ids" rel="noopener ugc nofollow" target="_blank">Bundle ID</a>和<a class="ae jd" href="https://support.google.com/admob/answer/9972781?hl=en" rel="noopener ugc nofollow" target="_blank"> Package Name </a>是唯一标识符，由您选择。对于苹果应用商店或谷歌Play商店中的两个应用程序来说，它们不可能分别是相同的。常见的格式是<code class="du ma mb mc md b">com.company.appname</code>，例如<code class="du ma mb mc md b">com.socialauthexample.mobile_app</code>。</strong></p><p id="ff18" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">注意:不要使用连字符(-)或下划线(_)，否则可能会出错。</p><p id="f47c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> SHA-1证书指纹<br/><br/>要为您的开发环境获取它，您可以遵循以下步骤。查看<a class="ae jd" href="https://www.kindacode.com/article/android-how-to-get-sha-certificate-fingerprints/" rel="noopener ugc nofollow" target="_blank">这篇文章</a>以获得更多关于为生产获取指纹的信息和说明。</strong></p><p id="ddf2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">对于Mac: </strong></p><pre class="jg jh ji jj fd me md mf mg aw mh bi"><span id="8c04" class="ky jw hi md b fi mi mj l mk ml">keytool -list -v -keystore ~/.android/debug.keystore -alias androiddebugkey -storepass android -keypass android</span></pre><p id="29a5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">对于Windows: </strong></p><pre class="jg jh ji jj fd me md mf mg aw mh bi"><span id="e467" class="ky jw hi md b fi mi mj l mk ml">keytool -list -v -keystore C:\Users\&lt;Your User Name&gt;\.android\debug.keystore -alias androiddebugkey</span></pre><p id="4b61" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="je">注意:确保之前至少运行一次Android Studio，否则可能会收到错误。</em></p><h1 id="c170" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">设置您的应用程序</h1><h2 id="f109" class="ky jw hi bd jx kz la lb kb lc ld le kf iq lf lg kj iu lh li kn iy lj lk kr ll bi translated">创建基础应用程序</h2><pre class="jg jh ji jj fd me md mf mg aw mh bi"><span id="7d41" class="ky jw hi md b fi mi mj l mk ml">flutter create --org com.socialauthexample mobile_app</span></pre><h2 id="0e57" class="ky jw hi bd jx kz la lb kb lc ld le kf iq lf lg kj iu lh li kn iy lj lk kr ll bi translated">安装所需的依赖项</h2><p id="536d" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq kv is it iu kw iw ix iy kx ja jb jc hb bi translated">我们的社交认证解决方案和令牌的安全存储需要三个包。</p><p id="58e6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jd" href="https://pub.dev/packages/flutter_appauth" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj">flutter _ app auth</strong></a><strong class="ih hj"><br/></strong>维护良好的Flutter包，包裹在<a class="ae jd" href="https://appauth.io/" rel="noopener ugc nofollow" target="_blank"> AppAuth </a>周围，为用户提供认证和授权。</p><p id="548f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jd" href="https://pub.dev/packages/http" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj">http</strong></a><strong class="ih hj"><br/></strong>基于未来的库来执行HTTP请求，由Dart团队开发。</p><p id="c96b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jd" href="https://pub.dev/packages/flutter_secure_storage" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj">flutter _ secure _ storage</strong></a><strong class="ih hj"><br/></strong>一个将数据存储在安全存储器中的Flutter插件。</p><pre class="jg jh ji jj fd me md mf mg aw mh bi"><span id="3e2f" class="ky jw hi md b fi mi mj l mk ml">flutter pub add flutter_appauth &amp;&amp; flutter pub add http &amp;&amp; flutter pub add flutter_secure_storage</span></pre><h1 id="68dd" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">为我们的应用程序提供凭证</h1><p id="d82b" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq kv is it iu kw iw ix iy kx ja jb jc hb bi translated">为了成功地认证我们的用户，我们需要提供客户端id(以前获得的)并将URL重定向到我们的应用程序。</p><h2 id="1908" class="ky jw hi bd jx kz la lb kb lc ld le kf iq lf lg kj iu lh li kn iy lj lk kr ll bi translated">重定向URL格式</h2><p id="4f2e" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq kv is it iu kw iw ix iy kx ja jb jc hb bi translated">重定向或回调URL是OAuth2服务器在成功认证后将用户发送到的地址。谷歌在格式上有<a class="ae jd" href="https://developers.google.com/identity/protocols/oauth2/native-app#request-parameter-redirect_uri" rel="noopener ugc nofollow" target="_blank">具体要求</a>。我们在本例中使用的格式基于您的客户端id:<code class="du ma mb mc md b">com.googleusercontent.apps.&lt;CLIENT-ID&gt;:redirect_uri_path</code></p><p id="8ff4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> iOS </strong></p><pre class="jg jh ji jj fd me md mf mg aw mh bi"><span id="e61d" class="ky jw hi md b fi mi mj l mk ml">com.googleusercontent.apps.&lt;IOS-CLIENT-ID&gt;:/oauthredirect</span></pre><p id="f0b9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">安卓</strong></p><pre class="jg jh ji jj fd me md mf mg aw mh bi"><span id="48b0" class="ky jw hi md b fi mi mj l mk ml">com.googleusercontent.apps.&lt;ANDROID-CLIENT-ID&gt;:/oauthredirect</span></pre><p id="7551" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">使用代码库中的变量<br/> </strong>我们使用一个助手文件<code class="du ma mb mc md b">lib/helper/constants.dart</code>来存储应用程序的所有常量，并根据应用程序运行的平台传递正确的凭证。</p><figure class="jg jh ji jj fd jk"><div class="bz dy l di"><div class="mm mn l"/></div><figcaption class="jr js et er es jt ju bd b be z dx translated">社交验证示例应用程序的常数</figcaption></figure><blockquote class="mo mp mq"><p id="5794" class="if ig je ih b ii ij ik il im in io ip mr ir is it ms iv iw ix mt iz ja jb jc hb bi translated">注意:出于安全原因，凭证不应该成为源代码的一部分。提供它们最安全的方式是使用环境变量，例如<a class="ae jd" href="https://pub.dev/packages/flutter_config" rel="noopener ugc nofollow" target="_blank"> flutter_config </a>，但是这超出了本文的范围。</p></blockquote><h2 id="15b9" class="ky jw hi bd jx kz la lb kb lc ld le kf iq lf lg kj iu lh li kn iy lj lk kr ll bi translated">设置URL方案</h2><p id="c6f0" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq kv is it iu kw iw ix iy kx ja jb jc hb bi translated">除了为Flutter AppAuth提供重定向URL之外，我们还需要让我们的应用程序知道所需的URL方案。</p><p id="d87a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">CFBundleURLSchemes(iOS)<br/></strong>为了配置iOS的URL方案，我们在<code class="du ma mb mc md b">/ios/Runner/Info.plist</code>文件中添加了一个新的<code class="du ma mb mc md b">dict</code>标签<code class="du ma mb mc md b">CFBundleURLTypes</code>。</p><figure class="jg jh ji jj fd jk"><div class="bz dy l di"><div class="mm mn l"/></div></figure><p id="2129" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">appAuthRedirectScheme(Android)<br/></strong>对于Android，我们需要调整<code class="du ma mb mc md b">/android/app/build.gradle</code>文件中的以下条目。</p><figure class="jg jh ji jj fd jk"><div class="bz dy l di"><div class="mm mn l"/></div></figure><p id="742b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="je">注意:确保URL方案和重定向URL匹配，否则您可能无法在认证后被重定向。</em></p><h1 id="c46d" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">构建应用程序</h1><p id="cdf8" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq kv is it iu kw iw ix iy kx ja jb jc hb bi translated">我们的应用程序将为未经认证的用户显示一个登录屏幕，在成功认证后，该屏幕将被我们的主屏幕所取代。此外，以前登录的用户在重新启动应用程序后仍保持登录状态。</p><p id="111b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们正在用我们的<code class="du ma mb mc md b">lib/main.dart</code>文件中的一些基本逻辑创建一个用户界面，三个额外的屏幕，以及一个处理认证的服务<code class="du ma mb mc md b">lib/services/authentication_service.dart</code>。</p><h2 id="ed39" class="ky jw hi bd jx kz la lb kb lc ld le kf iq lf lg kj iu lh li kn iy lj lk kr ll bi translated">应用界面</h2><p id="6054" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq kv is it iu kw iw ix iy kx ja jb jc hb bi translated">main.dart <br/> 我们的<code class="du ma mb mc md b">main.dart</code>持有我们的应用程序的基础结构。两个标志，<code class="du ma mb mc md b">isLoading</code>和<code class="du ma mb mc md b">isLoggedIn</code>，表示当前的认证状态，以及当前是否加载了某个动作。它们的状态由三种方法处理(<code class="du ma mb mc md b">setLoadingState</code>、<code class="du ma mb mc md b">setAuthenticatedState</code>和<code class="du ma mb mc md b">setUnauthenticatedState</code>)，构建器相应地提供正确的屏幕、<code class="du ma mb mc md b">LoadingScreen</code>、<code class="du ma mb mc md b">MainScreen</code>、<code class="du ma mb mc md b">AuthenticationScreen</code>。</p><p id="d2f5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在应用程序初始化时，我们的应用程序会检查用户当前是否已经过身份验证，并相应地设置状态(关于如何发生的细节将在下面进一步讨论)。如果用户已经通过身份验证，则提供<code class="du ma mb mc md b">MainScreen</code>，否则，我们的用户将看到<code class="du ma mb mc md b">AuthenticationScreen</code>。此外，我们将适当的函数作为回调来传递，以便稍后更改状态。</p><figure class="jg jh ji jj fd jk"><div class="bz dy l di"><div class="mm mn l"/></div></figure><p id="d832" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> loading_screen.dart <br/></strong></p><figure class="jg jh ji jj fd jk"><div class="bz dy l di"><div class="mm mn l"/></div></figure><p id="0368" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">authentic ation _ screen . dart<br/>成功时，我们的应用程序切换到认证状态，显示<code class="du ma mb mc md b">MainScreen</code>，否则，它返回到未认证状态，再次显示<code class="du ma mb mc md b">AuthenticationScreen</code>。</strong></p><figure class="jg jh ji jj fd jk"><div class="bz dy l di"><div class="mm mn l"/></div></figure><p id="a1f5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> main_screen.dart <br/>当单击按钮时，我们的logout方法被调用，该方法又调用身份验证服务，并在成功时将应用程序的状态更改为unauthenticated。</strong></p><figure class="jg jh ji jj fd jk"><div class="bz dy l di"><div class="mm mn l"/></div></figure><h2 id="0915" class="ky jw hi bd jx kz la lb kb lc ld le kf iq lf lg kj iu lh li kn iy lj lk kr ll bi translated">认证服务</h2><p id="fac3" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq kv is it iu kw iw ix iy kx ja jb jc hb bi translated">真正的魔力在于我们的认证服务。它检查我们安全存储中已经存在的刷新令牌，执行身份验证和刷新过程，并保存和删除我们获得的令牌。</p><p id="3918" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">基础知识<br/> </strong>身份验证服务是作为单例构建的，这意味着任何时候都只能存在一个实例。构造函数是私有的，只能从类内部调用。为了访问服务，我们总是需要调用实例<code class="du ma mb mc md b">AuthService.instance.someMethod()</code>。该服务提供三个公共方法和一个私有方法供内部使用。</p><p id="cc2c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">初始化<br/> </strong>第一个方法，在<code class="du ma mb mc md b">main.dart</code>中被应用程序调用的是<code class="du ma mb mc md b">initAuth()</code>。它检查现有的刷新令牌，并试图用它获得新的访问令牌。如果成功了，我们就有了一个登录的用户，我们的应用程序就进入了认证状态。如果没有，要么是没有用户登录，要么是令牌过期。在这两种情况下，我们的应用程序都会进入未经验证的状态。</p><p id="b2fb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">登录<br/> </strong>一旦用户点击登录按钮，我们的<code class="du ma mb mc md b">login()</code>方法就会被调用并开始认证过程。出现一个Google登录窗口，用户可以进行身份验证。如果一切顺利，将返回一个带有访问和刷新令牌的结果。</p><p id="3c18" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">注销后，保存的刷新令牌被删除，我们的应用程序切换回未认证状态。</p><p id="0516" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">处理认证结果<br/> </strong> <code class="du ma mb mc md b">_handleAuthResult</code>是我们服务中唯一的私有方法。它负责处理我们在验证时或在现有刷新令牌的帮助下试图获得新的访问令牌时从Google得到的响应。<br/>如果结果有效，我们更新刷新令牌。之后，我们将获得的访问令牌与来自我们自己后端的身份验证令牌进行交换，并保存它以供将来使用。</p><blockquote class="mo mp mq"><p id="383b" class="if ig je ih b ii ij ik il im in io ip mr ir is it ms iv iw ix mt iz ja jb jc hb bi translated">注意:由于这超出了本文的范围，我在方法的未注释部分为您展示了一个简单的例子。您可以根据需要用自己的后端来实现它。对于这个场景，我们只是假设后端返回了一个我们可以使用的有效令牌。</p></blockquote><figure class="jg jh ji jj fd jk"><div class="bz dy l di"><div class="mm mn l"/></div></figure><h1 id="96c1" class="jv jw hi bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">摘要</h1><p id="c9fb" class="pw-post-body-paragraph if ig hi ih b ii kt ik il im ku io ip iq kv is it iu kw iw ix iy kx ja jb jc hb bi translated">现在，您有了使用Google登录的基本社交认证模式。通过使用不同的凭证，它可以很容易地改变为不同的提供商，如脸书或Twitter。之后，您的后端将处理获得的访问令牌，并为您提供一个新的身份验证令牌。关于Django后端的例子，请查看我的另一篇文章。</p><p id="67ec" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">随意在评论里伸手或者关注我</strong><a class="ae jd" href="https://twitter.com/florian_abel_" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj">Twitter</strong></a><strong class="ih hj">(</strong><a class="ae jd" href="https://twitter.com/florian_abel_" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj">@ Florian _ Abel _</strong></a><strong class="ih hj">)。我很高兴听到你的想法、问题和经历。</strong></p></div></div>    
</body>
</html>