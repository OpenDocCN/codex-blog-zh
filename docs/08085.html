<html>
<head>
<title>PyCUDA, the FFT and the Gerchberg-Saxton algorithm</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">PyCUDA、FFT和Gerchberg-Saxton算法</h1>
<blockquote>原文：<a href="https://medium.com/codex/pycuda-the-fft-and-the-gerchberg-saxton-algorithm-35fb7bceb62f?source=collection_archive---------0-----------------------#2022-07-15">https://medium.com/codex/pycuda-the-fft-and-the-gerchberg-saxton-algorithm-35fb7bceb62f?source=collection_archive---------0-----------------------#2022-07-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/250872555b843cc687d413f07e33e78c.png" data-original-src="https://miro.medium.com/v2/resize:fit:750/format:webp/1*1w4DTs7br7qzLYlSM9vXMw.png"/></div></figure><p id="b7fc" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">恢复其振幅和变换振幅已知的二维函数的问题是一个经典的光学问题。</p><p id="23dd" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">解决这个问题的第一个简单算法是Gerchberg和Saxton的算法。它包括给振幅已知的函数的相位分配一个初始猜测。随后，对如此获得的函数进行傅立叶变换。变换的相位被保留，而幅度被称为问题数据的数据所取代。如此获得的变换被变换回空间域。以非常类似于在变换域中所做的方式，在空间域中，函数的相位被保留，而幅度被问题数据代替。该过程继续进行，直到达到收敛。停止迭代的一个标准可以是当未知函数从一次迭代到另一次迭代没有显著变化时返回结果。</p><p id="0b92" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">Gerchberg和Saxton算法也被归类为<em class="jk">相位恢复</em>算法，因为其目标是从未知函数的振幅和其变换的振幅开始恢复未知函数的相位。</p><p id="50ea" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在<a class="ae jl" href="https://www.retrorefractions.com/blog/" rel="noopener ugc nofollow" target="_blank"> Retro Refractions </a>博客上，可以检索到很多关于我们正在讨论的问题和正在讨论的算法的有用信息。</p><p id="d348" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">本文的目的是展示Gerchberg和Saxton算法的一个简单PyCUDA实现，这也给我们提供了一个机会，指出在图形处理器(GPU)上计算并行FFT和IFFTs的一个可能的例程。</p><p id="44e4" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在下面的例子中，我们将使用蝴蝶的黑白图像的强度的平方根作为未知函数的振幅，而变换的振幅将被认为一致等于1。</p><p id="f3da" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在深入PyCUDA实现之前，让我们先来看一个顺序Python版本。在下面的<a class="ae jl" href="https://github.com/vitalitylearning2021/FFT/tree/main/GerchbergSaxton" rel="noopener ugc nofollow" target="_blank">链接</a>中可以找到顺序和并行版本。</p></div><div class="ab cl jm jn gp jo" role="separator"><span class="jp bw bk jq jr js"/><span class="jp bw bk jq jr js"/><span class="jp bw bk jq jr"/></div><div class="hb hc hd he hf"><p id="d65d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">Python中实现Gerchberg和Saxton算法的函数如下:</p><figure class="jt ju jv jw fd ij"><div class="bz dy l di"><div class="jx jy l"/></div></figure><p id="3a83" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">请注意，<code class="du jz ka kb kc b">measuredAmplitudeSpace</code>和<code class="du jz ka kb kc b">measuredAmplitudeFourier</code>是问题的数据，即函数和变换函数的振幅，未知函数的相位完全随机选择。由于<code class="du jz ka kb kc b">numpy</code>库的功能，产生了随机相位。</p><p id="c339" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在<code class="du jz ka kb kc b">for</code>循环中，函数及其变换的振幅被问题数据反复替换。在顺序情况下，FFT和IFFT是通过<code class="du jz ka kb kc b">numpy</code>库实现的。</p></div><div class="ab cl jm jn gp jo" role="separator"><span class="jp bw bk jq jr js"/><span class="jp bw bk jq jr js"/><span class="jp bw bk jq jr"/></div><div class="hb hc hd he hf"><p id="229b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">PyCUDA中实现Gerchberg和Saxton算法的函数如下:</p><figure class="jt ju jv jw fd ij"><div class="bz dy l di"><div class="jx jy l"/></div></figure><p id="3829" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">它假设<code class="du jz ka kb kc b">d_img</code>输入图像已经是PyCUDA <code class="du jz ka kb kc b">gpuarray</code>。与之相反，它返回一个<code class="du jz ka kb kc b">numpy</code>数组。</p><p id="23ae" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">该函数遵循与Python实现相同的代码行。未知函数的相位仍然是随机选择的，这一次要感谢PyCUDA库的功能，它允许直接在GPU上生成随机数组。并行FFT的实现得益于<code class="du jz ka kb kc b">skcuda</code>库的<code class="du jz ka kb kc b">fft</code>功能，它本质上是CUDA <code class="du jz ka kb kc b">cuFFT</code>库的一个包装器。与<code class="du jz ka kb kc b">cuFFT</code>库例程一样，<code class="du jz ka kb kc b">skcuda</code> FFT库也需要一个<code class="du jz ka kb kc b">plan</code>。与顺序版本不同，由于PyCUDA提供的元素运算，通过将函数除以其幅度来提取相位。更多详情，请参见PyCUDA 中的<a class="ae jl" href="https://vitalitylearning.medium.com/elementary-operations-in-pycuda-5cb8d0b72161?source=your_stories_page-------------------------------------" rel="noopener">基本运算。</a></p><p id="2d43" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">最后，在位于<a class="ae jl" href="https://github.com/vitalitylearning2021/FFT/tree/main/GerchbergSaxton" rel="noopener ugc nofollow" target="_blank">链接</a>的存储库中，Gerchberg和Saxton函数的另一个并行版本实现如下:</p><figure class="jt ju jv jw fd ij"><div class="bz dy l di"><div class="jx jy l"/></div></figure><p id="3024" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在这个稍有不同的版本中，<em class="jk">投影</em>操作，即替换作为问题数据涉及的函数的幅度，是通过一个显式CUDA内核实现的:</p><figure class="jt ju jv jw fd ij"><div class="bz dy l di"><div class="jx jy l"/></div></figure><figure class="jt ju jv jw fd ij er es paragraph-image"><div class="er es if"><img src="../Images/250872555b843cc687d413f07e33e78c.png" data-original-src="https://miro.medium.com/v2/resize:fit:750/format:webp/1*1w4DTs7br7qzLYlSM9vXMw.png"/></div></figure></div></div>    
</body>
</html>