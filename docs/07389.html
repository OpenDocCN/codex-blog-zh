<html>
<head>
<title>Azure Functions — Bindings and triggers explained by an example using C#</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Azure函数——通过一个使用C#的例子解释绑定和触发器</h1>
<blockquote>原文：<a href="https://medium.com/codex/azure-functions-bindings-and-triggers-explained-by-an-example-using-c-229c18295f02?source=collection_archive---------25-----------------------#2022-06-13">https://medium.com/codex/azure-functions-bindings-and-triggers-explained-by-an-example-using-c-229c18295f02?source=collection_archive---------25-----------------------#2022-06-13</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/cdb76c8510fb9fbce3de9611b134c97a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*dmebKxeqAkq0kkLk"/></div></div></figure><p id="d84b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">与其他服务/应用程序的自动化交互是使用Azure功能的主要好处之一。这对于用Azure函数实现业务逻辑至关重要。这些功能是由触发器和绑定提供的。</p><div class="jo jp ez fb jq jr"><a rel="noopener follow" target="_blank" href="/codex/basics-of-serverless-functions-by-the-example-of-azure-functions-hands-on-2de0e9a13d03"><div class="js ab dw"><div class="jt ab ju cl cj jv"><h2 class="bd hj fi z dy jw ea eb jx ed ef hh bi translated">以Azure Functions + Hands on为例，介绍无服务器功能的基础知识</h2><div class="jy l"><h3 class="bd b fi z dy jw ea eb jx ed ef dx translated">云计算的最大优势之一是能够打开和关闭您的计算资源…</h3></div><div class="jz l"><p class="bd b fp z dy jw ea eb jx ed ef dx translated">medium.com</p></div></div><div class="ka l"><div class="kb l kc kd ke ka kf io jr"/></div></div></a></div><h2 id="1b86" class="kg kh hi bd ki kj kk kl km kn ko kp kq jb kr ks kt jf ku kv kw jj kx ky kz la bi translated">概观</h2><p id="f258" class="pw-post-body-paragraph iq ir hi is b it lb iv iw ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated"><strong class="is hj">触发器</strong>定义函数如何执行。它们决定函数何时被调用和从空闲状态中唤醒。Azure函数提供了各种不同的<a class="ae lg" href="https://docs.microsoft.com/en-us/azure/azure-functions/functions-triggers-bindings?tabs=csharp" rel="noopener ugc nofollow" target="_blank">触发器</a>。例如:您可以使用它们在每次有新条目存储到Cosmos DB时触发您的函数。以下是一个不完整的列表:</p><ul class=""><li id="0cbc" class="lh li hi is b it iu ix iy jb lj jf lk jj ll jn lm ln lo lp bi translated">HTTP/Webhook</li><li id="4899" class="lh li hi is b it lq ix lr jb ls jf lt jj lu jn lm ln lo lp bi translated">卡夫卡</li><li id="1c30" class="lh li hi is b it lq ix lr jb ls jf lt jj lu jn lm ln lo lp bi translated">活动中心</li><li id="168f" class="lh li hi is b it lq ix lr jb ls jf lt jj lu jn lm ln lo lp bi translated">事件网格</li><li id="e601" class="lh li hi is b it lq ix lr jb ls jf lt jj lu jn lm ln lo lp bi translated">存储帐户(Blob、表、队列)</li><li id="1666" class="lh li hi is b it lq ix lr jb ls jf lt jj lu jn lm ln lo lp bi translated">宇宙数据库</li><li id="21bd" class="lh li hi is b it lq ix lr jb ls jf lt jj lu jn lm ln lo lp bi translated">Azure SQL</li></ul><p id="4f96" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">绑定</strong>是实现与其他服务连接的有效方式。这些都有助于与Cosmos DB、Kafka、Storage Accounts等服务进行双向数据交换。绑定可以像输入绑定(in)、输出绑定(out)或两种方式(inout)一样工作。函数可以根据您的用例的需要从/向服务检索/发送。</p><h2 id="b403" class="kg kh hi bd ki kj kk kl km kn ko kp kq jb kr ks kt jf ku kv kw jj kx ky kz la bi translated"><strong class="ak">声明式配置</strong></h2><p id="3585" class="pw-post-body-paragraph iq ir hi is b it lb iv iw ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated">Azure Functions提供的最大的时间节省之一是，你不需要手动实现这些触发器和绑定。您可以利用声明性配置方法。这使您的生活变得更加简单，并且为您提供了一个稳定的工具，这有助于您的解决方案的质量。</p><p id="818c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">使用C#开发函数，这种声明性实现是通过为函数方法使用decorators来完成的。让我们看一个绑定到Azure存储队列的输入的小例子。在本例中，当某个队列收到消息时，该函数被调用。这个事件触发这个函数，并通过它的输入绑定获取消息的内容。然后，该消息通过输出绑定被重定向到另一个队列。你可以在这里看到代码:</p><figure class="lv lw lx ly fd ij"><div class="bz dy l di"><div class="lz ma l"/></div></figure><p id="0973" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">触发器和入站绑定</strong>定义如下:</p><pre class="lv lw lx ly fd mb mc md me aw mf bi"><span id="e23a" class="kg kh hi mc b fi mg mh l mi mj">Run([QueueTrigger("test-queue", Connection = "functionkafkatrigger2022_STORAGE")]string myQueueItem, ILogger log)</span></pre><p id="263b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">test-queue是我们的输入队列的名称，Connection是连接字符串的键。在本地开发时，该项的值存储在local.settings.json中，而在部署时，它保存在应用程序设置中。这个绑定只提供消息的内容，消息通过myQueueItem字符串触发函数。这个参数可以很容易地在下面的代码中使用，就像您可以在函数内部的两行代码中看到的那样。</p><p id="71ff" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">输出绑定</strong>由下式定义:</p><pre class="lv lw lx ly fd mb mc md me aw mf bi"><span id="ce43" class="kg kh hi mc b fi mg mh l mi mj">[return: Queue("test-output", Connection = "StorageConnectionAppSetting")]</span></pre><p id="ae51" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">test-output是输出应该写入的名称，Connection也是连接字符串的键。向队列发送数据只需调用return语句即可。在这个例子中，我们从输入中得到的相同消息，只是被发送到名为test-output的队列中。</p><p id="64f2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">有了这个解决方案，现在只要函数部署在Azure中或者在本地机器上运行，写入测试队列的消息就会被复制到测试输出队列中。</p><h1 id="c357" class="mk kh hi bd ki ml mm mn km mo mp mq kq mr ms mt kt mu mv mw kw mx my mz kz na bi translated">结论</h1><p id="b917" class="pw-post-body-paragraph iq ir hi is b it lb iv iw ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated">绑定和触发器提供了一种与不同服务/应用程序交互的简单方式。这使您能够专注于业务问题，因为实现到不同数据源的连接的重复工作已经从您这里抽象出来了。</p></div></div>    
</body>
</html>