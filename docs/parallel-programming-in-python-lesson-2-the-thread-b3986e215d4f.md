# Python 中的并行编程——第 2 课。线

> 原文：<https://medium.com/codex/parallel-programming-in-python-lesson-2-the-thread-b3986e215d4f?source=collection_archive---------13----------------------->

![](img/e528ebd9f3ea1a80ff179c57af1bbe8b.png)

这是系列课程的第二部分，涵盖了 Python 编程语言为并行编程提供的各种工具以及使用它们的动机。在上一课中，我们探讨了并行设计的应用需求，并使用 Python 线程进行了演示。在本课中，我们将详细研究 Python 线程。

本课的章节:

1.  线程:解决方案领域
2.  “文件监视器”线程功能
3.  封装文件监视器
4.  详细说明 Python 线程
5.  练习:“尾部效用”

# 1.线程:解决方案领域

最初的计算模型包括一个处理器，输入(指令和数据)以离散的形式输入，处理每个输入并相应地改变其内部状态。然后，*存储程序*数字计算机将程序(指令和数据序列)存储在自己的存储器中。它仍然以离散的顺序片段读取输入，但它们来自内部，使用一个*程序计数器*指向要执行的下一条指令。虽然这两种模式看似相似，但它们之间存在着巨大的差异和机遇。直接从外部被告知做什么和被告知(仍然是从外部)如何告诉自己做什么之间有着巨大的差异。第一台机器只能和它的操作员一样聪明。后者是具有学习潜力的智能机器。

有了以正确顺序执行指令的可靠机制，并假设指令位于连续的内存中(并因此可能与唯一的内存*地址*相关联)，我们可以，例如，将一系列循环逻辑集中在*函数*(过去被称为*子例程)*中，如果足够通用，它可以是从程序中的不同位置调用的*。当一个函数被调用时，程序计数器被改变指向它的入口点。但首先必须记录下调用代码中下一个指令的地址(函数*返回时恢复)*，以及其他信息，比如函数调用的结果放在哪里(如果有的话)。由于被调用的函数可能还会调用另一个函数(或者它自己，据我们所知)等等，额外的这种执行*帧*可能会被堆叠在一个称为执行*堆栈的专用结构中。**

这些函数调用被描述为*阻塞*或*同步*，因为一旦一个函数调用了另一个函数，它的执行就被“暂停”了，直到另一个函数返回(因为只有一个程序计数器，它暂时指向别处)。

![](img/55771a239b94c537ee49dd119bdbd974.png)

现代计算机允许程序管理一个以上的堆栈，由此而来的是同时运行几个*控制线程*的能力。不同的控制线程可能会通过智能分时方案(在单个处理器上)或分配给不同的处理器(在可用的情况下)，或者(最有可能)两者来交叉。对于*函数和函数调用*范例，m *多线程*选项提供了模拟*非阻塞*或*异步*函数调用的机会。(此类功能的应用需求将在这些课程的其他部分详细讨论)。调用函数——而不是同步调用另一个函数*并阻塞自己(将程序计数器交给它)——现在有机会*在单独的线程上启动*被调用的函数(让操作系统担心部署)，并继续并行执行。但这仅仅是开始。并行编程产生了许多需要解决的小问题(如果我们坚持仍然模拟一些——或者全部——阻塞函数调用用例，我们为什么要这样做是另一回事):当异步“调用”结束时会发生什么？(当它发生时，我们，打电话的人，不在那里)。如何检索异步调用的结果(如果有)？同时，如何监控并行控制线程的进度？如何干预并行线程的操作？等等。*

*我们总结了这些(和许多其他)技术挑战的特殊解决方案，说这两个功能必须在一个*协议上达成一致。**

*![](img/2880f04da1f51be664c18616a3ac3dbc.png)*

*从理论上讲，这似乎并没有超出正常人的理解范围，但是在实践中，它却非常难学，而且它的实现是出了名的容易出错。依我拙见，使线程概念难以获得的是具体化的*谬误*(将我们对我们看到的事物背后的动机的理解误认为是物理上存在的*事物*)。我们有一种将计算机程序视为 T4 事物的自然倾向，这可能是真的——但只是在问题领域。在*解决方案*域(即运行它的计算机)中，它并不存在。只有这么多离散的指令，静静地等待执行，在一个序列尚未展开。由于只有一个程序计数器(假设有一个内核)，并且给定了执行堆栈机制，因此在任何给定时间都只能有一个函数“运行”。当一个函数“调用”另一个函数时，它无法继续运行，因为它不存在(程序计数器去了别处)。实际上，它的状态被保留了下来(在执行堆栈上)，所以如果一切顺利的话，它可能会在适当的时候复活。在这种情况下，执行堆栈和多线程(多执行堆栈的能力)代表了程序员在实现程序(或者至少是函数)需求的过程中取得的重大胜利。(只要一个人不会忘乎所以，把这个比喻误认为是真实的世界，把自己的无能归咎于他人——例如多线程的便利性)。*

*虽然“异步函数调用”只是执行一个离散的任务(并行)并离开是可能的和合法的，但有趣的(并且相当频繁的)多线程用例涉及一个无限循环的线程，一次处理一个离散的输入，产生的响应以某种方式按时到达每个发送线程。(这也称为*事件循环*，如介绍性课程中所述)。整个中断的流程(由使用线程和已使用线程组成)必须仔细编排，以确保每个控制线程按时完成工作，并与其他线程协调一致。*

*![](img/9ba8c7902cd29fc3ee0d47a071f5f2b5.png)*

# *2.“文件监视器”线程功能*

**问题:*监控一个磁盘文件，修改时记录警告信息。*

**解决方案:**文件监视器*功能使用操作系统工具来监视文件的最新已知修改时间，并在修改时间发生变化时提醒其客户端。*

**一些设计决策:**

*   *文件监视器是在一个单独的控制线程中启动的(为了不妨碍正在使用的应用程序同时完成它的工作)。*
*   *文件监视器通过负责通知的回调与人机界面分离。*

**下面是一个简单的 Python (3.9)实现(注释如下):**

1.  **全球*结束警戒旗。这个简单的解决方案可以满足这个初始原型的需要。(我们将在适当的时候考虑更强大的解决方案)。*
2.  *文件监视器使用客户端提供的回调函数来提醒它的客户端。这将信息的生产者(文件观察者)从人机界面(可以是终端、对话窗口、套接字、计数器等)中分离出来。*
3.  *在确认要被监视的文件确实存在之后，文件监视器获得其最新的已知修改时间(“get-m-time”)，并继续每两秒对其进行一次迭代比较，当检测到改变时发出警报。当全局结束标志发出信号时，迭代停止(据我们所知，是由客户端发出的)。*
4.  *这个例子的简单报警功能输出到终端，格式化(二进制)变化时间用于显示。*
5.  *该程序试图从命令行获取要监视的文件的名称。否则它向用户请求它。*
6.  *程序向文件中写入一些东西，以确保它将存在(当文件监视器访问它时)。*
7.  *现在，我们有了一个要监视的文件，文件监视器在一个单独的控制线程中启动，给出了要监视的文件的名称和控制台通知回调。该线程尚未激活！*
8.  *现在线自由了！文件监视器功能将很快被调用(异步！).*
9.  *测试程序对文件进行修改，以五秒钟为间隔，连续五次追加一些文本。它期望文件监视器(以前在它自己的线程中启动)能够动态地捕捉这些变化。测试程序在每次访问时打开和关闭文件(以更新文件修改时间)。*
10.  **五秒钟*对于文件监视器(每隔*两秒钟*唤醒一次)来说是足够的时间来检测变化。(它还保持进度可被人眼看到)。*
11.  *测试完成后，测试程序会通知文件监视器结束。*
12.  *测试程序等待线程结束(it " *joins"* it)，以防止线程继续运行超过主程序的结尾。这种预防措施在这里并不重要(我们可以相信文件监视器无论如何都会结束，因为它刚刚被告知要这样做)。尽管如此，这仍然是很好的并行编程风格！*

**输出:**

```
*file "fileWatcherTest.txt" changed on Sat Dec 12 19:35:22 2015 file "fileWatcherTest.txt" changed on Sat Dec 12 19:35:27 2015 file "fileWatcherTest.txt" changed on Sat Dec 12 19:35:32 2015 file "fileWatcherTest.txt" changed on Sat Dec 12 19:35:37 2015 file "fileWatcherTest.txt" changed on Sat Dec 12 19:35:42 2015*
```

*在这个例子中我们学到了什么？*

*   *一个 Python 控制线程接受一个*函数*和可选的*参数*传递给它(当它最终启动时)。*
*   *当请求启动时，线程调用函数，但是在专用的执行堆栈上，所以它不会*阻塞*线程的启动器。*
*   *当线程函数返回时，线程终止。(线程对象继续存在，但没有太大用处)。*
*   *线程应该结束是有原因的。要么这个线程已经完成了它的任务，要么启动它的另一个线程(在我们的例子中是主程序)不再需要它了。终止线程需要*同步*。线程和它的启动器都必须同意一个专有的*协议*。主程序必须能够用*信号*通知线程结束，并且线程必须能够捕捉到该信号。这种设计模式在并行编程中很常见。线程在循环中，客户端也可以访问的布尔值是循环的终止条件。*
*   *由于编程上的疏忽，线程可能会继续运行(至少在 Python 中)，即使在主程序应该返回之后。如果程序员确定线程确实注定要结束(例如，它刚刚被告知这一结果)，但应该允许一些时间来清理，主程序*加入*线程——它被*阻塞*直到线程结束。*

**其他 Python 线程功能。*尽管 CPython 似乎将它的线程实现为主机操作系统线程的包装器，但它没有公开后者的全部功能(并添加了一些次要的属性)。*

*   *你不能杀死一个 Python 线程(即通过暴力终止它)。尽管这种限制有很大的教育价值(见上面的讨论)，但在那些(并不罕见的)现实生活中，当一个线程由于程序员无法控制的原因而被阻塞时(例如，正在阻塞 I/O)，除了从外部终止整个程序之外别无选择，这可能会成为一种负担！*
*   *由于*全局解释器锁*(“GIL”)，Python 线程从不同时运行*。在未来的某个版本中，这一点可能会有所放松，但在此之前，它会阻止多线程 Python 程序从多核平台的性能中获益。**
*   **您不能查询线程终止状态(默认情况下)。如果需要的话，自己实现这个功能。**

***附加功能(线程特定):***

*   **将线程标记为“守护进程”。(在 UNIX 世界中，这个术语专用于在后台静默工作并且也将被静默删除的服务器)。守护进程线程(至少在理论上)以主程序结束(并且不必被加入)。**
*   **给线程一个用户定义的名称。**
*   **判断线程是否处于活动状态(或者已经返回)。**

***附加功能(非特定线程):***

*   **获取当前线程。这包括获得主程序的包装器(实际上也是一个线程)。**
*   **计数和枚举活动 Python 线程(在当前进程中)**
*   **获取当前线程 id (Python 给定的和 OS 给定的)**
*   **获取和设置线程堆栈大小(在极少数情况下，默认情况下不会这样做)。**

# **3.封装文件监视器功能**

***问题:*文件监视器线程*函数*在这个简单的例子中完成了工作，但是，作为一个通用的基础设施，它还有一些不足之处。特别是，它将受益于以下功能:**

*   **在几个不相关的场合观看《T4》的多个文件。(相反，当前由函数实现的、由全局布尔表示的功能限制了应用程序只能查看一个文件！)**
*   **将文件监视器分离到一个库(例如真实的基础设施)。全局变量挡住了去路。**

***一个解决方案:*文件监视器功能值得拥有一个*类*。**

***一些设计决策:***

*   **文件监视器是使用文件名和警告函数(而不是线程函数)构建的。**
*   **Python 线程由文件监视器在内部创建。**
*   **线程函数是文件监视器的一个(私有)方法。**
*   **文件监视器请求启动文件监视器线程。**
*   **终结符标志是文件监视器的私有属性，客户端可以通过 getter 和 setter 访问它。**

***重构 starter 原型代码，以满足面向对象的设计(注释如下，输出保持不变):***

1.  **“文件守望者”现在是一个职业的骄傲的名字。**
2.  **过去是文件监视器函数的参数和局部变量，现在是文件监视器类的成员数据。**
3.  **终结符标志现在是文件监视器类的成员。**
4.  **Python 线程是文件观察器类的成员，在后者的构造函数中构造。对于*线程函数，*被赋予了一个*绑定方法*，由文件监视器*对象*(“self”)和文件监视器*方法*(“File Watcher . run”)组成。**
5.  ***开始*线程现在由线程对象负责(但由客户端请求)。**
6.  **相反地，停止线程现在也是线程对象的责任，保护客户端免受布尔实现的影响。**
7.  **提取事件循环以运行线程方法，恰当地称为*。***
8.  **主程序使用文件名和警告函数(而不是线程函数)初始化一个文件监视器对象。主程序逻辑的其余部分保持不变。**

***现在，有了这个面向对象的设计，我们可以直观地检查并行逻辑:***

**![](img/c20c02f05cee2a7bac2f0ea34a152385.png)**

***序列图注释:***

*   **文件监视器在控件*的并行线程上启动。*这里主程序和文件监视器部分各司其职。**
*   **两个主循环(“向文件添加行”和“监视文件”)独立发生，仍然并行。**
*   **“通知变更”是*与*(通过数据)和“向文件添加行”的耦合。第一个(“文件修改日期[已更改]”)的输入是后者“文件附加行[并关闭]”的输出，即文件已更改。“数据耦合”是并行设计中一个常见的设计习语，取代了你可能从过程编程中了解到的*时间耦合*(命令按照书写的顺序出现)。过程化编程就像“先做 A 再做 B”(按此顺序)。在事件驱动的设计中，这被替换为“B 消费 A 生产的”(因此，必须遵循它)。**
*   **停止文件监视器是主程序的*同步*。该作业(发信号)由主程序线程中的文件监视器对象*立即执行(非阻塞)。但是对于文件监视器线程来说是*异步*，在后台运行。根据协议，计划在下一次迭代中停止*上方的循环*。***

*许多人忽略了一个事实，因此至少造成了一些并行编程错误，那就是，在一个*面向对象的*并行设计中，一个线程可能被异步*和同步*访问。(1) *异步:*首先，线程被启动以独立完成工作，然后，它偶尔会收到信号或以自己的速度接收数据。(2) *同步:*线程方法被调用改变线程状态，非阻塞。注意歧义:*信令*出现在两个列表中！在这里不迷失方向的关键是记住控制的*线程——不考虑编程的习语——不是一个对象！这是一个函数的执行状态。除此之外，您的实现可以添加任何您需要的东西(比如保持状态同步可用、发信号和发送数据)，只要您记住调用函数的线程*才是最重要的！当您在主程序的上下文中同步调用线程的方法时，您的*当前线程就是主程序*(而不是线程对象，它一直在后台运行)！***

# 4.等一下！Python 已经有线程类了！

内含内置*螺纹。用户定义的线程类中的线程*，比如我们的文件监视器，是多余的。我们可以通过*继承*来达到同样的目的。重构相当简单:逻辑保持不变，因为*从一个类继承*和*包含*的一个实例——至少在目前的情况下——实际上是一样的。(这里我们有通过重用的面向对象*。穿线。Thread 不是抽象基类也不是接口，不涉及*可替代性*)。除此之外，更少的编码和*继承*所有其他的东西——数据和方法。(相反，如果我们可以忍受的话，这种被限制在基类的设计中是理所当然的惩罚)。在这种情况下，限制(如下所列)是我们可以轻松忍受的。*

唯一可覆盖的线程方法是*run*——线程函数。

*   考虑到 Python 不支持“虚拟”函数。基础线程 *start* 方法调用 *self.run()* ，如果这样的方法存在(否则不调用)。因此，必须不折不扣地调用“run”方法。任何其他名称(比如“Run”)都不能被调用，留给我们的是默认的什么都不做！
*   基本 Python 线程不支持事件循环。(也不应该！并非所有(甚至大多数)线程都是基于事件循环的)。无论在 *run* 方法中发生什么，都是派生类作者的责任。因此，底线对*停止*没有反应。(相当不对称。正如我们已经看到的，它确实响应*开始*。如果需要的话，实现你自己的*停止*方法。

*重构基于类的原型代码，以满足符合库的设计(注释如下，输出和逻辑保持不变):*

1.  “文件监视器”类继承了内置的“线程”。线程”。
2.  这个文件监视器中不再有内置的线程成员(而是继承了一个)。文件观察器构造函数委托给基本内置线程构造函数。
3.  其余的文件监视器成员保持不变。
4.  *运行*的方法保持不变。它的名字(“run”)将它指定为线程函数。
5.  我们必须添加的唯一方法是*停止*。(基础线程不支持停止，因为它不知道线程方法的功能)。
6.  主程序不受文件监视器类内部更改的影响。

# 5.练习:“启动器尾部实用程序”

“Tail”是一个 Unix 实用程序，其逻辑非常类似于我们的“文件监视器”示例，但是，它没有宣布文件被修改的事实，而是输出了非常多的行，假设(1)文件仅通过追加进行修改，以及(2)文件包含纯文本。tail 的典型用途是跟踪日志文件(当它们被创建时)。

将“文件监视器”示例修改成一个基本的“Tail”实用程序。请考虑以下情况:从末尾(而不是从开头)读取文件，这需要:

*   以*二进制*模式—‘Rb’—打开文件，然后…
*   到结束位置— inp.seek(0，2)
*   下一行(经过最后一个已知的文件结尾)由 inp.readline()获取。非空结果表示有效行(要显示)。空结果意味着我们仍然在文件的末尾(但这不是错误)。
*   从另一面在文件上写入保持不变。不要忘记在*追加*模式下打开文件——“a+”！

努力做一份诚实的工作！在接下来的课程中，您将重构这个简单的初学者作为练习！

# *下一步是什么？*

在下一课中，我们将看到经典的*生产者/消费者*示例。我们将考虑一些使用 Python 同步原语的“徒手”实现，并尝试评估它们各自的优点。然后，在接下来的课程中，我们将使用高级 Python 工具实现生产者/消费者算法:多处理和协作处理(同步和异步)。

1.  介绍
2.  线程*(你在这里！)*
3.  同步原语(多线程)
4.  同步原语(多处理)
5.  协作处理—同步
6.  协作处理—异步