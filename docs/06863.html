<html>
<head>
<title>Asynchronous Programming</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">异步编程</h1>
<blockquote>原文：<a href="https://medium.com/codex/asynchronous-programming-73b4f1988cc6?source=collection_archive---------5-----------------------#2022-05-17">https://medium.com/codex/asynchronous-programming-73b4f1988cc6?source=collection_archive---------5-----------------------#2022-05-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/4adb0ee9e7c2a0a69acb733dda6b24ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*adu4Cn5jSvca96rezI6jqg.jpeg"/></div></div></figure><div class=""/><p id="94b4" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我想介绍一些关于. NET中异步编程的事情。主要概念也可以应用于其他语言，所以请随意通读。我们将讨论异步和并行编程的常见误解，以及如何决定合适的方法。我还将描述异步是如何工作的。在下面的文章中，我将展示一个使用异步方法可以实现的性能提升的例子。我们还将讨论如何在同步环境中使用异步。希望你永远不需要这么做:)</p><ul class=""><li id="bd6a" class="jo jp ht is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated"><a class="ae jx" rel="noopener" href="/@karol.rossa/asynchronous-performance-1be01a71925d">异步与同步性能</a></li><li id="1416" class="jo jp ht is b it jy ix jz jb ka jf kb jj kc jn jt ju jv jw bi translated"><a class="ae jx" rel="noopener" href="/@karol.rossa/valuetask-vs-task-5fb4f9c6517">价值任务与任务</a></li></ul><h1 id="c644" class="kd ke ht bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">异步与并行</h1><p id="264c" class="pw-post-body-paragraph iq ir ht is b it lb iv iw ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated">在并行编程中，工作是同时并行进行的:)。可以同时完成的工作量取决于处理器内核的数量。它在处理占用大量CPU处理时间的任务时最有用，并且可以被分割成更小的块。</p><figure class="lh li lj lk fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es lg"><img src="../Images/9e21cff47d6b8c9c815d2453eac0adc7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g7BA4e0RXaS2_wR3cr0opw.png"/></div></div><figcaption class="ll lm et er es ln lo bd b be z dx translated">并行处理</figcaption></figure><p id="a809" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们甚至可以在一个内核上实现异步代码，但它可以利用多核机器。异步不是同时做多个单元的工作，而是在当前需要计算时间的任务之间切换。在处理流程外部的任何事情时，比如调用DB或HTTP客户端，它可以节省大量处理时间。在使用HTTP客户端调用网络资源之后，我们需要等待响应。我们可以在线程上完成额外的工作，而不是阻塞线程。</p><figure class="lh li lj lk fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es lp"><img src="../Images/7b269835c3954cece2835b04baa10510.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2yaD3MPUxfMCNMXIG0RkLA.png"/></div></div><figcaption class="ll lm et er es ln lo bd b be z dx translated">异步处理</figcaption></figure><h1 id="3b95" class="kd ke ht bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">什么是异步</h1><p id="eda4" class="pw-post-body-paragraph iq ir ht is b it lb iv iw ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated">异步编程就是释放等待外部资源的线程，这样我们就可以将它们用于其他工作。我之前提到过，async可以在单线程上工作，但是今天几乎所有的机器都配备了多核处理器。我将向您展示我们如何从中受益。此外，请记住，在编写异步代码时，我们必须从调用堆栈的顶部到底部使用异步。</p><p id="a229" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在幕后，async创建了一个状态机。你可以找到无数的文章将async比作沸水或在厨房准备食物。这次我们将讨论它是如何工作的。让我们看看下面的例子，一步一步来。</p><p id="151b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><a class="ae jx" href="https://github.com/krossa/AsyncSample" rel="noopener ugc nofollow" target="_blank"> <strong class="is hu">代码库</strong> </a></p><blockquote class="lq lr ls"><p id="d9f6" class="iq ir lt is b it iu iv iw ix iy iz ja lu jc jd je lv jg jh ji lw jk jl jm jn hb bi translated"><em class="ht"> Dump()是我的自定义函数，用于将信息打印到控制台</em>。</p></blockquote><figure class="lh li lj lk fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es lx"><img src="../Images/cf90d58bd47df6d6de52cf5661760322.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cP-5KwPN6MHu2eoyqeQoDQ.png"/></div></div><figcaption class="ll lm et er es ln lo bd b be z dx translated">代码版本A</figcaption></figure><figure class="lh li lj lk fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es ly"><img src="../Images/c4fb68c49ed77bd68d4c59ff8d23cc46.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oGxikHDZmjd99Udc0MlbKw.png"/></div></div><figcaption class="ll lm et er es ln lo bd b be z dx translated">代码版本B</figcaption></figure><p id="6f8c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">代码B的不同之处仅在于等待来自ExternaAsync的任务之前在ProcessAsync中完成的工作量。</p><figure class="lh li lj lk fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es lz"><img src="../Images/660e72e35d1325462c9fe306efa8391b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1ypBEXvvPKvupExmW7gmXg.png"/></div></div><figcaption class="ll lm et er es ln lo bd b be z dx translated">结果A</figcaption></figure><figure class="lh li lj lk fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es ma"><img src="../Images/8c8a45648cf7a9dc12bc86ca18700c86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ldeoBkMfULXY6fFIzCjYQw.png"/></div></div><figcaption class="ll lm et er es ln lo bd b be z dx translated">成果B</figcaption></figure><p id="8e96" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi mb translated">我们应用程序的入口点。线程1负责这项工作。</p><p id="57e4" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi mb translated">还没有什么令人兴奋的，只是初始化我们的过程，像标准同步函数一样调用ExternalAsync函数。线程1也完成这项工作。</p><p id="156c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi mb translated"><span class="l mc md me bm mf mg mh mi mj di"> 3 </span>仍在线程1上同步初始化外部工作。但是现在，我们遇到了我们节目中的第一个等待。任务。Delay(100)表示对外部资源(如HttpClient)的异步调用。GetAsync函数。这时，工作被委托给外部驱动程序，我们必须等待结果。但是我们没有等待和无所事事，而是立即返回ProcessAsync函数。</p><p id="4da7" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">返回ProcessAsync后，我们可以在HTTP请求运行时完成额外的工作。我们还可以注意到，异步可以并行工作。现在我们将考虑这两种情况。<br/> <strong class="is hu"> A (1_000) </strong> —在ExternalAsync能够完成之前完成的少量工作。<br/> <strong class="is hu"> B (1_000_000_000) </strong> —比ExternalAsync花费更多时间完成的繁重工作</p><h2 id="d845" class="mk ke ht bd kf ml mm mn kj mo mp mq kn jb mr ms kr jf mt mu kv jj mv mw kz mx bi translated">版本A</h2><p id="c5a2" class="pw-post-body-paragraph iq ir ht is b it lb iv iw ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi mb translated"><span class="l mc md me bm mf mg mh mi mj di"> 4 </span>在输出中，我们可以看到两个检查点“处理更多工作1/2”相继出现在线程1上。当我们在任务中点击wait时，我们没有其他事情可做。任务还没有解决，我们需要等待。因此，线程1被释放到线程池中，可以用于不同的用途，比如处理对控制器的另一个调用。</p><p id="2440" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi mb translated"><span class="l mc md me bm mf mg mh mi mj di"> 5 </span>外部工作最终完成，在新线程5上继续执行。在完成ExternalAsync方法中的工作后，我们将结果返回给ProcessAsync。</p><p id="6654" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi mb translated"><span class="l mc md me bm mf mg mh mi mj di"> 6 </span>只有外部调用是并行执行的，但这是由一些外部驱动程序处理的，而不是由我们的应用程序处理的。在本例中，ProcessAsync中的工作在线程5上继续。我们的代码是按顺序执行的，但是在等待异步调用时，我们不会阻塞线程1。仅这一点就让我们的应用程序性能大幅提升。</p><h2 id="59ec" class="mk ke ht bd kf ml mm mn kj mo mp mq kn jb mr ms kr jf mt mu kv jj mv mw kz mx bi translated">版本B</h2><p id="4179" class="pw-post-body-paragraph iq ir ht is b it lb iv iw ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi mb translated"><span class="l mc md me bm mf mg mh mi mj di"> 4 </span></p><ul class=""><li id="42f3" class="jo jp ht is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated">Thread_Id(1)处理更多工作1</li><li id="a38b" class="jo jp ht is b it jy ix jz jb ka jf kb jj kc jn jt ju jv jw bi translated">Thread_Id(5)外部完成</li><li id="90e6" class="jo jp ht is b it jy ix jz jb ka jf kb jj kc jn jt ju jv jw bi translated">Thread_Id(1)处理更多工作2</li></ul><p id="176e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们已经实现了并行处理，不需要任何额外的代码，只需要知道async是如何工作的，调用ExternalAsync，然后在代码中等待它的任务。由于不同的线程id(1–5)，我们可以清楚地看到这一点。如果我们在第4行等待ExternalAsync，我们的代码就不可能并行化。</p><p id="25f3" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi mb translated">在这个例子中，当在ProcessAsync中点击await时，任务已经被解决了，所以我们可以在同一个线程1上继续工作。我希望我们能够用这些知识编写更好的异步代码，同时利用并行化。</p><h1 id="1220" class="kd ke ht bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">异步如何工作</h1><p id="8083" class="pw-post-body-paragraph iq ir ht is b it lb iv iw ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated">三个部分定义了异步:async、await和Task。Async创建一个具有一个初始状态的状态机。每个await添加一个额外的状态，所以状态的数量等于await的数量+ 1。任务是结果的包装。该任务包含有关状态和结果的信息，可以等待。</p><p id="98ff" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们已经知道，每个await都会向我们的状态机添加一个状态。如果可能，我们应该避免它。例如，当添加带有设置或日志记录的抽象层(如代理)时，我们只是传递一个对异步方法的调用。请记住，我们最终必须等待代码库中的所有任务。如果一个最终没有被等待的异步方法抛出了一个异常，那么这个异常将会丢失，我们将不会有任何错误的记忆。</p><figure class="lh li lj lk fd hk er es paragraph-image"><div class="er es my"><img src="../Images/5a7de8203216c2e26ff1f75f678d9519.png" data-original-src="https://miro.medium.com/v2/resize:fit:1308/format:webp/1*IDM3AT77galqTsFyhaqWJA.png"/></div><figcaption class="ll lm et er es ln lo bd b be z dx translated">返回任务</figcaption></figure><h1 id="9e39" class="kd ke ht bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">提示和注意事项</h1><p id="7676" class="pw-post-body-paragraph iq ir ht is b it lb iv iw ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated">异步编程是一个庞大的话题。我无法在一篇文章中涵盖所有内容。我已经提到了可以让你编写高效异步代码的东西。现在，我们将讨论更多的指导原则。我们将再次触及每个主题的基础。</p><h2 id="72cf" class="mk ke ht bd kf ml mm mn kj mo mp mq kn jb mr ms kr jf mt mu kv jj mv mw kz mx bi translated">注销令牌</h2><p id="c71b" class="pw-post-body-paragraph iq ir ht is b it lb iv iw ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated">当编写供您使用的异步代码时，如果您不打算使用它，可以忽略传递取消令牌。它允许您取消长时间运行的任务。在创建通用的库时，最好记住它。只需用默认值作为最后一个参数添加即可。</p><figure class="lh li lj lk fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es mz"><img src="../Images/d3ae9acfa8c848a1017471b9311d42b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yXYLNMba672KGwI0_7QG8Q.png"/></div></div><figcaption class="ll lm et er es ln lo bd b be z dx translated">注销令牌</figcaption></figure><h2 id="c7cd" class="mk ke ht bd kf ml mm mn kj mo mp mq kn jb mr ms kr jf mt mu kv jj mv mw kz mx bi translated">同步上下文和配置等待</h2><p id="e01e" class="pw-post-body-paragraph iq ir ht is b it lb iv iw ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated">SynchronizationContext的主要方面是提供一种将工作单元排队到上下文的方法。上下文不局限于单个线程，可以在它们之间传递。它主要用于具有用户界面的应用程序，如WPF或Windows窗体。由于传递了SynchronizationContext，它允许您进行后台工作，并在返回时在UI线程中进行更改。的巨大变化。NET Core将从ASP.NET中移除SynchronizationContext。</p><p id="5b7d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">ConfigureAwait用于避免在原始上下文中强制调用回调。默认情况下，。NET使用原始上下文。不将原始上下文传递给回调函数有很多好处。</p><blockquote class="lq lr ls"><p id="7ec6" class="iq ir lt is b it iu iv iw ix iy iz ja lu jc jd je lv jg jh ji lw jk jl jm jn hb bi translated"><em class="ht">configurewait(continueoncomputuredcontext:false)</em></p></blockquote><p id="502f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hu">性能提升</strong>。当所有的回调都在同一个上下文中排队时，它增加了按顺序执行它们的延迟。有时，只检查同步上下文会给路径增加不必要的延迟。</p><p id="4124" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">避免死锁。在一些罕见的情况下，当异步代码同步执行时(。Result)和SynchronizationContext将可以在其上运行的操作数限制为1。想象一下主线程使用上下文的情况。异步方法是用。结果使它成为阻塞主线程的同步调用。现在，异步方法在不同的线程上完成，并且不能访问上下文，因为它在主线程中被阻塞了。</p><p id="b3bf" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果没有必要，应该通过将await配置为false来避免强制使用原始上下文。</p><blockquote class="lq lr ls"><p id="4432" class="iq ir lt is b it iu iv iw ix iy iz ja lu jc jd je lv jg jh ji lw jk jl jm jn hb bi translated"><em class="ht">当事人。AsyncCall()。configurewait(fasle)</em></p></blockquote><h2 id="f3c3" class="mk ke ht bd kf ml mm mn kj mo mp mq kn jb mr ms kr jf mt mu kv jj mv mw kz mx bi translated">价值任务</h2><p id="899a" class="pw-post-body-paragraph iq ir ht is b it lb iv iw ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated">ValueTask是包装值或任务并将其返回的结构。它应该用作可以同步或异步运行的方法的返回类型。例如，可以从缓存中检索值或需要对外部资源进行异步调用的方法。</p><figure class="lh li lj lk fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es na"><img src="../Images/6c5c9bdf19a87cc59ddeac95e55d9281.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a_Gfc1dxH_L-5e5LxH9VvQ.png"/></div></div><figcaption class="ll lm et er es ln lo bd b be z dx translated">价值任务</figcaption></figure><p id="ff70" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">任务分配比返回普通值占用更多的资源。如果同步执行一个方法，就不需要创建任务。所以ValueTask包装了一个普通的整数值。这是因为ValueTask实现了必要的方法，尤其是GetAwaiter()，并且可以由调用者作为Task使用。<a class="ae jx" rel="noopener" href="/@karol.rossa/valuetask-vs-task-5fb4f9c6517">在这里你可以检查内存分配的差异。</a></p><p id="bd3a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">只有几项操作不应在ValueTask实例上执行:</p><ul class=""><li id="5b1b" class="jo jp ht is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated">多次等待实例。</li><li id="1b1c" class="jo jp ht is b it jy ix jz jb ka jf kb jj kc jn jt ju jv jw bi translated">多次调用AsTask。</li><li id="ef36" class="jo jp ht is b it jy ix jz jb ka jf kb jj kc jn jt ju jv jw bi translated">使用。结果还是。GetAwaiter()。GetResult()当操作还没有完成时，或者多次使用它们。</li></ul></div></div>    
</body>
</html>