<html>
<head>
<title>The Pragmatic Programmer EP.8 — Things during coding</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">实用程序员EP . 8——编码过程中的事情</h1>
<blockquote>原文：<a href="https://medium.com/codex/the-pragmatic-programmer-ep-8-things-during-coding-6bcd344e4ff2?source=collection_archive---------7-----------------------#2022-06-08">https://medium.com/codex/the-pragmatic-programmer-ep-8-things-during-coding-6bcd344e4ff2?source=collection_archive---------7-----------------------#2022-06-08</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="4fb0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这一集将指导你在编码时应该关注哪些因素或事情。</p><h1 id="781e" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">处理你的潜意识</h1><p id="afb1" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">当你目睹某事或面对某种情况时，你可能会变得不受控制。因为这是你的本能，是你通过反复学习获得的，或是与生俱来的。作为一名程序员，当你写程序的时候，你害怕任何事情，例如，<strong class="ih hj">每当你执行查询语句</strong>的时候，你都会害怕。你的大脑通常试图告诉你一些事情。你应该找出你为什么会有这种感觉，并通过以下步骤找到解决办法:</p><ol class=""><li id="1e35" class="kg kh hi ih b ii ij im in iq ki iu kj iy kk jc kl km kn ko bi translated">找到恐惧的根源:有两个问题。其中之一是你的大脑作为一个开发者，在试图判断它是否有效。因为你经历过。另一个问题是你害怕犯错。</li><li id="4f55" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc kl km kn ko bi translated">倾听自己:你的大脑通过阅读所有可读的回答，例如，错误的陈述，或错误的逻辑编程，来唤起注意力，以找到问题的根源。您应该后退一步，阅读您正在编写的代码，不管它是否符合业务逻辑。</li><li id="40ba" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc kl km kn ko bi translated">与你的大脑交谈:因为你不能直接控制你的大脑，与他们交谈的最简单的方法是通过短暂休息、与队友聊天或散步来让他们休息一会儿。</li><li id="eddd" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc kl km kn ko bi translated">重启一切:我们应该认为这只是一个游戏，不要太当真。当你被一段代码卡住时，你就把它藏起来，开始做原型。这是一个原型，这意味着它可能会失败并被丢弃。然后，创建注释来概述您将执行的步骤。你可以继续编码，直到你对你的代码满意或者你的实验工作正常。那时，你可能会丢弃你的原型，从干净的代码开始。</li></ol><p id="92b2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">除此之外，你可能会被分配到现有的代码上工作。您可能会遇到奇怪的编码风格或模式。这是获得新知识的一种方式。记下它，并在合适的时候应用它。</p><p id="9954" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你在培养业务团队时感觉有什么不对劲，或者某个要求让你觉得不清楚或难以实现，停下来评估你的感受。大声表达你的想法。相信你的直觉，不要让问题找上你。可能很难解决。</p></div><div class="ab cl ku kv gp kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="hb hc hd he hf"><h1 id="5ed3" class="jd je hi bd jf jg lb ji jj jk lc jm jn jo ld jq jr js le ju jv jw lf jy jz ka bi translated">巧合编程</h1><p id="24a7" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">巧合的编程是当你写代码时，它似乎通过给定的<em class="lg">有限</em> <em class="lg">测试</em>而工作。但是，实际上，它可能会在其他情况下失败。例如，在不同环境中的一个应用程序现在工作正常，但是它只是重合，某一天可能出现错误。</p><p id="3a82" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">意外实现随时随地都有可能发生。这是一个你可能没有被设计去做的例行程序，但是它似乎<em class="lg">有效。</em></p><p id="f3c3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了防止编程的巧合，你应该依赖于记录需求文档。如果没有，你应该尽可能地在文件上签名。而且，重要的是通过全面的测试案例来证明它，而不是想象。</p><h2 id="e793" class="lh je hi bd jf li lj lk jj ll lm ln jn iq lo lp jr iu lq lr jv iy ls lt jz lu bi translated">如何无巧合地编程</h2><ul class=""><li id="3c9c" class="kg kh hi ih b ii kb im kc iq lv iu lw iy lx jc ly km kn ko bi translated">意识到你在做什么。</li><li id="2662" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc ly km kn ko bi translated">只有在你理解清楚的情况下，在开始编码之前收集所有核心逻辑(可以毫无疑问地解释一切)。</li><li id="474c" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc ly km kn ko bi translated">使用你完全了解的技术或工具，因为你知道是什么导致它失败。</li><li id="f056" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc ly km kn ko bi translated">计划，并遵循计划。</li><li id="9874" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc ly km kn ko bi translated">不要依赖任何模糊的概念或假设。</li><li id="1f22" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc ly km kn ko bi translated">记录应用程序的假设和限制。</li><li id="3019" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc ly km kn ko bi translated">通过断言在代码中测试业务逻辑，可能是在单元测试中。</li><li id="eda1" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc ly km kn ko bi translated">优先考虑你的努力。花时间在重要的方面。</li><li id="7eac" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc ly km kn ko bi translated">不要害怕修改不正确的现有代码。遗产并不总是神圣的。</li></ul><p id="cf71" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以，下一次有些事情看起来可行，但是你不知道为什么，确保这不仅仅是一个巧合。</p></div><div class="ab cl ku kv gp kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="hb hc hd he hf"><h1 id="391d" class="jd je hi bd jf jg lb ji jj jk lc jm jn jo ld jq jr js le ju jv jw lf jy jz ka bi translated">算法速度</h1><p id="71ab" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">在开发代码时，您应该关注代码的执行速度或资源消耗。这就是为什么你应该知道如何评估你的算法的速度。<strong class="ih hj">大O符号</strong>在计算机科学中用于评估算法速度。</p><blockquote class="lz ma mb"><p id="df80" class="if ig lg ih b ii ij ik il im in io ip mc ir is it md iv iw ix me iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="hi">大O符号</em> </strong> <em class="hi">是一种数学符号，描述当自变量趋向某一特定值或无穷大时函数的极限行为— </em> <a class="ae mf" href="https://en.wikipedia.org/wiki/Big_O_notation" rel="noopener ugc nofollow" target="_blank"> <em class="hi">维基百科</em> </a></p></blockquote><p id="7018" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">符号由表示</p><p id="75b3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du mg mh mi mj b"><strong class="ih hj">O(...) where n is the size of records for a particular routine</strong></code></p><p id="c62c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它使用来表示取决于输入大小的可能次数的上限。与<em class="lg"> n </em>相关的最高项将得到关注，而其他项将被丢弃。所以，我们可以得出结论</p><p id="a7b4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> O(2n +100n) </strong>与<strong class="ih hj">相同O(2n ) </strong>与<strong class="ih hj"> O(n ) </strong>相同</p><p id="c09d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">事实上，具有O(n)的算法-1可能比具有O(n)的算法-2更快，但是我们忽略它，因为大O符号不会告诉你实际的次数，但是<em class="lg">它只告诉我们当我们改变输入的次数时，这些值将如何变化。</em></p><figure class="ml mm mn mo fd mp er es paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="er es mk"><img src="../Images/da7136ae3c3610b81eb37947006a4f35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*YaHhGWynT_950bfJ.png"/></div></div><figcaption class="mw mx et er es my mz bd b be z dx translated">感谢<a class="ae mf" href="https://www.bigocheatsheet.com/" rel="noopener ugc nofollow" target="_blank">BigOCheatSheet.com</a></figcaption></figure><p id="9514" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如您所见，可能的符号是</p><blockquote class="lz ma mb"><p id="c48f" class="if ig lg ih b ii ij ik il im in io ip mc ir is it md iv iw ix me iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="hi"> O(1) </em> </strong> <em class="hi">:常量(访问数组中的元素，简单语句)</em></p><p id="e1eb" class="if ig lg ih b ii ij ik il im in io ip mc ir is it md iv iw ix me iz ja jb jc hb bi translated"><strong class="ih hj"><em class="hi">O(log(n))</em></strong><em class="hi">:对数(二分搜索法)。对数的底数无关紧要，所以这是等价的。</em></p><p id="b90a" class="if ig lg ih b ii ij ik il im in io ip mc ir is it md iv iw ix me iz ja jb jc hb bi translated"><strong class="ih hj"><em class="hi">【O(n)</em></strong><em class="hi">:线性(顺序搜索)</em></p><p id="eb52" class="if ig lg ih b ii ij ik il im in io ip mc ir is it md iv iw ix me iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="hi"> O(n log(n)): </em> </strong> <em class="hi">比线性差，但差不了多少。(快速排序的平均运行时间，堆排序)</em></p><p id="b315" class="if ig lg ih b ii ij ik il im in io ip mc ir is it md iv iw ix me iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="hi"> O(n ) </em> </strong> <em class="hi">:平方律(选择和插入排序)</em></p><p id="1536" class="if ig lg ih b ii ij ik il im in io ip mc ir is it md iv iw ix me iz ja jb jc hb bi translated"><strong class="ih hj"><em class="hi"/></strong><em class="hi">:立方(两个n×n矩阵相乘)</em></p><p id="92c7" class="if ig lg ih b ii ij ik il im in io ip mc ir is it md iv iw ix me iz ja jb jc hb bi translated"><strong class="ih hj"><em class="hi">【o(c^n】)</em></strong><em class="hi">:指数(旅行商问题，集合划分)——</em><a class="ae mf" href="https://learning.oreilly.com/library/view/the-pragmatic-programmer/9780135956977/f_0063.xhtml#:-:text=%20an%20example" rel="noopener ugc nofollow" target="_blank"><em class="hi">务实的程序员</em> </a></p></blockquote><p id="4105" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">转到您的代码，您可以通过这个例程来评估您的代码</p><p id="a50c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> O(n) </strong>简单循环:访问element-1直到element-<em class="lg">n<br/></em><strong class="ih hj">O(<em class="lg">m</em>x<em class="lg">n</em>)</strong>嵌套循环:在另一个循环中循环，其中循环有<em class="lg"> m </em>和<em class="lg"> n </em>元素。<br/> <strong class="ih hj"> O(log <em class="lg"> n </em> ) </strong>二进制斩:递归分析一个输入的一半<br/><strong class="ih hj">O(<em class="lg">n</em>log<em class="lg">n</em>)</strong>分而治之:将输入分成更小的部分，递归确定那个输入，最后组合出最终答案。<br/> <strong class="ih hj"> O(n！)</strong> combinatoric:任何一种通过n，n-1，n-2，n-3，…，1次访问一个输入的算法</p><p id="d46a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">意识到算法，你通过估计你的算法速度来写代码。让我们让<a class="ae mf" href="https://en.wikipedia.org/wiki/Profiling_(computer_programming)" rel="noopener ugc nofollow" target="_blank">代码剖析器</a>来帮助你。</p></div><div class="ab cl ku kv gp kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="hb hc hd he hf"><h1 id="555e" class="jd je hi bd jf jg lb ji jj jk lc jm jn jo ld jq jr js le ju jv jw lf jy jz ka bi translated">重构</h1><p id="a99f" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">你的代码随时间变化是中性的。这是代码进化。</p><blockquote class="lz ma mb"><p id="77bd" class="if ig lg ih b ii ij ik il im in io ip mc ir is it md iv iw ix me iz ja jb jc hb bi translated">重写、返工和重新架构代码统称为重构。但是有一部分活动已经被实践为 <strong class="ih hj"> <em class="hi">重构</em> </strong></p><p id="312a" class="if ig lg ih b ii ij ik il im in io ip mc ir is it md iv iw ix me iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="hi">重构</em> </strong> <em class="hi">被马丁·福勒定义为:</em></p><p id="f60c" class="if ig lg ih b ii ij ik il im in io ip mc ir is it md iv iw ix me iz ja jb jc hb bi translated"><em class="hi">重组现有代码体的规范技术，在不改变其外部行为的情况下改变其内部结构。——</em><a class="ae mf" href="https://learning.oreilly.com/library/view/the-pragmatic-programmer/9780135956977/f_0064.xhtml#:-:text=The%20gardening%20metaphor%20is,d%20to%20be%20weeded%20or%20pruned." rel="noopener ugc nofollow" target="_blank"><em class="hi">务实的程序员</em> </a></p></blockquote><p id="8436" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">重构是一项小任务。它将在一天内完成。在开始重构之前，单元测试是最重要的事情。每个函数或重构目标都需要单元测试，以保证您的代码在重构后继续正常执行。</p><p id="9fab" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下一个问题是我们应该多久重构一次。答案往往是尽你所能。如果您发现您的代码在其他地方重复了，知识过时了，需求已经改变了，需要在其他地方使用，需要提高系统性能，甚至需要添加一小段代码来编写更多的测试用例，您可以随时重构它们。然而，本书的作者建议，重构时必须完成以下三件事:</p><blockquote class="lz ma mb"><p id="c6a3" class="if ig lg ih b ii ij ik il im in io ip mc ir is it md iv iw ix me iz ja jb jc hb bi translated"><em class="hi"> 1。不要试图在重构的同时增加功能。</em></p><p id="c7a6" class="if ig lg ih b ii ij ik il im in io ip mc ir is it md iv iw ix me iz ja jb jc hb bi translated"><em class="hi"> 2。在开始重构之前，确保你有好的测试。</em></p><p id="448c" class="if ig lg ih b ii ij ik il im in io ip mc ir is it md iv iw ix me iz ja jb jc hb bi translated"><em class="hi"> 3。采取简短、谨慎的步骤— </em> <a class="ae mf" href="https://learning.oreilly.com/library/view/the-pragmatic-programmer/9780135956977/f_0064.xhtml#:-:text=Clearly%2C" rel="noopener ugc nofollow" target="_blank"> <em class="hi">务实的程序员</em> </a></p></blockquote></div><div class="ab cl ku kv gp kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="hb hc hd he hf"><h1 id="9922" class="jd je hi bd jf jg lb ji jj jk lc jm jn jo ld jq jr js le ju jv jw lf jy jz ka bi translated">通过测试编码</h1><p id="84c4" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">测试是确认和验证软件在特定环境下工作的过程。然而，测试的关键优势不仅仅在于执行时间，还在于我们如何看待测试。</p><p id="6db5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们一直在思考测试，我们会考虑如何设计一个可测试代码的软件结构，我们应该测试什么，我们如何测试，等等。这是一个众所周知的激励我们用测试编码的工具。</p><h2 id="ecde" class="lh je hi bd jf li lj lk jj ll lm ln jn iq lo lp jr iu lq lr jv iy ls lt jz lu bi translated">测试驱动开发(TDD)</h2><p id="7662" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">使用一个简单的循环，TDD迫使我们在开始编码之前考虑测试:</p><ol class=""><li id="cc2d" class="kg kh hi ih b ii ij im in iq ki iu kj iy kk jc kl km kn ko bi translated">想象一个你想要实现的功能。</li><li id="c414" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc kl km kn ko bi translated">创建一个测试来指定函数的期望值。</li><li id="4210" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc kl km kn ko bi translated">运行所有测试。您将看到只有一个测试失败了，那就是您刚刚编写的函数。</li><li id="fc24" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc kl km kn ko bi translated">尽可能实现最小的代码片段来通过测试。</li><li id="d35b" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc kl km kn ko bi translated">再次运行所有测试，以验证它们是否通过。</li><li id="3e59" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc kl km kn ko bi translated">重构以改进您的代码。</li></ol><p id="3fb2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">只需重复上述步骤，直到您的应用满足所有要求(参见<a class="ae mf" rel="noopener" href="/codex/the-pragmatic-programmer-ep-5-imperfect-software-ea2239dfd16f">契约设计</a>)。在这一点上，你会发现你的应用程序的所有部分都由测试用例来保证。在我们开始之前，我们应该知道我们应该往哪个方向走。不是自上而下或者自下而上，而是端到端。从简单的端到端开始。然后，将它们重组到适当的层中，并通过测试确认每个修改都通过了相同的逻辑。</p></div><div class="ab cl ku kv gp kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="hb hc hd he hf"><h1 id="be6d" class="jd je hi bd jf jg lb ji jj jk lc jm jn jo ld jq jr js le ju jv jw lf jy jz ka bi translated">基于属性的测试</h1><p id="5ede" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">除了需求测试之外，基于属性的测试是你应该执行的，以给你的应用程序更多的<em class="lg">不变量</em>。一个突出的例子是通过长度和排序列表中每个元素的结果进行测试。</p><figure class="ml mm mn mo fd mp"><div class="bz dy l di"><div class="na nb l"/></div></figure><p id="ca6f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">运行该测试后，您将看到:</p><figure class="ml mm mn mo fd mp"><div class="bz dy l di"><div class="na nb l"/></div></figure><p id="a7f2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在假设(hypo alias)的幕后，这个库帮助我们根据所选的数据类型随机选择100个输入。</p><p id="9ec1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，如果假设发现某个值破坏了您的功能，您应该将它包含在单元测试中。因为，在下一次运行测试的时候，库可能会也可能不会选择这个值。</p></div><div class="ab cl ku kv gp kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="hb hc hd he hf"><h1 id="4795" class="jd je hi bd jf jg lb ji jj jk lc jm jn jo ld jq jr js le ju jv jw lf jy jz ka bi translated">安全意识</h1><p id="2f65" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">编码时应考虑基本的安全性。我们可以简单地应用它，以便让您的应用程序安全和健康。</p><ol class=""><li id="b464" class="kg kh hi ih b ii ij im in iq ki iu kj iy kk jc kl km kn ko bi translated">最小化攻击面:应用程序越复杂，就越容易受到攻击。使减少危险漏洞变得简单。</li><li id="baf4" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc kl km kn ko bi translated">最低特权:如果有人要求，只允许最低授权。不要授予他们所有人管理员权限。</li><li id="8312" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc kl km kn ko bi translated">安全默认值:保持应用程序的默认安全性，即使这很不舒服，例如，键入星号时隐藏密码。有些人可能希望看到它是正确的还是错误的。如果你在公共场所，它会保护你的密码不被窥探。</li><li id="4e40" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc kl km kn ko bi translated">加密敏感数据:绝对不要以纯文本形式留下敏感信息，如密码、国民身份证号码等。</li><li id="e08f" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc kl km kn ko bi translated">保持安全更新:始终保持所有工作电脑的安全补丁最新。如果过期了，可能会有危险。</li></ol></div><div class="ab cl ku kv gp kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="hb hc hd he hf"><h1 id="b334" class="jd je hi bd jf jg lb ji jj jk lc jm jn jo ld jq jr js le ju jv jw lf jy jz ka bi translated">命名一切</h1><p id="a7f9" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">在编程中，我们不可避免地要经常给变量、函数、包、文件等命名。因为我们努力找出重点是什么。</p><blockquote class="lz ma mb"><p id="a878" class="if ig lg ih b ii ij ik il im in io ip mc ir is it md iv iw ix me iz ja jb jc hb bi translated"><em class="hi">名字深具意义这一观点背后是有科学依据的。事实证明，大脑阅读和理解单词的速度真的很快— </em> <a class="ae mf" href="https://learning.oreilly.com/library/view/the-pragmatic-programmer/9780135956977/f_0068.xhtml#:-:text=It%20turns%20out%20that%20the%20bra,erstand%20words%20really%20fast" rel="noopener ugc nofollow" target="_blank"> <em class="hi">务实的程序员</em> </a></p></blockquote><p id="e459" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如，你应该通过<code class="du mg mh mi mj b">let seller = assign(role)</code>而不是<code class="du mg mh mi mj b">let user = assign(role)</code>显式声明一个变量。或者，定义一个类似于<code class="du mg mh mi mj b">def requestSummaryReport(Financial criteria)</code>而不是<code class="du mg mh mi mj b">def getData()</code>的函数。</p><p id="74e2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然而，声明一个在特定语言文化中众所周知的变量是可以接受的，比如在C语言编程中为循环增量变量声明<strong class="ih hj"> i，j，k </strong>。</p><p id="7cf5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最关键的方面是一致性。所有队友都应该理解每个单词的意思，并在相同的上下文中使用它们。许多团队利用字典向团队列出特殊术语。</p><p id="0701" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，仔细指定所有有意义的事物的名称，因为重命名会耗费大量精力来弄清楚它的真正含义。甚至很难。</p></div><div class="ab cl ku kv gp kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="hb hc hd he hf"><p id="4b7b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请注意，上面显示的所有示例都是示例，只是为了强调对概念的理解。它可能被简化理解，而不是正确的语言语法。</p><p id="3a7f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">感谢《实用编程》这本书提供了以上知识，如果你有兴趣阅读这本书，点击<a class="ae mf" href="https://learning.oreilly.com/library/view/the-pragmatic-programmer/9780135956977/" rel="noopener ugc nofollow" target="_blank">这里</a>了解更多详情。</p></div></div>    
</body>
</html>