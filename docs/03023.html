<html>
<head>
<title>Coercion in Javascript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Javascript中的强制</h1>
<blockquote>原文：<a href="https://medium.com/codex/coercion-in-javascript-fcbbe274f6f9?source=collection_archive---------12-----------------------#2021-08-15">https://medium.com/codex/coercion-in-javascript-fcbbe274f6f9?source=collection_archive---------12-----------------------#2021-08-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/1b1151dbdc2bc639d5d79c77d8046ce1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*XhNLQKlDImTaK2fS"/></div></div></figure><p id="0d1f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你曾经对这些javascript问题的结果感兴趣吗？那</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="cbed" class="jx jy hi jt b fi jz ka l kb kc">[] + [] = ""<br/>[] + {} = "[object Object]"<br/>{} + {} = NaN<br/>{} + [] = 0<br/>[] + 5  = "5"</span></pre><p id="fdc1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我既好奇又震惊。这就是为什么我深入研究，以了解那里发生了什么。在这篇文章中，我将与你分享我的发现，你将能够看到我们是如何得到这些答案的。</p><h1 id="92cb" class="kd jy hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">数据类型和类型</h1><p id="940d" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">javascript中有七种数据类型，分别是:<code class="du lf lg lh jt b">null, undefined, boolean, string,number,object and symbol</code>。</p><p id="c8fa" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du lf lg lh jt b">typeof</code>操作符用于确定javascript操作数的数据类型。在<code class="du lf lg lh jt b">1 + 2</code>这个表达式中，<code class="du lf lg lh jt b">1</code>和<code class="du lf lg lh jt b">2</code>都是<code class="du lf lg lh jt b">operands</code>。<code class="du lf lg lh jt b">typeof</code>返回一个字符串，如下所示:</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="1869" class="jx jy hi jt b fi jz ka l kb kc">typeof "string"  ==&gt; 'string'<br/>typeof 4         ==&gt; 'number'<br/>typeof undefined ==&gt; 'undefined'<br/>typeof true      ==&gt; 'boolean'<br/>typeof {}        ===&gt; 'object'<br/>typeof Symbol()  ===&gt; 'symbol'<br/>typeof null      ===&gt; 'object'</span><span id="8e97" class="jx jy hi jt b fi li ka l kb kc">//===================================<br/>typeof []                 // 'object'<br/>typeof function func(){}.  // 'function'</span></pre><p id="43df" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">注意<code class="du lf lg lh jt b">null</code>是唯一的数据类型，它是<code class="du lf lg lh jt b">falsy</code>并从<code class="du lf lg lh jt b">typeof</code>检查中返回一个‘对象’。</p><p id="30a8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">并且<code class="du lf lg lh jt b">typeof function</code>和<code class="du lf lg lh jt b">typeof array</code>返回‘函数’和‘对象’。原因是<code class="du lf lg lh jt b">functions</code>和<code class="du lf lg lh jt b">array</code>是<code class="du lf lg lh jt b">object</code>类型的子类型。</p><h2 id="c3cb" class="jx jy hi bd ke lj lk ll ki lm ln lo km jb lp lq kq jf lr ls ku jj lt lu ky lv bi translated">强迫</h2><p id="7ef5" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">Javascript是动态类型的。这意味着变量的类型可以改变。也就是说，一个字符串形式的变量最终可以是另一种类型，比如像这样的对象:</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="747c" class="jx jy hi jt b fi jz ka l kb kc">let person = "Chidera"  //string data type<br/>  person = {}               // has become an object data type</span></pre><p id="256b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">强制</strong>，也称为“类型转换”，用于“将一种数据类型转换为另一种”。例如，用来将一个字符串转换成一个数字或者将数字转换成字符串等等。</p><p id="a872" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">有两种类型的胁迫，即:“<code class="du lf lg lh jt b">Explicit and implicit coercion</code>”。</p><p id="e31b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当使用诸如<code class="du lf lg lh jt b">String(), Number() or Boolean()</code>这样的语法直接转换类型时，会发生显式强制。</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="03c9" class="jx jy hi jt b fi jz ka l kb kc">let num = 4; //number type<br/>let str = 'person' // string type<br/>let bool = true // boolean type</span><span id="367c" class="jx jy hi jt b fi li ka l kb kc">// Explicit conversion syntax gives<br/>String(4) = '4' // number 4 has been converted to string<br/>Number(true) = 1  // boolean true has been converted to number <br/>Boolean(str) = true // string "str" has been converted to boolean</span></pre><p id="5b9e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当使用某些操作符和表达式时，隐式强制就不那么明显了。例如</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="1445" class="jx jy hi jt b fi jz ka l kb kc">let age = 13;<br/>let info = 'The student is' + age 'years old' // The student is 13 years old;</span></pre><p id="7ab8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">除了称为<code class="du lf lg lh jt b">non-primitive</code>的<code class="du lf lg lh jt b">object</code>数据类型外，所有的数据类型(空、未定义、布尔、字符串、数字和符号)都称为<code class="du lf lg lh jt b">primitives</code>。</p><h1 id="528d" class="kd jy hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">原始强制</h1><p id="35f3" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">原语和非原语的强制行为是完全不同的。原语可以被强制或更改为数字、字符串或布尔值。</p><h1 id="3e97" class="kd jy hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">将原语强制转换为数字</h1><p id="8564" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">使用<code class="du lf lg lh jt b">comparison operators</code>将图元更改为<code class="du lf lg lh jt b">number</code>。比较运算符包括“<code class="du lf lg lh jt b">&gt;, &gt;=, &lt;, =&lt;</code>”等。让我们看看这是如何做到的</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="b0fa" class="jx jy hi jt b fi jz ka l kb kc">// string and number<br/> "6" &gt;= 1<br/>// Solution,<br/>// - Convert '6' (string) to number gives 6 (number), hence<br/> 6 &gt;= 1 //which returns<br/> true</span><span id="8b43" class="jx jy hi jt b fi li ka l kb kc">// boolean and number<br/>false &gt; 3<br/>// Solution,<br/>// - Convert false to number gives 0, hence<br/>0 &gt; 3 // returns<br/>false</span></pre><h1 id="2df2" class="kd jy hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">将原语强制转换为字符串</h1><p id="85a8" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">使用一元+运算符将原语强制转换为<code class="du lf lg lh jt b">string</code>。如果任何一个操作数是字符串，它会将它们强制转换为字符串。例如，这被称为<code class="du lf lg lh jt b">operator overboarding</code></p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="d042" class="jx jy hi jt b fi jz ka l kb kc">"7" + "hello"<br/>// gives "7hello" because they are both strings</span><span id="15e8" class="jx jy hi jt b fi li ka l kb kc">7 + "hello"<br/>// gives "7hello" because one of the operands "hello" is a string</span></pre><h1 id="132c" class="kd jy hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">将原语强制转换为布尔值</h1><p id="a6c9" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">使用逻辑运算符将原语转换为布尔值。逻辑运算符包括“<code class="du lf lg lh jt b">&amp;&amp;, ||, !</code>”。</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="3e32" class="jx jy hi jt b fi jz ka l kb kc">345 &amp;&amp; "hello"<br/>// evaluates to <br/>= true &amp;&amp; true<br/>// because converting a number to boolean gives you "true", same as converting a string to boolean also gives you "true"<br/>=  true</span><span id="3c96" class="jx jy hi jt b fi li ka l kb kc">// Also<br/>true &amp;&amp; "hello"<br/>= true &amp;&amp; true<br/>= true</span></pre><p id="5484" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">关于原语强制的更详细的解释，请查看我专门为javascript中的<a class="ae lw" href="https://hashnode.com/post/coercing-primitives-in-javascript-ckh4q0phi05mz39s16ptvhgl8" rel="noopener ugc nofollow" target="_blank">强制原语而写的这篇文章</a></p><h1 id="3037" class="kd jy hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">非原始强制(对象强制)</h1><p id="79f3" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">我们已经看到原始的强制是如何进行的。在本节中，我们将对非原语进行同样的操作。回想一下，我们之前说过object数据类型称为非原语，for函数和数组的<code class="du lf lg lh jt b">typeof</code>将总是分别解析为“function”和“object ”,因为函数和数组是object的<em class="lx">子类型</em>。就像原语一样，对象或非原语可以被强制为布尔值、字符串或数字。</p><h1 id="2947" class="kd jy hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">将非基元/对象强制转换为布尔值</h1><p id="73a0" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">逻辑运算符用于将对象强制转换为布尔值。<code class="du lf lg lh jt b">Objects will always resolve to true</code>。</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="7c9e" class="jx jy hi jt b fi jz ka l kb kc">// if we did<br/>console.log({} &amp;&amp; [] &amp;&amp; "person") // "person"<br/>// we get "person" because<br/>{} &amp;&amp; [] &amp;&amp; "person" // resolves to<br/>true &amp;&amp; true  &amp;&amp; true // finally giving<br/>= true</span><span id="6b5a" class="jx jy hi jt b fi li ka l kb kc">// Also, <br/>// if we <br/>console.log({} &amp;&amp; true) // "true"<br/>// Same principle above applies</span></pre><h1 id="7a91" class="kd jy hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">将非基元/对象强制转换为数字和字符串</h1><p id="e157" class="pw-post-body-paragraph iq ir hi is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">将非原语转换为数字和字符串的整体思想就是找到一种将非原语转换为原语的方法。</p><p id="48f2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">每个对象原型都有两个影响强制的方法。分别是<code class="du lf lg lh jt b">valueOf()</code>和<code class="du lf lg lh jt b">toString()</code>。如果您检查它们的类型，您会看到它们解析为如下函数:</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="f797" class="jx jy hi jt b fi jz ka l kb kc">typeof Object.prototype.valueOf() // "function"<br/>typeof Object.prototype.toString() // "function"</span></pre><p id="0ad1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在让我们检查一个对象的<code class="du lf lg lh jt b">valueOf()</code>和<code class="du lf lg lh jt b">toString()</code>。</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="8624" class="jx jy hi jt b fi jz ka l kb kc">let myObj = {} <br/>myObj.valueOf() <br/>myObj.toString()</span></pre><p id="3443" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">上述结果将构成本部分评估答案的基础。要将对象更改为数字或字符串，javascript引擎将首先执行一些检查:</p><ol class=""><li id="4503" class="ly lz hi is b it iu ix iy jb ma jf mb jj mc jn md me mf mg bi translated">它将根据对象的DefaultValue内部方法调用对象上的valueOf()或toString()。有人说是基于传递的“暗示”。如果数字是提示，则调用valueOf，否则如果字符串是提示，则调用valueOf。在大多数情况下，首先调用valueOf。</li><li id="f6df" class="ly lz hi is b it mh ix mi jb mj jf mk jj ml jn md me mf mg bi translated">接下来要检查(1)中的返回值是否是原语。如果是原语，则返回原语，否则继续(3)。</li><li id="90d5" class="ly lz hi is b it mh ix mi jb mj jf mk jj ml jn md me mf mg bi translated">调用next或fallback方法。这可以是toString()或valueOf()。也就是说，如果在上面的(1)中调用了valueOf()，那么下一个或fallback方法将变成toString()，同样，如果在(1)中调用了toString()，那么fallback方法将变成valueOf()。</li><li id="d5ad" class="ly lz hi is b it mh ix mi jb mj jf mk jj ml jn md me mf mg bi translated">使用回退方法再次执行(1)。如果返回值是一个原语，则返回它，否则抛出一个错误“<code class="du lf lg lh jt b">TypeError: Cannot convert object to primitive</code>”。</li></ol><p id="a209" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">回想一下上面的例子，我们检查了对象的valueOf和toString()。利用这些结果，我们来看一些例子</p><p id="5036" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">例1 </strong></p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="e1f0" class="jx jy hi jt b fi jz ka l kb kc">let myObj = {}<br/>2 + myObj</span></pre><p id="0e7f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">2已经是一个原语，所以让我们来评估非原语。首先我们在myObj上调用valueOf()。</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="de73" class="jx jy hi jt b fi jz ka l kb kc">myObj.valueOf()</span></pre><p id="2a7f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但是它解析为{}，这也是非primitve。因此我们调用回退方法，在本例中是toString()。</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="d5b1" class="jx jy hi jt b fi jz ka l kb kc">myObj.toString() //"[object object]"</span><span id="9fc3" class="jx jy hi jt b fi li ka l kb kc">// we now have<br/> 2 + "[object object]"</span></pre><p id="f0c7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du lf lg lh jt b">toString()</code>返回一个原始的字符串。</p><p id="ba89" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">召回<code class="du lf lg lh jt b">operator overboarding</code>？，如果任何操作数是字符串，它将整个表达式计算为字符串。在上面的块中，“[object object]”是一个字符串。所以我们有</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="65de" class="jx jy hi jt b fi jz ka l kb kc">= "2" + "[object object]" // "2[object object]"</span></pre><p id="2d9d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此，</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="0b50" class="jx jy hi jt b fi jz ka l kb kc">2 + myObj // "2[object object]"</span></pre><p id="4739" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们看另一个例子</p><p id="e2d3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">例2 </strong></p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="daf4" class="jx jy hi jt b fi jz ka l kb kc">[] + 5</span></pre><p id="c8f0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="lx">一元运算符(+)根据参数类型</em>执行字符串连接或数字加法。</p><p id="bf8c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此，+ 5(参数类型)变成了5(数字)。根据(1)中的规则，Number现在是求值的提示，所以我们在非原语[]上应用valueOf()</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="a409" class="jx jy hi jt b fi jz ka l kb kc">[].valueOf() // []</span></pre><p id="5478" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">它返回一个数组，另一个非原语。让我们回到下一个方法，即toStirng()。</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="f5b5" class="jx jy hi jt b fi jz ka l kb kc">[].toString() //""</span></pre><p id="bf06" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">它计算出一个空字符串，这是一个原语，所以我们有</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="6835" class="jx jy hi jt b fi jz ka l kb kc">[] + 5 <br/>// as<br/>"" + 5</span></pre><p id="9d5c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因为其中一个是字符串</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="ff77" class="jx jy hi jt b fi jz ka l kb kc">"" + 5 //becomes<br/>"" + "5" // "5"</span></pre><p id="7727" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们的最终解决方案是在评估两个字符串后得到的</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="6968" class="jx jy hi jt b fi jz ka l kb kc">[] + 5 // "5"</span></pre><p id="801d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">例3 </strong></p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="4b2e" class="jx jy hi jt b fi jz ka l kb kc">[] + {}</span></pre><p id="dc1e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">首先我们对它们调用valueOf()。</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="9bf6" class="jx jy hi jt b fi jz ka l kb kc">[].valueOf() // []<br/>{}.valueOf() // {}</span></pre><p id="5b74" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">返回了非原语，因此我们调用了fallback方法，在本例中是toString()</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="f277" class="jx jy hi jt b fi jz ka l kb kc">[].toString() // ""<br/>{}.toString() // "[object object]"</span></pre><p id="4756" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在我们有了这样的字符串原语</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="5e7e" class="jx jy hi jt b fi jz ka l kb kc">"" + "[object object]"</span></pre><p id="fe98" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">评估两个原语最终给我们</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="38b9" class="jx jy hi jt b fi jz ka l kb kc">"[object object]"</span></pre><p id="0ee0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="5aec" class="jx jy hi jt b fi jz ka l kb kc">[] + {} //"[object object]"</span></pre><p id="498f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">例4 </strong></p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="eda5" class="jx jy hi jt b fi jz ka l kb kc">[] + []</span></pre><p id="31b9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对它们使用valueOf()会给出</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="9148" class="jx jy hi jt b fi jz ka l kb kc">[].valueOf() // []<br/>[].valueOf() // []</span></pre><p id="ea94" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因为返回了非原语，所以我们使用回退方法，即toString()。</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="019e" class="jx jy hi jt b fi jz ka l kb kc">[].toString() // ""<br/>[].toString() // ""</span></pre><p id="8b54" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们的问题归结为</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="0881" class="jx jy hi jt b fi jz ka l kb kc">"" + "" // ""</span></pre><p id="7ecc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="9fc6" class="jx jy hi jt b fi jz ka l kb kc">[] + [] //""</span></pre><p id="bb88" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">例5 </strong></p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="49ef" class="jx jy hi jt b fi jz ka l kb kc">{} + []</span></pre><p id="5463" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在这个有点棘手，因为它解析为0。让我们看看怎么做。</p><p id="32a9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">回想一下，当我们在例3中评估<code class="du lf lg lh jt b">[] + {}</code>时，我们得到了<code class="du lf lg lh jt b">"[objectobject]"</code></p><p id="456d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然而，对于我们的第五个例子，考虑两个操作数{}和[]。对于第一个{}，javascript不会将其解释为对象。相反，它将其解释为一个代码块。所以我们有这样的东西</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="cce9" class="jx jy hi jt b fi jz ka l kb kc">{} + [] // as<br/>code block + []</span></pre><p id="2692" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">javascript接下来要做的是忽略代码块，所以我们有</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="6c53" class="jx jy hi jt b fi jz ka l kb kc">+ []</span></pre><p id="97c8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">[]上的一元运算符(+)将其强制为一个数字，因此我们有</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="628f" class="jx jy hi jt b fi jz ka l kb kc">Number([]) // 0</span></pre><p id="4f4e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们就是这样回到0的。</p><p id="35be" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">概括起来</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="f508" class="jx jy hi jt b fi jz ka l kb kc">{} + []<br/>= code block + []</span></pre><p id="7d1b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">忽略我们拥有的代码块</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="7fc6" class="jx jy hi jt b fi jz ka l kb kc">+ []</span></pre><p id="8646" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">使用一元+评估[]</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="497d" class="jx jy hi jt b fi jz ka l kb kc">Number([]) // 0</span></pre><p id="c80f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">例6 </strong></p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="cfaa" class="jx jy hi jt b fi jz ka l kb kc">{} + {}</span></pre><p id="bcaf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">与示例5一样，javascript将第一个操作数{}解释为代码块。它忽略了它，并且由于一元(+)操作符，它像这样处理第二个</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="e77d" class="jx jy hi jt b fi jz ka l kb kc">Number({}) // NaN</span></pre><p id="0752" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="b488" class="jx jy hi jt b fi jz ka l kb kc">{} + {} // NaN</span></pre><p id="97c4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">例7 </strong></p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="97d3" class="jx jy hi jt b fi jz ka l kb kc">'' - false</span></pre><p id="638f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">减法操作数没有溢出操作，因此对操作数调用ToNumber</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="6eba" class="jx jy hi jt b fi jz ka l kb kc">Number('') - Number(false) //<br/>// This resolves to<br/> = 0 - 0</span></pre><p id="547d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="3000" class="jx jy hi jt b fi jz ka l kb kc">'' - false // 0</span></pre></div><div class="ab cl mm mn gp mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="hb hc hd he hf"><p id="c0e9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="lx">原载于</em><a class="ae lw" href="https://dera.hashnode.dev/coercion-in-javascript" rel="noopener ugc nofollow" target="_blank"><em class="lx">https://dera . hashnode . dev</em></a><em class="lx">。</em></p></div></div>    
</body>
</html>