<html>
<head>
<title>4 Python Performance Techniques to Remember</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">要记住的4种Python性能技术</h1>
<blockquote>原文：<a href="https://medium.com/codex/4-python-performance-techniques-to-remember-1b04898de03d?source=collection_archive---------0-----------------------#2021-08-28">https://medium.com/codex/4-python-performance-techniques-to-remember-1b04898de03d?source=collection_archive---------0-----------------------#2021-08-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="496d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">嘿！一个点击诱饵的故事，让你在忽略当前任务时阅读。不妨(希望)学点东西，对吧？至少它不是付费的。</p><p id="1b10" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">好吧，给你。让我们考虑一些Python。如果你正在做一些以表现为导向的事情，也许这些会帮到你。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jd"><img src="../Images/27c745ad63e6ca0e9bea7514142282af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1202/format:webp/1*PPIp7twJJUknfohZqtL8pQ.png"/></div><figcaption class="jl jm et er es jn jo bd b be z dx translated">Python:根据目前的统计数据，你可能正在使用的最流行的语言</figcaption></figure><h1 id="4ce2" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">1.LRU缓存</h1><p id="195b" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">情况:你有一个做重复计算的函数，或者它做查找，它很有可能连续多次做相同的计算或查找。对于您的代码或您正在查找的服务，或者两者，这会很快占用大量资源。</p><p id="cd3c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以用“最近最少使用”的LRU缓存来解决这个问题。这将缓存您的函数调用的结果，以便如果您再次以相同的方式调用它，它将从缓存中获取结果，而不是运行整个过程。</p><p id="adb5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用它很容易。让我们看看如何:</p><pre class="je jf jg jh fd kt ku kv kw aw kx bi"><span id="072d" class="ky jq hi ku b fi kz la l lb lc">from functools import lru_cache</span><span id="2f89" class="ky jq hi ku b fi ld la l lb lc"><em class="ks"># The same function twice, but one of them is cached!</em></span><span id="36d0" class="ky jq hi ku b fi ld la l lb lc">def uncached_lookup(<em class="ks">big_tuple</em>: tuple, <em class="ks">number_to_find</em>: int):<br/>    return <em class="ks">number_to_find</em> in <em class="ks">big_tuple</em></span><span id="8420" class="ky jq hi ku b fi ld la l lb lc">@lru_cache(<em class="ks">maxsize</em>=256)<br/>def cached_lookup(<em class="ks">big_tuple</em>: tuple, <em class="ks">number_to_find</em>: int):<br/>    return <em class="ks">number_to_find</em> in <em class="ks">big_tuple</em></span></pre><p id="0720" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">那是……就这样。您只需添加一个小装饰器并选择一个大小，Python会处理剩下的事情。有一个警告——函数的参数类型需要是可哈希的。所以你不能把字典作为一个参数，但是你可以使用一个元组。结果相当惊人——我做了一个时间测试，你可以在这里找到要点<a class="ae le" href="https://gist.github.com/svidovich/de59e345825df66137e71608531de81c" rel="noopener ugc nofollow" target="_blank"/>:</p><pre class="je jf jg jh fd kt ku kv kw aw kx bi"><span id="0466" class="ky jq hi ku b fi kz la l lb lc">mydriasis@akkad:~/Desktop$ python lru_sample.py <br/>59000 uncached lookups took 0.8154561520ms<br/>59000 cached lookups took 0.2635743618ms</span></pre><p id="e7c5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">哇！节省大量时间。</p><h1 id="0327" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">2.杜平简易清单</h1><p id="5817" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">情境:你有一个清单。它有副本。你<em class="ks">不在乎秩序。</em>你不必做一个新的列表，然后像这样迭代它</p><pre class="je jf jg jh fd kt ku kv kw aw kx bi"><span id="f4da" class="ky jq hi ku b fi kz la l lb lc">deduped_list = list()</span><span id="13ff" class="ky jq hi ku b fi ld la l lb lc">for item in big_list:<br/>    if item not in deduped_list:<br/>        deduped_list.append(item)</span></pre><p id="3f1c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">说真的，请不要这样做。太可怕了。这也是StackOverflow 关于这个问题的最高投票答案。这是<em class="ks">非常不理想的</em>，而且浪费了几行代码。相反，只需将其更改为一组并返回:</p><pre class="je jf jg jh fd kt ku kv kw aw kx bi"><span id="d9d4" class="ky jq hi ku b fi kz la l lb lc">deduped_list = list(set(big_list))</span></pre><p id="1cee" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">那是……就这样。我知道，这些真的是令人兴奋的技术。但是<em class="ks">男孩的区别。</em>我做了一个时间测试，你可以在这里找到要点<a class="ae le" href="https://gist.github.com/svidovich/4b40335e19ff16ab3c10eb88aefbbeee" rel="noopener ugc nofollow" target="_blank"/>:</p><pre class="je jf jg jh fd kt ku kv kw aw kx bi"><span id="8016" class="ky jq hi ku b fi kz la l lb lc">mydriasis@akkad:~/Desktop/samples$ python list_dedupe.py <br/>Deduping 1000000-element list to 100 by creating a new list took 0.4950282574ms<br/>Deduping 1000000-element list to 100 using set conversion took 0.0072016716ms</span></pre><p id="19a1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">差远了。它甚至不在同一个球场。我求你了，用定投法。</p><h1 id="1fa6" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">3.用集合检查成员资格</h1><p id="b4e7" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">场景:你有一个大的列表或者元组或者什么的，你有一些元素。你想知道你得到的元素是否在大列表或元组中。</p><p id="da34" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">相反，从一组事物开始，并在这组事物中寻找成员。这为您提供了免费的重复数据消除，并且集合操作速度惊人地快。您仍然可以使用“in”关键字。我做了一个时间测试，你可以在这里找到要点:</p><pre class="je jf jg jh fd kt ku kv kw aw kx bi"><span id="d4e5" class="ky jq hi ku b fi kz la l lb lc">mydriasis@akkad:~/Desktop/samples$ python set_lookups.py <br/>10000 lookups on list took 84.0385153294ms<br/>10000 lookups on set took 0.0007445812ms</span></pre><p id="1e57" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">好吧，<em class="ks">也许</em>我的设置有点偏差。但是，如果你正在做大量的成员查找，使用集合。你不会后悔的。我发誓。</p><h1 id="26fa" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">4.数据集与集合异或</h1><p id="9841" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">场景:你有两个数据集。也许两份名单？二元组？你想要一个或另一个中的所有东西，但不是两个都要。你不在乎顺序。这个有点棘手。您可以很容易地编写一个嵌套循环来遍历它们:</p><pre class="je jf jg jh fd kt ku kv kw aw kx bi"><span id="d48e" class="ky jq hi ku b fi kz la l lb lc">xored_list = list()</span><span id="3935" class="ky jq hi ku b fi ld la l lb lc">for item in big_list_1:<br/>    if item not in big_list_2:<br/>        xored_list.append(item)</span><span id="86c8" class="ky jq hi ku b fi ld la l lb lc">for item in big_list_2:<br/>    if item not in big_list_1:<br/>        xored_list.append(item)</span></pre><p id="24b1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="ks">更正:我的一个朋友指出随文章发布的代码是错误的。我已经把它修好了(我想)。让我知道它是否合法。</em></p><p id="e7ab" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这样做是可行的，但是随着列表变大，这将变得非常慢，非常快。相反，我们可以使用set API的内置函数，名为<em class="ks">对称差</em>。为了更好地理解，下面是两组的文氏图表示:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lf"><img src="../Images/c7e980f4d6ad24703dc151eb433f157a.png" data-original-src="https://miro.medium.com/v2/resize:fit:884/format:webp/0*GLvNBRuSvfdbhCbZ.png"/></div><figcaption class="jl jm et er es jn jo bd b be z dx translated">对称差异:一切都不相同</figcaption></figure><p id="4b9d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">看哪！这正是我们所需要的。代码非常简单:</p><pre class="je jf jg jh fd kt ku kv kw aw kx bi"><span id="7f2c" class="ky jq hi ku b fi kz la l lb lc">xored_list = list(set(big_list_1).symmetric_difference(big_list_2))</span></pre><p id="06fc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">就是这样。真的，就是这样。尽管需要转换成新的数据类型，但它甚至更快。作为主题，我做了一个时间测试，你可以在这里找到一个要点<a class="ae le" href="https://gist.github.com/svidovich/667fa6da22d76a79ff9457cd212cbf99" rel="noopener ugc nofollow" target="_blank"/>:</p><pre class="je jf jg jh fd kt ku kv kw aw kx bi"><span id="153b" class="ky jq hi ku b fi kz la l lb lc">mydriasis@akkad:~/Desktop/article-code/perf$ python dataset_xor.py <br/>List xor with 1000 items by iteration took 0.0177657604ms<br/>List xor with 1000 items by set symmetric difference took 0.0002312660ms</span></pre><p id="6fa1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">神圣的地狱！那是…呀！是的，不要只是重复列表。那是粗鲁的。也许有另一种方法在性能上与set symmetric difference相似，但我一时想不出来。还有，这些数字让我的文章更好看。</p><h1 id="5aa2" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">结论</h1><p id="04bd" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">这些是你可以做的事情。也许下次你写Python的时候会记得它们，你需要做…这些具体的事情。等等，你要去哪里？你没印象吗？嘿，别走。拜托，周六下午我和你一样无聊。这篇文章没那么糟糕，是吗？哦，你已经知道列表集重复数据删除的事情？那对称差呢，很酷，对吧？</p><p id="7d96" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">资源</p><p id="7dbd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">设置对称差异图形:<a class="ae le" href="https://commons.wikimedia.org/wiki/File:SetSymmetricDifference.svg" rel="noopener ugc nofollow" target="_blank"> kismalac，CC0，via Wikimedia Commons </a></p></div></div>    
</body>
</html>