<html>
<head>
<title>Kafka Automation to Remove one broker from the cluster</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kafka Automation从集群中删除一个代理</h1>
<blockquote>原文：<a href="https://medium.com/codex/kafka-automation-to-remove-one-broker-from-the-cluster-81dd594f8759?source=collection_archive---------10-----------------------#2022-06-19">https://medium.com/codex/kafka-automation-to-remove-one-broker-from-the-cluster-81dd594f8759?source=collection_archive---------10-----------------------#2022-06-19</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="729e" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated"><strong class="ak">问题陈述</strong></h1><p id="948d" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我们有一个由3个代理组成的Kafka集群，由于某些java版本的原因，3个节点中的一个被损坏，每次我们需要在该特定代理上重新启动Kafka服务时，通常需要大约30–40分钟才能恢复。<br/>所以我们决定从集群中丢弃这个代理。不过，在此之前，我们还必须添加2个代理来维护负载，以便在删除节点之前，我们可以将其各个主题的分区分发到其他4个节点。</p><h1 id="9333" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated"><strong class="ak">决议</strong></h1><h2 id="893d" class="kb ig hi bd ih kc kd ke il kf kg kh ip jo ki kj it js kk kl ix jw km kn jb ko bi translated"><strong class="ak">待办事项:- </strong></h2><ol class=""><li id="ab91" class="kp kq hi jf b jg jh jk jl jo kr js ks jw kt ka ku kv kw kx bi translated">在集群中添加2个新的Kafka代理。</li><li id="020a" class="kp kq hi jf b jg ky jk kz jo la js lb jw lc ka ku kv kw kx bi translated">执行python脚本，从同步副本(ISR)中移除该代理id，并更改相应分区的领导者。</li><li id="a963" class="kp kq hi jf b jg ky jk kz jo la js lb jw lc ka ku kv kw kx bi translated">用bash脚本执行分区的重新分配。</li></ol><h2 id="34ee" class="kb ig hi bd ih kc kd ke il kf kg kh ip jo ki kj it js kk kl ix jw km kn jb ko bi translated"><strong class="ak">先决条件</strong></h2><ol class=""><li id="43db" class="kp kq hi jf b jg jh jk jl jo kr js ks jw kt ka ku kv kw kx bi translated">对于所有Kafka主题，复制因子(RF)应大于1。</li><li id="4e75" class="kp kq hi jf b jg ky jk kz jo la js lb jw lc ka ku kv kw kx bi translated">运行自动化脚本需要Python。</li><li id="f741" class="kp kq hi jf b jg ky jk kz jo la js lb jw lc ka ku kv kw kx bi translated">您需要两个具有相同Kafka和zookeeper版本的新节点。</li></ol><p id="5496" class="pw-post-body-paragraph jd je hi jf b jg ld ji jj jk le jm jn jo lf jq jr js lg ju jv jw lh jy jz ka hb bi translated">使用下面的Public Git Hub Repository来访问自动化中使用的所有脚本。</p><div class="li lj ez fb lk ll"><a href="https://github.com/madhavdubey97/corrupted-kafka-broker.git" rel="noopener  ugc nofollow" target="_blank"><div class="lm ab dw"><div class="ln ab lo cl cj lp"><h2 class="bd hj fi z dy lq ea eb lr ed ef hh bi translated">GitHub-madhavdubey 97/corrupted-Kafka-broker</h2><div class="ls l"><h3 class="bd b fi z dy lq ea eb lr ed ef dx translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="lt l"><p class="bd b fp z dy lq ea eb lr ed ef dx translated">github.com</p></div></div><div class="lu l"><div class="lv l lw lx ly lu lz ma ll"/></div></div></a></div><h1 id="e915" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">将Kafka代理添加到您现有的集群中</h1><p id="197e" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">确保您的两个新kafka节点在Kafka _ directory/config/server . properties和zookeeper.properties <br/>文件中具有所需的更改，并具有唯一的代理id和zookeeper id。</p><p id="b0a6" class="pw-post-body-paragraph jd je hi jf b jg ld ji jj jk le jm jn jo lf jq jr js lg ju jv jw lh jy jz ka hb bi translated"><strong class="jf hj">在所有Kafka节点上配置以下变化</strong></p><p id="9c7b" class="pw-post-body-paragraph jd je hi jf b jg ld ji jj jk le jm jn jo lf jq jr js lg ju jv jw lh jy jz ka hb bi translated">在server.properties中添加<strong class="jf hj"> zookeeper.connect </strong>键和两个新的Kafka ips</p><p id="623f" class="pw-post-body-paragraph jd je hi jf b jg ld ji jj jk le jm jn jo lf jq jr js lg ju jv jw lh jy jz ka hb bi translated"><strong class="jf hj">zookeeper . connect = node 1:2181，node2:2181，node3:2181，newnode1:2181，newnode2:2181 </strong></p><p id="c315" class="pw-post-body-paragraph jd je hi jf b jg ld ji jj jk le jm jn jo lf jq jr js lg ju jv jw lh jy jz ka hb bi translated">在zookeeper.properties中添加新节点</p><p id="4476" class="pw-post-body-paragraph jd je hi jf b jg ld ji jj jk le jm jn jo lf jq jr js lg ju jv jw lh jy jz ka hb bi translated"><strong class="jf hj">server . 4 = new node 1:2888:3888<br/>server . 5 = new node 1:2888:3888</strong></p><p id="1d5e" class="pw-post-body-paragraph jd je hi jf b jg ld ji jj jk le jm jn jo lf jq jr js lg ju jv jw lh jy jz ka hb bi translated">重启所有节点上的zookeeper和Kafka服务。<br/> <strong class="jf hj">服务动物园管理员重启<br/>服务卡夫卡重启</strong></p><p id="d4ee" class="pw-post-body-paragraph jd je hi jf b jg ld ji jj jk le jm jn jo lf jq jr js lg ju jv jw lh jy jz ka hb bi translated">现在，您可以通过zookeeper-cli检查您的节点可用性。运行<strong class="jf hj">Kafka _ dir/bin/zookeeper-shell . sh localhost:2181</strong>命令进入zookeeper shell <strong class="jf hj">。然后运行<strong class="jf hj"> ls /brokers/ids，在zookeeper中检查您的可用经纪人。你应该还会看到新的经纪人id。现在，您的新kafka节点已成功添加到集群中。</strong></strong></p><p id="1a62" class="pw-post-body-paragraph jd je hi jf b jg ld ji jj jk le jm jn jo lf jq jr js lg ju jv jw lh jy jz ka hb bi translated">但是，在两个新节点上重新分配分区仍处于待定状态。为此，我们将坚持我们的主要问题，即从集群中删除损坏的kafka节点，因此我们将从损坏的节点中删除所有分区，并将它们重新分发到其他4个节点。为了达到这个目的，你可以使用下面的python脚本。</p><p id="ed80" class="pw-post-body-paragraph jd je hi jf b jg ld ji jj jk le jm jn jo lf jq jr js lg ju jv jw lh jy jz ka hb bi translated"><strong class="jf hj">从集群中删除损坏的Kafka节点</strong></p><p id="e8e7" class="pw-post-body-paragraph jd je hi jf b jg ld ji jj jk le jm jn jo lf jq jr js lg ju jv jw lh jy jz ka hb bi translated">执行<strong class="jf hj">remove _ broker _ from _ cluster . py</strong>python脚本，将损坏节点的分区重新分配给现有的4个代理。举个例子，我们的节点1被破坏了。</p><figure class="mc md me mf fd mg er es paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="er es mb"><img src="../Images/b0f585ffd8e708d5cf2edeb0de774ccb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Nnzm_CSD38cCir_l4vc45w.png"/></div></div></figure><figure class="mc md me mf fd mg er es paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="er es mm"><img src="../Images/fa86b4800de3b9a89e2dc07c27e09da1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5ukRGYATja8zfm3iIF8_SQ.png"/></div></div></figure><p id="6549" class="pw-post-body-paragraph jd je hi jf b jg ld ji jj jk le jm jn jo lf jq jr js lg ju jv jw lh jy jz ka hb bi translated">在执行了上面的脚本之后，现在所有分区的zookeeper状态都已经改变了。</p><h2 id="8a1a" class="kb ig hi bd ih kc kd ke il kf kg kh ip jo ki kj it js kk kl ix jw km kn jb ko bi translated">Bash脚本分区的重新分配</h2><ol class=""><li id="6916" class="kp kq hi jf b jg jh jk jl jo kr js ks jw kt ka ku kv kw kx bi translated">在kafka-cli命令下运行以获取所有主题的列表。<br/><strong class="jf hj">bin/Kafka-topics . sh-list-zookeeper localhost:2181。</strong></li><li id="9bf9" class="kp kq hi jf b jg ky jk kz jo la js lb jw lc ka ku kv kw kx bi translated">执行<strong class="jf hj"> kafka_rap_generate.sh </strong>生成新的重新分配分区。</li></ol><figure class="mc md me mf fd mg er es paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="er es mn"><img src="../Images/b31620788160f6131eb76f6a7b58e03d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N5qxSH3_BeLWhGXvlfK2hQ.png"/></div></div></figure><p id="2d0a" class="pw-post-body-paragraph jd je hi jf b jg ld ji jj jk le jm jn jo lf jq jr js lg ju jv jw lh jy jz ka hb bi translated">3.现在运行<strong class="jf hj"> kafka_rap_execute.sh </strong>让实际的更改生效。</p><figure class="mc md me mf fd mg er es paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="er es mo"><img src="../Images/1025b541f3309f628e18d4a38cc0bcab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4vOCcj_7pWuhzzhJhsljuQ.png"/></div></div></figure><p id="9404" class="pw-post-body-paragraph jd je hi jf b jg ld ji jj jk le jm jn jo lf jq jr js lg ju jv jw lh jy jz ka hb bi translated">现在，您可以检查成功执行上述步骤后，您可以看到损坏的代理不再是任何分区的领导者和ISR成员，现在您可以安全地从Kafka集群中删除此损坏的节点。</p><h2 id="e242" class="kb ig hi bd ih kc kd ke il kf kg kh ip jo ki kj it js kk kl ix jw km kn jb ko bi translated"><strong class="ak">注:</strong></h2><p id="97a7" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">这是一个用例，我们看到类似于<strong class="jf hj"> <br/> </strong> 1的错误。<strong class="jf hj"> </strong>分区的重新分配无限期停留在“仍在进行中”状态<br/> 2。卡夫卡对分区的重新分配仍在进行中。</p><p id="89c9" class="pw-post-body-paragraph jd je hi jf b jg ld ji jj jk le jm jn jo lf jq jr js lg ju jv jw lh jy jz ka hb bi translated">对于我们来说，每个分区都出现这些错误，其中被破坏的代理是ISR的领导者或成员，因此在这种情况下，我们必须在zookeeper中更改分区状态，这是由<strong class="jf hj">remove _ broker _ from _ cluster . py</strong>完成的</p></div></div>    
</body>
</html>