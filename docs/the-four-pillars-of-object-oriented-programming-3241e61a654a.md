# 面向对象编程的四大支柱

> 原文：<https://medium.com/codex/the-four-pillars-of-object-oriented-programming-3241e61a654a?source=collection_archive---------3----------------------->

## [法典](http://medium.com/codex)

![](img/ba34088a2faed1f0e8ed4bafaea797b8.png)

# **抽象**

通过对用户隐藏实现细节来处理复杂性。无论何时你调用一个 API，你都在使用一个抽象的例子。您不知道也不需要知道 API 中的代码是什么样子——您只需要它返回结果。这也适用于方法、对象和数据结构。大型项目通常有无数的抽象层，开发人员在不同的模块上工作，通过清晰和最小的公共接口公开复杂的功能。

# **传承**

面向对象编程试图通过实体之间的关系来模拟我们对现实的感知。比如汽车**是**车辆，卡车**是**车辆，摩托车**是**车辆。因此，汽车、卡车和摩托车类都将继承车辆类(或接口)。这不应该与**组合**混淆，后者描述了**与**的关系。汽车**有一个**车轮，但车轮**不是**汽车，汽车**不是**车轮。

# **多态性**

这一原则与继承密切相关，并描述了一个对象成为多种类型对象的能力。如果你有一个继承了类**车辆**的类**汽车**，那么一个**汽车**对象可以被认为是类型**汽车**和类型**车辆。**如果你有一个接受**车辆**参数的方法，但是你传入了一个**汽车**参数**，**运行时多态将允许它在被调用时自动被接受为**车辆**对象。显然存在涉及多态性的约束和例外，但是不要让这个名字威胁到你对这个简单概念的理解。当你把这个词分解成它的词根时，“poly”意味着“许多”，“morph”意味着“形式”——多态性描述了一个对象同时具有多种形式的能力。

# **封装**

在面向对象编程中，将对象的数据成员**私有**并包装在**访问器**和**变异器**方法中被认为是标准做法。如果一个汽车对象包含一个整数**current _ gals，**你可以使用**car . current _ gals**来访问这个值。但是，如果您想防止**current _ galls**被赋予不适当的值(比如负数或字符串)，您必须通过 getCurrentGallons()(访问器方法)和 setCurrentGallons() (mutator 方法)来过滤更改。即使该值没有可察觉的约束，封装对象的数据成员仍然是强制性的。大多数 ide 都有自动生成 getters(访问器)和 setters(赋值器)的内置函数。