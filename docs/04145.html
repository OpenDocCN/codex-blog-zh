<html>
<head>
<title>NextJs and Server-Side rendering</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">NextJs和服务器端渲染</h1>
<blockquote>原文：<a href="https://medium.com/codex/nextjs-and-server-side-rendering-ssr-35b84afdc60d?source=collection_archive---------3-----------------------#2021-10-30">https://medium.com/codex/nextjs-and-server-side-rendering-ssr-35b84afdc60d?source=collection_archive---------3-----------------------#2021-10-30</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="c3c0" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">介绍NextJs如何简化React服务器端渲染</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/00f14c271369f98f59e213856b38c8b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*pCgdClvyfxEkAKWQ"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">奥拉夫·阿伦斯·罗特内在<a class="ae jn" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><h1 id="b44e" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">NextJs之前</h1><p id="f6cb" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">尽管React已经存在了7年多，但关于它的最大争论之一是它在服务器端使用的有效性。许多开发人员抱怨说，他们需要大量的样板代码来呈现在服务器端提供的页面上。这使得开发人员更多地在客户端使用React，并在服务器端寻找替代品。当时存在的一种模式是制作页面的核心构建块(从服务器获得服务)，并在客户端提供React服务，以某种方式实现它，使它能够操作DOM并注入更多组件。</p><h1 id="549b" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">应对服务器端的发展</h1><p id="6fd3" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">上述场景是阻止许多大公司投资升级他们的堆栈以某种方式使用React的最大障碍。他们总是抱怨说，仅仅编写在客户端工作的代码是不够的。这并不意味着没有办法解决这个问题，开发者(直到今天)使用ReactDOM函数在服务器和客户端上合成和服务React(<a class="ae jn" href="https://www.digitalocean.com/community/tutorials/react-server-side-rendering" rel="noopener ugc nofollow" target="_blank">查看这个例子</a>)。然而，NextJs的引入使得生产就绪静态&amp;服务器端代码变得更加容易，它具有许多其他生产功能，如智能捆绑，开箱即用，配置最少。</p><p id="8d16" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">由于这篇文章关注的是NextJs中的服务器端渲染，我不会详细介绍NextJs本身是如何工作的，因为你可以随时查看他们的<a class="ae jn" href="https://nextjs.org/" rel="noopener ugc nofollow" target="_blank">文档</a>。</p><h1 id="67d2" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">getServerSideProps()函数</h1><p id="38e6" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">NextJs允许开发人员按页面构建他们的应用程序，每个页面都是一个独立的入口点(就像一个单独封装和捆绑的迷你应用程序)，他们可以选择在客户端或服务器端呈现页面，或者通过从页面文件中导出某些函数来作为静态页面。</p><p id="e546" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">getServerSideProps()允许NextJs检测到这是一个服务器端呈现的页面，它不会在客户端级别上提供它，而是会在服务器上执行它，合成它的内容，并将其与服务器上预取的任何数据一起提供给客户端。</p><p id="4f89" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">下面是该函数最简单的格式</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lh li l"/></div></figure><p id="5ce3" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">因为NextJs在将抽象实现转换为本地实现方面做了很多工作，所以它提供了很棒的<a class="ae jn" href="https://nextjs.org/docs/api-reference/next.config.js/introduction" rel="noopener ugc nofollow" target="_blank"> config </a>系统，扩展了开发人员配置和服务生产就绪代码的能力。configs在如此多的属性中扩展了实现，从自定义头到路由以及它们之间的任何东西。这增加了另一个层次的灵活性，使得使用框架更加健壮和直观。</p><h1 id="8d1a" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">结论</h1><p id="8ecb" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">NextJs的出现有很多原因，服务器端渲染只是其中之一，尽管这绝对是他们迄今为止提供的最令人惊叹的功能之一，值得一提的是，它仍然缺乏一些核心概念，如完整的客户端路由，这是他们不支持的，因为他们认为url的变化是一个新页面路由的指示，这会导致到服务器的完整行程。你可以在这里阅读更多关于这个问题的<a class="ae jn" href="https://github.com/vercel/next.js/issues/8193" rel="noopener ugc nofollow" target="_blank">。此外，NextJs在渲染和路由方面将每个页面视为一个独立的应用程序，因此它缺少SPA概念。</a></p></div></div>    
</body>
</html>