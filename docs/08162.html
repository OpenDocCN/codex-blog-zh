<html>
<head>
<title>Developing my first machine learning model</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">开发我的第一个机器学习模型</h1>
<blockquote>原文：<a href="https://medium.com/codex/developing-my-first-machine-learning-model-ad42306d06f9?source=collection_archive---------12-----------------------#2022-07-20">https://medium.com/codex/developing-my-first-machine-learning-model-ad42306d06f9?source=collection_archive---------12-----------------------#2022-07-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/e3b9070bc6c41f5fd2caa926c204027e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_IOv4HaPuZHgZAWwjhdg1Q.jpeg"/></div></div></figure><p id="557a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我想从一个非常简单的模型开始，使用Kaggle的房价预测数据集。我使用谷歌的Colab来处理细节，如果我需要分享一些代码帮助，它是一个很好的工具。我按照Jovian.ai创建的阶段进行，这是我在研究如何建立这个网站时发现的一个训练ML网站。确定的主要阶段是:</p><h2 id="c9e4" class="jo jp hi bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">基于线性回归的房价预测</h2><p id="2948" class="pw-post-body-paragraph iq ir hi is b it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj kn jl jm jn hb bi translated">1.下载并浏览数据</p><p id="4eb3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">2.为训练准备数据集</p><p id="3fc1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">3.训练线性回归模型</p><p id="8eac" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">4.进行预测并评估模型</p><h2 id="d684" class="jo jp hi bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">步骤1探索数据(<strong class="ak">数字变量和销售价格之间的相关性</strong></h2><p id="6c76" class="pw-post-body-paragraph iq ir hi is b it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj kn jl jm jn hb bi translated">在运行模型的过程中，我觉得有必要更好地理解数据的相关性，所以我最终制作了两个图表，以便更好地直观理解。作为探索性数据分析(EDA)的新手，很容易看出什么是相关的，但我有一种感觉，一旦我开始更多地了解这个主题，特征工程将发挥更大的作用。</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="d03a" class="jo jp hi kt b fi kx ky l kz la">num_col <strong class="kt hj">=</strong> prices_df<strong class="kt hj">.</strong>select_dtypes(exclude<strong class="kt hj">=</strong>['object'])<br/>correlation <strong class="kt hj">=</strong> num_col<strong class="kt hj">.</strong>corr()<br/>corr_price <strong class="kt hj">=</strong> prices_df[['SalePrice']]</span><span id="871e" class="jo jp hi kt b fi lb ky l kz la">plt<strong class="kt hj">.</strong>figure(figsize<strong class="kt hj">=</strong>(17,20))<br/><strong class="kt hj">for</strong> i <strong class="kt hj">in</strong> range(len(num_col<strong class="kt hj">.</strong>columns)):<br/>    plt<strong class="kt hj">.</strong>subplot(10,4,i<strong class="kt hj">+</strong>1)<br/>    sns<strong class="kt hj">.</strong>scatterplot(x<strong class="kt hj">=</strong>num_col<strong class="kt hj">.</strong>iloc[:, i], y<strong class="kt hj">=</strong>'SalePrice', data<strong class="kt hj">=</strong>num_col<strong class="kt hj">.</strong>dropna())<br/>    plt<strong class="kt hj">.</strong>title('Corr to SalePrice = {}'<strong class="kt hj">.</strong>format(np<strong class="kt hj">.</strong>around(corr_price<strong class="kt hj">.</strong>iloc[i, 0], decimals<strong class="kt hj">=</strong>3)))<br/>plt<strong class="kt hj">.</strong>tight_layout()<br/>plt<strong class="kt hj">.</strong>show()</span></pre><figure class="ko kp kq kr fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lc"><img src="../Images/61873164e2b3628a0d4d5a9dde8ce287.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OhBsnBbubqucI1ASt2vHlg.png"/></div></div></figure><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="a34a" class="jo jp hi kt b fi kx ky l kz la">plt<strong class="kt hj">.</strong>figure(figsize<strong class="kt hj">=</strong>(20,20))<br/>correlation <strong class="kt hj">=</strong> num_col<strong class="kt hj">.</strong>corr()<br/>sns<strong class="kt hj">.</strong>heatmap(correlation, linewidth<strong class="kt hj">=</strong>1, cmap<strong class="kt hj">=</strong>'coolwarm', annot<strong class="kt hj">=True</strong>, fmt<strong class="kt hj">=</strong>'.2f', cbar<strong class="kt hj">=False</strong>, square<strong class="kt hj">=True</strong>)<br/>plt<strong class="kt hj">.</strong>title("Correlation of numerical attributes", size<strong class="kt hj">=</strong>16)<br/>plt<strong class="kt hj">.</strong>show()</span></pre><figure class="ko kp kq kr fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ld"><img src="../Images/a31b9de19e5c1722cac32d1c9c195fd3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TT6zoPQL2kWIeZr92UKOyg.png"/></div></div></figure><h2 id="688b" class="jo jp hi bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">步骤2-为训练准备数据集</h2><p id="4c05" class="pw-post-body-paragraph iq ir hi is b it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj kn jl jm jn hb bi translated">为了准备数据集，我遵循以下步骤。我曾在代码中的各个阶段经历过这一过程，但过了一段时间后，我意识到将它推进管道真的有助于我理解流程。</p><h2 id="c938" class="jo jp hi bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">在训练模型之前，我们需要准备数据集。以下是我们将遵循的步骤</h2><ul class=""><li id="9ad6" class="le lf hi is b it kj ix kk jb lg jf lh jj li jn lj lk ll lm bi translated">确定用于定型模型的输入列和目标列。</li><li id="c50b" class="le lf hi is b it ln ix lo jb lp jf lq jj lr jn lj lk ll lm bi translated">识别数字和分类输入列。</li><li id="4a84" class="le lf hi is b it ln ix lo jb lp jf lq jj lr jn lj lk ll lm bi translated"><a class="ae ls" href="https://scikit-learn.org/stable/modules/impute.html" rel="noopener ugc nofollow" target="_blank">估算</a>(填充)数字列中缺失的值</li><li id="712e" class="le lf hi is b it ln ix lo jb lp jf lq jj lr jn lj lk ll lm bi translated"><a class="ae ls" href="https://scikit-learn.org/stable/modules/preprocessing.html#scaling-features-to-a-range" rel="noopener ugc nofollow" target="_blank">将数字列中的</a>值缩放到(0，1)范围。</li><li id="235b" class="le lf hi is b it ln ix lo jb lp jf lq jj lr jn lj lk ll lm bi translated"><a class="ae ls" href="https://scikit-learn.org/stable/modules/preprocessing.html#encoding-categorical-features" rel="noopener ugc nofollow" target="_blank">将</a>分类数据编码成独热向量。</li><li id="fa25" class="le lf hi is b it ln ix lo jb lp jf lq jj lr jn lj lk ll lm bi translated">将数据集拆分为定型集和验证集。</li></ul><h2 id="1325" class="jo jp hi bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">评估数据集中缺少太多值的列</h2><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="9648" class="jo jp hi kt b fi kx ky l kz la">lost <strong class="kt hj">=</strong> inputs_df<strong class="kt hj">.</strong>count()<strong class="kt hj">.</strong>copy(deep<strong class="kt hj">=True</strong>)<br/>lost <strong class="kt hj">=</strong> 1460<strong class="kt hj">-</strong>lost[lost<strong class="kt hj">&lt;</strong>1460]<br/>lost_pd <strong class="kt hj">=</strong> lost<strong class="kt hj">.</strong>reset_index(name<strong class="kt hj">=</strong>'count')</span><span id="3a72" class="jo jp hi kt b fi lb ky l kz la">plt<strong class="kt hj">.</strong>figure(figsize<strong class="kt hj">=</strong>(10, 8))<br/>ax <strong class="kt hj">=</strong> sns<strong class="kt hj">.</strong>barplot(x<strong class="kt hj">=</strong>'count', y<strong class="kt hj">=</strong>'index', data<strong class="kt hj">=</strong>lost_pd)<br/>ax<strong class="kt hj">.</strong>set(xlabel<strong class="kt hj">=</strong>'Lost')</span></pre><figure class="ko kp kq kr fd ij er es paragraph-image"><div class="er es lt"><img src="../Images/6eba8e8162e35e59c5952acdf38598fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1330/format:webp/1*EyRsMzJok3Al3YIFF9qcBg.png"/></div></figure><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="a169" class="jo jp hi kt b fi kx ky l kz la">px<strong class="kt hj">.</strong>bar(lost_pd, x<strong class="kt hj">=</strong>'count',y<strong class="kt hj">=</strong>'index')</span></pre><p id="141a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">删除缺少太多值的数据</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="b6ca" class="jo jp hi kt b fi kx ky l kz la"><em class="lu"># Drop columns in training and test data</em><br/>cols_to_drop <strong class="kt hj">=</strong> ['LotFrontage', 'Alley', 'FireplaceQu', 'PoolQC', 'Fence', 'MiscFeature']<br/>inputs_df <strong class="kt hj">=</strong> inputs_df<strong class="kt hj">.</strong>drop(cols_to_drop, axis<strong class="kt hj">=</strong>1)</span></pre><h2 id="2111" class="jo jp hi bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">识别数字和分类数据</h2><p id="ea64" class="pw-post-body-paragraph iq ir hi is b it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj kn jl jm jn hb bi translated">数据准备的下一步是识别数字列和分类列。我们可以通过查看每一列的数据类型来做到这一点。</p><blockquote class="lv lw lx"><p id="7cf1" class="iq ir lu is b it iu iv iw ix iy iz ja ly jc jd je lz jg jh ji ma jk jl jm jn hb bi translated"><em class="hi">创建两个列表</em> <code class="du mb mc md kt b"><em class="hi">numeric_cols</em></code> <em class="hi">和</em> <code class="du mb mc md kt b"><em class="hi">categorical_cols</em></code> <em class="hi">，分别包含数据帧内数值和分类输入列的名称。数字列具有数据类型</em> <code class="du mb mc md kt b"><em class="hi">int64</em></code> <em class="hi">和</em> <code class="du mb mc md kt b"><em class="hi">float64</em></code> <em class="hi">，而分类列具有数据类型</em> <code class="du mb mc md kt b"><em class="hi">object</em></code> <em class="hi">。</em></p></blockquote><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="e6ac" class="jo jp hi kt b fi kx ky l kz la"><strong class="kt hj">import</strong> numpy <strong class="kt hj">as</strong> np</span><span id="c161" class="jo jp hi kt b fi lb ky l kz la">numeric_cols <strong class="kt hj">=</strong> inputs_df<strong class="kt hj">.</strong>select_dtypes(include<strong class="kt hj">=</strong>['int64', 'float64'])<strong class="kt hj">.</strong>columns<strong class="kt hj">.</strong>tolist()</span><span id="8b4b" class="jo jp hi kt b fi lb ky l kz la">categorical_cols <strong class="kt hj">=</strong> inputs_df<strong class="kt hj">.</strong>select_dtypes(include<strong class="kt hj">=</strong>['object'])<strong class="kt hj">.</strong>columns<strong class="kt hj">.</strong>tolist()</span><span id="91f0" class="jo jp hi kt b fi lb ky l kz la">print(list(numeric_cols))</span><span id="0087" class="jo jp hi kt b fi lb ky l kz la">['MSSubClass', 'LotArea', 'OverallQual', 'OverallCond', 'YearBuilt', 'YearRemodAdd', 'MasVnrArea', 'BsmtFinSF1', 'BsmtFinSF2', 'BsmtUnfSF', 'TotalBsmtSF', '1stFlrSF', '2ndFlrSF', 'LowQualFinSF', 'GrLivArea', 'BsmtFullBath', 'BsmtHalfBath', 'FullBath', 'HalfBath', 'BedroomAbvGr', 'KitchenAbvGr', 'TotRmsAbvGrd', 'Fireplaces', 'GarageYrBlt', 'GarageCars', 'GarageArea', 'WoodDeckSF', 'OpenPorchSF', 'EnclosedPorch', '3SsnPorch', 'ScreenPorch', 'PoolArea', 'MiscVal', 'MoSold', 'YrSold']</span><span id="ca2c" class="jo jp hi kt b fi lb ky l kz la">print(list(categorical_cols))</span><span id="4000" class="jo jp hi kt b fi lb ky l kz la">['MSZoning', 'Street', 'LotShape', 'LandContour', 'Utilities', 'LotConfig', 'LandSlope', 'Neighborhood', 'Condition1', 'Condition2', 'BldgType', 'HouseStyle', 'RoofStyle', 'RoofMatl', 'Exterior1st', 'Exterior2nd', 'MasVnrType', 'ExterQual', 'ExterCond', 'Foundation', 'BsmtQual', 'BsmtCond', 'BsmtExposure', 'BsmtFinType1', 'BsmtFinType2', 'Heating', 'HeatingQC', 'CentralAir', 'Electrical', 'KitchenQual', 'Functional', 'GarageType', 'GarageFinish', 'GarageQual', 'GarageCond', 'PavedDrive', 'SaleType', 'SaleCondition']</span></pre><h2 id="e62c" class="jo jp hi bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">步骤2.1数据转换的管道</h2><h2 id="7197" class="jo jp hi bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">估算数字数据</h2><h2 id="a32c" class="jo jp hi bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">我们数据集中的一些数字列包含缺失值(<code class="du mb mc md kt b">nan</code>)。</h2><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="eab5" class="jo jp hi kt b fi kx ky l kz la">missing_counts <strong class="kt hj">=</strong> inputs_df[numeric_cols]<strong class="kt hj">.</strong>isna()<strong class="kt hj">.</strong>sum()<strong class="kt hj">.</strong>sort_values(ascending<strong class="kt hj">=False</strong>)<br/>missing_counts[missing_counts <strong class="kt hj">&gt;</strong> 0]</span><span id="5cf5" class="jo jp hi kt b fi lb ky l kz la">GarageYrBlt    81<br/>MasVnrArea      8<br/>dtype: int64</span></pre><p id="ffc9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">机器学习模型无法处理缺失数据。填充缺失值的过程称为<a class="ae ls" href="https://scikit-learn.org/stable/modules/impute.html" rel="noopener ugc nofollow" target="_blank">插补</a>。</p><figure class="ko kp kq kr fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es me"><img src="../Images/92b56993ccbd4d0b5ed44fdad9afede6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*atvD0u4PQvQSIKOU"/></div></div></figure><p id="f7e0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">有几种插补技术，但我们将使用最基本的一种:使用来自<code class="du mb mc md kt b">sklearn.impute</code>的<code class="du mb mc md kt b">SimpleImputer</code>类用列中的平均值替换缺失值。</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="1afb" class="jo jp hi kt b fi kx ky l kz la"><strong class="kt hj">from</strong> sklearn.compose <strong class="kt hj">import</strong> ColumnTransformer<br/><strong class="kt hj">from</strong> sklearn.pipeline <strong class="kt hj">import</strong> Pipeline<br/><strong class="kt hj">from</strong> sklearn.impute <strong class="kt hj">import</strong> SimpleImputer<br/><strong class="kt hj">from</strong> sklearn.preprocessing <strong class="kt hj">import</strong> MinMaxScaler<br/><strong class="kt hj">from</strong> sklearn.preprocessing <strong class="kt hj">import</strong> OneHotEncoder</span><span id="c6d2" class="jo jp hi kt b fi lb ky l kz la"><em class="lu"># Preprocessing for numerical data</em><br/>numerical_transformer <strong class="kt hj">=</strong> Pipeline(steps<strong class="kt hj">=</strong>[<br/>    ('imputer', SimpleImputer(strategy<strong class="kt hj">=</strong>'constant')),<br/>    ('scaler', MinMaxScaler())                                       <br/>])<br/></span><span id="fd2d" class="jo jp hi kt b fi lb ky l kz la"><em class="lu"># Preprocessing for categorical data</em><br/>categorical_transformer <strong class="kt hj">=</strong> Pipeline(steps<strong class="kt hj">=</strong>[<br/>    ('imputer', SimpleImputer(strategy<strong class="kt hj">=</strong>'most_frequent')),<br/>    ('onehot', OneHotEncoder(sparse<strong class="kt hj">=False</strong>, handle_unknown<strong class="kt hj">=</strong>'ignore'))<br/>])</span><span id="cfe7" class="jo jp hi kt b fi lb ky l kz la"><em class="lu"># Bundle preprocessing for numerical and categorical data</em><br/>preprocessor <strong class="kt hj">=</strong> ColumnTransformer(<br/>    transformers<strong class="kt hj">=</strong>[<br/>        ('num', numerical_transformer, numeric_cols),<br/>        ('cat', categorical_transformer, categorical_cols)<br/>    ])</span></pre><h2 id="d3b1" class="jo jp hi bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">训练和验证集</h2><p id="cfa7" class="pw-post-body-paragraph iq ir hi is b it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj kn jl jm jn hb bi translated">最后，让我们将数据集分成训练集和验证集。我们将使用随机选择的25%的数据子集进行验证。此外，我们将只使用数字和编码列，因为模型的输入必须是数字。</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="a4dc" class="jo jp hi kt b fi kx ky l kz la"><strong class="kt hj">from</strong> sklearn.model_selection <strong class="kt hj">import</strong> train_test_split</span><span id="66ce" class="jo jp hi kt b fi lb ky l kz la">train_inputs, val_inputs, train_targets, val_targets <strong class="kt hj">=</strong> train_test_split(inputs_df, <br/>                                                                        targets, <br/>                                                                        test_size<strong class="kt hj">=</strong>0.25, <br/>                                                                        random_state<strong class="kt hj">=</strong>42)</span><span id="a1ff" class="jo jp hi kt b fi lb ky l kz la">train_inputs</span></pre><p id="5463" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">1095行× 73列</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="ab05" class="jo jp hi kt b fi kx ky l kz la">train_targets</span><span id="af17" class="jo jp hi kt b fi lb ky l kz la">1023    191000<br/>810     181000<br/>1384    105000<br/>626     139900<br/>813     157900<br/>         ...  <br/>1095    176432<br/>1130    135000<br/>1294    115000<br/>860     189950<br/>1126    174000<br/>Name: SalePrice, Length: 1095, dtype: int64</span><span id="ef94" class="jo jp hi kt b fi lb ky l kz la">val_inputs</span></pre><p id="9e7c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">365行× 73列</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="0b73" class="jo jp hi kt b fi kx ky l kz la">val_targets</span><span id="6382" class="jo jp hi kt b fi lb ky l kz la">892     154500<br/>1105    325000<br/>413     115000<br/>522     159000<br/>1036    315500<br/>         ...  <br/>988     195000<br/>243     120000<br/>1342    228500<br/>1057    248000<br/>1418    124000<br/>Name: SalePrice, Length: 365, dtype: int64</span></pre><h2 id="1cfd" class="jo jp hi bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">步骤3-训练线性回归模型</h2><p id="cf82" class="pw-post-body-paragraph iq ir hi is b it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj kn jl jm jn hb bi translated">现在我正处于训练模型的阶段，一切都是为了什么。线性回归是解决回归问题的常用技术。在线性回归模型中，目标被建模为输入要素的线性组合(或加权和)。使用均方根误差(RMSE)等损失函数对模型预测进行评估。</p><h2 id="45e1" class="jo jp hi bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">以下是线性回归模型构造方式的直观总结:</h2><figure class="ko kp kq kr fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mf"><img src="../Images/d1631ec4db026829b10216e13efdce58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Q1WLAdWnZ1A-Re1L"/></div></div></figure><p id="e624" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但是，当我们有大量共线的输入列时，即当一列的值与另一列的值高度相关时，线性回归不能很好地推广。这是因为它试图完美地拟合训练数据。</p><h2 id="8c04" class="jo jp hi bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">相反，我们将使用岭回归，这是线性回归的一种变体，它使用一种称为L2正则化的技术来引入另一个损失项，从而迫使模型更好地进行概化。在这里了解更多关于岭回归的信息:<a class="ae ls" href="https://www.youtube.com/watch?v=Q81RR3yKn30" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=Q81RR3yKn30</a></h2><blockquote class="lv lw lx"><p id="022b" class="iq ir lu is b it iu iv iw ix iy iz ja ly jc jd je lz jg jh ji ma jk jl jm jn hb bi translated"><em class="hi">使用</em> <code class="du mb mc md kt b"><em class="hi">sklearn.linear_model</em></code> <em class="hi">中的</em> <code class="du mb mc md kt b"><em class="hi">Ridge</em></code> <em class="hi">类创建并训练一个线性回归模型。</em></p></blockquote><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="84e4" class="jo jp hi kt b fi kx ky l kz la"><strong class="kt hj">from</strong> sklearn.linear_model <strong class="kt hj">import</strong> Ridge<br/><strong class="kt hj">from</strong> sklearn.metrics <strong class="kt hj">import</strong> mean_absolute_error<br/><strong class="kt hj">from</strong> sklearn.metrics <strong class="kt hj">import</strong> mean_squared_error</span><span id="b2d5" class="jo jp hi kt b fi lb ky l kz la"><em class="lu"># Create the model</em><br/>model <strong class="kt hj">=</strong> Ridge()</span><span id="23fb" class="jo jp hi kt b fi lb ky l kz la"><em class="lu"># Bundle preprocessing and modeling code in a pipeline</em><br/>my_pipeline <strong class="kt hj">=</strong> Pipeline(steps<strong class="kt hj">=</strong>[('preprocessor', preprocessor),<br/>                              ('model', model)<br/>                             ])</span><span id="2fad" class="jo jp hi kt b fi lb ky l kz la"><em class="lu"># Preprocessing of training data, fit model </em><br/>my_pipeline<strong class="kt hj">.</strong>fit(train_inputs, train_targets)</span><span id="4609" class="jo jp hi kt b fi lb ky l kz la"><em class="lu"># Preprocessing of validation data, get predictions</em><br/>val_preds <strong class="kt hj">=</strong> my_pipeline<strong class="kt hj">.</strong>predict(val_inputs)</span></pre><blockquote class="lv lw lx"><p id="ddd5" class="iq ir lu is b it iu iv iw ix iy iz ja ly jc jd je lz jg jh ji ma jk jl jm jn hb bi translated"><em class="hi">生成预测并计算训练集和验证集的RMSE损失。</em></p><p id="4978" class="iq ir lu is b it iu iv iw ix iy iz ja ly jc jd je lz jg jh ji ma jk jl jm jn hb bi translated">提示<em class="hi">:使用</em> <code class="du mb mc md kt b"><em class="hi">mean_squared_error</em></code> <em class="hi">和参数</em> <code class="du mb mc md kt b"><em class="hi">squared=False</em></code> <em class="hi">计算RMSE损失。</em></p></blockquote><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="4ca3" class="jo jp hi kt b fi kx ky l kz la"><em class="lu"># Evaluate the model</em><br/>val_mae <strong class="kt hj">=</strong> mean_absolute_error(val_targets, val_preds)<br/>print('MAE:', val_mae)</span><span id="7bc7" class="jo jp hi kt b fi lb ky l kz la">val_rmse <strong class="kt hj">=</strong> mean_squared_error(val_preds, val_targets, squared<strong class="kt hj">=False</strong>)<br/>print('RSME:', val_rmse)</span><span id="39ba" class="jo jp hi kt b fi lb ky l kz la">MAE: 18708.04506910382<br/>RSME: 28406.187359634816</span></pre><h2 id="6404" class="jo jp hi bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">做预测</h2><h2 id="3155" class="jo jp hi bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">该模型可用于使用以下辅助函数对新输入进行预测:</h2><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="63b9" class="jo jp hi kt b fi kx ky l kz la"><strong class="kt hj">def</strong> predict_input(single_input):<br/>    input_df <strong class="kt hj">=</strong> pd<strong class="kt hj">.</strong>DataFrame([single_input])<br/>    cols_to_drop <strong class="kt hj">=</strong> ['LotFrontage', 'Alley', 'FireplaceQu', 'PoolQC', 'Fence', 'MiscFeature']<br/>    input_df <strong class="kt hj">=</strong> input_df<strong class="kt hj">.</strong>drop(cols_to_drop, axis<strong class="kt hj">=</strong>1)<br/>    <strong class="kt hj">return</strong> my_pipeline<strong class="kt hj">.</strong>predict(input_df)</span><span id="d239" class="jo jp hi kt b fi lb ky l kz la">sample_input <strong class="kt hj">=</strong> { 'MSSubClass': 20, 'MSZoning': 'RL', 'LotFrontage': 77.0, 'LotArea': 9320,<br/> 'Street': 'Pave', 'Alley': <strong class="kt hj">None</strong>, 'LotShape': 'IR1', 'LandContour': 'Lvl', 'Utilities': 'AllPub',<br/> 'LotConfig': 'Inside', 'LandSlope': 'Gtl', 'Neighborhood': 'NAmes', 'Condition1': 'Norm', 'Condition2': 'Norm',<br/> 'BldgType': '1Fam', 'HouseStyle': '1Story', 'OverallQual': 4, 'OverallCond': 5, 'YearBuilt': 1959,<br/> 'YearRemodAdd': 1959, 'RoofStyle': 'Gable', 'RoofMatl': 'CompShg', 'Exterior1st': 'Plywood',<br/> 'Exterior2nd': 'Plywood', 'MasVnrType': 'None','MasVnrArea': 0.0,'ExterQual': 'TA','ExterCond': 'TA',<br/> 'Foundation': 'CBlock','BsmtQual': 'TA','BsmtCond': 'TA','BsmtExposure': 'No','BsmtFinType1': 'ALQ',<br/> 'BsmtFinSF1': 569,'BsmtFinType2': 'Unf','BsmtFinSF2': 0,'BsmtUnfSF': 381,<br/> 'TotalBsmtSF': 950,'Heating': 'GasA','HeatingQC': 'Fa','CentralAir': 'Y','Electrical': 'SBrkr', '1stFlrSF': 1225,<br/> '2ndFlrSF': 0, 'LowQualFinSF': 0, 'GrLivArea': 1225, 'BsmtFullBath': 1, 'BsmtHalfBath': 0, 'FullBath': 1,<br/> 'HalfBath': 1, 'BedroomAbvGr': 3, 'KitchenAbvGr': 1,'KitchenQual': 'TA','TotRmsAbvGrd': 6,'Functional': 'Typ',<br/> 'Fireplaces': 0,'FireplaceQu': np<strong class="kt hj">.</strong>nan,'GarageType': np<strong class="kt hj">.</strong>nan,'GarageYrBlt': np<strong class="kt hj">.</strong>nan,'GarageFinish': np<strong class="kt hj">.</strong>nan,'GarageCars': 0,<br/> 'GarageArea': 0,'GarageQual': np<strong class="kt hj">.</strong>nan,'GarageCond': np<strong class="kt hj">.</strong>nan,'PavedDrive': 'Y', 'WoodDeckSF': 352, 'OpenPorchSF': 0,<br/> 'EnclosedPorch': 0,'3SsnPorch': 0, 'ScreenPorch': 0, 'PoolArea': 0, 'PoolQC': np<strong class="kt hj">.</strong>nan, 'Fence': np<strong class="kt hj">.</strong>nan, 'MiscFeature': 'Shed',<br/> 'MiscVal': 400, 'MoSold': 1, 'YrSold': 2010, 'SaleType': 'WD', 'SaleCondition': 'Normal'}</span><span id="c95f" class="jo jp hi kt b fi lb ky l kz la">predicted_price <strong class="kt hj">=</strong> predict_input(sample_input)</span><span id="f4f1" class="jo jp hi kt b fi lb ky l kz la">print('The predicted sale price of the house is ${}'<strong class="kt hj">.</strong>format(predicted_price))</span><span id="47cb" class="jo jp hi kt b fi lb ky l kz la">The predicted sale price of the house is $[121479.08244573]</span></pre><p id="d507" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">改变上面的<code class="du mb mc md kt b">sample_input</code>值，观察对预测价格的影响。</p><h2 id="5ac8" class="jo jp hi bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated">保存模型</h2><p id="9fee" class="pw-post-body-paragraph iq ir hi is b it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj kn jl jm jn hb bi translated">让我们将模型(以及其他有用的对象，如管道)保存到磁盘上，这样我们就可以用它来进行预测，而无需重新训练。</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="cf8d" class="jo jp hi kt b fi kx ky l kz la"><strong class="kt hj">import</strong> joblib</span><span id="3652" class="jo jp hi kt b fi lb ky l kz la">joblib<strong class="kt hj">.</strong>dump(my_pipeline, 'house_price_predictor.joblib')</span><span id="7bae" class="jo jp hi kt b fi lb ky l kz la">new_pipeline <strong class="kt hj">=</strong> joblib<strong class="kt hj">.</strong>load('house_price_predictor.joblib')</span><span id="866e" class="jo jp hi kt b fi lb ky l kz la"><strong class="kt hj">def</strong> new_predict_input(single_input):<br/>    input_df <strong class="kt hj">=</strong> pd<strong class="kt hj">.</strong>DataFrame([single_input])<br/>    cols_to_drop <strong class="kt hj">=</strong> ['LotFrontage', 'Alley', 'FireplaceQu', 'PoolQC', 'Fence', 'MiscFeature']<br/>    input_df <strong class="kt hj">=</strong> input_df<strong class="kt hj">.</strong>drop(cols_to_drop, axis<strong class="kt hj">=</strong>1)<br/>    <strong class="kt hj">return</strong> new_pipeline<strong class="kt hj">.</strong>predict(input_df)</span><span id="b9b4" class="jo jp hi kt b fi lb ky l kz la">new_predict_input(sample_input)</span><span id="1ed6" class="jo jp hi kt b fi lb ky l kz la">array([121479.08244573])</span></pre><h1 id="d24f" class="mg jp hi bd jq mh mi mj ju mk ml mm jy mn mo mp kb mq mr ms ke mt mu mv kh mw bi translated">结论</h1><p id="e0ca" class="pw-post-body-paragraph iq ir hi is b it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj kn jl jm jn hb bi translated">总的来说，我认为开发我的第一个ML模型并不太复杂，但我也觉得要解决的问题并不是一个很大的挑战。当然，要真正将这个模型投入生产，我会非常担心用当前数据更新模型，并且每个月左右对它进行重新训练。</p><p id="1ebd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">从我到目前为止读到的关于ML建模和运行我的第一个模型的所有内容来看，这个行业似乎会继续民主化建模开发。市场似乎想让模型创建对每个人都是可评估的，或者至少对那些有适度编码背景的人是可评估的！</p><figure class="ko kp kq kr fd ij"><div class="bz dy l di"><div class="mx my l"/></div></figure></div></div>    
</body>
</html>