<html>
<head>
<title>What You Need To Know To Debug A Preempted Pod On Kubernetes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Kubernetes上调试被抢占的Pod需要知道什么</h1>
<blockquote>原文：<a href="https://medium.com/codex/what-you-need-to-know-to-debug-a-preempted-pod-on-kubernetes-1c956eec3f35?source=collection_archive---------3-----------------------#2022-07-27">https://medium.com/codex/what-you-need-to-know-to-debug-a-preempted-pod-on-kubernetes-1c956eec3f35?source=collection_archive---------3-----------------------#2022-07-27</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/89b60c418a453fa2d96aeb7d6c2bc1d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZHlAmS0ZKsc4B5qGv0NWcw.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">普通技术人员在<a class="ae iu" href="https://unsplash.com/s/photos/coder?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="8a42" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这篇文章的目的是分享一些关于Kubernetes生产平台管理的想法。这个想法是集中在一个主要的问题，许多初学者遇到这个平台，即:管理抢占的豆荚。</p><h1 id="b0ac" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">什么是抢占式Pod？</h1><p id="e6a5" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">抢占在每个编排平台上都是一个著名的噩梦，这不是Kubernetes的专利，但这个平台的几个方面都可能是意外抢占的根本原因。</p><p id="a526" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们把它放在上下文中，当请求一个pod创建时，pod的定义进入一个队列。调度器从队列中挑选一个pod，并试图找到一个节点，在该节点上，pod可以从所分配的资源(也称为请求和限制)。如果调度器不能在满足pod的所有要求的适当节点上找到空间，则为未决的pod触发抢占逻辑，并且更新pod的状态以向用户提供信息。</p><p id="a2ac" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当一个单元被抢占并被设置为高优先级时，Kubernetes将自动搜索一个或多个具有较低优先级的单元，以请求它们优雅地结束，从而优先部署这个新单元。幸运的是，抢占并不一定要从一个节点中删除所有优先级较低的单元，它可以有选择地这样做，以避免同时抢占数百个容器，从而最大限度地减少协调单元所需的操作。</p><p id="7ad4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在某些用例中，可能很难理解导致Kubernetes抢占或驱逐pod并造成这种非自愿的工作负载中断的途径，尤其是在缺乏可观察性的环境中。因此，在抢占开始时，了解Kubernetes的资源是什么是很重要的。</p><h1 id="5f0f" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">什么是限制、请求和配额？</h1><p id="2509" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">Kubernetes是一个编排平台，这意味着它有本地组件来控制集群上可用的分布式资源(CPU、内存和磁盘)。Kubernetes使用这些信息根据所需的和可用的资源在节点上附加、调度和启动一个pod。</p><p id="262c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为此，Kubernetes使用了三个概念:</p><ul class=""><li id="34fb" class="kw kx hi ix b iy iz jc jd jg ky jk kz jo la js lb lc ld le bi translated">要求</li><li id="b4c4" class="kw kx hi ix b iy lf jc lg jg lh jk li jo lj js lb lc ld le bi translated">限制</li><li id="4cd4" class="kw kx hi ix b iy lf jc lg jg lh jk li jo lj js lb lc ld le bi translated">配额/限制范围</li></ul><p id="81ae" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">查询和限制是在容器级别定义的，因此可以由容器化的应用程序团队来管理。查询定义了为启动容器而分配的资源。在其生命周期中，容器可能会超出为启动应用程序而分配的资源。因此，有必要通过定义限制来控制该容器可能需要的资源数量。这两个参数允许Kubernetes评估可以在哪个节点上调度容器。</p><p id="d596" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果这些数据被忽略，Kubernetes认为容器可以根据需要消耗尽可能多的资源。这种行为需要另一个级别的控制，不是在pod级别，而是在名称空间级别。这种类型的控制通常由DevOps团队管理，以最小化容器错误配置的影响。这些限制称为配额或限制范围。它们定义了一个名称空间可以分配多少资源。</p><p id="6764" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这些信息非常重要，因为它确保了对资源的控制，从而控制了平台的成本。这对FinOps团队预测和潜在降低基础设施成本尤为重要。</p><p id="d419" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这些配置也是作为pod抢占的一部分首先要检查的。事实上，缺乏资源是任何指挥者先发制人的首要原因。</p><h1 id="e4b0" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">如何确定服务质量？</h1><p id="cd14" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">服务质量(QoS)不是您可以通过在定义YAML文件中设置它来直接控制的。Kubernetes是唯一一个可以定义服务质量等级并将其附加到pod的软件，这就是为什么理解这个概念很重要，因为它决定了pod的调度和驱逐优先级。</p><p id="f413" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">基本上，Kubernetes调度程序使用一个QoS类来基于多种因素做出关于在节点上调度pod的决策:</p><ul class=""><li id="c631" class="kw kx hi ix b iy iz jc jd jg ky jk kz jo la js lb lc ld le bi translated">分配给新pod的限制和请求</li><li id="6252" class="kw kx hi ix b iy lf jc lg jg lh jk li jo lj js lb lc ld le bi translated">节点上可用的空闲CPU和内存资源</li><li id="5313" class="kw kx hi ix b iy lf jc lg jg lh jk li jo lj js lb lc ld le bi translated">与新单元的优先级相比，现有单元的优先级</li></ul><p id="f400" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Kubelet使用它来控制pod被驱逐的顺序，并使用高级CPU管理策略来实现更复杂的pod放置决策。</p><p id="5605" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Kubernetes按照优先级顺序使用三种不同的QoS等级:</p><ul class=""><li id="3adc" class="kw kx hi ix b iy iz jc jd jg ky jk kz jo la js lb lc ld le bi translated"><strong class="ix hj">保证</strong>，豆荚被认为是最优先的，保证不被杀死，直到它们超过自己的极限。</li><li id="771f" class="kw kx hi ix b iy lf jc lg jg lh jk li jo lj js lb lc ld le bi translated"><strong class="ix hj">尽力而为</strong>，pod有某种形式的最小资源保证，但是在可用的时候可以使用更多的资源。在系统资源的压力下，一旦超出请求，这些容器更有可能被杀死。</li><li id="0e93" class="kw kx hi ix b iy lf jc lg jg lh jk li jo lj js lb lc ld le bi translated"><strong class="ix hj">可爆发</strong>，吊舱将被视为最低优先级。如果系统资源耗尽，这些pod中的进程会首先被杀死。</li></ul><h1 id="f0db" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">什么是优先类？</h1><p id="04d3" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">优先级类在集群级别定义，并在pod级别使用，Kubernetes使用它来对列出要执行的任务(尤其是pod的创建)的队列进行分类、排序和优先级排序，但它也用于在集群缺乏资源时驱逐(或抢占)pod。</p><p id="89b2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">原则相对简单，该位置保留给具有最高优先级的资源。在集群上设置优先级策略非常重要，这样Kubernetes就可以智能地管理您组织的关键资源。</p><p id="ef42" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">该政策必须由开发运维团队定义，并为所有工程团队所理解，以促进其在YAML定义文件中的采用和实施。</p><p id="9216" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">数字不易记忆和阅读，建议使用优先级类名，如<em class="lk">临界、高、正常、低</em>或<em class="lk">无</em>，以便于使用和理解附属于pod的类。</p><p id="ffa6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在预占pod的上下文中，从Kubernetes的角度来看，检查pod的优先级类别可能是理解其优先级的第二件事。</p><h1 id="20db" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">什么是亲缘关系？</h1><p id="bf19" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">orchestrator平台使用关联性来为集群上的资源定义最佳本地化。这些定义是编排者应该尽可能遵循的规则，因为他们有能力成为<em class="lk">要求的</em>或<em class="lk">首选的</em>。</p><p id="45ac" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在Kubernetes框架中，关联是在pod级别定义的，允许与集群的两个组件进行交互:</p><ul class=""><li id="afbe" class="kw kx hi ix b iy iz jc jd jg ky jk kz jo la js lb lc ld le bi translated">其他吊舱可能部署两个吊舱尽可能接近对方。</li><li id="ef60" class="kw kx hi ix b iy lf jc lg jg lh jk li jo lj js lb lc ld le bi translated">用于在特定节点类型上部署pod的节点，例如带有GPU或SSD驱动器的节点。</li></ul><p id="0f42" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Kubernetes调度程序基于附加到资源上的标签，以便考虑亲缘关系或反亲缘关系。</p><p id="02fd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">亲缘关系增加了另一个级别的集成，这需要对集群的资源有所了解。这种整合可以对吊舱的抢占起到作用。添加亲缘关系可以迫使Kubernetes将现有资源移动到其他节点，以便在同一个节点上部署两个新的pod。另一方面，添加一个反亲缘关系可以迫使Kubernetes移动资源，如果条件不能满足，吊舱可能根本不会部署。</p><p id="b545" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，在抢占的情况下，小心使用亲缘关系并记录它们的使用以促进调试阶段是很重要的。</p><h1 id="96a2" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">什么是正常关机？</h1><p id="047a" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">宽限关闭不是抢占式pods的一个活动部分，但是需要理解它，因为它会对Kubernetes在抢占期间所做的事情造成混淆。</p><p id="adff" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一般来说，Kubernetes总是试图以最好的方式停止一个应用程序，给他时间来完成他的工作。但是，当这段时间超过预期时间时，Kubernetes会杀死pod，从而杀死应用程序。为了避免任何数据丢失，在应用程序的容器化过程中应该考虑Kubernetes的这一方面。</p><p id="5d21" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">作为抢占式pod的一部分，这种平稳的关闭期可能会给一些人造成困惑，因为调度程序将在此期间继续对其任务进行优先级排序，因此会创建新的pod。因此，在请求终止pod和重新创建pod之间存在延迟。为了最小化这个间隙，平稳结束周期可以减少到零。建议小心使用这种方法，以避免对容器管理的数据产生任何影响。</p><h1 id="a093" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">如何防止抢占？</h1><p id="aa0d" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">某些导致pod抢占的问题可以通过使用自动化流程来避免，如果它们适用于Kubernetes集群的上下文的话。</p><h2 id="4c20" class="ll ju hi bd jv lm ln lo jz lp lq lr kd jg ls lt kh jk lu lv kl jo lw lx kp ly bi translated">集群自动扩展</h2><p id="683a" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">当与缺乏计算资源相关时，集群自动扩展是防止pod抢占的有效但昂贵的方法。</p><p id="e338" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这种解决方案不应该应用于所有优先级，而应该只应用于最重要的优先级，以便控制资源成本。这显然需要对应用程序及其优先级进行相关的分类。</p><p id="1a52" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">集群自动扩展必须与强大的可观察性平台相结合，以尽早识别抢占并采取所有必要的措施。</p><p id="1c05" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">自动扩展可以被视为一种临时解决方案，让工程团队有时间来确定一种永久的解决方案。</p><h2 id="818d" class="ll ju hi bd jv lm ln lo jz lp lq lr kd jg ls lt kh jk lu lv kl jo lw lx kp ly bi translated">提交前挂钩</h2><p id="be49" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">强烈建议遵循最佳管理实践，以防止人为错误，从而始终保持健康的Kubernetes集群。</p><p id="2b6b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">将控制点添加到定义文件中，无论是在集成管道中，还是作为预提交命令，以防止开发人员无缘无故地将pod推入高优先级的生产环境，这都是一个好的实践。现在有几个工具(比如<a class="ae iu" href="https://www.datree.io/" rel="noopener ugc nofollow" target="_blank"> Datree </a>、<a class="ae iu" href="https://www.checkov.io/" rel="noopener ugc nofollow" target="_blank"> Checkov </a>等。)可以轻松集成到自动化流程中，允许开发可定制的控制点，以便在违反规则时阻止部署。</p><p id="c429" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">还可以在每个集群上定义安全策略和Kubernetes治理，以确保没有人在现有集群上手动做错任何事情。这些策略可以由一个<a class="ae iu" href="https://www.openpolicyagent.org/" rel="noopener ugc nofollow" target="_blank">开放策略代理</a>和一个<a class="ae iu" href="https://open-policy-agent.github.io/gatekeeper/website/docs/" rel="noopener ugc nofollow" target="_blank">看门人</a>轻松管理，如果不遵守规则，就拒绝应用程序。</p><p id="8b2c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这两种检查点的组合可以防止人为错误，并可能节省您的调试时间，但它们的实现需要监控以检测任何偏离行为和准确的文档记录，以促进这些安全策略的采用。</p><h1 id="cc41" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">下一个？</h1><p id="69b6" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">有关Kubernetes的更多信息，请阅读这些文档:</p><ul class=""><li id="c781" class="kw kx hi ix b iy iz jc jd jg ky jk kz jo la js lb lc ld le bi translated"><a class="ae iu" href="https://kubernetes.io/docs/concepts/scheduling-eviction/pod-priority-preemption/" rel="noopener ugc nofollow" target="_blank"> Pod优先级和抢占</a></li><li id="aa50" class="kw kx hi ix b iy lf jc lg jg lh jk li jo lj js lb lc ld le bi translated"><a class="ae iu" href="https://kubernetes.io/docs/concepts/workloads/pods/disruptions/" rel="noopener ugc nofollow" target="_blank">中断</a></li><li id="2841" class="kw kx hi ix b iy lf jc lg jg lh jk li jo lj js lb lc ld le bi translated"><a class="ae iu" href="https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/" rel="noopener ugc nofollow" target="_blank">吊舱和集装箱的资源管理</a></li><li id="cef9" class="kw kx hi ix b iy lf jc lg jg lh jk li jo lj js lb lc ld le bi translated"><a class="ae iu" href="https://kubernetes.io/docs/tasks/administer-cluster/limit-storage-consumption/" rel="noopener ugc nofollow" target="_blank">限制存储消耗</a></li><li id="357b" class="kw kx hi ix b iy lf jc lg jg lh jk li jo lj js lb lc ld le bi translated"><a class="ae iu" rel="noopener" href="/google-cloud/quality-of-service-class-qos-in-kubernetes-bb76a89eb2c6">Kubernetes上的服务质量等级是什么？</a></li></ul><h1 id="4fa5" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">关于作者</h1><p id="6ace" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated"><a class="ae iu" href="https://www.linkedin.com/in/nicolas-giron-6129b0a1/" rel="noopener ugc nofollow" target="_blank"> Nicolas Giron </a> —现场可靠性工程师(SRE) — DevOps</p></div></div>    
</body>
</html>