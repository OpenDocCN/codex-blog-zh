<html>
<head>
<title>JavaScript Data Structures and Algorithms (Graphs, part 3)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript数据结构和算法(图表，第3部分)</h1>
<blockquote>原文：<a href="https://medium.com/codex/javascript-data-structures-and-algorithms-graphs-part-3-507c91eff33e?source=collection_archive---------11-----------------------#2021-06-22">https://medium.com/codex/javascript-data-structures-and-algorithms-graphs-part-3-507c91eff33e?source=collection_archive---------11-----------------------#2021-06-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/5f95ad7dd14c6d830864bcf059d5b7a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*dFuZ7iDwBYoPkUwO"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">丁满·斯图德勒在<a class="ae hv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><div class=""/><p id="28c7" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">你好！如果您正在阅读这篇文章，并且还没有阅读关于图形数据结构的本系列文章的第1部分和第2部分，可以先阅读这些文章。你可以在这里找到第一部分<a class="ae hv" rel="noopener" href="/codex/javascript-data-structures-and-algorithms-graphs-67cc1d9bfcc7">和第二部分</a><a class="ae hv" rel="noopener" href="/codex/javascript-data-structures-and-algorithms-graphs-part-2-533534289b23">这里</a>。</p><p id="6e17" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">上次我分解了图的搜索算法，以及它们的实现。我们讨论了使用队列从一个顶点遍历到另一个顶点，在DFS的情况下，保存一个访问过的顶点的列表(在我们的例子中我们使用了一个集合),以便沿着一条路径回溯。今天，我将介绍您在处理图形时可能会遇到的其他算法，尤其是那些源自深度优先和广度优先搜索算法的算法。事不宜迟，让我们开始吧！</p><h2 id="cb3c" class="jt ju hy bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">Dijkstra算法</h2><p id="4fac" class="pw-post-body-paragraph iv iw hy ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">现在我们知道，图中的边可以是有向的或无向的，也可以是加权的或未加权的。也许有一天，我们最终会编写一个GPS应用程序来计算地图上两个给定点之间的最短路径。这类问题可以通过在我们的图形代码中实现<em class="kt"> Dijkstra的算法</em>来解决。Dijkstra的算法通过逐层测量到相邻节点的距离来寻找图中顶点之间的最短距离。</p><p id="47e7" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Dijkstra的算法是通过集成广度优先搜索的变体来实现的，其中，随着从顶点到顶点的遍历，当我们的算法从原点遍历时，在更新它们的权重值之前，我们在无穷远处初始化每个边的权重。像BFS一样，我们保留了一个队列来保存我们的算法将要遍历的顶点，以及已经访问过的顶点的列表。</p><figure class="ku kv kw kx fd hk"><div class="bz dy l di"><div class="ky kz l"/></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">Dijkstra算法，用于查找图形中顶点的最短路径。(创建于https:/carbon.now.sh)</figcaption></figure><p id="7065" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在上面的例子中，在遍历之前，将相对于原点的所有顶点的距离变量初始化为无穷大，以及将存储相对于原点到顶点的最小距离的变量。然后原点的距离从无穷大更新到0，然后我们的算法遍历到每个相邻的顶点。这些顶点相对于原点的距离随着每个顶点被访问而更新。同时，一个存储最小距离的变量和一个存储离原点距离最小的顶点的变量被分配到内存中。这意味着一个顶点的距离等于原点和给定顶点之间的距离之和。然后返回到顶点的最短路径。</p><h2 id="1289" class="jt ju hy bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">拓扑排序</h2><p id="4a16" class="pw-post-body-paragraph iv iw hy ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated"><em class="kt">拓扑排序</em>主要在我们希望节点按定义的顺序处理时实现。举例来说，如果我们需要一个依赖列表来在其他包之前导入一些包，我们可以使用拓扑排序。该算法在执行DFS时创建遍历节点的线性表示。事实上，实现拓扑排序算法就像用栈实现的深度优先搜索，以保持遍历图的顶点的特定顺序。</p><figure class="ku kv kw kx fd hk"><div class="bz dy l di"><div class="ky kz l"/></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">一种拓扑排序算法，使用深度优先搜索遍历图的顶点，并记录堆栈中顶点的顺序。(创建于https://carbon.now.sh</figcaption></figure><p id="19a7" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">上面的例子还包含一个帮助器函数，它将把一个访问过的顶点添加到堆栈中。<em class="kt">拓扑排序</em>函数将保存一个相似的堆栈以及一组遍历的顶点。该函数还将调用递归助手函数来遍历DFS中尚未访问过的所有可用路径。</p><figure class="ku kv kw kx fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es la"><img src="../Images/6fbbb0c5a06b3d10f93c85e20fcfc081.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K8Fq3nAhj7dS1DTNNKfaeg.png"/></div></div></figure><p id="f215" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">拓扑排序的可视化，每个距离初始化为无穷大(1)，遍历后每个距离更新(2)。(来自https://visualgo.net)</p><p id="cca2" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在上面的例子中，我们已经在我们的帮助函数中初始化了<em class="kt">距离</em>变量。当我们执行深度优先搜索算法时，每个顶点相对于原点的距离随着每个顶点被访问而更新。这是通过跟踪具有最小距离的顶点以及最小距离值本身来实现的。如果找到更小的距离，这些值(最小距离处的顶点和该距离)将被更新。在遍历结束时，我们将得到每个顶点到原点的距离，到原点距离最小的顶点，以及该距离的值。</p><p id="165d" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">感谢阅读！图遍历有时会令人困惑，但坚持是关键(只是不要累垮自己)。我的下一篇文章将是我关于图形的迷你系列的最后一篇，在这里，我将回顾我们的算法，并分析每个实现的好处和权衡，包括每个实现的时间/空间复杂性。下次见！</p><h2 id="da3d" class="jt ju hy bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">引用的消息来源</h2><blockquote class="lb lc ld"><p id="a5d5" class="iv iw kt ix b iy iz ja jb jc jd je jf le jh ji jj lf jl jm jn lg jp jq jr js hb bi translated">裴，余思敏。<em class="hy"> JavaScript数据结构和算法</em>。第一版。，Apress，2019，第17章:图表(第293–301页)。</p><p id="482b" class="iv iw kt ix b iy iz ja jb jc jd je jf le jh ji jj lf jl jm jn lg jp jq jr js hb bi translated">"使用Javascript DFS的拓扑排序."<em class="hy"> RxJS，Ggplot2，Python数据持久化，Caffe2，PyBrain，Python数据访问，H2O，Colab，Theano，Flutter，KNime，Mean。Js，Weka，Solidity </em>，<a class="ae hv" href="https://www.tutorialspoint.com/Topological-sorting-using-Javascript-DFS." rel="noopener ugc nofollow" target="_blank">https://www . tutorialspoint . com/topology-sorting-using-Javascript-DFS。【2021年6月20日访问。</a></p></blockquote></div></div>    
</body>
</html>