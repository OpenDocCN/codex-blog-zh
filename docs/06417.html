<html>
<head>
<title>MQTT in Android</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Android中的MQTT</h1>
<blockquote>原文：<a href="https://medium.com/codex/mqtt-in-android-ff3b083f2221?source=collection_archive---------5-----------------------#2022-04-23">https://medium.com/codex/mqtt-in-android-ff3b083f2221?source=collection_archive---------5-----------------------#2022-04-23</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/9ed95953b00af2065a33f7a575d4c24f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Gnp0yx-8lUlVMdgk"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">圭多·科帕在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="c249" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">MQTT在最近几年得到了广泛的关注，尤其是在IOT和M2M通信领域。</p><p id="951a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">MQTT是一个客户端服务器发布/订阅消息传输协议。它是轻量级的，开源的，易于实现。</p><p id="07c0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">MQTT特别适合IOT的要求，因为它具有以下特征:</p><p id="ff29" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">I)重量轻，带宽效率高</p><p id="69b1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">ii)数据不可知</p><p id="72c8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">iii)持续会话意识</p><p id="f0df" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">iv)构建在TCP之上</p><p id="d004" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">v)不可靠信道上的可靠通信</p><p id="12e8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">vi)可扩展</p><p id="eb91" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">vii)构建推送通信</p><p id="65f6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">viii)双向通信</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es jt"><img src="../Images/e3132d4690174a095494a596874940d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ghAdrOwm1SPOX2DyOogItQ.png"/></div></div></figure><p id="c50f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">发布订阅模式</strong></p><p id="cfeb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">与其他流行的协议(如遵循客户机服务器架构的HTTP)相比，MQTT遵循发布/订阅模式。</p><p id="9ae3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一旦设备(发布者)向代理发送数据，代理就将数据发布给所有其他订阅了该主题的客户机(订阅者)。</p><p id="61f5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这种空间和时间的解耦有助于MQTT真正可伸缩。</p><p id="cf16" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">缺点是代理是单点故障，所以我们必须使用代理集群。</p><p id="c0e7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> MQTT主题</strong></p><p id="59e2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">MQTT broker使用主题为每个连接的客户机过滤消息。主题通常是分层的，由一个或多个级别组成:</p><p id="1aa0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我的家/底层/客厅</p><p id="3a2c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我的家/一楼/书房</p><p id="466b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">可以在主题名称中使用通配符</p><p id="34ca" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">+通配符:my home/ground floor/+/temperature—这与my home/ground floor/living room/temperature或my home/ground floor/kitchen/temperature匹配</p><p id="2202" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">#通配符:我的家/底层/#-这匹配我的家/底层/客厅/，我的家/底层/厨房/，我的家/底层/厨房/温度，我的家/底层/客厅/灯光/亮度</p><p id="c846" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">实施细节</strong></p><p id="4176" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们可以使用任何MQTT客户端库，比如Eclipse的Paho。</p><p id="1a1d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于经纪人，我们可以在后端使用HiveMQ、Mosquitto等。</p><p id="9729" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们看看如何在Android应用程序中实现MQTT，使用HiveMQ作为代理。</p><p id="ded2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们将使用公共HiveMQ代理:<strong class="ix hj">端口为1883的broker.hivemq.com</strong></p><p id="b7b8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><a class="ae iu" href="https://www.hivemq.com/public-mqtt-broker/" rel="noopener ugc nofollow" target="_blank"><strong class="ix hj"/></a><strong class="ix hj">和题目foo/bar </strong></p><p id="9e22" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">第一步:</strong></p><p id="20a4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在build.gradle文件中添加Eclipse Paho库的以下依赖项。</p><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="9eb2" class="kd ke hi jz b fi kf kg l kh ki">implementation <strong class="jz hj">‘org.eclipse.paho:org.eclipse.paho.client.mqttv3:1.2.4’</strong></span><span id="2a3b" class="kd ke hi jz b fi kj kg l kh ki">implementation <strong class="jz hj">‘org.eclipse.paho:org.eclipse.paho.android.service:1.1.1’</strong></span></pre><p id="a9da" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">第二步:</p><p id="039f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在AndroidManifest文件中包含以下服务。</p><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="2e87" class="kd ke hi jz b fi kf kg l kh ki">&lt;<strong class="jz hj">service android:name=”org.eclipse.paho.android.service.MqttService”/</strong>&gt;</span></pre><p id="5934" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">第三步:</strong></p><p id="e605" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为主题和mqttClient定义成员变量。</p><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="d9c2" class="kd ke hi jz b fi kf kg l kh ki"><strong class="jz hj">lateinit var mqttClient</strong>:MqttAndroidClient</span><span id="de16" class="kd ke hi jz b fi kj kg l kh ki"><strong class="jz hj">val topic</strong>=<strong class="jz hj">”foo/bar”</strong></span></pre><p id="bc24" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">第四步:</strong></p><p id="682c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在onStart()中连接到MQTT代理</p><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="e2d4" class="kd ke hi jz b fi kf kg l kh ki"><strong class="jz hj">fun </strong>connectMqtt() {</span><span id="fa8c" class="kd ke hi jz b fi kj kg l kh ki"><strong class="jz hj">    var </strong>clientId = MqttClient.generateClientId()</span><span id="0cc4" class="kd ke hi jz b fi kj kg l kh ki"><strong class="jz hj">    mqttClient </strong>= MqttAndroidClient(<em class="kk">applicationContext</em>,       <strong class="jz hj">"tcp://broker.hivemq.com:1883"</strong>, clientId)</span><span id="d562" class="kd ke hi jz b fi kj kg l kh ki"><strong class="jz hj">   try </strong>{</span><span id="6730" class="kd ke hi jz b fi kj kg l kh ki"><strong class="jz hj">       var </strong>token: IMqttToken = <strong class="jz hj">mqttClient</strong>.connect()</span><span id="b025" class="kd ke hi jz b fi kj kg l kh ki">       token.<em class="kk">actionCallback </em>= <strong class="jz hj">object </strong>: IMqttActionListener {</span><span id="556f" class="kd ke hi jz b fi kj kg l kh ki"><strong class="jz hj">          override fun </strong>onSuccess(asyncActionToken: IMqttToken?) {</span><span id="85aa" class="kd ke hi jz b fi kj kg l kh ki">              Log.d(<strong class="jz hj">"MQTT"</strong>, <strong class="jz hj">"connection success"</strong>)</span><span id="f1da" class="kd ke hi jz b fi kj kg l kh ki">              subscribe()</span><span id="c7b9" class="kd ke hi jz b fi kj kg l kh ki">           }</span><span id="6c6e" class="kd ke hi jz b fi kj kg l kh ki"><strong class="jz hj">          override fun </strong>onFailure(asyncActionToken: IMqttToken?,    exception: Throwable?) {</span><span id="6615" class="kd ke hi jz b fi kj kg l kh ki">              Log.d(<strong class="jz hj">"MQTT"</strong>, <strong class="jz hj">"connection failure"</strong>)</span><span id="a78a" class="kd ke hi jz b fi kj kg l kh ki">           }</span><span id="c7a9" class="kd ke hi jz b fi kj kg l kh ki">      }</span><span id="45a2" class="kd ke hi jz b fi kj kg l kh ki"><strong class="jz hj">      mqttClient</strong>.setCallback( <strong class="jz hj">object</strong>:MqttCallback {</span><span id="aa3c" class="kd ke hi jz b fi kj kg l kh ki"><strong class="jz hj">           override fun </strong>connectionLost(cause: Throwable?) {</span><span id="33f9" class="kd ke hi jz b fi kj kg l kh ki">                Log.d(<strong class="jz hj">"MQTT"</strong>,<strong class="jz hj">"connection lost"</strong>)</span><span id="8cc8" class="kd ke hi jz b fi kj kg l kh ki">            }</span><span id="06dd" class="kd ke hi jz b fi kj kg l kh ki"><strong class="jz hj">          override fun </strong>messageArrived(topic: String?, message:  MqttMessage?) {</span><span id="1ef9" class="kd ke hi jz b fi kj kg l kh ki">               Log.d(<strong class="jz hj">"MQTT"</strong>, <strong class="jz hj">"message arrived on topic "</strong>+topic+ <strong class="jz hj">"  message:"</strong>+message?.toString())</span><span id="b355" class="kd ke hi jz b fi kj kg l kh ki">            }</span><span id="8d74" class="kd ke hi jz b fi kj kg l kh ki"><strong class="jz hj">         override fun </strong>deliveryComplete(token: IMqttDeliveryToken?) {</span><span id="8411" class="kd ke hi jz b fi kj kg l kh ki">           Log.d(<strong class="jz hj">"MQTT"</strong>, <strong class="jz hj">"deliveryComplete"</strong>)</span><span id="f1c5" class="kd ke hi jz b fi kj kg l kh ki">           }</span><span id="51cc" class="kd ke hi jz b fi kj kg l kh ki">       })</span><span id="1d42" class="kd ke hi jz b fi kj kg l kh ki">    } <strong class="jz hj">catch </strong>(e: MqttException) {</span><span id="8ae3" class="kd ke hi jz b fi kj kg l kh ki">    }</span><span id="eb47" class="kd ke hi jz b fi kj kg l kh ki">}</span></pre><p id="0fb4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">正如我们所看到的，这段代码涉及2个回调，一个是MQTT连接成功/失败的回调，另一个是MQTT传递和消息到达的回调。</p><p id="4011" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">注意，我们在成功连接时调用subscribe()方法。</p><p id="d728" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">第五步:</strong></p><p id="d843" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">添加订阅方法。</p><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="8839" class="kd ke hi jz b fi kf kg l kh ki"><strong class="jz hj">fun </strong>subscribe(){</span><span id="94b0" class="kd ke hi jz b fi kj kg l kh ki"><strong class="jz hj">    var </strong>token=<strong class="jz hj">mqttClient</strong>.subscribe(<strong class="jz hj">topic</strong>,1)</span><span id="8eef" class="kd ke hi jz b fi kj kg l kh ki">    token.<em class="kk">actionCallback</em>=<strong class="jz hj">object</strong>:IMqttActionListener{</span><span id="fc43" class="kd ke hi jz b fi kj kg l kh ki"><strong class="jz hj">         override fun </strong>onSuccess(asyncActionToken: IMqttToken?) {</span><span id="fd76" class="kd ke hi jz b fi kj kg l kh ki">            Log.d(<strong class="jz hj">"MQTT"</strong>, <strong class="jz hj">"subscribe success"</strong></span><span id="ac8d" class="kd ke hi jz b fi kj kg l kh ki">         }</span><span id="36fd" class="kd ke hi jz b fi kj kg l kh ki"><strong class="jz hj">         override fun </strong>onFailure(asyncActionToken: IMqttToken?, exception: Throwable?) {</span><span id="ba87" class="kd ke hi jz b fi kj kg l kh ki">            Log.d(<strong class="jz hj">"MQTT"</strong>, <strong class="jz hj">"subscribe failed"</strong>)</span><span id="5ca2" class="kd ke hi jz b fi kj kg l kh ki">         }</span><span id="80ef" class="kd ke hi jz b fi kj kg l kh ki">    }</span><span id="9a99" class="kd ke hi jz b fi kj kg l kh ki">}</span></pre><p id="5c63" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">第六步:</strong></p><p id="d289" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">添加发布方法:</p><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="607a" class="kd ke hi jz b fi kf kg l kh ki"><strong class="jz hj">fun </strong>publish(payload:String){</span><span id="b663" class="kd ke hi jz b fi kj kg l kh ki"><strong class="jz hj">    val </strong>message = MqttMessage()</span><span id="ebfe" class="kd ke hi jz b fi kj kg l kh ki">    message.<em class="kk">payload </em>= payload.<em class="kk">toByteArray</em>()</span><span id="8f88" class="kd ke hi jz b fi kj kg l kh ki">    message.<em class="kk">qos </em>= 1</span><span id="ee5e" class="kd ke hi jz b fi kj kg l kh ki">    message.<em class="kk">isRetained </em>= <strong class="jz hj">false</strong></span><span id="5136" class="kd ke hi jz b fi kj kg l kh ki"><strong class="jz hj">    mqttClient</strong>.publish(<strong class="jz hj">topic</strong>, message, <strong class="jz hj">null</strong>,  <strong class="jz hj">object</strong>:IMqttActionListener{</span><span id="0b81" class="kd ke hi jz b fi kj kg l kh ki"><strong class="jz hj">        override fun </strong>onSuccess(asyncActionToken: IMqttToken?) {</span><span id="81eb" class="kd ke hi jz b fi kj kg l kh ki">            Log.d(<strong class="jz hj">"MQTT"</strong>, <strong class="jz hj">"publish success"</strong>)</span><span id="62df" class="kd ke hi jz b fi kj kg l kh ki">        }</span><span id="aeeb" class="kd ke hi jz b fi kj kg l kh ki"><strong class="jz hj">        override fun </strong>onFailure(asyncActionToken: IMqttToken?, exception: Throwable?) {</span><span id="0a73" class="kd ke hi jz b fi kj kg l kh ki">            Log.d(<strong class="jz hj">"MQTT"</strong>, <strong class="jz hj">"publish failed"</strong>)</span><span id="5a9d" class="kd ke hi jz b fi kj kg l kh ki">        }</span><span id="b524" class="kd ke hi jz b fi kj kg l kh ki">    })</span><span id="ee2a" class="kd ke hi jz b fi kj kg l kh ki">}</span></pre><p id="e2bb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">第七步:</strong></p><p id="e8e1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">需要时取消订阅()。</p><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="a7f6" class="kd ke hi jz b fi kf kg l kh ki"><strong class="jz hj">fun </strong>unsubscribe(){</span><span id="260b" class="kd ke hi jz b fi kj kg l kh ki"><strong class="jz hj">    mqttClient</strong>.unsubsribe(<strong class="jz hj">topic</strong>)</span><span id="bf5f" class="kd ke hi jz b fi kj kg l kh ki">}</span></pre><p id="a8f2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">第八步:</strong></p><p id="48ab" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在onStop()中添加一个断开方法</p><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="25d9" class="kd ke hi jz b fi kf kg l kh ki"><strong class="jz hj">fun </strong>disconnectMqtt(){</span><span id="3980" class="kd ke hi jz b fi kj kg l kh ki"><strong class="jz hj">    try</strong>{</span><span id="becf" class="kd ke hi jz b fi kj kg l kh ki"><strong class="jz hj">        var </strong>token= <strong class="jz hj">mqttClient</strong>.disconnect()</span><span id="0ec5" class="kd ke hi jz b fi kj kg l kh ki">        token?.<em class="kk">actionCallback</em>=<strong class="jz hj">object</strong>:IMqttActionListener{</span><span id="c966" class="kd ke hi jz b fi kj kg l kh ki"><strong class="jz hj">            override fun </strong>onSuccess(asyncActionToken: IMqttToken?) {</span><span id="b694" class="kd ke hi jz b fi kj kg l kh ki">               Log.d(<strong class="jz hj">"MQTT"</strong>,<strong class="jz hj">"disconnect success"</strong>)</span><span id="0676" class="kd ke hi jz b fi kj kg l kh ki">            }</span><span id="99f3" class="kd ke hi jz b fi kj kg l kh ki"><strong class="jz hj">            override fun </strong>onFailure(asyncActionToken: IMqttToken?, exception: Throwable?) {</span><span id="4f56" class="kd ke hi jz b fi kj kg l kh ki">                Log.d(<strong class="jz hj">"MQTT"</strong>, <strong class="jz hj">"disconnect failed"</strong>);</span><span id="2792" class="kd ke hi jz b fi kj kg l kh ki">            }</span><span id="2b53" class="kd ke hi jz b fi kj kg l kh ki">        }</span><span id="42a3" class="kd ke hi jz b fi kj kg l kh ki">     }<strong class="jz hj">catch </strong>(e:MqttException){</span><span id="b3c6" class="kd ke hi jz b fi kj kg l kh ki">     }</span><span id="6b88" class="kd ke hi jz b fi kj kg l kh ki">}</span></pre><p id="e3be" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">第九步:</strong></p><p id="acb1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">测试</p><p id="da75" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">I)打开以下HiveMQ代理</p><p id="ff41" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><a class="ae iu" href="http://www.hivemq.com/demos/websocket-client/" rel="noopener ugc nofollow" target="_blank">http://www.hivemq.com/demos/websocket-client/</a></p><p id="1992" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">ii)连接并将主题设置为foo/bar(与应用程序中使用的相同)</p><p id="bbe9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">键入任何消息，然后单击发布</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kl"><img src="../Images/fd0f089e8c0d1ca7ee9325b7e9bff073.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NctCD0vrYULQR4ERHIQyQg.png"/></div></div></figure><p id="fe5d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">iii)应用程序收到相同的消息</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div class="er es km"><img src="../Images/6f5c41c3a2b73d37e4b74756e25e601d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1228/format:webp/1*9meiUGuowADT_ws21Z6QyA.png"/></div></figure><p id="3948" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">iv)在MQTT broker中订阅相同的主题</p><p id="a0dc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">v)从应用程序发布消息，例如来自应用程序的问候</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kn"><img src="../Images/a525c626c3f97342c42efc3bc621d94f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-Jn3NRbdnbArulQ7c1x0iA.png"/></div></div></figure><figure class="ju jv jw jx fd ij er es paragraph-image"><div class="er es ko"><img src="../Images/3e850a561cbd4808289bbbed0639190a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/format:webp/1*yeN5XDzNCSJWIRSgcgjpmA.png"/></div></figure><p id="e9a7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">vi)代理收到相同的消息</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kp"><img src="../Images/b119420f4ee2d5c6f66e6a9b8e5d1567.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zKK9hEkr3YL-lu4h-TEzcw.png"/></div></div></figure><p id="288d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是一个非常简单的例子，可以理解发布者可以发布任何消息，然后由代理接收，一旦代理发布了消息，所有订阅者都会收到。我们可以很容易地在两部手机上运行这个应用程序，看看这是怎么回事。</p><p id="9700" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这可以在IOT应用程序中扩展，其中温度传感器或门传感器发布关于某个主题的消息，所有订阅者(例如，应用程序接收最新的温度，而无需轮询温度)。</p><p id="7fab" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">其他术语:</strong></p><p id="f107" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> QoS </strong></p><p id="97b4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是参与者之间保证的服务质量。</p><p id="5d86" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> QoS 0 </strong>:这也叫‘最多一次’或者‘一发了之’。我们可以在不使用消息队列的时候使用它，如果一些消息丢失了，比如高频率的消息，比如温度。</p><p id="a982" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> QoS1 </strong>:这个也叫“至少一次”。这通常是默认的，是保证和带宽之间的一个很好的折衷。</p><p id="4756" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是一次“恰好一次”的递送。即使设备之间失去连接并重新连接，它也能保证传输。</p><p id="3870" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">持续会话</strong></p><p id="29ae" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在持久会话中，代理会记住客户端和以下信息</p><ul class=""><li id="6af9" class="kq kr hi ix b iy iz jc jd jg ks jk kt jo ku js kv kw kx ky bi translated">会话数据</li><li id="c74d" class="kq kr hi ix b iy kz jc la jg lb jk lc jo ld js kv kw kx ky bi translated">签署</li><li id="925d" class="kq kr hi ix b iy kz jc la jg lb jk lc jo ld js kv kw kx ky bi translated">未确认的QoS消息</li><li id="97ff" class="kq kr hi ix b iy kz jc la jg lb jk lc jo ld js kv kw kx ky bi translated">排队的消息</li></ul><p id="dc4e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">清洁会话</strong></p><p id="cda5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在干净会话中，代理会在客户端断开连接后立即删除所有信息。</p><p id="6541" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">消息队列</strong></p><p id="0a05" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是MQTT独有的特性。</p><p id="4a54" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果会话是持久的，当客户端脱机时，Broker将所有QoS1/2消息排队。只要客户端重新连接，消息就会再次传递。</p><p id="e46a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">保留的消息</strong></p><p id="c9b6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">任何主题的最后一条消息都由代理保存，这样任何新的订阅者只要连接上就可以获得新的值。</p><p id="b532" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在发布命令中设置为布尔值。每个主题只保留1条消息。</p><p id="7985" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">保持活力</strong></p><p id="7f5d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果代理在保持活动期间没有从客户端接收到任何消息，代理将断开客户端。默认值为60秒。</p><p id="85a2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这有助于避免半开TCP问题。</p><p id="5436" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果客户端使用相同的客户端ID重新连接，旧的连接将被清除并删除，新的连接将被建立。这被称为客户接管。</p><p id="c159" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">遗嘱</strong></p><p id="b688" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果一个客户端由于网络故障或在保持活动期间没有消息而断开连接，则通知所有其他客户端。</p><p id="8ae2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最后一条消息由客户端在连接数据包中设置，详细信息如下:</p><p id="78dd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">lastWillTopic，lastWillQos，LastWillMessage，lastWillRetain。</p><p id="045c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">原博夫</strong></p><p id="c3e5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Protobuf指定了一种语言中立的机制，以一种简单的结构序列化数据，这种结构对于设备之间的传输是有效的。因此，在MQTT实现中通常使用Protobuff，其中客户机代码可以用C++编写，服务器代码可以用Java编写，数据可以通过MQTT使用Protobuff传输。</p><p id="778e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">完整的源代码可以从下面的链接下载:</p><p id="c4e1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><a class="ae iu" href="https://github.com/sonika-srivastava/MqttSample" rel="noopener ugc nofollow" target="_blank">https://github.com/sonika-srivastava/MqttSample</a></p><p id="9a5e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">参考资料:</p><p id="9fdf" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><a class="ae iu" href="https://www.hivemq.com/mqtt-essentials/" rel="noopener ugc nofollow" target="_blank">https://www.hivemq.com/mqtt-essentials/</a></p></div></div>    
</body>
</html>