<html>
<head>
<title>A study of Test Driven Development and Functional Programming in TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript中测试驱动开发和函数式编程的研究</h1>
<blockquote>原文：<a href="https://medium.com/codex/a-study-of-test-driven-development-and-functional-programming-in-typescript-5a1212dff16a?source=collection_archive---------4-----------------------#2022-06-06">https://medium.com/codex/a-study-of-test-driven-development-and-functional-programming-in-typescript-5a1212dff16a?source=collection_archive---------4-----------------------#2022-06-06</a></blockquote><div><div class="dt gx gy gz ha hb"/><div class="hc hd he hf hg"><div class=""/><div class=""><h2 id="c39a" class="pw-subtitle-paragraph ig hi hj bd b ih ii ij ik il im in io ip iq ir is it iu iv iw ix dy translated">从基于类的IoC到功能性的TDD？—一次旅行</h2></div><figure class="iz ja jb jc fe jd es et paragraph-image"><div role="button" tabindex="0" class="je jf di jg bf jh"><div class="es et iy"><img src="../Images/982d4d15c03b7810c8faa90ed614c4cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pTm-KtgM8rs1ggud5HCqSw.png"/></div></div><figcaption class="jk jl eu es et jm jn bd b be z dy translated">照片由<a class="ae jo" href="https://unsplash.com/?utm_source=Hashnode&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae jo" href="https://unsplash.com/es/@ratushny?utm_source=Hashnode&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Dmitry Ratushny </a>拍摄</figcaption></figure><h1 id="c4ed" class="jp jq hj bd jr js jt ju jv jw jx jy jz ip ka iq kb is kc it kd iv ke iw kf kg bi translated">介绍</h1><p id="138a" class="pw-post-body-paragraph kh ki hj kj b kk kl ik km kn ko in kp kq kr ks kt ku kv kw kx ky kz la lb lc hc bi translated">我来自面向对象编程(OOP)的背景——这是我学习编程的形成时期的热门话题——由C++和Java驱动。拥抱单元测试意味着拥抱控制反转(IoC)和依赖注入(DI)。这就是方法。</p><p id="22f0" class="pw-post-body-paragraph kh ki hj kj b kk ld ik km kn le in kp kq lf ks kt ku lg kw kx ky lh la lb lc hc bi translated">随着我选择的语言切换到TypeScript，以及通过HTTP APIs传递接口定义的对象来传递数据，真正的OOP类消失了，但我继续使用DI类。业务逻辑在服务类中，服务类实际上只是构造函数中共享DI的函数集合。单元测试模拟出了所有的依赖关系，我的覆盖率经常达到100%，这让我很自豪。我首先用单元测试<em class="li">测试了我的代码，所以在第一次部署时一切正常。我基本上忘记了如何使用IDE的调试器。</em></p><p id="1c30" class="pw-post-body-paragraph kh ki hj kj b kk ld ik km kn le in kp kq lf ks kt ku lg kw kx ky lh la lb lc hc bi translated">一切都很好。</p><p id="766b" class="pw-post-body-paragraph kh ki hj kj b kk ld ik km kn le in kp kq lf ks kt ku lg kw kx ky lh la lb lc hc bi translated">我曾听到测试驱动开发(TDD)的粉丝们惊叹它的神奇之处，但我认为我的<em class="li">部署前测试</em>方法基本上做到了这一点。(事实证明，并不尽然。)</p><p id="62d7" class="pw-post-body-paragraph kh ki hj kj b kk ld ik km kn le in kp kq lf ks kt ku lg kw kx ky lh la lb lc hc bi translated">我曾听到函数式编程(FP)的粉丝们惊呼它们优于面向对象编程。但是，嘿，我只是用类来为DI组织我的函数——所以我基本上是函数式的。(是，但不是。)</p><p id="0567" class="pw-post-body-paragraph kh ki hj kj b kk ld ik km kn le in kp kq lf ks kt ku lg kw kx ky lh la lb lc hc bi translated">我看不出这些之间有什么联系。这两个我都没有完全理解，我知道。偶尔，我会阅读一篇关于TDD或FP的博客文章，试图理解这种兴奋感。我想发现这些技术令人兴奋！但是我读的所有东西都很基础，我看不到如何将其应用到实际问题中，它们也没有显示如何将概念联系起来。或者更糟的是，TDD被完全曲解了，看起来很可怕，因为做错了是可怕的。</p><p id="523f" class="pw-post-body-paragraph kh ki hj kj b kk ld ik km kn le in kp kq lf ks kt ku lg kw kx ky lh la lb lc hc bi translated">我认为:功能性对于纯粹的功能来说是很好的，但是你如何测试不纯粹的编排呢？</p><h1 id="7ad2" class="jp jq hj bd jr js jt ju jv jw jx jy jz ip ka iq kb is kc it kd iv ke iw kf kg bi translated">什么是真正的测试驱动开发？</h1><p id="99da" class="pw-post-body-paragraph kh ki hj kj b kk kl ik km kn ko in kp kq kr ks kt ku kv kw kx ky kz la lb lc hc bi translated">Robert c . Martin(Bob叔叔)在他关于<a class="ae jo" href="https://www.youtube.com/watch?v=BSaAMQVq01E" rel="noopener ugc nofollow" target="_blank">期望专业化</a>的演讲中涉及了很多关于软件开发实践的内容，特别是这里的TDD<a class="ae jo" href="https://vimeo.com/97516288" rel="noopener ugc nofollow" target="_blank"/>。(看这些。)</p><p id="4bd1" class="pw-post-body-paragraph kh ki hj kj b kk ld ik km kn le in kp kq lf ks kt ku lg kw kx ky lh la lb lc hc bi translated">与复式记账会计实践的类比尤其引起了我的共鸣。复式簿记是为每个账户保留一个交易分类账的纪律。当你从一个账户中扣除时，它必须立即被加到另一个账户中。通常这个“账户”不是传统意义上的账户，它只是一种跟踪和<em class="li">检查你工作的手段。这是校验和。这里减去；加在那里；比较总数。如果你犯了一个错误，簿记员马上就知道了。</em></p><p id="881c" class="pw-post-body-paragraph kh ki hj kj b kk ld ik km kn le in kp kq lf ks kt ku lg kw kx ky lh la lb lc hc bi translated">我们经常编写所有的代码，然后<em class="li">编写所有的测试来检查它。记账员<em class="li">不要</em>。他们在这里减去一个条目，然后在那里加上它。这是原子操作。为什么？因为如果他们都做了一个，然后又做了另一个，并且犯了一个错误，那么最后的校验和就是“不匹配”。错在哪里？它是他们添加的<em class="li">多个</em>事务之一中的<em class="li">某处</em>。这很痛苦，而自动输入所有事务就没那么痛苦了。</em></p><p id="c9c9" class="pw-post-body-paragraph kh ki hj kj b kk ld ik km kn le in kp kq lf ks kt ku lg kw kx ky lh la lb lc hc bi translated">TDD就像复式记账一样。规则被放在两个地方，原子地。写测试代码，然后写一些生产代码。校验和。写一些测试代码，写一些生产代码。校验和。这听起来可能很痛苦，但是如果你引入了一个bug，你会立刻发现它。这是终极林挺工具。与生产中的一个bug相比，这有多痛苦？一旦你习惯了，就不会了。这是#1 TDD承诺:无Bug代码！(警告:当然，你必须理解想要的行为。否则你会写两次错误的行为。)</p><p id="6082" class="pw-post-body-paragraph kh ki hj kj b kk ld ik km kn le in kp kq lf ks kt ku lg kw kx ky lh la lb lc hc bi translated">这是第二个TDD承诺:你的代码将会更干净，更容易维护，并且是自文档化的。观看视频，找出这个承诺的论据。</p><p id="9d92" class="pw-post-body-paragraph kh ki hj kj b kk ld ik km kn le in kp kq lf ks kt ku lg kw kx ky lh la lb lc hc bi translated">如果Bob叔叔和我最终让你相信测试驱动开发(TDD)是令人惊奇的，那么请继续关注Ian Cooper关于这个主题的演讲:<a class="ae jo" href="https://www.youtube.com/watch?v=EZ05e7EMOLM" rel="noopener ugc nofollow" target="_blank"> TDD，哪里出错了</a>(是的，这实际上是专业的TDD！他指出了人们误解的地方。)</p><p id="c78f" class="pw-post-body-paragraph kh ki hj kj b kk ld ik km kn le in kp kq lf ks kt ku lg kw kx ky lh la lb lc hc bi translated">接下来在我的研究中，我发现了这本指南。不再是一个简单化的例子。TDD和FP在一个大到足以应对真正挑战的例子中出现，并逐步解释而不仅仅是一个最终结果。但是…嗯……这些工厂功能是怎么回事？现在一切都是工厂。😬</p><p id="3567" class="pw-post-body-paragraph kh ki hj kj b kk ld ik km kn le in kp kq lf ks kt ku lg kw kx ky lh la lb lc hc bi translated">最后一篇文章链接到这个<a class="ae jo" href="https://www.jamesshore.com/v2/blog/2018/testing-without-mocks" rel="noopener ugc nofollow" target="_blank">无模拟测试的原始指南</a>。这是另一个与TDD紧密联系的概念，但是这个概念使用了类而不是函数。尽管这些课程仍然涉及工厂。此外，示例显示了React代码——提醒我React组件本身使用工厂模式，无论是基于函数的还是基于类的。我不知道他为什么想完全不模仿(到了在进程中运行一个假服务器的地步——已经模仿过了！)，但要点是嘲笑(和假装)可能是最后的选择，而不是第一选择。</p><h1 id="b57f" class="jp jq hj bd jr js jt ju jv jw jx jy jz ip ka iq kb is kc it kd iv ke iw kf kg bi translated">什么是函数式编程？</h1><p id="c934" class="pw-post-body-paragraph kh ki hj kj b kk kl ik km kn ko in kp kq kr ks kt ku kv kw kx ky kz la lb lc hc bi translated">实现全功能，还是使用类？在某种程度上，它们都使用JavaScript，但这是这些例子中突出的一点:它们都是JavaScript而不是TypeScript。在某种程度上，我可以看到，当进行适当的TDD时，强类型的有力论据被削弱了:失败是默认发生的。这让我想到也许我可以允许隐式<code class="dv lj lk ll lm b">any</code>(关闭eslint规则)且不为所有的<em class="li"/>定义类型，但是强类型仍然有好处。FP的类型更难吗？在FP和完全动态类型化之间确实存在关联。🧐</p><p id="e97c" class="pw-post-body-paragraph kh ki hj kj b kk ld ik km kn le in kp kq lf ks kt ku lg kw kx ky lh la lb lc hc bi translated">什么时候使用类vs函数？<a class="ae jo" href="https://labs42io.github.io/clean-code-typescript/" rel="noopener ugc nofollow" target="_blank">这篇关于将<a class="ae jo" href="http://cleancoder.com/" rel="noopener ugc nofollow" target="_blank"> CleanCode </a>应用于TypeScript的文章</a>帮助我认识到这不是一个非此即彼的选择。看着这些模式，我意识到我可以<em class="li">学习</em>功能，但是在有意义的地方享受类和真正的OOP的好处。简而言之:类用于面向对象的逻辑，模块用于相关功能的分组。</p><p id="7442" class="pw-post-body-paragraph kh ki hj kj b kk ld ik km kn le in kp kq lf ks kt ku lg kw kx ky lh la lb lc hc bi translated"><em class="li">但是等一下</em>，你个FP修炼者吼道！函数式编程不是这样的！是的，鲍勃叔叔在他的关于函数式编程的演讲中给了我很好的指导。真正的FP是关于无国籍的。一个纯函数是没有副作用的——给定相同的输入，它将总是有相同的输出。纯粹。可测试。无国籍。经常递归。事实上，FP纯粹主义者告诉我们，泛函没有状态，甚至没有局部变量，也没有循环；递归取代了这两者，为了让开发者体验不那么差，你需要一种为此设计的语言。(Lisp，Haskell，Clojure，…)简单地只使用函数而不使用类并不自动意味着FP。真的，应用不能完全是FP；只有函数才能是纯粹的。没有状态的应用程序只是一个很大的功能，用途非常有限。此外，我们在这里讨论的是JavaScript，它不是真正的FP语言，而是一种混合语言。函数不一定要纯。我们甚至有类(函数加状态)。</p><p id="325b" class="pw-post-body-paragraph kh ki hj kj b kk ld ik km kn le in kp kq lf ks kt ku lg kw kx ky lh la lb lc hc bi translated">JavaScript可以做FP吗？是的，像<code class="dv lj lk ll lm b">map</code>和<code class="dv lj lk ll lm b">filter</code>这样的<code class="dv lj lk ll lm b">Array</code>功能是有效的。流行的<a class="ae jo" href="https://rxjs.dev/" rel="noopener ugc nofollow" target="_blank"> RxJS </a>库也是函数式的，如果你使用过它，你就会知道函数式有多复杂。TypeScript functional中的大狗是<a class="ae jo" href="https://gcanti.github.io/fp-ts/" rel="noopener ugc nofollow" target="_blank"> fp-ts </a>。与RxJS相比，它更需要整个应用程序团队的大量投入来学习和使用这种方法。</p><p id="5dcb" class="pw-post-body-paragraph kh ki hj kj b kk ld ik km kn le in kp kq lf ks kt ku lg kw kx ky lh la lb lc hc bi translated">那么我是在看真正的FP，还是只是没有使用<code class="dv lj lk ll lm b">class</code>关键字？</p><h1 id="8df0" class="jp jq hj bd jr js jt ju jv jw jx jy jz ip ka iq kb is kc it kd iv ke iw kf kg bi translated">所以… TDD？</h1><p id="94b1" class="pw-post-body-paragraph kh ki hj kj b kk kl ik km kn ko in kp kq kr ks kt ku kv kw kx ky kz la lb lc hc bi translated">我买的是TDD卖的。这听起来是可行的，个人甚至可以在现有的项目中做到这一点，而不需要强迫一个应用程序的其他开发人员，无论是现在还是将来，去理解和使用它。(的确，我已经开始这么做了！)</p><p id="b13c" class="pw-post-body-paragraph kh ki hj kj b kk ld ik km kn le in kp kq lf ks kt ku lg kw kx ky lh la lb lc hc bi translated">不知道如何真正开始？</p><p id="7ebb" class="pw-post-body-paragraph kh ki hj kj b kk ld ik km kn le in kp kq lf ks kt ku lg kw kx ky lh la lb lc hc bi translated">下面是TDD的三个规则:</p><ol class=""><li id="2298" class="ln lo hj kj b kk ld kn le kq lp ku lq ky lr lc ls lt lu lv bi translated">编写产品代码只是为了通过失败的单元测试。</li><li id="e0b8" class="ln lo hj kj b kk lw kn lx kq ly ku lz ky ma lc ls lt lu lv bi translated">编写的单元测试不要超过足以失败的程度(编译失败就是失败)。</li><li id="459e" class="ln lo hj kj b kk lw kn lx kq ly ku lz ky ma lc ls lt lu lv bi translated">除了通过一个失败的单元测试所必需的，不要写更多的产品代码。</li></ol><p id="852f" class="pw-post-body-paragraph kh ki hj kj b kk ld ik km kn le in kp kq lf ks kt ku lg kw kx ky lh la lb lc hc bi translated">这里有一些用JavaScript 进行TDD的<a class="ae jo" href="https://www.jamesshore.com/v2/projects/lunch-and-learn" rel="noopener ugc nofollow" target="_blank">实时流例子。</a></p><h1 id="169f" class="jp jq hj bd jr js jt ju jv jw jx jy jz ip ka iq kb is kc it kd iv ke iw kf kg bi translated">所以……FP？</h1><p id="5d27" class="pw-post-body-paragraph kh ki hj kj b kk kl ik km kn ko in kp kq kr ks kt ku kv kw kx ky kz la lb lc hc bi translated">对我来说，用TypeScript，不行。</p><p id="ab24" class="pw-post-body-paragraph kh ki hj kj b kk ld ik km kn le in kp kq lf ks kt ku lg kw kx ky lh la lb lc hc bi translated">肯特·c·多德关于功能教学法的观点值得一读。我不接受“<code class="dv lj lk ll lm b">this</code>太复杂”的论点，我认为他只是对<code class="dv lj lk ll lm b">class</code>关键字过敏，但是用纯函数代替OOP的无状态编程有一些优点。它不仅使测试变得容易，而且使用定义为接口而不是类的对象非常好。对于一些逻辑转换，可以用一个类来实现构建器模式。</p><p id="ce77" class="pw-post-body-paragraph kh ki hj kj b kk ld ik km kn le in kp kq lf ks kt ku lg kw kx ky lh la lb lc hc bi translated">我们应该在模块(文件)级别而不是类级别定义函数吗？下面是我们如何在没有任何花哨的依赖注入(DI)魔法的情况下实现控制反转(IoC ):</p><pre class="iz ja jb jc fe mb lm mc md aw me bi"><span id="833b" class="mf jq hj lm b fj mg mh l mi mj"><strong class="lm hk">function a() {<br/>}<br/><br/>function fakeA() {<br/>}<br/><br/>function b() {<br/>}<br/><br/>function fakeB() {<br/>}<br/><br/>export function moduleFactory(<br/>        otherModuleDependency = otherModuleFactory(),<br/>) {<br/>   return {a, b};<br/>}<br/><br/>export function fakeModuleFactory() {<br/>   return {a: fakeA, b: fakeB};<br/>}</strong></span></pre><p id="7ba6" class="pw-post-body-paragraph kh ki hj kj b kk ld ik km kn le in kp kq lf ks kt ku lg kw kx ky lh la lb lc hc bi translated">许多FP代码实际上不仅对<code class="dv lj lk ll lm b">class</code>关键字过敏，甚至对<code class="dv lj lk ll lm b">function</code>也过敏！因此，我们可以像这样将工厂函数导出为模块默认值:</p><pre class="iz ja jb jc fe mb lm mc md aw me bi"><span id="effa" class="mf jq hj lm b fj mg mh l mi mj"><strong class="lm hk">import UserRepository from "user.repository";<br/><br/>export default (repo = UserRepository()) =&gt; {<br/>   return {<br/>      a: () =&gt; {<br/>      },<br/>      b: () =&gt; {<br/>      },<br/>   };<br/>}</strong></span></pre><p id="395b" class="pw-post-body-paragraph kh ki hj kj b kk ld ik km kn le in kp kq lf ks kt ku lg kw kx ky lh la lb lc hc bi translated">对我来说，这比带有构造函数DI的漂亮的<code class="dv lj lk ll lm b">export class UserLogic</code>可读性更差。</p><p id="417f" class="pw-post-body-paragraph kh ki hj kj b kk ld ik km kn le in kp kq lf ks kt ku lg kw kx ky lh la lb lc hc bi translated"><a class="ae jo" href="https://www.reddit.com/r/typescript/comments/ufucle/comment/i72c5di/?utm_source=share&amp;utm_medium=web2x&amp;context=3" rel="noopener ugc nofollow" target="_blank">Reddit上的dvlsg</a>也许最好地总结了函数(闭包)与类的争论:</p><blockquote class="mk ml mm"><p id="1318" class="kh ki li kj b kk ld ik km kn le in kp mn lf ks kt mo lg kw kx mp lh la lb lc hc bi translated"><em class="hj">有些人只是更喜欢在类上使用闭包而不是使用状态，不喜欢使用‘this’。真的是这样。这是一个有效的观点，但它只是一个观点。</em></p></blockquote><p id="b101" class="pw-post-body-paragraph kh ki hj kj b kk ld ik km kn le in kp kq lf ks kt ku lg kw kx ky lh la lb lc hc bi translated">然后是推特上的Dax Raad:</p><blockquote class="mk ml mm"><p id="10a8" class="kh ki li kj b kk ld ik km kn le in kp mn lf ks kt mo lg kw kx mp lh la lb lc hc bi translated">没有人谈论函数式编程的一个基本权衡是，你用得越多，你就变得越烦人</p></blockquote><p id="6ed1" class="pw-post-body-paragraph kh ki hj kj b kk ld ik km kn le in kp kq lf ks kt ku lg kw kx ky lh la lb lc hc bi translated">FP是一个大转变。一路走下去会使你的代码不被大多数编程社区所维护，因此需要完全的认同。选择用一种非母语的语言来做FP比试图说服人们转向一种合适的FP语言更糟糕。可以提出这样做的理由，但这是一个巨大的飞跃。</p><h1 id="413c" class="jp jq hj bd jr js jt ju jv jw jx jy jz ip ka iq kb is kc it kd iv ke iw kf kg bi translated">所以… OOP？</h1><p id="4c8b" class="pw-post-body-paragraph kh ki hj kj b kk kl ik km kn ko in kp kq kr ks kt ku kv kw kx ky kz la lb lc hc bi translated">函数式和面向对象并不是非黑即白的对立选项。我们来稍微探索一下。</p><p id="8349" class="pw-post-body-paragraph kh ki hj kj b kk ld ik km kn le in kp kq lf ks kt ku lg kw kx ky lh la lb lc hc bi translated">我们当然可以从FP那里借鉴很多，就像JavaScript ES2015在引入新的<code class="dv lj lk ll lm b">Array</code>函数如<code class="dv lj lk ll lm b">map</code>和<code class="dv lj lk ll lm b">reduce</code>时所做的那样。将业务逻辑塞入纯函数和不可变类中采用了一些FP概念，但没有太深入。</p><p id="3ade" class="pw-post-body-paragraph kh ki hj kj b kk ld ik km kn le in kp kq lf ks kt ku lg kw kx ky lh la lb lc hc bi translated">用于DI和测试的只有功能和“没有模仿”(结果证明只是手工制作的赝品)的方法看起来并不能买到任何东西。类构造函数被替换为工厂。这里有一个很好的例子。高度相关的函数是按一个工厂返回的方式组合在一起，还是按一个类组合在一起，没有任何区别。我当然也遇到过类变大的问题，因为某件事情的所有逻辑和编排都被塞在一起，但是函数和模块也会发生这种情况。</p><p id="4e88" class="pw-post-body-paragraph kh ki hj kj b kk ld ik km kn le in kp kq lf ks kt ku lg kw kx ky lh la lb lc hc bi translated">解决方案不是按照它们操作的东西对功能进行分组，而是按照它们共享的依赖关系(<a class="ae jo" href="https://en.wikipedia.org/wiki/Cohesion_(computer_science)" rel="noopener ugc nofollow" target="_blank">高内聚</a>)和它们做什么(<a class="ae jo" href="https://en.wikipedia.org/wiki/Single-responsibility_principle" rel="noopener ugc nofollow" target="_blank">单一责任</a>)。不要让一个<code class="dv lj lk ll lm b">UserService</code>类变得越来越大，而是让每个用例都有一个操作用户的类。这使得班级人数很少。</p><p id="d908" class="pw-post-body-paragraph kh ki hj kj b kk ld ik km kn le in kp kq lf ks kt ku lg kw kx ky lh la lb lc hc bi translated">下面我使用来自<code class="dv lj lk ll lm b">"domain/models"</code>的接口和一个(纯)保护函数，来自<code class="dv lj lk ll lm b">"domain/logic"</code>和<code class="dv lj lk ll lm b">"utils/assertions"</code>的纯函数，并把它们作为一个<em class="li">用例</em>协调在一个干净的内聚类中。</p><pre class="iz ja jb jc fe mb lm mc md aw me bi"><span id="df08" class="mf jq hj lm b fj mg mh l mi mj"><strong class="lm hk">import { isUserSignUpRequest, UserSignUpRequest, UserSignUpResponse } from "domain/models";<br/>import { newUserFactory } from "domain/logic/user";<br/>import { assertValidInput } from "utils/assertions";<br/><br/>// Optionally use DI magic to gain performance of singletons:<br/>// @Injectable()<br/>export class UserSignUpUseCase {<br/>   // Dependencies defaulted - tests can provide mocks or fakes<br/>   constructor(<br/>           auth = new AuthService(),<br/>           userRepo = new UserRepository(),<br/>   ) {<br/>   }<br/><br/>   async process(request: UserSignUpRequest): Promise&lt;UserSignUpResponse&gt; {<br/>      this.validateRequest(request);<br/>      const user = newUserFactory(request);<br/>      await this.userRepo.put(user);<br/>      return {user};<br/>   }<br/><br/>   private validateRequest(request: UserSignUpRequest): void {<br/>      this.auth.assertIsNotAuthenticated();<br/>      assertValidInput(request, isUserSignUpRequest);<br/>   }<br/>}</strong></span></pre><p id="4d8f" class="pw-post-body-paragraph kh ki hj kj b kk ld ik km kn le in kp kq lf ks kt ku lg kw kx ky lh la lb lc hc bi translated">这些用例类也可以被称为传统意义上的“控制器”。这个名字现在经常用于RESTful路径处理，所以我发现<code class="dv lj lk ll lm b">UseCase</code>更清晰。</p><p id="dd44" class="pw-post-body-paragraph kh ki hj kj b kk ld ik km kn le in kp kq lf ks kt ku lg kw kx ky lh la lb lc hc bi translated">这可以通过模块作用域导出工厂函数来实现吗？绝对的。它的可读性会一样强吗？我说不。</p><h1 id="9529" class="jp jq hj bd jr js jt ju jv jw jx jy jz ip ka iq kb is kc it kd iv ke iw kf kg bi translated">要遵守的规则？</h1><p id="1595" class="pw-post-body-paragraph kh ki hj kj b kk kl ik km kn ko in kp kq kr ks kt ku kv kw kx ky kz la lb lc hc bi translated">这是我个人的看法，也是我打算如何继续下去。你的研究和背景可能会让你得出不同的结论。</p><ol class=""><li id="e421" class="ln lo hj kj b kk ld kn le kq lp ku lq ky lr lc ls lt lu lv bi translated">使用TDD，根据具体情况灵活使用。(不要执着。)</li><li id="06ce" class="ln lo hj kj b kk lw kn lx kq ly ku lz ky ma lc ls lt lu lv bi translated">为API使用类型和接口。</li><li id="9281" class="ln lo hj kj b kk lw kn lx kq ly ku lz ky ma lc ls lt lu lv bi translated">支持业务转换逻辑的纯函数——任何带有一个或两个参数，并返回一个或两个结果而没有突变或外部状态的函数。</li><li id="dc43" class="ln lo hj kj b kk lw kn lx kq ly ku lz ky ma lc ls lt lu lv bi translated">在有价值的地方使用OOP但是对象必须是自包含的，这样状态变化<em class="li">只</em>影响对象实例。</li><li id="9c19" class="ln lo hj kj b kk lw kn lx kq ly ku lz ky ma lc ls lt lu lv bi translated">对具有<a class="ae jo" href="https://en.wikipedia.org/wiki/Single-responsibility_principle" rel="noopener ugc nofollow" target="_blank">单一职责</a>和<a class="ae jo" href="https://en.wikipedia.org/wiki/Cohesion_(computer_science)" rel="noopener ugc nofollow" target="_blank">高内聚</a>的<em class="li">小</em>类使用依赖注入(DI)。这些类不是面向对象的，只是函数和依赖的集合。这可以用模块和工厂函数来完成，但是对于可读性较差的语法来说，这比一个干净的类要花费更多的精力；这种语法上的好处是有充分理由的。此外，将函数分组名(类)与文件名分开感觉更灵活。</li><li id="64de" class="ln lo hj kj b kk lw kn lx kq ly ku lz ky ma lc ls lt lu lv bi translated">如果需要一个测试用例，将它与真实代码一起导出，这样它就可以被依赖于它的任何测试重用。</li></ol><h1 id="5182" class="jp jq hj bd jr js jt ju jv jw jx jy jz ip ka iq kb is kc it kd iv ke iw kf kg bi translated">文件结构</h1><p id="c794" class="pw-post-body-paragraph kh ki hj kj b kk kl ik km kn ko in kp kq kr ks kt ku kv kw kx ky kz la lb lc hc bi translated">综上所述，我该如何组织源代码呢？</p><pre class="iz ja jb jc fe mb lm mc md aw me bi"><span id="801d" class="mf jq hj lm b fj mg mh l mi mj"> .<br/> └── src<br/>     ├── domain<br/>     │   ├── logic # domain logic functions &amp; OO classes<br/>     │   │   └── user.logic.ts<br/>     │   └── models<br/>     │       ├── index.ts<br/>     │       └── user.ts<br/>     ├── handlers<br/>     │   └── user-sign-up.lambda.ts<br/>     ├── external<br/>     │   ├── dynamodb.service.ts<br/>     │   └── repositories<br/>     │       └── user.repository.ts<br/>     └── use-cases<br/>         └── user<br/>             ├── user-sign-up.test.ts<br/>             └── user-sign-up.ts</span></pre><p id="915f" class="pw-post-body-paragraph kh ki hj kj b kk ld ik km kn le in kp kq lf ks kt ku lg kw kx ky lh la lb lc hc bi translated">整个<code class="dv lj lk ll lm b">domain</code>，或者仅仅是<code class="dv lj lk ll lm b">domain/models</code>，可能会进入一个单独的包，与客户端代码共享——这些模型就是你的API契约。</p><p id="c7f7" class="pw-post-body-paragraph kh ki hj kj b kk ld ik km kn le in kp kq lf ks kt ku lg kw kx ky lh la lb lc hc bi translated"><code class="dv lj lk ll lm b">handlers</code>是代码的入口点。对于不同的环境，您可能有不同的处理程序，比如一个用于AWS Lambda，另一个用于容器化的云。这让你踏上了<a class="ae jo" href="https://adam.fanello.net/hexagonal-architecture-by-example-meetup" rel="noopener ugc nofollow" target="_blank">六边形建筑</a>之路。在这里，<code class="dv lj lk ll lm b">user-sign-up.lambda.ts</code>只是处理来自API Gateway和Lambda的解包请求，调用用例，并将正确的响应格式化回Lambda和API Gateway。</p><p id="aaac" class="pw-post-body-paragraph kh ki hj kj b kk ld ik km kn le in kp kq lf ks kt ku lg kw kx ky lh la lb lc hc bi translated"><code class="dv lj lk ll lm b">external</code>目录是你的六边形架构的右边——与外部资源和状态目标的接口。</p><p id="d4b6" class="pw-post-body-paragraph kh ki hj kj b kk ld ik km kn le in kp kq lf ks kt ku lg kw kx ky lh la lb lc hc bi translated">最后，<code class="dv lj lk ll lm b">use-cases</code>协调各个请求和命令的处理。</p><h1 id="5ba2" class="jp jq hj bd jr js jt ju jv jw jx jy jz ip ka iq kb is kc it kd iv ke iw kf kg bi translated">结论</h1><p id="0502" class="pw-post-body-paragraph kh ki hj kj b kk kl ik km kn ko in kp kq kr ks kt ku kv kw kx ky kz la lb lc hc bi translated">这些技术的探索很有趣，但是肯定会让你的博客文章更长！TDD和FP之间的关系并不像我开始想的那样紧密，但是弄清楚如何用FP进行单元测试是非常重要的。</p><p id="0498" class="pw-post-body-paragraph kh ki hj kj b kk ld ik km kn le in kp kq lf ks kt ku lg kw kx ky lh la lb lc hc bi translated">让我们总结一下:</p><ol class=""><li id="3e4f" class="ln lo hj kj b kk ld kn le kq lp ku lq ky lr lc ls lt lu lv bi translated">TDD给你超能力；拥抱它！</li><li id="2366" class="ln lo hj kj b kk lw kn lx kq ly ku lz ky ma lc ls lt lu lv bi translated">真正的函数式编程只在为它而设计的语言中实用，但是我们可以从FP中吸取经验并应用到其他语言中。</li><li id="fb15" class="ln lo hj kj b kk lw kn lx kq ly ku lz ky ma lc ls lt lu lv bi translated"><code class="dv lj lk ll lm b">class</code>关键字不是毒药，是OOP之外有用的语法糖。</li></ol></div><div class="ab cl mq mr gq ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="hc hd he hf hg"><p id="c022" class="pw-post-body-paragraph kh ki hj kj b kk ld ik km kn le in kp kq lf ks kt ku lg kw kx ky lh la lb lc hc bi translated"><em class="li">最初发表于https://adam.fanello.net/tdd-and-fp-study</em><a class="ae jo" href="https://adam.fanello.net/tdd-and-fp-study" rel="noopener ugc nofollow" target="_blank"/>(此处代码格式更好)。</p></div></div>    
</body>
</html>