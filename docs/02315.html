<html>
<head>
<title>A Quick Guide to Recursion</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">递归快速指南</h1>
<blockquote>原文：<a href="https://medium.com/codex/a-quick-guide-to-recursion-b84fdaf6986d?source=collection_archive---------25-----------------------#2021-07-12">https://medium.com/codex/a-quick-guide-to-recursion-b84fdaf6986d?source=collection_archive---------25-----------------------#2021-07-12</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/d9a8c34e28bea0fbf57b2a2f28b21482.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hK95-8tvB4dala-H"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">亚历克斯·埃克曼在Unsplash<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">上的照片</a></figcaption></figure><p id="7967" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我目前正在做一个关于排序算法的五部分系列，但是决定稍微绕一下来解释递归。我这样做是因为我的排序算法系列的下一个，也是最后两个主题，将在算法中引入递归。所以，理解递归确实是相关的。</p><h1 id="1b90" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">什么是递归？</h1><p id="4dff" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated"><strong class="ix hj">递归</strong>是一种解决问题的方法，其解决方案依赖于同一问题的较小实例的解决方案。这是分而治之算法(如合并排序)中常用的技术。</p><p id="ba3a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在递归中，<em class="kw">函数将调用它自己，直到它不再调用为止</em>。它停止调用自身的条件称为<em class="kw">基础用例</em>。这意味着如果你不小心忘记设置一个基本条件，调用可能是无限的。</p><p id="5a48" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">假设我们试图通过分治法对一个列表进行排序。分而治之的意思是，我们从一个列表开始，把列表分成两半(分成一个更小的列表)，然后再把每个列表分成两半——如此等等。然后，每当列表不能再被分割时，我们可以将我们的基本情况分配给，例如当每个列表只有一个元素时。</p><p id="5152" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">以这个列表为例:</p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="1beb" class="lg ju hi lc b fi lh li l lj lk">list = [ 4, 7, 1, 6 ]</span></pre><p id="9908" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">通过分而治之，上面的列表将被一分为二:</p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="86dc" class="lg ju hi lc b fi lh li l lj lk">[4, 7]  [1, 6]</span></pre><p id="107f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后进入另外两个，总共四个列表:</p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="4972" class="lg ju hi lc b fi lh li l lj lk">[4] [7] [1] [6]</span></pre><p id="b952" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">由于上述数字不能再分割，我们可以将此作为我们的基本情况，例如:</p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="1431" class="lg ju hi lc b fi lh li l lj lk"># base case condition</span><span id="6811" class="lg ju hi lc b fi ll li l lj lk">if len(list) &lt; 2 :<br/>    return list[:]</span></pre><h1 id="3285" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">为什么要用递归？</h1><p id="ab27" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">简单地说，你不需要使用递归来解决问题，但是它可以帮助你压缩代码。</p><p id="3721" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果你错过了分而治之的要点，你需要把一个大问题分解成小的部分，在用这个解决方案解决大问题之前，在一个小的层面上解决每个问题。通过递归，我们可以将问题分解成它的“基本情况”并直接求解。</p><h1 id="3e82" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">递归示例</h1><p id="5dd7" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">我们来看一个非常基础的递归算法。在下面的函数中，我们将把一个数组拆分成它的基本情况，同时返回每个拆分列表:</p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="3cdd" class="lg ju hi lc b fi lh li l lj lk">def divide_arr(arr):<br/>    if len(arr) &lt; 2:<br/>        return arr[:]<br/>    else:<br/>        middle = len(arr)//2<br/>        print('original list: ', arr)<br/>        print('left list after split:  ', [:middle])<br/>        print('right list after split: ', [middle:]<br/>        list1 = divide_arr(arr[:middle])<br/>        list2 = divide_arr(arr[middle:])</span></pre><p id="b61a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">正如您在代码的最底部看到的，<code class="du lm ln lo lc b">divde_arr()</code>实际上调用了它自己。这是递归在起作用！只有当数组的长度小于2时，才会达到基本情况，递归行为才会停止。</p><p id="95c1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如何应用递归的另一个主要例子是通过倒计数计时器。可以自行调用该函数来帮助计时器在停止到零之前倒计时:</p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="52e3" class="lg ju hi lc b fi lh li l lj lk">def recursion_countdown(n):<br/>    if n == 0:<br/>        return n<br/>    else:<br/>        print(n)<br/>        time.sleep(1)<br/>    return recursion_countdown(n-1)</span></pre><p id="0f02" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">很有趣，对吧？</p><p id="be2e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">既然我们已经完成了递归，我将从我离开的地方继续下一篇文章——合并排序！到时候见！</p></div></div>    
</body>
</html>