# 一堂简单的编程课

> 原文：<https://medium.com/codex/a-simple-lesson-in-coding-38334e9d8608?source=collection_archive---------18----------------------->

![](img/cb9bf9c5d34b2508a67172cf0ebff0a8.png)

威斯康辛州华盛顿岛，藏在树叶后面的旧卡车。(作者照片，2021)。

这些天我在修改我在第一周的数据结构课程中用到的例子。这些例子帮助学生更新他们的基本编程技能。其中一个例子对我来说是宝贵的一课。

它从一个简单的问题开始:写一个方法来判断一个字符串是否是回文。几乎是本能地，我输入了下面的代码:

第 4、5 和 6 行的详细程度是为了说明的目的，将在下一次尝试中合并。

看起来简单明了，但它却有着不切实际的缺点。这是降临到二年级学生身上的一种常见疾病——有时也降临到他们的导师身上:我们不假思索就匆忙编写代码。我们可能已经弄清楚了基本的逻辑:假设任何字符串都是一个回文，直到我们在其中找到一对驳斥我们假设的字母。我们从字符串的前端和末端开始比较成对的字母，向其中心移动。

上面的代码里有两件事我不喜欢。首先，如果字符串是一个单字母单词，那么运行循环就像是一种浪费。为了避免这种情况，我添加了下面第 3 行的`if`语句。该方法现在将所有单字母单词视为回文。如果我们愿意，我们可以改变这一点；目前，我还能接受。

请注意，前面的冗长已经合并成一行(第 5 行)。

我不喜欢这种方法的第二点是它很浪费。考虑这样的情况:`isPalindrome(**"supercalifragilisticexpialidocious");**` 它的第一个字母匹配它的最后一个字母(`'s'=='s’`)，它的第二个和倒数第二个字母(`'u'=='u'`)也是如此。但这不再是第三个和倒数第三个字母的情况，分别是`p`和`o`。至此，这个词作为回文被取消了资格。为什么继续剩下的 14 个配对比较。即使它们都显示匹配的字母，这个单词也不是回文。难道不能节省一些处理时间，一发现不匹配就调用吗？当然可以，只需在下面添加第 6 行和第 7 行。

不过，这很糟糕。几乎和写作一样糟糕:

```
if (!palindrome)
  break; // the for-loop
```

如果我们预料到不运行整个循环的情况，最好不要使用 for 循环。试图过早地跳出 for 循环是不明智的。它可以工作，但不是好代码。

下一步是用一个更智能的*循环重写这个方法。下面第 5 行中的 while 循环检查每一对字母。如果发现不匹配，它可能会更快停止。*

这个例子帮助学生更新他们关于返回类型和参数、字符串方法以及迭代设置中的条件的知识。它将他们从冗长的、设计不良的代码转变为更健壮的方法。它强调了`for`和`while`循环之间的主要区别。这也引发了关于设计考虑的有趣对话。

一个值得讨论的话题是传递给方法的参数。如果我们调用`isPalindrome("**Noon**");`，第一个和最后一个字母不相等，因此 *Noon* 不是一个回文。但它是，我们需要说服我们的代码。因此，我们需要在我们的方法中添加以下语句。

```
s = s.**toLowerCase()**; // or .toUpperCase()
```

如果 may 将`"Noon"`传递给该方法，它会在比较每对字母之前将其转换为`"noon"`(或`"NOON"`)。

另一个考虑是关于论点中的空格。假设我们在语法上调用`isPalindrome("**Race car"**);`，它是一个回文。我们的方法将返回`false`，因为`s.charAt(3)==s.charAt(4)`为假。因此，我们开始用以下方式消除空格:

```
s = s.**replace(" ", "")**.toLowerCase();
```

而`"Race car"`变成了`"racecar"`。现在，所有成对条件都为真:

```
s.charAt(0) == s.charAt(6); // true because **r** acecar  ==  raceca **r**
s.charAt(1) == s.charAt(5); // true because r **a** cecar == racec **a** r
s.charAt(2) == s.charAt(4); // true because ra **c** ecar == race **c** ar
s.charAt(3) == s.charAt(3); // true because rac **e** car == rac **e** car
```

但是还有更多。那么`isPalindrome("**a man, a plan, a canal: Panama**");`是回文吗？如果我们通过`replace()`和`toLowerCase()`清洗字符串，我们得到`"aman,aplan,acanal:panama"`:不完全是一个回文。我们需要再次清洗字符串`s`，去掉标点符号。

```
s = s.**replaceAll("[^a-zA-Z ]", "")**.replace(" ", "").toLowerCase();
```

上面的方法`replace()`现在是多余的——它的角色可以委托给`replaceAll()`,只需在正则表达式中稍加修改。然而，我没有这样做，因为我想说明我应用于字符串参数的三个独立的转换:删除标点符号，删除空格，转换为小写(或大写)。最后，前两个删除可以合并到一个正则表达式中，删除所有非字母字符(包括空格、标点、数字等)。现在，最终产品如下所示，第 4 行中的字符串`a`经过了转换。

接下来，对话可以转到上面的第 4 行是否可以委托给一个助手方法，即，

讨论这种委托的必要性也是很好的，因为我们可以将分解和可重用性作为良好的编码实践来讨论。

最后，还有一个问题需要讨论:调用`wash()`的位置。我们把它放在了`if`的范围内，也就是说，我们只对包含两个或更多字符的参数调用它。这可能会有问题。询问`isPalindrome("4");`将返回`true`，尽管我们的目的是检查由字母组成的单词。询问`isPalindrome("5A");`也将返回 true，因为`wash()`将把参数减少到只有`"A"`。这是一个谈论预期和意外代码行为以及测试在我们设计过程中的作用的机会。

返回课堂的学生可能对他们的基本编程技能有些生疏。一个构建布尔方法的简单入门示例可以帮助他们探索技术和设计考虑事项，并刷新他们的编码能力。从这里，我们可以将对话引向简单的测试，讨论性能分析，甚至扫描一些文本文件来搜索回文。那么重复数据的问题就出现了。这将我们带到集合论行为数据结构，真正的乐趣开始了！

*接下来:* [*一堂简单的编码课，重温一下。*](/@leoirakliotis/a-simple-lesson-in-coding-revisited-fbc9add1e599)