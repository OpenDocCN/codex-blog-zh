<html>
<head>
<title>How your Computer Really Runs C++?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你的电脑到底是怎么运行C++的？</h1>
<blockquote>原文：<a href="https://medium.com/codex/how-your-computer-really-runs-c-1b58b993aa53?source=collection_archive---------8-----------------------#2021-05-24">https://medium.com/codex/how-your-computer-really-runs-c-1b58b993aa53?source=collection_archive---------8-----------------------#2021-05-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/e2ca5b114fa8d19bd3fe3b483dfc40f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xHeo_CwEn4TQnK54"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">Alexandre Debiève 在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="011a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们来谈谈实际执行简单C++代码的所有复杂事情。我们将讨论内存、编译器、汇编代码等等，所以认真一点，让我们看看这是如何执行的。</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="05bf" class="kc kd hi jy b fi ke kf l kg kh">struct A {<br/>public:<br/>  A(int _a, char _b, double _c): a(_a), b(_b), c(_c) {}<br/>  int foo(int i);<br/>  int a;<br/>  char b;<br/>  double c;<br/>}</span><span id="2dd1" class="kc kd hi jy b fi ki kf l kg kh">int main(){<br/>  A A1(1,'c',146.2);<br/>  cout &lt;&lt; A1.c;<br/>  cout &lt;&lt; A1.foo(3);<br/>}</span></pre><p id="6539" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">1.我们通过分配堆栈帧寄存器S=0来创建一个新的堆栈帧。</p><p id="7127" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">2.我们在堆栈上为A1分配了16个字节的内存。int有4个字节，char有1个字节，double有8个字节。每个字段都需要按照其字段大小的倍数进行对齐。例如，int只能在4的倍数的地址上定义。基本上，编译器优化了字段的对齐方式，以便可以通过一次读取将它们读入内存。电脑一次读入32或64位内存(取决于电脑的系统)，从32或64位地址的倍数开始，因此您可以通过对齐内存来节省额外的读取。如果这个概念不太熟悉，可以看看<a class="ae iu" href="https://fresh2refresh.com/c-programming/c-structure-padding/" rel="noopener ugc nofollow" target="_blank">https://fresh 2 refresh . com/c-programming/c-structure-padding/</a>。</p><figure class="jt ju jv jw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kj"><img src="../Images/1cdd9a3832dfcc66d582e72de31bdccc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3fAls-SFVoEzA-wyexPIdg.png"/></div></div></figure><p id="daef" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">3.在S+0上调用<code class="du kk kl km jy b">A1</code>的构造函数，将分配的内存变成有用的位。在构造函数之前，内存只是垃圾。</p><p id="6b63" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">4.对于<code class="du kk kl km jy b">cout &lt;&lt; A1.c</code>，存储器地址S+8从存储器中取出并存储在寄存器r1中。大会大概看起来像<code class="du kk kl km jy b">READ S+8, r1</code>。所有的操作，包括加载和存储，都是通过寄存器来完成的。你不能只打印出内存S+8，相反，你需要把它加载到一个寄存器中，然后打印出这个寄存器。</p><p id="0c09" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">5.接下来，我们创建一个新的堆栈框架，这样我们就可以调用<code class="du kk kl km jy b">foo</code>。我们通过在堆栈(prev_S)中保存当前的S并将S寄存器更新为16来实现这一点，因为我们当前已经在先前的堆栈中使用了16字节的内存来存储<code class="du kk kl km jy b">A1</code>。</p><p id="069e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">6.接下来，我们需要在堆栈上加载<code class="du kk kl km jy b">foo</code>的参数。我们将常数3推送到堆栈上，<code class="du kk kl km jy b">push S+0, $3</code>。</p><p id="a3b3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">7.我们还需要将指向<code class="du kk kl km jy b">A1</code>的指针推送到堆栈<code class="du kk kl km jy b">push S+4, &amp;A1</code>(在真实的汇编中，你需要将<code class="du kk kl km jy b">&amp;A1</code>的内存加载到一个寄存器中，然后将其推送到堆栈中)。如果<code class="du kk kl km jy b">&amp;A1</code>不是<code class="du kk kl km jy b">foo</code>的参数，我们为什么要把它推到堆栈中？因为<code class="du kk kl km jy b">foo</code>的实际指令在所有A对象之间共享，<code class="du kk kl km jy b">foo</code>本身并不能访问调用它的特定A对象。所以，编译器会将<code class="du kk kl km jy b">A1</code>对象的地址隐式传递给<code class="du kk kl km jy b">foo</code>，这样<code class="du kk kl km jy b">foo</code>就可以在这个特定的A对象上运行。这就是为什么我们在C++类中有“This”指针。“this”指针隐式传递给所有方法，并隐式放在类中的每个字段访问或方法调用之前。</p><figure class="jt ju jv jw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kn"><img src="../Images/8b04b3d125d023b3b5592ddaa157c051.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IAmqGZ6f5zyP-b_la7imxw.png"/></div></div></figure><p id="93f0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">8.现在我们的堆栈框架和参数都设置好了，我们通过将程序计数器(<a class="ae iu" href="https://whatis.techtarget.com/definition/program-counter#:~:text=A%20program%20counter%20is%20a,its%20stored%20value%20by%201." rel="noopener ugc nofollow" target="_blank"> pc </a>)移动到<code class="du kk kl km jy b">foo</code>指令的地址来调用<code class="du kk kl km jy b">foo</code>。pc是一个指向当前指令行的特殊寄存器。简单地将pc移动到开始位置<code class="du kk kl km jy b">foo</code>会使计算机执行<code class="du kk kl km jy b">foo</code>。</p><p id="4153" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">9.当<code class="du kk kl km jy b">foo</code>结束时，它会将函数的返回值写入一个特殊的寄存器，<a class="ae iu" href="https://arvindsraj.wordpress.com/2013/01/12/x86-registers-register-conventions-and-calling-conventions/" rel="noopener ugc nofollow" target="_blank"> EAX </a>。此外，S被设置为prev_S=0，因为我们已经完成了<code class="du kk kl km jy b">foo</code>函数。注意，栈上的东西实际上并没有被清除，而是S，只是被移回到它之前的位置。</p><p id="0cfa" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">10.现在，我们<code class="du kk kl km jy b">cout</code>走出EAX。</p><p id="3404" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">11.我们的主堆栈即将结束，这将触发所有已创建对象的析构函数。调用<code class="du kk kl km jy b">A1</code>的析构函数，程序退出。</p><p id="981e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们完事了。请注意，为了避免冗余和避免一些复杂的组装，甚至本演练也掩盖了所发生的一些事情。我希望这能让你明白编译和执行C++代码时到底发生了什么。</p></div></div>    
</body>
</html>