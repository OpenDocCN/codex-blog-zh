# C++多线程，简单的方法

> 原文：<https://medium.com/codex/c-multithreading-the-simple-way-95aa1f7304a2?source=collection_archive---------1----------------------->

## [抄本](http://medium.com/codex)

![](img/51c2aa4e0c92a56b0f2da2d364f7e22c.png)

由 [Boris Dunand](https://unsplash.com/@borisdunand?utm_source=medium&utm_medium=referral) 在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄的照片

多线程是当今几乎所有计算机处理器最强大和最重要的功能之一。多线程允许软件在同一个程序中同时执行不同的代码。如果没有多线程，Web 服务器、web 浏览器、数据库、移动应用程序以及几乎任何生产级软件都无法正常工作。

多线程通常以困难著称。与软件开发中的其他概念相比，人们当然可以提出这样的理由。然而，多线程与一般的编程并没有太大的不同。这只是潜在的更危险。不过，学会防范危险可以让你实现比单线程方式更强大的算法和程序。

要理解多线程，最好从最不危险的概念开始，然后向潜在最危险的概念前进。这使得人们能够适应线程化，并朝着更关键、更谨慎的代码编写前进。

# 并发

也许威胁最小的多线程形式是并发。并发通常意味着多个线程同时运行，但不共享任何资源。这意味着线程之间不共享数据结构、内存或其他内容。并发性通常用于可以在线程之间拆分并独立处理的任务。

为了说明这一点，让我们来看一个例子，每个线程都有一个指向一个整数的指针，线程递增这个整数，然后停止。每个线程开始运行，直到它将数字增加几百次。然后，这些线程，通常称为“工作线程”，被主线程加入。所有线程同时工作。

如果您是多线程新手，这段代码的一些部分可能没有意义。`join()`方法大概就是其中之一。关于启动新线程需要理解的一个重要细节是，它们的工作和功能完全独立于主线程，即从`main()`开始的线程。因为他们是完全分开的，所以我们必须决定一个点，在这个点上我们希望等待他们完成分配给他们的工作。

想想类似的情况，两个人可能会分开做他们各自的任务，然后再“结合”在一起。如果你和朋友一起旅行或去某个地方，你不想放弃他们！理想情况下，你应该等待他们再次赶上。线程也是同样的逻辑。任何时候创建额外的线程，都有义务指导你希望中央主线程如何按照它们来行动。

## 派遣

你总是要加入线程吗？不。事实上，还有一个选择。就像朋友的例子一样，一个朋友可能想走自己的路回家，而不是和你见面。对于线程来说，这叫做分离。分离一个线程意味着允许它独立于主线程工作并完成它的工作。但是，这可能是危险的。举下面的例子，非常类似于`join()`的例子。

这里的第一个风险是在被删除后使用堆分配。与`join()`不同，`detach()`不会让调用线程停止或等待任何东西。这意味着一旦对`detach()`的第三次调用结束，调用线程将删除`numbers`数组。如果创建的线程还没有完成它们的工作，它们将写入一个被删除的数组，这会破坏内存。

这里的第二个风险是，如果创建的线程的工作没有完成，即使在主线程完成之后，它们也可以继续运行。或者他们可能一结束就被杀死。根据 C++标准，这是未定义的行为。不管特定的编译器能保证什么，未定义的行为是应该避免的。`detach()`有一些有效的用例，但是它们都需要线程间某种其他形式的同步才是可靠的。

# 共享资源

![](img/865b9431210c673364fcaa43eea0887a.png)

阿瑟·埃德尔曼在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄的照片

两个不同的线程可以访问同一个内存地址的资源称为共享资源。请务必注意对*地址*的强调。在此处所示的前一个示例中，多个线程访问同一个数组，这不是共享资源，因为没有两个线程从同一个内存地址读取或写入。数组可能只是四个独立的整数指针，数组本身没有任何东西使它成为共享资源。

与并发性不同，当希望线程在相同的数据或对象上执行工作时，会使用共享资源。这意味着对象没有被分配到一个线程自己的堆栈上，只有一个对象对其他线程可见。让这一点变得难以理解的是，尽管两个线程都可以访问某些资源，但它们永远看不到其他线程访问该资源。

现实生活中共享资源的一个很好的例子是晚上的机场跑道。跑道上有闪烁的灯光，帮助引导飞机准备着陆时对准跑道。但是由于黑暗和飞行速度，其他飞机在晚上很难甚至不可能看到对方。如果一架飞机试图与另一架飞机同时降落在跑道上，那将是灾难性的。飞机避免这种碰撞的唯一方法是通过空中交通管制进行协调。

线程的工作方式是一样的，因为它们依赖同步机制来协调对资源的访问，比如不在完全相同的时间写入资源。我们将在这里讨论的机制，可能是最常见的一个，是互斥。类型为`std::mutex`的互斥锁允许线程获取*锁。*锁是一种控制形式，一次只允许一个线程处理一段代码。让我们看看这个例子。

在上面的例子中，当调用线程在与队列相关的互斥体上构造一个锁时，类的`push()`和`pop()`方法都会发生。这个锁最好用作 RAII 样式的对象，它只在某些代码范围内有效。一旦程序完成了这个作用域，锁保护对象就被销毁，允许另一个线程构造并获取互斥体上的锁。这种模式继续满足一次只有一个线程可以修改队列的条件。

# 互斥锁仍然有潜在的危险

即使它们听起来非常简洁和直接，互斥锁仍然是危险的。当一个线程获得一个互斥锁时，它负责释放或销毁这个锁，这样其他线程也可以访问代码的安全范围。如果一个线程没有释放它所获得的锁，会发生什么？很糟糕的事情。

一个*泄漏锁*是当一个线程锁定了一个互斥锁，但是由于某种原因这个锁永远不能被解锁。如果发生这种情况，所有的线程都将阻塞并无限期地等待互斥体，没有任何进展或做任何工作。

互斥体的经验法则是仔细地、批判性地思考线程在给互斥体加锁时会做什么。至关重要的是，线程只有在绝对需要单线程访问时才会锁定，并且在这样做的同时，尽可能快地工作。虽然互斥锁提供了一种安全访问同一资源的方法，但它们是以性能为代价的。

有没有其他方法来防止非法的，多线程之间的双重访问资源？是的。但这是另一篇文章的主题。