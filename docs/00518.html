<html>
<head>
<title>The prototype chain: how JavaScript really works</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">原型链:JavaScript如何真正工作</h1>
<blockquote>原文：<a href="https://medium.com/codex/the-prototype-chain-how-javascript-really-works-83db2013af3?source=collection_archive---------0-----------------------#2021-02-19">https://medium.com/codex/the-prototype-chain-how-javascript-really-works-83db2013af3?source=collection_archive---------0-----------------------#2021-02-19</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><h2 id="eef1" class="hg hh hi bd b fp hj hk hl hm hn ho dx hp translated" aria-label="kicker paragraph"><a class="ae ge" href="http://medium.com/codex" rel="noopener">法典</a></h2><div class=""/><figure class="ev ex ip iq ir is er es paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="er es io"><img src="../Images/714c7192a3dff33dcf8493c39549d996.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S2Z7lRjYrNEVVN0T1Sccew.jpeg"/></div></div></figure><p id="d36c" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">如果像我一样，您以前的编程经验是使用面向对象的语言，如Java或C#，JavaScript的基于原型的继承方法可能需要一分钟才能让您明白。</p><p id="4721" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">你可以过得很好，不需要太深入研究，甚至不需要考虑原型。然而，当我们将构造函数和类混合在一起时，事情开始变得更有趣了。</p><p id="2ade" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">所以，让我们在🤿潜水吧</p><h1 id="890c" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">什么是原型？</h1><p id="8162" class="pw-post-body-paragraph iz ja hi jb b jc kv je jf jg kw ji jj jk kx jm jn jo ky jq jr js kz ju jv jw hb bi translated">JavaScript中的每个对象都可以链接到原型对象，原型对象是提供继承的机制。</p><p id="4dce" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">您可以使用<code class="du la lb lc ld b">__proto__</code>属性查看对象指向的原型。</p><p id="4f79" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">附带说明:围绕使用<code class="du la lb lc ld b">__proto__</code>有一些争议，实际上它被弃用，而支持<code class="du la lb lc ld b">Object.getPrototypeOf()</code>。你可以在这里了解更多信息<a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/proto" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="1611" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">当在一个对象上调用一个属性或方法时，如果该对象不包含它，那么JavaScript引擎将查找该对象的原型来解析该属性或方法。</p><p id="f082" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">你可能以前见过术语<strong class="jb hs">原型链</strong>。这是对象本身的原型也可以包含原型等等的地方。</p><p id="9f2b" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">如果一个对象不包含属性或方法，JavaScript引擎将继续沿着原型链向上尝试并解决它。</p><h1 id="bee8" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">构造函数</h1><p id="da45" class="pw-post-body-paragraph iz ja hi jb b jc kv je jf jg kw ji jj jk kx jm jn jo ky jq jr js kz ju jv jw hb bi translated">你可能在JavaScript中看到过一些用<code class="du la lb lc ld b">new</code>关键字调用的函数，例如<code class="du la lb lc ld b">new Date()</code>——这些是<strong class="jb hs">构造函数。</strong>为了与本文的其余部分保持一致，下面是一个构造函数的样子以及它的用法:</p><pre class="lf lg lh li fd lj ld lk ll aw lm bi"><span id="b548" class="ln jy hi ld b fi lo lp l lq lr">function Swan(colour, mood) {<br/>    this.colour = colour;<br/>    this.mood = mood;<br/>}</span><span id="6517" class="ln jy hi ld b fi ls lp l lq lr">let swan = new Swan('white', 'angry');</span></pre><p id="87e8" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">上面的代码块使用构造函数<code class="du la lb lc ld b">Swan</code>创建了一个对象<code class="du la lb lc ld b">swan</code>，属性<code class="du la lb lc ld b">colour</code>和<code class="du la lb lc ld b">mood</code>分别设置为<code class="du la lb lc ld b">'white'</code>和<code class="du la lb lc ld b">'angry'</code>。注意构造函数大写的惯例。</p><p id="d69c" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">你可能已经注意到了<code class="du la lb lc ld b">this</code>关键字的用法，如果你花了很多时间在JavaScript或其他面向对象语言上，你可能已经见过它的用法了。不过要小心，与Java等面向对象语言相比，它在JavaScript中的表现可能不像你预期的那样。</p><h2 id="8e62" class="ln jy hi bd jz lt lu lv kd lw lx ly kh jk lz ma kl jo mb mc kp js md me kt ho bi translated">这</h2><p id="b205" class="pw-post-body-paragraph iz ja hi jb b jc kv je jf jg kw ji jj jk kx jm jn jo ky jq jr js kz ju jv jw hb bi translated">我们不会对<code class="du la lb lc ld b">this</code>进行过多的描述，因为它是JavaScript中与绑定相关的最令人困惑的领域之一，很容易就有一篇专门的文章(如果您觉得这有帮助，请告诉我！).</p><p id="6e16" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">长话短说，<code class="du la lb lc ld b">this</code>的值可以根据函数被调用的位置而变化。</p><p id="3bb0" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">当在如上例的构造函数的上下文中使用时，JavaScript引擎创建一个内部的<code class="du la lb lc ld b">this</code>上下文，该上下文被绑定到使用构造函数创建的新对象上——在我们的例子中是<code class="du la lb lc ld b">swan</code>。</p><h1 id="b3ea" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">使用原型链的继承</h1><blockquote class="mf"><p id="184c" class="mg mh hi bd mi mj mk ml mm mn mo jw dx translated">在JavaScript中，所有函数都有一个原型属性，所有对象都有一个指向其构造函数原型的<code class="du la lb lc ld b">__proto__</code>属性。</p></blockquote><p id="cb57" class="pw-post-body-paragraph iz ja hi jb b jc mp je jf jg mq ji jj jk mr jm jn jo ms jq jr js mt ju jv jw hb bi translated">可以认为<code class="du la lb lc ld b">__proto__</code>属性指向创建它的函数的原型。</p><p id="937f" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">记住，我们也可以使用<code class="du la lb lc ld b">Object.getPrototypeOf(yourObject)</code>获得对象的原型，这样做是更好的做法。</p><p id="7dd0" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">让我们更深入地研究一下前面的例子:</p><pre class="lf lg lh li fd lj ld lk ll aw lm bi"><span id="f8cc" class="ln jy hi ld b fi lo lp l lq lr">function Swan(colour, mood) {<br/>    this.colour = colour;<br/>    this.mood = mood;<br/>}</span><span id="3894" class="ln jy hi ld b fi ls lp l lq lr">let swan = new Swan('white', 'angry')</span><span id="b9f4" class="ln jy hi ld b fi ls lp l lq lr">Swan.prototype.isSassy = () =&gt; true;</span></pre><p id="01b0" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">Swan有一个原型属性，我们也添加了<code class="du la lb lc ld b">isSassy()</code>函数。</p><p id="ddb3" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">当我们使用<code class="du la lb lc ld b">Swan</code>构造函数创建<code class="du la lb lc ld b">swan</code>对象时，这意味着<code class="du la lb lc ld b">swan</code>对象的<code class="du la lb lc ld b">__proto__</code>属性将指向<code class="du la lb lc ld b">Swan</code>的原型。</p><p id="d393" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">试一试。可以复制粘贴上面的代码片段，使用<code class="du la lb lc ld b">swan.__proto__</code>查看<code class="du la lb lc ld b">swan</code>的原型。这将返回:</p><pre class="lf lg lh li fd lj ld lk ll aw lm bi"><span id="ea96" class="ln jy hi ld b fi lo lp l lq lr">&gt; swan.__proto__<br/>{isSassy: ƒ, constructor: ƒ}<br/>    isSassy: () =&gt; true<br/>    constructor: ƒ Swan(colour, mood)<br/>    __proto__: Object</span></pre><p id="7941" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated"><code class="du la lb lc ld b">swan.__proto__</code>的<code class="du la lb lc ld b">constructor</code>告诉我们它是使用<code class="du la lb lc ld b">Swan</code>函数构建的，我们还可以看到<code class="du la lb lc ld b">isSassy()</code>函数在原型上<code class="du la lb lc ld b">swan.__proto__</code>如预期链接。</p><p id="6a6d" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">用构造函数创建的对象的一个有用的特性是它允许我们检查它的类型:</p><pre class="lf lg lh li fd lj ld lk ll aw lm bi"><span id="a294" class="ln jy hi ld b fi lo lp l lq lr">swan instanceof Swan //returns true</span></pre><p id="6f6a" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated"><a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/instanceof" rel="noopener ugc nofollow" target="_blank"> MDN </a>将<code class="du la lb lc ld b">instanceof</code>运算符定义如下:</p><blockquote class="mu mv mw"><p id="4791" class="iz ja mx jb b jc jd je jf jg jh ji jj my jl jm jn mz jp jq jr na jt ju jv jw hb bi translated"><code class="du la lb lc ld b"><strong class="jb hs">instanceof</strong></code> <strong class="jb hs">操作符</strong>测试一个构造函数的<code class="du la lb lc ld b">prototype</code>属性是否出现在一个对象的原型链中。返回值是一个布尔值。</p></blockquote><p id="ab40" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">将此应用于我们的示例:</p><p id="96e8" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated"><code class="du la lb lc ld b">Swan</code>构造函数有如下原型:</p><pre class="lf lg lh li fd lj ld lk ll aw lm bi"><span id="8279" class="ln jy hi ld b fi lo lp l lq lr">Swan(colour, mood) {<br/>    this.colour = colour;<br/>    this.mood = mood;<br/>}</span></pre><p id="3e99" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">并且<code class="du la lb lc ld b">swan.__proto__</code>具有下面的构造函数属性，就像我们之前演示的那样:</p><pre class="lf lg lh li fd lj ld lk ll aw lm bi"><span id="6119" class="ln jy hi ld b fi lo lp l lq lr">Swan(colour, mood) {<br/>    this.colour = colour;<br/>    this.mood = mood;<br/>}</span></pre><p id="55e7" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">因此，当<code class="du la lb lc ld b">Swan</code>原型出现在<code class="du la lb lc ld b">swan</code>的原型链中时，返回布尔值<code class="du la lb lc ld b">true</code>。</p><p id="5fc8" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">需要注意的一件重要事情是，检查了整个原型链。如果你有更复杂的原型链，请记住这一点，同时，在默认情况下，所有新对象<code class="du la lb lc ld b">__proto__</code>属性都指向它们的原型链中的<code class="du la lb lc ld b">Object.prototype</code>，因此检查<code class="du la lb lc ld b">&lt;arbitraryObject&gt; instanceof Object</code>是否总是返回true。</p><h1 id="538a" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">JavaScript中的类并不像你想象的那样</h1><p id="d1d2" class="pw-post-body-paragraph iz ja hi jb b jc kv je jf jg kw ji jj jk kx jm jn jo ky jq jr js kz ju jv jw hb bi translated">现在我们已经讨论了原型和构造函数的基本原理，在这篇文章中我还想谈一件事。</p><p id="c461" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">当我刚从大学毕业，开始专业地使用JavaScript时，我花了很多时间在广泛使用的面向对象语言上(对我来说主要是Java)，看到JavaScript中的类并开始将它们联系起来是非常容易的。</p><p id="ad03" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">在面向对象的语言中，如Java，类通常作为一个蓝图，并且——排除任何静态行为——每当一个新的对象被实例化时，它被实例化为它自己的副本，并在内存中占据它自己的空间。</p><p id="81bf" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">然而在JavaScript中，类只是语法上的糖，实际上仍然是一个函数。当一个类被“实例化”时，新的对象实际上有一个指向类方法的原型(实际上是原型上的属性！)并且包含引用它的构造函数——听起来熟悉吗？</p><p id="f76f" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">为了证明我的观点，请看以下内容:</p><pre class="lf lg lh li fd lj ld lk ll aw lm bi"><span id="cbf1" class="ln jy hi ld b fi lo lp l lq lr">class RubberDuckClass {<br/>    constructor(colour) {<br/>        this.colour = colour<br/>    }<br/>    doesFloat() {<br/>        return true;<br/>    }<br/>}</span><span id="974e" class="ln jy hi ld b fi ls lp l lq lr">function RubberDuckConstructor(colour) {<br/>    this.colour = colour;<br/>}</span><span id="e60c" class="ln jy hi ld b fi ls lp l lq lr">RubberDuckConstructor.prototype.doesFloat = () =&gt; true;</span><span id="5531" class="ln jy hi ld b fi ls lp l lq lr">let rubberDuckClassObject = new RubberDuckClass('yellow');<br/>let RubberDuckConstructorObject = new RubberDuckConstructor('blue');</span></pre><p id="5b04" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">在这个例子中，我们实际上可以证明，一个类实际上只不过是一个穿着花哨衣服的函数</p><p id="a3d7" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">rubberDuckClassObject:</p><ul class=""><li id="53bb" class="nb nc hi jb b jc jd jg jh jk nd jo ne js nf jw ng nh ni nj bi translated">将<code class="du la lb lc ld b">colour</code>属性设置为参数(' yellow ')</li><li id="d1cf" class="nb nc hi jb b jc nk jg nl jk nm jo nn js no jw ng nh ni nj bi translated">原型:<br/> -构造函数引用<code class="du la lb lc ld b">RubberDuckClass</code> <br/> -具有<code class="du la lb lc ld b">doesFloat()</code>功能</li></ul><p id="ffbb" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">rubberDuckConstructorObject:</p><ul class=""><li id="a0d9" class="nb nc hi jb b jc jd jg jh jk nd jo ne js nf jw ng nh ni nj bi translated">将<code class="du la lb lc ld b">colour</code>属性设置为参数(“蓝色”)</li><li id="6183" class="nb nc hi jb b jc nk jg nl jk nm jo nn js no jw ng nh ni nj bi translated">原型:<br/> -构造函数引用<code class="du la lb lc ld b">RubberDuckConstructor</code> <br/> -具有<code class="du la lb lc ld b">doesFloat()</code>功能</li></ul><p id="2630" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">虽然从表面上看，JavaScript类看起来就像我们在传统的基于类的设计模式中所期望的那样；在本质上，类仍然只不过是具有原型机制提供的继承能力的函数。</p><p id="0b9b" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">在我看来，这就是为什么JavaScript中的类会让人误解。最终有一天，作为一名开发人员，你将需要更深入地研究这种语言，到那时，当你发现类可能与你想象的不一样时，你会大吃一惊。</p></div></div>    
</body>
</html>