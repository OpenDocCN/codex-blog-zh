<html>
<head>
<title>5 Hardest Python Questions! Part — 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">5个最难的Python问题！第二部分</h1>
<blockquote>原文：<a href="https://medium.com/codex/5-hardest-python-questions-part-2-ishaangupta1201-836b6d5e4e89?source=collection_archive---------0-----------------------#2022-08-01">https://medium.com/codex/5-hardest-python-questions-part-2-ishaangupta1201-836b6d5e4e89?source=collection_archive---------0-----------------------#2022-08-01</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="a45c" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">用这些问题迷惑你的pythoneer朋友</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ix"><img src="../Images/d7f3cfb745481dec82abeabaeef13276.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*QWSvJ94k3MIsQzsy1Bxspw.jpeg"/></div><figcaption class="jf jg et er es jh ji bd b be z dx translated">Andrea Piacquadio 摄于Pexels</figcaption></figure><h1 id="8b58" class="jk jl hi bd jm jn jo jp jq jr js jt ju io jv ip jw ir jx is jy iu jz iv ka kb bi translated">这个故事第一部分的链接—</h1><div class="kc kd ez fb ke kf"><a rel="noopener follow" target="_blank" href="/codex/5-hardest-python-questions-497a6df140d3"><div class="kg ab dw"><div class="kh ab ki cl cj kj"><h2 class="bd hj fi z dy kk ea eb kl ed ef hh bi translated">5个最难的Python问题！</h2><div class="km l"><h3 class="bd b fi z dy kk ea eb kl ed ef dx translated">用这些问题迷惑你的pythoneer朋友</h3></div><div class="kn l"><p class="bd b fp z dy kk ea eb kl ed ef dx translated">medium.com</p></div></div><div class="ko l"><div class="kp l kq kr ks ko kt jd kf"/></div></div></a></div><h1 id="4071" class="jk jl hi bd jm jn jo jp jq jr js jt ju io jv ip jw ir jx is jy iu jz iv ka kb bi translated">1.)Python里一切都是对象！🤨</h1><p id="a48a" class="pw-post-body-paragraph ku kv hi kw b kx ky ij kz la lb im lc ld le lf lg lh li lj lk ll lm ln lo lp hb bi translated">猜测产量？</p><pre class="iy iz ja jb fd lq lr ls lt aw lu bi"><span id="e8ff" class="lv jl hi lr b fi lw lx l ly lz">print(isinstance(object, type))<br/>print(isinstance(type, object))<br/>print(isinstance(type, type))<br/>print(isinstance(object, object))</span></pre><p id="229c" class="pw-post-body-paragraph ku kv hi kw b kx ma ij kz la mb im lc ld mc lf lg lh md lj lk ll me ln lo lp hb bi translated"><strong class="kw hj">回答:真，真，真，真</strong></p><p id="a331" class="pw-post-body-paragraph ku kv hi kw b kx ma ij kz la mb im lc ld mc lf lg lh md lj lk ll me ln lo lp hb bi translated">这是因为在python中一切都是对象。所有类型如<em class="mf"> int、str和object </em>都是一个<em class="mf">类型</em>类的实例，它是一个对象，因为<strong class="kw hj"> <em class="mf">在python中一切都是对象。</em>T11】</strong></p><h1 id="c2bf" class="jk jl hi bd jm jn jo jp jq jr js jt ju io jv ip jw ir jx is jy iu jz iv ka kb bi translated">2.)sum()函数😨</h1><p id="33cb" class="pw-post-body-paragraph ku kv hi kw b kx ky ij kz la lb im lc ld le lf lg lh li lj lk ll lm ln lo lp hb bi translated">猜猜这种情况下的输出？</p><pre class="iy iz ja jb fd lq lr ls lt aw lu bi"><span id="66dd" class="lv jl hi lr b fi lw lx l ly lz">print(sum(“”))<br/>print(sum(“”, []))<br/>print(sum(“”, {}))</span></pre><p id="9338" class="pw-post-body-paragraph ku kv hi kw b kx ma ij kz la mb im lc ld mc lf lg lh md lj lk ll me ln lo lp hb bi translated"><strong class="kw hj">答案:0，[]，{} </strong></p><p id="21c6" class="pw-post-body-paragraph ku kv hi kw b kx ma ij kz la mb im lc ld mc lf lg lh md lj lk ll me ln lo lp hb bi translated">为了理解这一点，让我们看看sum()是如何工作的-</p><p id="26a3" class="pw-post-body-paragraph ku kv hi kw b kx ma ij kz la mb im lc ld mc lf lg lh md lj lk ll me ln lo lp hb bi translated"><strong class="kw hj"> <em class="mf"> sum(iterable，/，start=0) </em> </strong></p><p id="be44" class="pw-post-body-paragraph ku kv hi kw b kx ma ij kz la mb im lc ld mc lf lg lh md lj lk ll me ln lo lp hb bi translated">从左到右对start和iterable的项求和，并返回总和。iterable的项通常是数字，起始值不允许是字符串。因此，在上述所有情况下，“”被视为空序列，因此<em class="mf"> sum </em>将简单地返回<em class="mf"> start </em>参数作为总结果。</p><h1 id="4560" class="jk jl hi bd jm jn jo jp jq jr js jt ju io jv ip jw ir jx is jy iu jz iv ka kb bi translated">3.)Python就是懒！😪</h1><p id="c76e" class="pw-post-body-paragraph ku kv hi kw b kx ky ij kz la lb im lc ld le lf lg lh li lj lk ll lm ln lo lp hb bi translated">猜猜这种情况下的输出？</p><pre class="iy iz ja jb fd lq lr ls lt aw lu bi"><span id="6232" class="lv jl hi lr b fi lw lx l ly lz">class follow:<br/>   def func(self):<br/>      return follow()</span><span id="fe5a" class="lv jl hi lr b fi mg lx l ly lz">a = follow()<br/>follow = int<br/>print(a.func())</span></pre><p id="f1c9" class="pw-post-body-paragraph ku kv hi kw b kx ma ij kz la mb im lc ld mc lf lg lh md lj lk ll me ln lo lp hb bi translated"><strong class="kw hj">答案:0 </strong></p><p id="e0fb" class="pw-post-body-paragraph ku kv hi kw b kx ma ij kz la mb im lc ld mc lf lg lh md lj lk ll me ln lo lp hb bi translated">这是因为python函数内部的代码只有在调用时才会执行。这意味着所有的<em class="mf"> NameErrors </em>都将被抛出，只有当我们真正调用这个方法时，变量才会被绑定。因此，在我们的例子中，在方法定义期间，Python允许我们引用尚未定义的类。但是，在执行过程中Python会从外部范围绑定名字<strong class="kw hj"> <em class="mf">跟随</em> </strong>，这意味着<em class="mf">函数</em>方法会返回一个新创建的<strong class="kw hj"> <em class="mf"> int </em> </strong>实例。</p><p id="4ae5" class="pw-post-body-paragraph ku kv hi kw b kx ma ij kz la mb im lc ld mc lf lg lh md lj lk ll me ln lo lp hb bi translated">有点困惑吧？😅</p><h1 id="b437" class="jk jl hi bd jm jn jo jp jq jr js jt ju io jv ip jw ir jx is jy iu jz iv ka kb bi translated">4.)AttributeErrors？😏</h1><p id="30a4" class="pw-post-body-paragraph ku kv hi kw b kx ky ij kz la lb im lc ld le lf lg lh li lj lk ll lm ln lo lp hb bi translated">猜猜这种情况下的输出？</p><pre class="iy iz ja jb fd lq lr ls lt aw lu bi"><span id="eb66" class="lv jl hi lr b fi lw lx l ly lz">print(sum([a.imag<br/>   for a in [<br/>      0, 5, 10e9, float(‘inf’), float(‘nan’)<br/>   ]<br/>]))</span></pre><p id="6dfd" class="pw-post-body-paragraph ku kv hi kw b kx ma ij kz la mb im lc ld mc lf lg lh md lj lk ll me ln lo lp hb bi translated"><strong class="kw hj">答案:0.0 </strong></p><p id="df31" class="pw-post-body-paragraph ku kv hi kw b kx ma ij kz la mb im lc ld mc lf lg lh md lj lk ll me ln lo lp hb bi translated">您一定认为这会产生错误，对吗？不会的。这是因为Python中所有的数值类型像<strong class="kw hj"> <em class="mf"> int，float </em> </strong>等。；都继承自一个基本的<em class="mf">对象</em>类，它们都返回实部和虚部，其中也包括<strong class="kw hj"><em class="mf"/></strong>和<strong class="kw hj"> <em class="mf"> NaN </em> </strong>。</p><h1 id="cb72" class="jk jl hi bd jm jn jo jp jq jr js jt ju io jv ip jw ir jx is jy iu jz iv ka kb bi translated">5.)数学又不行的地方！😵</h1><p id="bd52" class="pw-post-body-paragraph ku kv hi kw b kx ky ij kz la lb im lc ld le lf lg lh li lj lk ll lm ln lo lp hb bi translated">猜猜这种情况下的输出？</p><pre class="iy iz ja jb fd lq lr ls lt aw lu bi"><span id="aeec" class="lv jl hi lr b fi lw lx l ly lz">a=(1 &lt;&lt; 53)+1<br/>print(a+1.0 &gt; a)</span></pre><p id="1a77" class="pw-post-body-paragraph ku kv hi kw b kx ma ij kz la mb im lc ld mc lf lg lh md lj lk ll me ln lo lp hb bi translated"><strong class="kw hj">答案:假</strong></p><p id="524b" class="pw-post-body-paragraph ku kv hi kw b kx ma ij kz la mb im lc ld mc lf lg lh md lj lk ll me ln lo lp hb bi translated">这个解释会很长，所以请耐心听我说:)</p><p id="3ee3" class="pw-post-body-paragraph ku kv hi kw b kx ma ij kz la mb im lc ld mc lf lg lh md lj lk ll me ln lo lp hb bi mh translated">首先，由于<strong class="kw hj">任意精度运算</strong>(长运算)的反直觉行为。Python支持<em class="mf"> long </em>类型的非常大的整数，但是Python中浮点精度的限制是有限的。</p><p id="3dc3" class="pw-post-body-paragraph ku kv hi kw b kx ma ij kz la mb im lc ld mc lf lg lh md lj lk ll me ln lo lp hb bi translated">号码是2⁵ + 1 = 9007199254740993</p><p id="5b79" class="pw-post-body-paragraph ku kv hi kw b kx ma ij kz la mb im lc ld mc lf lg lh md lj lk ll me ln lo lp hb bi mh translated"><span class="l mi mj mk bm ml mm mn mo mp di">S</span>second是<strong class="kw hj"> float精度限制</strong>，这意味着它不能完全表示为Python float，因此，为了执行<em class="mf"> x + 1.0，</em> python将<em class="mf"> a </em>转换为<em class="mf"> float </em>，将其舍入为Python可以轻松表示的<em class="mf"> 9007199254740992.0 </em>，然后为其添加<em class="mf"> 1.0 </em>。但是由于相同的表示限制，它将其设置回<em class="mf"> 9007199254740992.0 </em>。</p><p id="0c21" class="pw-post-body-paragraph ku kv hi kw b kx ma ij kz la mb im lc ld mc lf lg lh md lj lk ll me ln lo lp hb bi mh translated"><span class="l mi mj mk bm ml mm mn mo mp di"> T </span> hird是由于<strong class="kw hj">比较规则</strong>。与其他语言不同的是，Python不会因为<em class="mf"> float </em> vs <em class="mf"> int </em>比较而抛出错误，也不会试图将两个操作数转换为相同的类型。相反，它们比较实际的数值。并且由于<em class="mf"> 9007199254740992.0 </em>低于<em class="mf"> 9007199254740993，</em>打印<strong class="kw hj">假</strong>。</p><p id="8d4f" class="pw-post-body-paragraph ku kv hi kw b kx ma ij kz la mb im lc ld mc lf lg lh md lj lk ll me ln lo lp hb bi translated"><em class="mf"> whewwww </em>！😵‍💫</p></div><div class="ab cl mq mr gp ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="hb hc hd he hf"><h1 id="19bb" class="jk jl hi bd jm jn mx jp jq jr my jt ju io mz ip jw ir na is jy iu nb iv ka kb bi translated">最后的想法</h1><p id="7d23" class="pw-post-body-paragraph ku kv hi kw b kx ky ij kz la lb im lc ld le lf lg lh li lj lk ll lm ln lo lp hb bi translated">那么这次你猜对了多少个输出呢？就在评论区！</p><p id="5dcc" class="pw-post-body-paragraph ku kv hi kw b kx ma ij kz la mb im lc ld mc lf lg lh md lj lk ll me ln lo lp hb bi translated">如果您还没有阅读本文的第1部分，那么如果您现在不喜欢python，请不要恨我😂。在python中还有很多类似的“陷阱”,但我认为这很棒，因为它将帮助您理解内部语言结构，并避免在您的项目中出现可能导致意外错误的用例。本文第一部分的链接已经在开始时分享了，去看看吧。与你的Pythoneer朋友分享这篇精彩的文章。😄</p><p id="6d53" class="pw-post-body-paragraph ku kv hi kw b kx ma ij kz la mb im lc ld mc lf lg lh md lj lk ll me ln lo lp hb bi translated"><em class="mf">在我的下一篇文章中再见… </em></p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es nc"><img src="../Images/0579775bdb5273df16d7bcb360bf144d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/1*zl3zTs_dg7IPKWMsicrSOg.gif"/></div></figure></div></div>    
</body>
</html>