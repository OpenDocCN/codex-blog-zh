<html>
<head>
<title>Creating a Self-regenerating Stamina Bar with a Cooldown System</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">创造一个带有冷却系统的自我再生耐力棒</h1>
<blockquote>原文：<a href="https://medium.com/codex/creating-a-self-regenerating-stamina-bar-with-a-cooldown-system-5ef67f4262a9?source=collection_archive---------11-----------------------#2021-05-24">https://medium.com/codex/creating-a-self-regenerating-stamina-bar-with-a-cooldown-system-5ef67f4262a9?source=collection_archive---------11-----------------------#2021-05-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/eb0359607e26c5befbaf27cb1cad2be9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*XxjhgOJjLrhaYp4fts-BCg.gif"/></div></div></figure><p id="d7d9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我之前写过一篇关于如何使用协程实现这一点的<a class="ae jo" href="https://levelup.gitconnected.com/how-to-create-a-self-regenerating-stamina-bar-in-unity-44ab156dbad9" rel="noopener ugc nofollow" target="_blank">文章</a>，这是另一种使用冷却系统的方法，这样玩家就不能滥用冲刺或推进功能。过程是类似的，滑块设置保持不变，如果你想知道我是如何得到这篇文章中的滑块的，请检查前一个。</p><h2 id="f3ac" class="jp jq hi bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj bi translated">目录:</h2><p id="3856" class="pw-post-body-paragraph iq ir hi is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hb bi translated"><a class="ae jo" href="#58f0" rel="noopener ugc nofollow">制作方法更新耐力条</a> <br/> <a class="ae jo" href="#1e21" rel="noopener ugc nofollow">使用按键调用方法</a> <br/> <a class="ae jo" href="#ec7f" rel="noopener ugc nofollow">再生耐力条</a> <br/> <a class="ae jo" href="#7bcb" rel="noopener ugc nofollow">添加冷却系统</a> <br/> ∘ <a class="ae jo" href="#4f8e" rel="noopener ugc nofollow">结果:</a></p></div><div class="ab cl kp kq gp kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="hb hc hd he hf"><h1 id="6aa2" class="kw jq hi bd jr kx ky kz jv la lb lc jz ld le lf kc lg lh li kf lj lk ll ki lm bi translated">制作一个更新耐力条的方法</h1><p id="e1a7" class="pw-post-body-paragraph iq ir hi is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hb bi translated">在这一节中，我们将创建一个方法来计算和更新滑块的变化。下面的例子展示了我为2D太空射手推力机构编写的代码，然而，同样的逻辑也适用于耐力棒。</p><ol class=""><li id="9663" class="ln lo hi is b it iu ix iy jb lp jf lq jj lr jn ls lt lu lv bi translated">首先，我们的代码中需要Unity UI库。</li></ol><figure class="lx ly lz ma fd ij er es paragraph-image"><div class="er es lw"><img src="../Images/87543a92e1a2900ad9dd191fc6dff349.png" data-original-src="https://miro.medium.com/v2/resize:fit:700/format:webp/0*VxCLgTe7dGxkuKi-.png"/></div></figure><p id="afe9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">2.现在我们可以访问UI了，我们可以为滑块创建一个引用。这将是一个SerializeField，以便我们可以在检查器中设置它。</p><figure class="lx ly lz ma fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mb"><img src="../Images/b701c9ab51f404b3c9ef41c84f8e51c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*jYhomP51DzDLFZg8.png"/></div></div></figure><figure class="lx ly lz ma fd ij er es paragraph-image"><div class="er es mc"><img src="../Images/11264c7150d1310db2b6239daeb3e34b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1396/0*sT6DNmF9hiy6u5KY.gif"/></div></figure><p id="18ff" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">3.在Start方法中获取Slider组件。</p><figure class="lx ly lz ma fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es md"><img src="../Images/05d270daf152962697f01b7f08a7312c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*_dKt6Q6UHonSer7w.png"/></div></div></figure><p id="f350" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">4.在试图在代码中使用组件之前，最好先检查它是否为空。</p><figure class="lx ly lz ma fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es md"><img src="../Images/778a0094518936a4aa5032961d6b24d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*eURUzgFEMmkxjjFt.png"/></div></div></figure><p id="e1d8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">5.为最大值创建一个全局<strong class="is hj">变量。该值应该与您在检查器中为滑块分配的最大值相匹配。它可以是int或float。</strong></p><blockquote class="me mf mg"><p id="454c" class="iq ir mh is b it iu iv iw ix iy iz ja mi jc jd je mj jg jh ji mk jk jl jm jn hb bi translated"><strong class="is hj">注意</strong>:如果您打算使用整数，请确保您在检查器中选择了“使用整数”。</p></blockquote><figure class="lx ly lz ma fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ml"><img src="../Images/8afd20753982a94d0b71c912359639e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DeSEPcDx7qrz46pDriNDCQ.png"/></div></div></figure><p id="f6f5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">6.创建一个计算和更新滑块/耐力条的方法。该方法将有一个数字参数来跟踪当前减少或增加的燃油。</p><figure class="lx ly lz ma fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mm"><img src="../Images/47744a9c36602ebdf0471489bf7aacb6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KL8pi1_PR66V_OgO4rPoWQ.png"/></div></div></figure><p id="3810" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">7.在这种方法中，我们需要确保总燃油量根据当前燃油变量增加或减少。这是通过使用<a class="ae jo" href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/addition-operator" rel="noopener ugc nofollow" target="_blank">速记符号+= </a>将当前燃料数加到总燃料数上来完成的</p><blockquote class="me mf mg"><p id="7ded" class="iq ir mh is b it iu iv iw ix iy iz ja mi jc jd je mj jg jh ji mk jk jl jm jn hb bi translated"><strong class="is hj">注意</strong>:程序知道数值是减少还是增加的方式是通过使用负数或正数。随着代码的深入，您将会看到这一点。</p></blockquote><figure class="lx ly lz ma fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mm"><img src="../Images/4c8120aa80f09c816b6e9a6936bb8018.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GNE_Pr-TpOWBOa0OAZ5hKQ.png"/></div></div></figure><p id="1ffd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">8.由于我们可以访问一个变量，该变量通过添加当前燃料来跟踪总燃料的更新，因此我们可以使用这个变量来检查是否有足够的燃料来继续写入或运行。如果没有，您可以将播放器的速度设置为默认值，在我的例子中是4。</p><blockquote class="me mf mg"><p id="0512" class="iq ir mh is b it iu iv iw ix iy iz ja mi jc jd je mj jg jh ji mk jk jl jm jn hb bi translated"><strong class="is hj">注意</strong>:这里的调试信息并不是必须的，但它有助于确保当滑块处于0时，if被注册。</p></blockquote><figure class="lx ly lz ma fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mm"><img src="../Images/7e0e7111f046c60e3377a3a14473621b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ct9eIdj4uv47CZu-ESan1Q.png"/></div></div></figure></div><div class="ab cl kp kq gp kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="hb hc hd he hf"><h1 id="1e21" class="kw jq hi bd jr kx ky kz jv la lb lc jz ld le lf kc lg lh li kf lj lk ll ki lm bi translated">使用按键来调用方法</h1><ol class=""><li id="6e6c" class="ln lo hi is b it kk ix kl jb mn jf mo jj mp jn ls lt lu lv bi translated">通过这种设置，只要在Update方法中按下一个键，就可以调用updateThrustGauge方法，并在参数中设置一个数字来确定滑块的增减量。</li></ol><figure class="lx ly lz ma fd ij er es paragraph-image"><div class="ab fe cl mq"><img src="../Images/b7f6957fb2da472f05f4bc925e91bfaa.png" data-original-src="https://miro.medium.com/v2/format:webp/1*Awvu3ats8Y8DqpELI_a8cA.png"/></div></figure><p id="66a3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这个例子中，我们使用<a class="ae jo" href="https://docs.unity3d.com/ScriptReference/Input.GetKeyDown.html" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj"> GetKey </strong> </a> <strong class="is hj">而不是</strong> <a class="ae jo" href="https://docs.unity3d.com/ScriptReference/Input.GetKeyDown.html" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj"> GetKeyDown </strong> </a>因为按键将逐帧为真，而GetKeyDown对于您按下它的那一帧为真。这意味着只要你按下那个键，在GetKey中运行的计算就会连续发生。我们需要这样做，以便滑块不断更新，而不是必须重复按键才能移动。</p><p id="0217" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我还将播放器速度设置为两倍(从4默认速度到8)。这是直接分配的，而不是通过算术来分配，因为我们不希望玩家变得越来越快，正如前面提到的，这就是响应GetKey的计算会发生的情况。</p><p id="a574" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">2.现在，我们需要将每次释放按键时播放器的速度标准化。为此，我们使用GetKeyUp，它以与GetKeyDown相同的方式注册该帧。</p><figure class="lx ly lz ma fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mr"><img src="../Images/c5b1eca448031e53fd239a5217cab91f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V7OyfysMc6LIsh51NWa6hA.png"/></div></div></figure></div><div class="ab cl kp kq gp kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="hb hc hd he hf"><h1 id="ec7f" class="kw jq hi bd jr kx ky kz jv la lb lc jz ld le lf kc lg lh li kf lj lk ll ki lm bi translated">再生耐力条</h1><p id="9a68" class="pw-post-body-paragraph iq ir hi is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hb bi translated">现在，我们需要在不使用的时候重新生成耐力条/滑块。我们不能使用GetKeyUp来这样做，因为它每次按键只会注册一次。相反，我们将把它放在更新中，并在玩家不冲刺的时候激活它。首先，我们需要多一点来做到这一点。</p><ol class=""><li id="593a" class="ln lo hi is b it iu ix iy jb lp jf lq jj lr jn ls lt lu lv bi translated">创建一个全局的bool变量来跟踪玩家什么时候推或者不推。这在默认情况下是错误的，因为我们的玩家不仅仅是在游戏开始时喷射或推进。</li></ol><figure class="lx ly lz ma fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ms"><img src="../Images/0279d7df70856e28bd841a410c32619c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j1cDZvtE-BFTAzIl37-HIw.png"/></div></div></figure><p id="049b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">2.创建两个方法将值设置为true和false。最好的做法是让方法来处理这个问题，而不是动态地改变变量的值。</p><figure class="lx ly lz ma fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ms"><img src="../Images/64117994ece6769c5d08e988daa93ecd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6__lUaRB6_pB5ih0NvcPiQ.png"/></div></div></figure><p id="1b35" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">3.现在我们需要一种再生的方法。或者，这可以松散地放在更新中，但我觉得放在方法中更有条理。每当停止推进被调用时，该方法将被激活。</p><p id="3ba1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">注意updateThrustGauge方法这次是如何递增的。</p><figure class="lx ly lz ma fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mt"><img src="../Images/5e9069b399cf3a49f2eca4cffdcef2f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g46WZBlezLGZUg_FkGszyg.png"/></div></div></figure><p id="784a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">4.每当按键时调用isThrusting方法。</p><figure class="lx ly lz ma fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mt"><img src="../Images/6105ff53963ca4a94ec7ec0416155a78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h-R8JEEsFEFybyd2s1Pm9Q.png"/></div></div></figure><p id="86a7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">5.每当释放键时调用StopThrusting方法。由于您正在跟踪每个，再生方法将相应地变为活动和非活动。将regenFule方法添加到GetKeyUp之外，这样无论何时thrusting为假，它都会不断地重新生成工具条。</p><figure class="lx ly lz ma fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mu"><img src="../Images/ad539b6a619771357ef8d071045d8c66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w_JjmQtb9JFanLDi71iLRg.png"/></div></div></figure></div><div class="ab cl kp kq gp kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="hb hc hd he hf"><h1 id="7bcb" class="kw jq hi bd jr kx ky kz jv la lb lc jz ld le lf kc lg lh li kf lj lk ll ki lm bi translated">添加冷却系统</h1><p id="c6ef" class="pw-post-body-paragraph iq ir hi is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hb bi translated">冷却系统实现起来既快又简单，你可以在这篇文章中了解更多。让我们来看看如何将它实现到这段代码中。</p><ol class=""><li id="fd1a" class="ln lo hi is b it iu ix iy jb lp jf lq jj lr jn ls lt lu lv bi translated">创建两个全局变量，一个是延迟，一个是你再次冲刺的时候。我使用SerializeField，这样我就可以在检查器中看到值是如何变化的，或者出于调试目的自己调整它。你可以调整这些数字，这取决于你希望球员被限制弹跳或冲刺多长时间。</li></ol><figure class="lx ly lz ma fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mu"><img src="../Images/cf64a203caf7f4d0ef2af2d7addeff98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xyW9617A9p_queLGGsMlOw.png"/></div></div></figure><p id="95ca" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">2.添加一个条件，通过比较当前运行时和our _canThrust变量来开始推进。</p><figure class="lx ly lz ma fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mv"><img src="../Images/6a34c1999e0e368d62ae836854e20758.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fngT6bESheaeAgi7sOFKWw.png"/></div></div></figure><p id="fdb8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">3.接下来，我们添加每当释放键时的延迟。我们不希望这个值无限增加，所以每当释放该键时，延迟就会增加。</p><figure class="lx ly lz ma fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mw"><img src="../Images/155dadde7a1eaa755d6f70da8d7908df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AomwBwxp37RhO0myvu4f7g.png"/></div></div></figure><h2 id="4f8e" class="jp jq hi bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj bi translated">结果是:</h2><figure class="lx ly lz ma fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mx"><img src="../Images/57eef10b8b559da2d9b88c498823f6e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*vmvCjoExZ5ZCxM_Y1BcD8g.gif"/></div></div></figure></div></div>    
</body>
</html>