<html>
<head>
<title>Chapter 4</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">第四章</h1>
<blockquote>原文：<a href="https://medium.com/codex/chapter-4-813fe3beba5c?source=collection_archive---------21-----------------------#2022-04-14">https://medium.com/codex/chapter-4-813fe3beba5c?source=collection_archive---------21-----------------------#2022-04-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="e4bb" class="pw-subtitle-paragraph ig hh hi bd b ih ii ij ik il im in io ip iq ir is it iu iv iw ix dx translated"><strong class="ak">方法使用实例变量</strong></h2></div><figure class="iz ja jb jc fd jd er es paragraph-image"><div class="er es iy"><img src="../Images/e8d1c1e140a1bcc3ca7f8da055bc589c.png" data-original-src="https://miro.medium.com/v2/resize:fit:904/0*ErnJn7KHz92RJWIN"/></div></figure><ul class=""><li id="9528" class="jg jh hi ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx bi translated">状态和行为，由实例变量和方法表示。</li><li id="6c62" class="jg jh hi ji b jj jy jl jz jn ka jp kb jr kc jt ju jv jw jx bi translated">方法使用实例变量值。</li><li id="67db" class="jg jh hi ji b jj jy jl jz jn ka jp kb jr kc jt ju jv jw jx bi translated">为了将值传递给方法，程序员使用参数和实参。参数是传递给方法的东西。</li><li id="d376" class="jg jh hi ji b jj jy jl jz jn ka jp kb jr kc jt ju jv jw jx bi translated">参数就像一个具有类型和名称的局部变量，可以在方法内部使用。</li></ul><figure class="iz ja jb jc fd jd er es paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="er es kd"><img src="../Images/df15771e8f934c1956dd398791de83ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*VhWbnpK3C7ekYNfS"/></div></div></figure><p id="47b1" class="pw-post-body-paragraph ki kj hi ji b jj jk ik kk jl jm in kl jn km kn ko jp kp kq kr jr ks kt ku jt hb bi translated">方法返回结果。如果有返回类型为void的方法，这意味着它们不返回任何东西。如果声明一个方法来返回一个类型，该类型必须由该方法返回；否则，将出现一条错误消息。</p><p id="90dd" class="pw-post-body-paragraph ki kj hi ji b jj jk ik kk jl jm in kl jn km kn ko jp kp kq kr jr ks kt ku jt hb bi translated">在方法中，您可以传递几个参数。您必须传递正确种类和顺序的参数，并且必须用逗号分隔它们。</p><figure class="iz ja jb jc fd jd er es paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="er es kv"><img src="../Images/17d02efb699d09d98d9b7c3cb89b15d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*v-SnJoc4uR33Zl01"/></div></div></figure><p id="7a91" class="pw-post-body-paragraph ki kj hi ji b jj jk ik kk jl jm in kl jn km kn ko jp kp kq kr jr ks kt ku jt hb bi translated">如果变量类型与参数类型匹配，就可以将变量传递给方法。</p><h2 id="ae89" class="kw kx hi bd ky kz la lb lc ld le lf lg jn lh li lj jp lk ll lm jr ln lo lp lq bi translated"><strong class="ak"> Java是传值的。</strong></h2><h2 id="7828" class="kw kx hi bd ky kz la lb lc ld le lf lg jn lh li lj jp lk ll lm jr ln lo lp lq bi translated"><strong class="ak">这意味着复制传递。</strong></h2><figure class="iz ja jb jc fd jd er es paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="er es lr"><img src="../Images/8cd41ffddbc2d5b3882aa5ad5d577f6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:724/0*Y-BXJG3bp3mkzc4L"/></div></div></figure><p id="6c32" class="pw-post-body-paragraph ki kj hi ji b jj jk ik kk jl jm in kl jn km kn ko jp kp kq kr jr ks kt ku jt hb bi translated">1.声明一个int变量，并给它赋值7。7的位进入一个名为x的变量。</p><figure class="iz ja jb jc fd jd er es paragraph-image"><div class="er es ls"><img src="../Images/b40dbd9e8f602b5d886a9f672ce65d0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:890/0*fSH7c813hnVzHtyy"/></div></figure><p id="3295" class="pw-post-body-paragraph ki kj hi ji b jj jk ik kk jl jm in kl jn km kn ko jp kp kq kr jr ks kt ku jt hb bi translated">2.用名为z的int参数声明一个方法。</p><figure class="iz ja jb jc fd jd er es paragraph-image"><div class="er es lt"><img src="../Images/d9c2438e2d4f47e7ee1685cb3a4b0f5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1318/0*mOHQAHx01OfF_qXO"/></div></figure><p id="5a45" class="pw-post-body-paragraph ki kj hi ji b jj jk ik kk jl jm in kl jn km kn ko jp kp kq kr jr ks kt ku jt hb bi translated">3.调用go方法，将变量x作为参数传递。x中的位被复制，副本到达z。</p><figure class="iz ja jb jc fd jd er es paragraph-image"><div class="er es lu"><img src="../Images/74dae10086b1aedebfb235b1c99d12e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1362/0*GBo3BCegcvQBASz9"/></div></figure><p id="3b41" class="pw-post-body-paragraph ki kj hi ji b jj jk ik kk jl jm in kl jn km kn ko jp kp kq kr jr ks kt ku jt hb bi translated">4.更改方法中z的值。x的值没有改变，传递给z的参数只是x的副本。该方法不能改变调用变量x中的位。</p><p id="05e5" class="pw-post-body-paragraph ki kj hi ji b jj jk ik kk jl jm in kl jn km kn ko jp kp kq kr jr ks kt ku jt hb bi translated">如果要返回几个值，请将返回类型声明为类型数组。</p><p id="2c6a" class="pw-post-body-paragraph ki kj hi ji b jj jk ik kk jl jm in kl jn km kn ko jp kp kq kr jr ks kt ku jt hb bi translated">隐式提升到该类型的内容可以被返回。当返回类型定义为int时，可以返回byte。因为byte比int小，所以有效。</p><h2 id="a0c1" class="kw kx hi bd ky kz la lb lc ld le lf lg jn lh li lj jp lk ll lm jr ln lo lp lq bi translated"><strong class="ak">吸气器和设置器</strong></h2><ul class=""><li id="3068" class="jg jh hi ji b jj lv jl lw jn lx jp ly jr lz jt ju jv jw jx bi translated">访问器和赋值器是getters和setters的术语。</li><li id="e6d5" class="jg jh hi ji b jj jy jl jz jn ka jp kb jr kc jt ju jv jw jx bi translated">getter用于返回getter应该得到的返回值。</li><li id="4a5b" class="jg jh hi ji b jj jy jl jz jn ka jp kb jr kc jt ju jv jw jx bi translated">如果实例变量没有setters，可以用点运算符访问它们。这种能力是有害的。可以使用Setters来避免这种情况。如果我们希望访问一个实例变量，我们使用它。然后，我们应该调用它们，而不是直接访问setters。</li></ul><h2 id="180b" class="kw kx hi bd ky kz la lb lc ld le lf lg jn lh li lj jp lk ll lm jr ln lo lp lq bi translated"><strong class="ak">封装</strong></h2><p id="941c" class="pw-post-body-paragraph ki kj hi ji b jj lv ik kk jl lw in kl jn ma kn ko jp mb kq kr jr mc kt ku jt hb bi translated">基本上，这意味着隐藏数据，这样我们就可以利用private这样的访问修饰符来隐藏数据。访问控制是通过将变量私有并提供公共的getters和setters来实现的。</p><p id="07bb" class="pw-post-body-paragraph ki kj hi ji b jj jk ik kk jl jm in kl jn km kn ko jp kp kq kr jr ks kt ku jt hb bi translated">封装在实例变量周围创建了一个屏障，迫使其他代码通过setter方法。这避免了对实例变量的直接访问。</p><figure class="iz ja jb jc fd jd er es paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="er es md"><img src="../Images/6057749f9c02905c8505460e4f5a5785.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*IU4PiidLU2SBwyR2"/></div></div></figure><ul class=""><li id="53fe" class="jg jh hi ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx bi translated">将实例变量标记为私有。</li><li id="b12f" class="jg jh hi ji b jj jy jl jz jn ka jp kb jr kc jt ju jv jw jx bi translated">将getters和setters标记为public。</li><li id="c504" class="jg jh hi ji b jj jy jl jz jn ka jp kb jr kc jt ju jv jw jx bi translated">如果你不初始化(赋值)一个实例变量并为它们调用getter方法，它将返回null，因为它们总是有一个默认值。</li></ul><h2 id="85a7" class="kw kx hi bd ky kz la lb lc ld le lf lg jn lh li lj jp lk ll lm jr ln lo lp lq bi translated"><strong class="ak">实例变量和局部变量的区别</strong></h2><p id="d795" class="pw-post-body-paragraph ki kj hi ji b jj lv ik kk jl lw in kl jn ma kn ko jp mb kq kr jr mc kt ku jt hb bi translated">1.在类中而不是在方法中声明的实例变量。</p><p id="d656" class="pw-post-body-paragraph ki kj hi ji b jj jk ik kk jl jm in kl jn km kn ko jp kp kq kr jr ks kt ku jt hb bi translated">2.方法中声明的局部变量。</p><p id="cb02" class="pw-post-body-paragraph ki kj hi ji b jj jk ik kk jl jm in kl jn km kn ko jp kp kq kr jr ks kt ku jt hb bi translated">3.局部变量必须在使用前初始化。这些没有默认值。如果你在初始化之前调用它们，那么它将抛出错误。</p><p id="77ab" class="pw-post-body-paragraph ki kj hi ji b jj jk ik kk jl jm in kl jn km kn ko jp kp kq kr jr ks kt ku jt hb bi translated">如果要比较两个原语的相等性，可以用==。这将检查这两个引用是否指向同一个对象。</p><p id="1414" class="pw-post-body-paragraph ki kj hi ji b jj jk ik kk jl jm in kl jn km kn ko jp kp kq kr jr ks kt ku jt hb bi translated">如果我们想检查两个对象是否相等，那么我们可以使用equals()方法。</p></div></div>    
</body>
</html>