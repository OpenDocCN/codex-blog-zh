<html>
<head>
<title>Building a JavaScript Table Web Scraper Using Python without Headless Browsers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在没有无头浏览器的情况下使用Python构建一个JavaScript Table Web Scraper</h1>
<blockquote>原文：<a href="https://medium.com/codex/building-a-javascript-table-web-scraper-using-python-without-headless-browsers-cafb8f94a4d?source=collection_archive---------11-----------------------#2022-08-18">https://medium.com/codex/building-a-javascript-table-web-scraper-using-python-without-headless-browsers-cafb8f94a4d?source=collection_archive---------11-----------------------#2022-08-18</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/50e02c37b6b79d20809da7b63eb02fbd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*W04Nq38MafB3dY9c.jpg"/></div></div></figure><p id="e2b4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Web表格是web上一些最大的数据源。它们已经有了易于阅读和理解的格式，并用于显示大量有用的信息，如员工数据、统计数据、原始研究模型等。</p><p id="7139" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">也就是说，并不是所有的桌子都是一样的，有些用传统技术刮起来会很棘手。</p><p id="6f86" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在本教程中，我们将了解HTML和JavaScript表格之间的区别，为什么后者更难抓取，我们将创建一个脚本来规避呈现表格的挑战，而不使用任何高度复杂的技术。</p><h1 id="804d" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">什么是JavaScript表？</h1><p id="89e4" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">JavaScript表也称为动态表或AJAX表，是一组行和列，用于直接在网页上以网格格式显示动态数据。</p><p id="0d4b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">与HTML表不同，JS表中的数据在呈现阶段后被注入到页面中，从而可以根据需要自动生成尽可能多的行和列来容纳数据，根据需要自动填充内容，并对数据使用任何JavaScript函数来排序、排名或更改表本身。</p><h1 id="b916" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">Web抓取中HTML表与JavaScript表的比较</h1><p id="1e9f" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">在前端，HTML表和JavaScript表看起来一样，都以网格格式显示数据。然而，HTML表，顾名思义，是直接在HTML文件上构建的表，而动态web表是由浏览器呈现的——在大多数情况下——通过获取包含信息的JSON文件并遵循JavaScript上编写的指令将数据注入HTML。</p><p id="dc35" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但这对我们意味着什么呢？只需请求网站的HTML文件，然后使用CSS类和id解析它以获得我们想要的信息，就可以访问HTML表。</p><p id="381d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于JavaScript表，这种方法没有用，因为我们需要的数据不在HTML文件中。最多，我们将最终抓取大量的空HTML元素。</p><p id="725a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">相反，我们的第一个选择是使用一个无头浏览器，比如Selenium，来访问和呈现网站。一旦数据被注入到浏览器中，我们现在就可以使用XPath和CSS选择器来访问它。</p><p id="e0ec" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">尽管Selenium是自动化任何类型的浏览器任务(甚至是web抓取)的一个很好的工具，但是有一个更简单的选项不需要这样一个过分的解决方案:</p><h1 id="0ceb" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">用请求抓取Python中的动态表</h1><p id="6a5f" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">是的，我们刚刚说过不能通过请求HTML文件来访问JavaScript表，但这不是我们要做的。</p><p id="fb1a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果你仔细阅读过，你就会知道动态表需要从某个地方提取数据，所以如果我们可以模仿浏览器在呈现页面时发送的请求，我们就可以访问完全相同的数据，而不需要无头浏览器。</p><p id="4052" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于本教程，我们将使用Python的<a class="ae kr" href="https://www.scraperapi.com/blog/web-scraping-python/" rel="noopener ugc nofollow" target="_blank">请求库</a>抓取<a class="ae kr" href="https://datatables.net/examples/data_sources/ajax.html" rel="noopener ugc nofollow" target="_blank">https://datatables.net/examples/data_sources/ajax.html</a>来提取网站上显示的所有员工数据。</p><figure class="kt ku kv kw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ks"><img src="../Images/3081b0cb147db77654a0683cff19decf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*hbG03zVLajlDmfQ8.png"/></div></div></figure><p id="268a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">注:</strong>如果这是你第一次用Python做网页抓取，我们推荐你看一下我们的<a class="ae kr" href="https://www.scraperapi.com/blog/web-scraping-python/" rel="noopener ugc nofollow" target="_blank">Python网页抓取初学者教程</a>。您将学习收集几乎所有您能找到的HTML数据所需的所有基础知识。</p><h1 id="bfb2" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">1.寻找隐藏的API来访问JSON数据</h1><p id="8e24" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">我们已经知道这个页面上的表格是动态生成的。但是，如果我们想要测试它，我们可以首先查看页面的源代码，并从表中查找一些数据。</p><figure class="kt ku kv kw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ks"><img src="../Images/7628f33b37953c6315775c4bcddf7c98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*9OnRTpSPF_STPQL1.jpg"/></div></div></figure><p id="5da1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们复制了第一个名字，然后按CTRL + F来查找元素，但什么也没有。该名称在页面的未呈现版本中不存在。这清楚地表明我们正在处理一个JavaScript生成的表。</p><p id="0a7a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在清楚了，让我们打开Chrome的DevTools，进入网络选项卡&gt;获取/XHR。</p><figure class="kt ku kv kw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ks"><img src="../Images/5ae6ec871cc49eea9ee7b40ebdeda47c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*gkvlf1tsqbnlPXRn.png"/></div></div></figure><p id="a667" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这个报告中，我们将能够看到浏览器发送的每个获取请求。要填充它，我们只需要用open选项卡重新加载页面。</p><figure class="kt ku kv kw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ks"><img src="../Images/dec0232187bf9b79f83305d1547688d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*weEXeoTLyDg_5ir5.png"/></div></div></figure><p id="f5a6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">注意:</strong>在这个场景中，只有一个文件被获取。在大多数情况下，你的目标网站会发送更多的请求，这使得找到正确的请求变得更加困难。根据经验，您可以使用文件大小作为参考。文件越大，它返回的数据就越多，这很好地表明它包含了我们想要收集的信息。</p><p id="2992" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在我们已经找到了我们的目标，我们将单击它并转到Response选项卡来查看这个请求中有什么。</p><figure class="kt ku kv kw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ks"><img src="../Images/96a073b04cc874d19851ac3c8e970fce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*bC4Z3ThNhfE-ChrV.png"/></div></div></figure><p id="123a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">太棒了，没有JSON格式的数据可供使用！要从我们的脚本中访问这个文件，我们需要单击Headers选项卡来获取请求的URL，并将我们的HTTP请求发送到所述URL。</p><figure class="kt ku kv kw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ks"><img src="../Images/33e230e939d387232a9e7c8dce8ab6f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*JB9coIaO81N6BpXs.png"/></div></div></figure><h1 id="3691" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">2.发送我们的初始HTTP请求</h1><p id="d98e" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">向我们的目标URL发送请求非常简单，只需将URL存储到一个变量中，然后使用requests.get(url)方法下载文件——这对于这个示例页面来说就足够了。</p><p id="9d96" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然而，当处理更复杂的网站时，你需要<a class="ae kr" href="https://www.scraperapi.com/blog/headers-and-cookies-for-web-scraping/" rel="noopener ugc nofollow" target="_blank">添加适当的请求头</a>以避免被禁止或屏蔽。例如，许多网站使用<a class="ae kr" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies" rel="noopener ugc nofollow" target="_blank"> Cookies </a>来验证向数据源文件发送请求的是人类用户而不是脚本。</p><p id="6e31" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">好消息是，我们已经在open Headers选项卡中获得了我们需要的所有信息。</p><figure class="kt ku kv kw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ks"><img src="../Images/d549a99e7c08a1f7c2077dd8734f4b75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*NglteuE6xmKOxwjl.png"/></div></div></figure><p id="6394" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">从这里开始，我们将只选取三个最重要的标题:</p><ul class=""><li id="154d" class="kx ky hi is b it iu ix iy jb kz jf la jj lb jn lc ld le lf bi translated">用户代理</li><li id="54a2" class="kx ky hi is b it lg ix lh jb li jf lj jj lk jn lc ld le lf bi translated">甜饼干</li><li id="8972" class="kx ky hi is b it lg ix lh jb li jf lj jj lk jn lc ld le lf bi translated">接受</li></ul><figure class="kt ku kv kw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ks"><img src="../Images/d977be0a4d32e7fd4851a8e63e1a94cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*zTjXu4NnqihlIWQ9.png"/></div></div></figure><p id="fb6e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们把所有这些都翻译成Python:</p><figure class="kt ku kv kw fd ij"><div class="bz dy l di"><div class="ll lm l"/></div></figure><p id="b993" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后我们可以打印(页面)进行测试，它应该返回一个响应200 —除此之外，请求失败。</p><h1 id="7d72" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">3.读取和抓取JSON数据</h1><p id="f81d" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">与解析后的HTML文件中的元素不同，我们的JSON数据由<a class="ae kr" href="https://www.microfocus.com/documentation/silk-performer/195/en/silkperformer-195-webhelp-en/GUID-6AFC32B4-6D73-4FBA-AD36-E42261E2D77E.html" rel="noopener ugc nofollow" target="_blank"> JSON对象</a>——每个对象都在花括号{}之间——和对象内的键值对或属性组成——尽管它们也可以是空的。</p><figure class="kt ku kv kw fd ij er es paragraph-image"><div class="er es ln"><img src="../Images/ad4dbd7e713250653e14e4815fe4cc33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1124/format:webp/0*VMLAKpwvSO4zICv9.png"/></div></figure><p id="4344" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这个例子中，我们的JSON对象是数据，而每组属性被称为一个<a class="ae kr" href="https://www.microfocus.com/documentation/silk-performer/195/en/silkperformer-195-webhelp-en/GUID-0847DE13-2A2F-44F2-A6E7-214CD703BF84.html" rel="noopener ugc nofollow" target="_blank"> JSON数组</a>。从这个意义上说，如果我们的web scraper选择JSON对象，它将返回一个JSON数组列表，而每个数组都有自己的属性列表。</p><p id="76f9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了询问我们的JSON文件，我们将使用Python的内置<a class="ae kr" href="https://www.geeksforgeeks.org/response-json-python-requests/#:~:text=json()%20returns%20a%20JSON,it%20returns%20a%20response%20object." rel="noopener ugc nofollow" target="_blank">。json() </a>方法在一个名为data的变量内返回我们的json对象。</p><figure class="kt ku kv kw fd ij"><div class="bz dy l di"><div class="ll lm l"/></div></figure><p id="1d98" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当打印我们的新变量时，它将返回1，因为只有一个对象被取用。</p><figure class="kt ku kv kw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ks"><img src="../Images/559c268c75b84a9cb70ccf70010bb705.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*pVQxGOy_X9LP8FC2.png"/></div></div></figure><p id="c31b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们可以使用几种不同的方法来提取JSON对象内部的信息。尽管如此，我们还是希望以一种易于将数据导出到CSV文件的方式来完成。</p><p id="4d7c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">首先，我们将每个JSON数组视为列表中的一个项，使用它们在索引中的位置来访问它们的内部属性——从零开始。</p><p id="8f5a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">注意:</strong>这个逻辑可以选择没有命名的特定键(就像本例中一样)或具有相同名称但不同值的JSON对象。</p><p id="8d49" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里有一个直观的例子来说明我们的意思:</p><figure class="kt ku kv kw fd ij"><div class="bz dy l di"><div class="ll lm l"/></div></figure><p id="d2c1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在<code class="du lo lp lq lr b">first_array</code>中，我们要求存储在数据中的JSON文件返回JSON对象内索引中的第一个数组。这是它返回的内容:</p><figure class="kt ku kv kw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ks"><img src="../Images/7ef75563036e8b97f0705ecaff063c9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*9ioy0s-_pT_eP4_4.png"/></div></div></figure><p id="9d97" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们还可以测试是否从JSON文件中获取了所有元素，如下所示:</p><figure class="kt ku kv kw fd ij"><div class="bz dy l di"><div class="ll lm l"/></div></figure><figure class="kt ku kv kw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ks"><img src="../Images/c4d2e6eb653b2727d15dd0afa6cf9951.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*JtTSK-nCiN4qfAPp.png"/></div></div></figure><p id="fd60" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">它返回我们想要抓取的行的正确长度:</p><figure class="kt ku kv kw fd ij er es paragraph-image"><div class="er es ls"><img src="../Images/ec7c85529f214418c785ead5e50fb6f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:928/format:webp/0*Bj2kXC2ZJkfgF927.png"/></div></figure><p id="40ae" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了提取数组内部的属性，我们可以遍历每个JSON数组，并根据元素在索引中的位置提取元素，如下所示:</p><figure class="kt ku kv kw fd ij"><div class="bz dy l di"><div class="ll lm l"/></div></figure><p id="88ce" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您可以随意命名每个属性，但为了清晰起见，我们建议您遵循原始表格中的相同约定。</p><h1 id="ce1b" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">4.将我们的数据导出到CSV文件</h1><p id="aeb6" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">因为我们的数据已经按照我们的要求格式化了，所以创建CSV文件非常简单。发送请求后，我们将创建一个新文件，并添加与数据匹配的标题:</p><figure class="kt ku kv kw fd ij"><div class="bz dy l di"><div class="ll lm l"/></div></figure><p id="f74e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">注意:</strong>不要忘记在你的文件顶部添加导入csv。没有必要安装pip。</p><p id="c52f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们将在for循环中使用<code class="du lo lp lq lr b">.writerow()</code>方法对抓取到CSV中的每个属性进行编码。</p><figure class="kt ku kv kw fd ij"><div class="bz dy l di"><div class="ll lm l"/></div></figure><p id="83cb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后，我们在循环之外关闭文件，并打印()CSV文件作为视觉反馈。</p><figure class="kt ku kv kw fd ij"><div class="bz dy l di"><div class="ll lm l"/></div></figure><h1 id="5eee" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">5.运行我们的脚本[全部代码]</h1><p id="43c4" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">恭喜你，你已经创建了一个简单而强大的动态web表刮刀！如果您一直在和我们一起编写代码，那么现在您的代码库应该是这样的:</p><figure class="kt ku kv kw fd ij"><div class="bz dy l di"><div class="ll lm l"/></div></figure><p id="3e52" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">通过运行我们的脚本，我们能够提取原始JavaScript表的所有57行，而不需要使用无头浏览器，也不用担心前端显示的分页特性。</p><figure class="kt ku kv kw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ks"><img src="../Images/b667054fbd78399c847e4e2d35ddd81d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*m34lwdUv6Q-bljIt.png"/></div></div></figure><p id="8127" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是您应该从脚本中获得的最终文件:</p><figure class="kt ku kv kw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ks"><img src="../Images/dff19e01f767a8ea1c19610643973aec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*18ddg__bNKPmLha0.jpg"/></div></div></figure><p id="fff2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">尽管这是一个虚拟的就业数据集，但是您可以很好地修改这个脚本来抓取web上几乎任何动态生成的表，以提取真实的就业、足球、天气或统计数据集。</p><h1 id="dc92" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">总结:使用ScraperAPI缩放您的刮刀</h1><p id="d081" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">使用正确的标题可以为你赢得很多战斗，但是如果你想为商业应用扩展你的项目或者收集大量的数据，这是不够的。在这种情况下，你需要通过创建函数来处理IP轮换和验证码，维护昂贵的代理池并重试任何失败的请求，从而更加努力地保护你的网络抓取器。</p><p id="16fd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">ScraperAPI旨在为您处理所有这些复杂性，只需在您的初始请求中添加一个字符串。</p><p id="3395" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了将我们的API集成到您的代码库，首先<a class="ae kr" href="https://www.scraperapi.com/signup" rel="noopener ugc nofollow" target="_blank">创建一个免费的ScraperAPI帐户</a>来生成您的API密钥。从您的仪表板上，您可以复制您的密钥并访问完整的<a class="ae kr" href="https://www.scraperapi.com/documentation/" rel="noopener ugc nofollow" target="_blank"> ScraperAPI文档</a>。</p><p id="6136" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">有了这些新信息，我们将按照以下结构更改我们的原始URL:</p><figure class="kt ku kv kw fd ij"><div class="bz dy l di"><div class="ll lm l"/></div></figure><p id="64c0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此，您的最终URL看起来会像这样:</p><figure class="kt ku kv kw fd ij"><div class="bz dy l di"><div class="ll lm l"/></div></figure><p id="7cfa" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">通过将我们的请求发送到ScraperAPI的服务器，API将使用其多年的统计分析和机器学习来确定请求成功的最佳报头和IP地址组合，重试任何不成功的尝试，处理验证码和被阻止的IP，并为每个请求轮换您的IP以模仿有机用户。</p><p id="3b7a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">此外，您可以在URL字符串中设置render=true，ScraperAPI将在返回HTML之前对其进行渲染。这对于那些没有API端点可以回退的时候非常方便，就像我们在本教程中所做的那样。</p><p id="37ea" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果您对我们今天所做的有任何疑问，请通过我们的网站或<a class="ae kr" href="https://twitter.com/scraperapi?lang=en" rel="noopener ugc nofollow" target="_blank"> Twitter </a>联系我们。我们随时准备帮助您找到并收集您需要的东西。</p><p id="2e85" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">刮的开心！</p></div></div>    
</body>
</html>