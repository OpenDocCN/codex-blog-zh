<html>
<head>
<title>Don’t fear the shell</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">不要害怕外壳</h1>
<blockquote>原文：<a href="https://medium.com/codex/dont-fear-the-shell-94c179e58c3?source=collection_archive---------14-----------------------#2021-04-09">https://medium.com/codex/dont-fear-the-shell-94c179e58c3?source=collection_archive---------14-----------------------#2021-04-09</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/d9d2aa346eeae9b0f848fd54d4b9cee1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4TMb_5xhB0t4Ba0fV5OKEQ.png"/></div></figure><p id="d370" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">由在英国布里斯托尔工作的<a class="ae jl" href="https://twitter.com/doma_dev" rel="noopener ugc nofollow" target="_blank"> doma团队</a>于<em class="jk">2021年4月9日</em>在<em class="jk"> Fri发表。</em></p><h1 id="4083" class="jm jn hi bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated">TL；速度三角形定位法(dead reckoning)</h1><p id="2c48" class="pw-post-body-paragraph im in hi io b ip kk ir is it kl iv iw ix km iz ja jb kn jd je jf ko jh ji jj hb bi translated">何时求助于shell脚本:</p><ul class=""><li id="f20c" class="kp kq hi io b ip iq it iu ix kr jb ks jf kt jj ku kv kw kx bi translated">便携性很重要</li><li id="c270" class="kp kq hi io b ip ky it kz ix la jb lb jf lc jj ku kv kw kx bi translated">手头的问题很紧迫</li><li id="3fda" class="kp kq hi io b ip ky it kz ix la jb lb jf lc jj ku kv kw kx bi translated">文件系统交互</li><li id="04df" class="kp kq hi io b ip ky it kz ix la jb lb jf lc jj ku kv kw kx bi translated">命令行程序自动化</li></ul><p id="ef59" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">何时寻找替代方案</p><ul class=""><li id="0c15" class="kp kq hi io b ip iq it iu ix kr jb ks jf kt jj ku kv kw kx bi translated">需要可扩展性</li><li id="df8e" class="kp kq hi io b ip ky it kz ix la jb lb jf lc jj ku kv kw kx bi translated">编写关键任务的代码</li></ul><p id="9820" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">Shell脚本是危险的，使用shellcheck并限制自己使用习惯用法</p></div><div class="ab cl ld le gp lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="hb hc hd he hf"><p id="e8c7" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">电脑控制台是计算领域第二重要的UX改进，仅次于窗口管理器。从允许计算机用户输入由单进程操作系统执行的程序到将它们转换成工具箱，控制台走过了漫长的道路。令人高兴的是，大部分工作都是在势不可挡的创新者<a class="ae jl" href="https://en.wikipedia.org/wiki/Douglas_McIlroy" rel="noopener ugc nofollow" target="_blank">道格拉斯·麦克洛伊</a>的监督下在贝尔实验室进行的。</p><p id="ab09" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">Multics“shell”就像那个时代其他支持终端的计算机上的输入一样，是一种接受程序并在Multics OS(UNIX的前身)上执行程序的工具。Multics shell的最早版本已经有了输入/输出重定向。直到道格拉斯·麦克洛伊<a class="ae jl" href="https://corecursive.com/021-gods-programming-language-with-philip-wadler/" rel="noopener ugc nofollow" target="_blank">发现(不是发明)</a>命令管道，它才成为所有操作系统的黄金标准。</p><p id="06e2" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">流水线和UNIX哲学允许编写小的特定问题的程序，这些程序可以在以后编写。但是2021年使用UNIX shell脚本的最大原因是可移植性。事实上，每个现代系统都有现成的UNIX shell。此外，通常编写一个写得相当好的shell脚本是“足够好的工作”。但是怎么做呢？让我们探索一下这个问题的答案，假设读者已经知道了shell脚本的基础知识。</p><h1 id="a318" class="jm jn hi bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated">bash中最少的shell脚本</h1><figure class="ll lm ln lo fd ij er es paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="er es lk"><img src="../Images/4e72704d44b3e51240b15f85e7266769.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*VuNqO49fa2bq9NUi.jpg"/></div></div></figure><p id="29a9" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">让我们抛开最重要的考虑。编写安全可靠的shell脚本几乎是不可能的。至少可以使用<code class="du lt lu lv lw b"><a class="ae jl" href="https://github.com/koalaman/shellcheck" rel="noopener ugc nofollow" target="_blank">shellcheck</a></code>，它与VSCode 集成了<a class="ae jl" href="https://marketplace.visualstudio.com/items?itemName=timonwong.shellcheck" rel="noopener ugc nofollow" target="_blank">。此外，对用户输入要非常严格，尽最大努力引用每一个包含变量的参数。</a></p><p id="b958" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">好了，说完了，让我们来讨论一步一步地创建一个合理的shell脚本。</p><h1 id="429f" class="jm jn hi bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated">设置您的shell环境</h1><p id="aaf1" class="pw-post-body-paragraph im in hi io b ip kk ir is it kl iv iw ix km iz ja jb kn jd je jf ko jh ji jj hb bi translated">在开始编程shell之前，我们需要首先确定我们将使用哪种shell脚本语言。关于这一点有三个学派:</p><ol class=""><li id="5774" class="kp kq hi io b ip iq it iu ix kr jb ks jf kt jj lx kv kw kx bi translated">默认使用<code class="du lt lu lv lw b">bash</code>。Bash是在拥有大量特性和可移植性之间的一个合理的中间地带，因为它随每个流行的操作系统一起提供。</li><li id="d09a" class="kp kq hi io b ip ky it kz ix la jb lb jf lc jj lx kv kw kx bi translated">默认使用<code class="du lt lu lv lw b">sh</code>，需要高级功能时使用<code class="du lt lu lv lw b">bash</code>。这是一种纯粹的方法。它提供了最大的可移植性，但是需要区分基本特性和bash专有特性。</li><li id="d4f1" class="kp kq hi io b ip ky it kz ix la jb lb jf lc jj lx kv kw kx bi translated">使用<code class="du lt lu lv lw b">zsh</code>、<code class="du lt lu lv lw b">fish</code>或其他“潮人”外壳做任何事情。我提到这个学派是为了完整。因为它破坏了可移植性，选择这个选项的人可能也用Python编码。</li></ol><p id="49b3" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">正如人们所猜测的，我们建议简单地对所有事情使用<code class="du lt lu lv lw b">bash</code>。当然，苹果似乎不同意将<code class="du lt lu lv lw b">bash</code>作为默认外壳，但它不会离开mac os系统。相反，Windows 10支持与WSL程序的合理整合。它需要一些设置，但是现在WSL2似乎成为了Windows开发的默认设置。</p><p id="4025" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">此外，<code class="du lt lu lv lw b">bash</code>脚本有细粒度的内置支持来降低不可避免的错误的影响。在设置您的shell时，我们建议您使用以下<a class="ae jl" href="https://www.gnu.org/software/bash/manual/bash.html#The-Set-Builtin" rel="noopener ugc nofollow" target="_blank">选项</a>:</p><p id="c680" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><code class="du lt lu lv lw b">#!/usr/bin/env bash<br/> set -euo pipefail</code></p><p id="f3d8" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">可选地添加<code class="du lt lu lv lw b">-x</code>以便于调试。</p><h1 id="8132" class="jm jn hi bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated">命令行参数处理</h1><p id="ad15" class="pw-post-body-paragraph im in hi io b ip kk ir is it kl iv iw ix km iz ja jb kn jd je jf ko jh ji jj hb bi translated">如果出于某种原因，你想用shell写一些大的东西，比如<a class="ae jl" href="https://github.com/manpages/issues-legacy" rel="noopener ugc nofollow" target="_blank">一个带有git后端的成熟的问题跟踪器</a>，你需要使用或者<a class="ae jl" href="https://github.com/manpages/issues-legacy/blob/master/issues#L30" rel="noopener ugc nofollow" target="_blank">制作你自己的调度系统</a>。然而，在本帖中，我们将考虑简单的参数处理。毕竟，我们大力提倡短小精悍的脚本，只做一件事。</p><p id="2bc7" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">首先，让我们看看如何打印帮助:</p><pre class="ll lm ln lo fd ly lw lz ma aw mb bi"><span id="d997" class="mc jn hi lw b fi md me l mf mg">if [["$1" == "--help" || "$1" == "-h"]]; then<br/>  cat &lt;&lt;EOH<br/>frgtmv: for each file read from STDIN, forget its filename entirely or amend part of it.<br/>...<br/>''frgtmv'' will then ''mv'' each of these files to ''\$(date +'%Y%m%d%H%M%S%N')'', preserving the file extension.<br/>...<br/>EOH<br/>  exit<br/>fi</span></pre><p id="6915" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">关键点:</p><ol class=""><li id="0c7c" class="kp kq hi io b ip iq it iu ix kr jb ks jf kt jj lx kv kw kx bi translated">我们使用了<code class="du lt lu lv lw b">&lt;&lt;EOH / EOH</code>“heredoc”语法，并确保我们没有缩进它下面的行。</li><li id="cfc2" class="kp kq hi io b ip ky it kz ix la jb lb jf lc jj lx kv kw kx bi translated">我们用反斜杠来转义特殊字符，如<code class="du lt lu lv lw b">$</code>。如果我们不这样做，bash会在subshell中评估内部。</li><li id="11ff" class="kp kq hi io b ip ky it kz ix la jb lb jf lc jj lx kv kw kx bi translated">印刷后别忘了给<code class="du lt lu lv lw b">exit</code>帮忙！</li></ol><p id="f667" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在让我们使用<code class="du lt lu lv lw b">-n</code>，一个检查变量是否被设置的谓词，来准备所需的变量。我们通常希望在文件的开头设置默认值:</p><pre class="ll lm ln lo fd ly lw lz ma aw mb bi"><span id="fdf3" class="mc jn hi lw b fi md me l mf mg">_mode="forget"<br/>_pattern_from=""<br/>_replace_with=""<br/><br/>if [-n "$1"]; then<br/>  _mode="amend"<br/>  _pattern_from="$1"<br/>fi<br/><br/>if [-n "$2"]; then<br/>  _replace_with="$2"<br/>fi</span></pre><p id="b438" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">有时，如果没有提供参数，您需要退出。我们使用<code class="du lt lu lv lw b">-z</code>来检查字符串是否为空:</p><pre class="ll lm ln lo fd ly lw lz ma aw mb bi"><span id="19ad" class="mc jn hi lw b fi md me l mf mg"># Exit if file or directory is not submitted or not a valid file or directory<br/>if [-z "$1"]; then<br/>  echo "We really need the first argument"<br/>  exit 228<br/>fi</span></pre><h1 id="6b1f" class="jm jn hi bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated">标准输入、管道和GNU并行</h1><p id="c28a" class="pw-post-body-paragraph im in hi io b ip kk ir is it kl iv iw ix km iz ja jb kn jd je jf ko jh ji jj hb bi translated">有时，您需要通过管道或用户输入从STDIN接收输入。使用<code class="du lt lu lv lw b">read -r</code>完成:</p><pre class="ll lm ln lo fd ly lw lz ma aw mb bi"><span id="7c3a" class="mc jn hi lw b fi md me l mf mg">while read -r _x; do<br/>  mv -v "$_x" "$(date +'%Y%m%d%H%M%S%N').${_x#*.}"<br/>done</span></pre><p id="88e2" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果您更关心性能而不是可移植性，请使用<code class="du lt lu lv lw b">cat -</code>将您的STDIN传递给GNU parallel，遵循以下模式:</p><pre class="ll lm ln lo fd ly lw lz ma aw mb bi"><span id="dee1" class="mc jn hi lw b fi md me l mf mg">function forget() {<br/>  mv -v "$2" "$(date +'%Y%m%d%H%M%S%N').$1.${2#*.}"<br/>}<br/>export -f forget # (A)<br/><br/>if [[$_mode == "forget"]]; then<br/>  cat - | parallel forget {%} {} # (B)<br/>fi</span></pre><p id="d284" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在<code class="du lt lu lv lw b">(A)</code>中，并行负载被实现为bash函数。注意<code class="du lt lu lv lw b">export</code>语句！我们建议编写接收两个变量的有效负载:并行作业ID ( <code class="du lt lu lv lw b">{%}</code>)和当前从STDIN流中读出的项目(<code class="du lt lu lv lw b">{}</code>)。有效载荷从<code class="du lt lu lv lw b">(B)</code>调用。</p><p id="e663" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">以下是一些有趣的<code class="du lt lu lv lw b">parallel</code>技巧:</p><ul class=""><li id="fe0e" class="kp kq hi io b ip iq it iu ix kr jb ks jf kt jj ku kv kw kx bi translated"><code class="du lt lu lv lw b">--keep-order</code>保证输入的顺序不变。每个输入需要几个文件句柄，这可能会成为一个瓶颈。</li><li id="0aae" class="kp kq hi io b ip ky it kz ix la jb lb jf lc jj ku kv kw kx bi translated"><code class="du lt lu lv lw b">find . -print0 | parallel -0 f {}</code>以空终止模式工作。</li><li id="4985" class="kp kq hi io b ip ky it kz ix la jb lb jf lc jj ku kv kw kx bi translated"><code class="du lt lu lv lw b">parallel 'echo "{%}:{1}:{2}";' ::: 1 2 ::: a b c</code>将并行化输入集{1，2} × {a，b，c}的笛卡尔积。</li></ul><h1 id="00ab" class="jm jn hi bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated">Bash参数扩展</h1><p id="82f9" class="pw-post-body-paragraph im in hi io b ip kk ir is it kl iv iw ix km iz ja jb kn jd je jf ko jh ji jj hb bi translated">让许多shell新用户困惑的是，“<a class="ae jl" href="https://www.gnu.org/software/bash/manual/html_node/Shell-Parameter-Expansion.html" rel="noopener ugc nofollow" target="_blank">参数扩展</a>”笼罩着一层神秘的面纱。在我们看来，造成这种结果有几个原因:</p><ol class=""><li id="67f4" class="kp kq hi io b ip iq it iu ix kr jb ks jf kt jj lx kv kw kx bi translated">参数扩展是一个统一的名称，它将访问值和替换值结合在一起。</li><li id="2b67" class="kp kq hi io b ip ky it kz ix la jb lb jf lc jj lx kv kw kx bi translated">在这些用例中，有无数的条件行为，它们是根据参数的种类决定的。</li><li id="e045" class="kp kq hi io b ip ky it kz ix la jb lb jf lc jj lx kv kw kx bi translated">没有太多的扩张。“扩展”这个词只是“减少到一个值”的一种晦涩的说法。</li></ol><p id="31a3" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">让我们从头开始。bash中的参数要么是变量(如<code class="du lt lu lv lw b">$HOME</code>)，要么是位置“自变量”参数(如<code class="du lt lu lv lw b">$1</code>)，要么是特殊参数(如<code class="du lt lu lv lw b">$@</code>)。</p><p id="739d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">“扩展”是参数的<a class="ae jl" href="https://en.wikipedia.org/wiki/Reduction_strategy_(lambda_calculus)" rel="noopener ugc nofollow" target="_blank">还原</a>为数值的过程。变量以人们期望的方式扩展。<a class="ae jl" href="https://www.gnu.org/software/bash/manual/html_node/Special-Parameters.html" rel="noopener ugc nofollow" target="_blank">然而，特殊参数</a>可以有上下文相关的扩展。扩展有特殊的语法来附加额外的计算，比如字符串替换，长度计算等等。</p><p id="a72a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们以下面这个变量为例:<code class="du lt lu lv lw b">x="a.b.c"</code>。根据我们的说法，下面是最常用的参数展开列表:</p><p id="66f6" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">1.脱衣。用例:获取文件扩展名或删除文件扩展名</p><pre class="ll lm ln lo fd ly lw lz ma aw mb bi"><span id="e15b" class="mc jn hi lw b fi md me l mf mg">$<!-- -->{x%.*} ≡ a.b<br/>${x%%.*} ≡ a<br/>${x#*.} ≡ b.c<br/>${x##*.} ≡ c</span></pre><p id="3f4f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">2.字符串替换。</p><pre class="ll lm ln lo fd ly lw lz ma aw mb bi"><span id="15bf" class="mc jn hi lw b fi md me l mf mg">$<!-- -->{x/./\!} ≡ a!b.c<br/>${x//./\!} ≡ a!b!c</span></pre><p id="79a8" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">3.用<code class="du lt lu lv lw b">IFS</code>和<code class="du lt lu lv lw b">[@]</code>进行数组枚举。</p><p id="040a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><code class="du lt lu lv lw b">IFS="."; for v in ${x[@]}; do echo -n "($v)"; done ≡ (a)(b)(c)</code></p><p id="005b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">您也可以使用“复合赋值”来构造数组:</p><pre class="ll lm ln lo fd ly lw lz ma aw mb bi"><span id="d7c5" class="mc jn hi lw b fi md me l mf mg">x=(a b c)<br/>for v in ${x[@]}; do <br/>    echo -n "($v)"<br/>done</span></pre><p id="fe1a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">通常不需要IFS操作。如果你要改变拆分上下文，你应该看看有没有别的方法。你可能会成为XY问题的受害者。</p><p id="35c1" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">本教程应该提供足够好的技术来快速有效地实现您想要的shell脚本。引用你的变量，快速失败，备份从破坏性的改变中恢复，不要使用太多的“高级功能”，因为它们容易出错，祝你好运！</p><p id="ad5d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们留给您一些我们编写的shell脚本，这些脚本拓展了shell的使用范围:</p><ul class=""><li id="f937" class="kp kq hi io b ip iq it iu ix kr jb ks jf kt jj ku kv kw kx bi translated"><a class="ae jl" href="https://github.com/manpages/usr-local-bin/blob/master/chess" rel="noopener ugc nofollow" target="_blank">巴什制造的棋钟</a></li><li id="7faf" class="kp kq hi io b ip ky it kz ix la jb lb jf lc jj ku kv kw kx bi translated"><a class="ae jl" href="https://git.sr.ht/%7Ejonn/shmux/tree/master/item/shmux" rel="noopener ugc nofollow" target="_blank">我每天使用的一个脚本:生成或重新附加到给定项目的</a> <code class="du lt lu lv lw b"><a class="ae jl" href="https://git.sr.ht/%7Ejonn/shmux/tree/master/item/shmux" rel="noopener ugc nofollow" target="_blank">tmux</a></code> <a class="ae jl" href="https://git.sr.ht/%7Ejonn/shmux/tree/master/item/shmux" rel="noopener ugc nofollow" target="_blank">会话</a></li><li id="1c0c" class="kp kq hi io b ip ky it kz ix la jb lb jf lc jj ku kv kw kx bi translated"><a class="ae jl" href="https://github.com/manpages/issues-legacy/blob/master/issues#L5-L15" rel="noopener ugc nofollow" target="_blank">自动检测位于</a> <code class="du lt lu lv lw b"><a class="ae jl" href="https://github.com/manpages/issues-legacy/blob/master/issues#L5-L15" rel="noopener ugc nofollow" target="_blank">include/</a></code> <a class="ae jl" href="https://github.com/manpages/issues-legacy/blob/master/issues#L5-L15" rel="noopener ugc nofollow" target="_blank">目录</a>中的脚本和评估模块的规范路径</li><li id="9a8b" class="kp kq hi io b ip ky it kz ix la jb lb jf lc jj ku kv kw kx bi translated"><a class="ae jl" href="https://github.com/manpages/issues-legacy/blob/master/include/bye.sh" rel="noopener ugc nofollow" target="_blank">终止</a> <a class="ae jl" href="https://github.com/manpages/issues-legacy/blob/master/issues#L3" rel="noopener ugc nofollow" target="_blank">工艺树</a>，<a class="ae jl" href="https://github.com/manpages/issues-legacy/blob/master/include/debug.sh" rel="noopener ugc nofollow" target="_blank">打印调试输出</a></li></ul><p id="fbbc" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果社区感兴趣的话，我们将花些时间用Turtle介绍Haskell中的可扩展shell脚本。像往常一样，在<a class="ae jl" href="https://twitter.com/doma_dev" rel="noopener ugc nofollow" target="_blank"> Twitter </a>或<a class="ae jl" href="https://dev.to/doma" rel="noopener ugc nofollow" target="_blank"> Dev.to </a>或<a class="ae jl" href="https://doma-dev.medium.com/" rel="noopener"> Medium </a> mirrors的评论中联系我们。</p></div><div class="ab cl ld le gp lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="hb hc hd he hf"><p id="84aa" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><em class="jk">原载于</em><a class="ae jl" href="https://doma.dev/blog/get-things-done-with-bash/" rel="noopener ugc nofollow" target="_blank"><em class="jk">https://DOMA . dev</em></a><em class="jk">。</em></p></div></div>    
</body>
</html>