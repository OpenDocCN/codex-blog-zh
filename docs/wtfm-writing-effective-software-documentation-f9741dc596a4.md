# WTFM:编写有效的软件文档

> 原文：<https://medium.com/codex/wtfm-writing-effective-software-documentation-f9741dc596a4?source=collection_archive---------5----------------------->

糟糕的文档会让我抓狂，因为它浪费了*不可思议的*大量时间，耗费了大量金钱，让我们开发人员效率低下，痛苦不堪。文档可能很糟糕，因为它是彻头彻尾的错误(错别字，引用旧版本，等等。)，但更多的时候，文档是糟糕的，因为它没有告诉我们需要知道的东西。你会发现这并不完全是主观的。

![](img/83dcd93febff7114746d012152f9f61d.png)

# 文件需要什么

这是一个非常简单的问题，但是当涉及到编写文档时，对于什么是必需的费用似乎没有“官方”的一致意见。难怪我们的软件不能用！所以让我试着定义一下需求:

1.  **举例说明。**首先，文档需要例子。其他都是次要的(对，*真的*)。
2.  **一个反馈回路。**文档必须能够根据用户的建议进行修改。(这暗示你实际上有用户)。

就是这样！拥有这些组件并不能保证你的文档是好的，但是没有这两个支柱，你的文档(以及你的软件)将会失败。

# 例子

你和这个星球上的每一个人都是通过听到一个又一个相关的例子来学会说话的。不仅仅是孩子这样学习:大部分成年人也从例子中学习。

例子跨越所有其他学习类型:如果学生是视觉、听觉或动觉学习者，一个例子是*他们需要什么*(教师可以迎合*如何*传递)。从我自己作为一个通晓多种语言的人和音乐家的经历来看，我可以证明 [Pimsleur 语言程序](https://languagelearning.stackexchange.com/questions/3001/what-is-the-pimsleur-method)(其重点是相关短语的重复)和[铃木方法](https://en.wikipedia.org/wiki/Suzuki_method)对于学习演奏乐器(其重点是通过耳朵学习演奏)的有效性。

例子管用！而软件项目在这方面的吝啬会使学习曲线变得不必要的陡峭。"这个文档有太多的例子了！"说从来没有开发商。

在编写示例时，请记住以下几点:

1.  **包括一个自述文件**，简洁地陈述你的软件是什么和做什么。没有用户:不要浪费任何人的时间。
2.  专注于任务(而不是概念)。为什么有用户在这里使用您的软件？他们可能需要完成什么任务？如果你的用户在使用你的软件之前需要下载和安装依赖项或者激活一个第三方 API 令牌，那么你应该包括如何做的例子。不要害怕超越你的软件环境:它不会在真空中独立存在，你的文档也不应该。如果你举起双手说“那不是我的问题”，这对你的用户没有任何帮助
3.  **包括变种。**如果你可以用几种不同的方式来使用某样东西，那么就用一些例子来展示这些用例；并列有助于阐明目的。
4.  **把例子放在他们能看到的地方。**对于函数，将示例放在函数文档中，对于类或模块，将示例放在类或模块文档中。考虑 GraphQL:它将 API 文档集成在 API 本身中最显眼的地方。这是一个巨大的胜利！还记得《银河系漫游指南》中具有讽刺意味的一幕吗？在那里，一份重要的拆除通知“陈列在一个锁着的文件柜的底部，文件柜卡在一个废弃的厕所里，门上贴着一个牌子，上面写着‘小心豹子’。”"
5.  **包括集成用例。如果一个单独的功能或模块本身并不真正有用，不要把我们蒙在鼓里:给我们展示一个例子，看看这些部分是如何组合在一起完成一个共同的任务的。了解你的受众以及他们需要做什么。**

# **反馈** **循环**

反馈循环实际上可能比包含示例更重要。如果有足够的时间和用户提供的“进化压力”，文档会进化成越来越好的化身。

想想维基百科:它是互联网上访问量最大的网站之一，努力包含*人类知识的全部广度*，它之所以能做到这一点，是因为它有一个非常简单的方法来促进大规模的同行评审(即，它有一个非常有效的反馈循环)。

对于许多软件项目来说，版本控制系统(例如 Git)是实现反馈循环的一种便利机制，但它只有在满足以下需求的情况下才有用:

1.  **允许有意义的改变。**用户必须能够发起实质性的改变(包括添加或删除内容的能力)。考虑一下 [MongoDB 的文档](https://docs.mongodb.com/):他们的反馈循环是一个彻底的失败，因为用户只能对“这个页面有多有用”给出一个*星级*。当然，他们的文档是糟糕的，因为他们选择了让它不可修复。
2.  **快。**文档必须相对快速地对反馈做出反应，因为反馈只有在推动变革时才有用。不要等到新版本发布时才发布更改，现在就发布消息*！*
3.  **征求所有用户(不仅仅是开发者)的反馈。**这可能是最难实现的目标之一，因为独立于代码本身维护文档的迭代变更是如此困难。内嵌文档的便利性(如 [Javadoc](https://en.wikipedia.org/wiki/Javadoc) )通常意味着反馈循环只会要求开发人员做出改变，因为只有他们有足够的技能来浏览代码库，所以这一点可能需要额外的考虑！

# 后续步骤

有例子和反馈环只是起点:关于你的软件可能有更多要说的，例如对它的设计哲学或概念的解释，但是只要记住:这种类型的文档是更高的量级，所以除非有一个坚实的基础，否则它没有立足之地。当软件作者详述他们在软件背后的哲学动机并误认为是“文档”时，往往会本末倒置——对于另一位试图编写类似软件的作者来说，这可能是一个有趣的题外话，但这样的编年史并没有告诉用户他们需要知道什么(即如何使用软件)。不要让哲学上的漫谈混淆了展示软件实际用途的例子。

教程也必须建立在坚实的基础上，当教程过分倾向于演示基本用例时，它可能表明原始文档中的缺陷或者缺少可行的反馈循环(或者两者都有)。举例来说，如果你曾经不幸遭遇过使用 Oracle 数据库的痛苦，你将会被定向到一个叫 Tom 的人的网站上，以获得如何在 Oracle 中做几乎任何事情的指导——这是他们的文档中所有错误的一个强有力的指示。

# 结论

不要让你所有的努力白费，因为你没有沟通你的软件是什么或如何使用它。编写计算机能理解的东西很容易；写出人类能够理解的文字可能要困难得多。我反对工程师不能写出有效文档的观点。是的，技术写作是一项技能，但是提供示例并不需要太多的写作，任何开发人员都可以建立一个反馈循环，请求他人帮助使您的文档有效和有用。