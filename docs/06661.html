<html>
<head>
<title>Why I don’t like Swift’s “throws”</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么我不喜欢斯威夫特的“投”</h1>
<blockquote>原文：<a href="https://medium.com/codex/why-i-dont-like-swift-s-throws-ec7bb672cd1e?source=collection_archive---------8-----------------------#2022-05-06">https://medium.com/codex/why-i-dont-like-swift-s-throws-ec7bb672cd1e?source=collection_archive---------8-----------------------#2022-05-06</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="cace" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以及为什么您仍然应该使用结果。</p><h1 id="422c" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">投掷函数的主要问题是</h1><p id="6a04" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">Swift有一系列表示失败的机制:抛出函数、断言和结果类型。</p><p id="7f8f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我向你保证，抛出函数是不好的，因为它们阻止我们创建健壮的、可维护的系统，因为当抛出函数起作用时，根本不可能执行编译器辅助的依赖注入。</p><h1 id="fb82" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">讨论一个示例系统</h1><p id="2e80" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">出于讨论的目的，我认为有一个示例系统是值得的。我们的系统将是苹果新闻应用的过度简化版本。</p><h2 id="a88a" class="kg je hi bd jf kh ki kj jj kk kl km jn iq kn ko jr iu kp kq jv iy kr ks jz kt bi translated">以下是要求</h2><ol class=""><li id="5dba" class="ku kv hi ih b ii kb im kc iq kw iu kx iy ky jc kz la lb lc bi translated">用户得到一个文章列表，他们可以点击打开并查看完整的文章。</li><li id="820f" class="ku kv hi ih b ii ld im le iq lf iu lg iy lh jc kz la lb lc bi translated">文章可以来自各种不同的来源，但在我们的例子中，我们将简化这两个只有两个:第一和第三方，1P和3P的简称。这两种文章类型有独立的后端。</li><li id="d03a" class="ku kv hi ih b ii ld im le iq lf iu lg iy lh jc kz la lb lc bi translated">打开一篇文章后，一个新的屏幕会显示文章的全部内容</li><li id="0ead" class="ku kv hi ih b ii ld im le iq lf iu lg iy lh jc kz la lb lc bi translated">文章可能需要订阅才能完整查看。如果用户没有订阅，则屏幕上会显示一条错误消息，旁边是获取订阅的选项。</li><li id="21ea" class="ku kv hi ih b ii ld im le iq lf iu lg iy lh jc kz la lb lc bi translated">如果用户没有订阅，对于需要订阅的文章，1P后端将返回403错误</li><li id="0a03" class="ku kv hi ih b ii ld im le iq lf iu lg iy lh jc kz la lb lc bi translated">如果用户没有订阅，对于需要订阅的文章，3P后端将返回401错误</li><li id="779f" class="ku kv hi ih b ii ld im le iq lf iu lg iy lh jc kz la lb lc bi translated">如果加载文章时出现互联网连接故障，应该向用户显示一条消息，要求检查他们的互联网连接</li><li id="5c71" class="ku kv hi ih b ii ld im le iq lf iu lg iy lh jc kz la lb lc bi translated">任何其他类型的错误(如服务器返回500)都应该向用户显示未知的错误消息。</li></ol><h2 id="fa95" class="kg je hi bd jf kh ki kj jj kk kl km jn iq kn ko jr iu kp kq jv iy kr ks jz kt bi translated">潜在的高级设计</h2><p id="e098" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">我特别想关注用例2-8。为处理这些需求而实施的虚拟系统由4个主要组件组成:</p><ul class=""><li id="fece" class="ku kv hi ih b ii ij im in iq li iu lj iy lk jc ll la lb lc bi translated">一个FullArticleViewModel，负责管理UI</li><li id="e036" class="ku kv hi ih b ii ld im le iq lf iu lg iy lh jc ll la lb lc bi translated">一个FullArticleFetcher协议，它抽象了下载文章的工作。它由FullArticleViewModel使用</li><li id="9c52" class="ku kv hi ih b ii ld im le iq lf iu lg iy lh jc ll la lb lc bi translated">一个firstparticlefetcher full articlefetcher的具体实现:由团队A维护并处理获取第一方文章。它使用Alamofire作为其支持网络层</li><li id="45b5" class="ku kv hi ih b ii ld im le iq lf iu lg iy lh jc ll la lb lc bi translated">FullArticleFetcher的第三方具体实现:由团队B维护，处理获取第三方文章。它使用URLSession作为其支持网络层。</li></ul><figure class="ln lo lp lq fd lr er es paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="er es lm"><img src="../Images/82f430831580c5ed135baf1339259524.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iI2KtUxNsopLPl17cfD7lg.png"/></div></div></figure><p id="9325" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里使用的两个网络堆栈是我们不希望在生产应用程序中看到的。也就是说，如果你没有在你工作过的至少一个应用程序中看到类似的东西，如果不是更糟的话，我会非常羡慕你。</p><h2 id="d27c" class="kg je hi bd jf kh ki kj jj kk kl km jn iq kn ko jr iu kp kq jv iy kr ks jz kt bi translated">V1实施</h2><p id="321a" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">让我们快速回顾一下这个系统可能出现的一些错误:</p><figure class="ln lo lp lq fd lr"><div class="bz dy l di"><div class="ly lz l"/></div></figure><p id="003b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将手动挥动网络代码并查看管理代码，因为这不是本文的重点。因此，让我们看看我们的视图模型现在必须处理的逻辑，以解决可能的错误:</p><figure class="ln lo lp lq fd lr"><div class="bz dy l di"><div class="ly lz l"/></div></figure><p id="cf7a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">呀。以上有几个问题。</p><p id="051c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，我们的核心业务逻辑需要意识到Fetcher类中的具体实现细节可能引发的所有可能的错误。这不仅使catch调用看起来很可怕，而且还引入了维护风险。重构具体的提取器或引入新的提取器可能会导致引发新的/不同的错误，catch all子句无法正确处理这些错误。这是对依赖性反转原则(DIP)的微妙违反，该原则规定:</p><blockquote class="ma mb mc"><p id="2be2" class="if ig md ih b ii ij ik il im in io ip me ir is it mf iv iw ix mg iz ja jb jc hb bi translated">实体必须依赖于抽象，而不是具体。它声明高级模块不能依赖于低级模块，但是它们应该依赖于抽象。</p></blockquote><h2 id="faf8" class="kg je hi bd jf kh ki kj jj kk kl km jn iq kn ko jr iu kp kq jv iy kr ks jz kt bi translated">V2，精简错误</h2><p id="84a3" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">解决这个问题的第一步是引入一个新的错误类型，它属于ViewModel。它列出了ViewModel期望处理的所有可处理的情况:</p><figure class="ln lo lp lq fd lr"><div class="bz dy l di"><div class="ly lz l"/></div></figure><p id="e5aa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这允许我们重构catch子句，只处理FullArticleFetchError，并将错误转换转移到具体的实现中。我们可以进一步记录FullArticleFetcher协议，声明实现只需要抛出FullArticleFetchError。</p><figure class="ln lo lp lq fd lr"><div class="bz dy l di"><div class="ly lz l"/></div></figure><h2 id="ab60" class="kg je hi bd jf kh ki kj jj kk kl km jn iq kn ko jr iu kp kq jv iy kr ks jz kt bi translated">V3，定义一个强的DI契约</h2><p id="cfcf" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">然而，上述实现仍然依赖于软契约。如果开发具体实现类的开发人员不注意，他们可能会忽略界面中的建议。</p><p id="118e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们需要一种方法让协议定义可以处理什么样的错误。不幸的是，swift不支持类型化抛出。那么，如果我们返回结果类型，而不是使用抛出，会怎么样呢？</p><p id="799c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是版本3:</p><figure class="ln lo lp lq fd lr"><div class="bz dy l di"><div class="ly lz l"/></div></figure><p id="655b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因为我们现在使用结果，所以让我们一起去掉do/try catch:</p><figure class="ln lo lp lq fd lr"><div class="bz dy l di"><div class="ly lz l"/></div></figure><p id="e0f9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们有了。我们的业务逻辑现在得到了控制，并且保证提取器总是符合它们的接口。</p></div><div class="ab cl mh mi gp mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="hb hc hd he hf"><h1 id="ab32" class="jd je hi bd jf jg mo ji jj jk mp jm jn jo mq jq jr js mr ju jv jw ms jy jz ka bi translated">这不是一个新的拍摄</h1><p id="79d6" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">这种优势在Swift的<a class="ae mt" href="https://github.com/apple/swift/blob/main/docs/ErrorHandlingRationale.rst" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj">error handling rational . rst</strong></a>中被叫了出来:</p><blockquote class="ma mb mc"><p id="8b56" class="if ig md ih b ii ij ik il im in io ip me ir is it mf iv iw ix mg iz ja jb jc hb bi translated">标记的、静态强制类型化传播的另一个小优点是:它有利于某些类型的重构。具体来说，当重构使一个操作产生错误时，这些属性的缺失会使重构更加危险，并增加意外引入bug的几率。如果传播是非类型化的，或者类型化不是静态执行的，编译器根本不会帮助您找到需要错误检查代码的调用点。即使使用静态类型的传播，如果没有在调用位置专门标记传播，编译器也不会警告您从可以处理或隐式传播错误的上下文中进行的调用。但是如果这些都是真的，编译器会强迫你单独查看所有现有的调用点。</p></blockquote><p id="5618" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是我觉得上面的文件掩盖了这个优势的重要性。希望把上面的例子放在一起有助于说明这一点，因为这是一个非常简单的例子。生产系统会复杂得多。</p><p id="c47d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我觉得很奇怪，斯威夫特去了无类型的投掷方向。该文档涵盖了类型化传播的一些缺点，但它们似乎是针对积极的函数重用的相对较小的问题。我认为这些缺点中的一些可以被解决，并且在系统设计层面上影响较小。</p><p id="312a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在swift社区中有一个关于<a class="ae mt" href="https://forums.swift.org/t/typed-throws/39660/182" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">类型投掷</strong> </a>的公开提议，要求类型投掷，在那里可以找到许多其他好的论点。</p><p id="9a2d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">就我个人而言，我认为合并流中结果类型和强类型错误的存在正好显示了如果采纳该建议，可以获得多大的兼容性。</p><h2 id="c554" class="kg je hi bd jf kh ki kj jj kk kl km jn iq kn ko jr iu kp kq jv iy kr ks jz kt bi translated">还有哪些反论点？</h2><p id="f5b2" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">该提议中的一个线程链接到了artima——检查异常的麻烦( ),这是Kotlin缺少“类型化抛出”背后的基本原理。然而，我认为这个决定更像是对Java异常的本能反应，在Java异常中，一个函数可以声明一系列不同的异常。事实上，<a class="ae mt" href="https://accu.org/journals/overload/10/48/griffiths_406/" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj">exceptual Java</strong></a>中描述的方法是一个很好的例子，说明了如何通过强制每个函数抛出一种错误类型来缓解这个问题。</p></div><div class="ab cl mh mi gp mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="hb hc hd he hf"><h1 id="9a5d" class="jd je hi bd jf jg mo ji jj jk mp jm jn jo mq jq jr js mr ju jv jw ms jy jz ka bi translated">结论</h1><p id="60e9" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">我希望这篇文章有助于阐明我所认为的swift中更好的错误处理实践。不管你同意还是不同意我的观点，我都很乐意通过喜欢这篇文章或者评论来听听你的想法。</p></div></div>    
</body>
</html>