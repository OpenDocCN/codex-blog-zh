# 递归快速指南

> 原文：<https://medium.com/codex/a-quick-guide-to-recursion-b84fdaf6986d?source=collection_archive---------25----------------------->

![](img/d9a8c34e28bea0fbf57b2a2f28b21482.png)

亚历克斯·埃克曼在 Unsplash[上的照片](https://unsplash.com?utm_source=medium&utm_medium=referral)

我目前正在做一个关于排序算法的五部分系列，但是决定稍微绕一下来解释递归。我这样做是因为我的排序算法系列的下一个，也是最后两个主题，将在算法中引入递归。所以，理解递归确实是相关的。

# 什么是递归？

**递归**是一种解决问题的方法，其解决方案依赖于同一问题的较小实例的解决方案。这是分而治之算法(如合并排序)中常用的技术。

在递归中，*函数将调用它自己，直到它不再调用为止*。它停止调用自身的条件称为*基础用例*。这意味着如果你不小心忘记设置一个基本条件，调用可能是无限的。

假设我们试图通过分治法对一个列表进行排序。分而治之的意思是，我们从一个列表开始，把列表分成两半(分成一个更小的列表)，然后再把每个列表分成两半——如此等等。然后，每当列表不能再被分割时，我们可以将我们的基本情况分配给，例如当每个列表只有一个元素时。

以这个列表为例:

```
list = [ 4, 7, 1, 6 ]
```

通过分而治之，上面的列表将被一分为二:

```
[4, 7]  [1, 6]
```

然后进入另外两个，总共四个列表:

```
[4] [7] [1] [6]
```

由于上述数字不能再分割，我们可以将此作为我们的基本情况，例如:

```
# base case conditionif len(list) < 2 :
    return list[:]
```

# 为什么要用递归？

简单地说，你不需要使用递归来解决问题，但是它可以帮助你压缩代码。

如果你错过了分而治之的要点，你需要把一个大问题分解成小的部分，在用这个解决方案解决大问题之前，在一个小的层面上解决每个问题。通过递归，我们可以将问题分解成它的“基本情况”并直接求解。

# 递归示例

我们来看一个非常基础的递归算法。在下面的函数中，我们将把一个数组拆分成它的基本情况，同时返回每个拆分列表:

```
def divide_arr(arr):
    if len(arr) < 2:
        return arr[:]
    else:
        middle = len(arr)//2
        print('original list: ', arr)
        print('left list after split:  ', [:middle])
        print('right list after split: ', [middle:]
        list1 = divide_arr(arr[:middle])
        list2 = divide_arr(arr[middle:])
```

正如您在代码的最底部看到的，`divde_arr()`实际上调用了它自己。这是递归在起作用！只有当数组的长度小于 2 时，才会达到基本情况，递归行为才会停止。

如何应用递归的另一个主要例子是通过倒计数计时器。可以自行调用该函数来帮助计时器在停止到零之前倒计时:

```
def recursion_countdown(n):
    if n == 0:
        return n
    else:
        print(n)
        time.sleep(1)
    return recursion_countdown(n-1)
```

很有趣，对吧？

既然我们已经完成了递归，我将从我离开的地方继续下一篇文章——合并排序！到时候见！