# 设计鲁棒 React 组件的专业技巧第二部分:线束尺寸

> 原文：<https://medium.com/codex/pro-tips-for-designing-robust-react-components-part-ii-bundle-size-5c65556ae5a1?source=collection_archive---------23----------------------->

![](img/eba415dc14df71822dc35c1ab7b7fa23.png)

photo by*@ bobbin io 2112 via*[*第 220 期*](https://www.twenty20.com/photos/36eb7b62-ed97-4f1a-8713-39163704ebbc/?utm_t20_channel=bl)

几周前，我分享了一些提高 React 应用程序性能的技巧。让我们看看如何改进另一个指标——捆绑包大小。

[](/codex/pro-tips-for-designing-robust-react-components-c3eaf9cd7ae4) [## 设计坚固 React 组件的专业技巧

### “如何让我的 React 应用程序更具响应性和可维护性？”

medium.com](/codex/pro-tips-for-designing-robust-react-components-c3eaf9cd7ae4) 

# 为什么包的大小很重要？

因为当用户打开你的页面时，这会影响你的应用程序加载的速度。这是至关重要的，因为许多用户可能会通过不可靠的 3G 或无线连接进行连接，速度很慢，因此小的捆绑包大小是必不可少的，这样用户就不会离开你的网站。如果网页加载时间超过 3 秒，用户往往会离开网站。2 秒的阈值是“危险区域”,大多数用户期望应用程序在这段时间内完全加载，如果没有，他们就会开始不耐烦。

当然，React 应用程序加载与页面加载是不对称的——通常，您可以加载大量 HTML 和 CSS，比 React.js 捆绑文件快得多。然而，加载时间仍然很重要，即使你有稍微长一点的时间来渲染应用程序。因此，虽然用户会原谅你花 10 秒来渲染应用程序，但 60 秒、45 秒，甚至可能 30 秒就不能这么说了。

没有人期望你在 2 秒内完成一个 React 应用程序，但是如果你能做到，那么你的团队应该举办一个披萨和啤酒庆祝会。对于其他人，这里有一些缩小包大小的技巧。

# 把你的包裹分成小份

这是一项非常强大的技术，可以让应用程序加载更快，因为现在 Webpack 可以按需加载一堆更小的包，而不是一个大的包。因此，你可以将你的应用程序的仪表盘打包成一个可以立即加载的包，并延迟加载代表其他辅助页面的包。我想这就是脸书、Instagram 和其他人用来保持他们的主要网站的加载时间可控的方法——这些网站是用 React 编写的。

从 Webpack 4 开始，拆分包是一个可用的特性。现在制作的应用程序可能不是使用 Webpack 3 或更低版本构建的，所以不必担心升级到稍微不兼容的版本。

## 代码分割是如何工作的？

Webpack 文档给了我们 3 种实现代码拆分的方法。第一个使用入口点，入口点使用 Webpack 配置中的`entry`配置行。这基本上意味着您想要分离的每个组件树在 Webpack 配置中引用的特定文件中都有一些祖先组件。整个树被捆绑成一个束。

这就是如何使用`entry`来定义 Webpack 需要制作的不同包:

您必须为所有的包包含`dependOn: 'shared'`，然后列出您作为依赖项导入的任何外部库以及多个组件树使用的每个组件的文件名。否则，共享依赖项在两个包中都是重复的，违背了代码分割的目的。本例中的 lodash 依赖项将在每个没有共享依赖项的已创建包中占用超过 500KB 的空间。

当然，将所有共享组件放在一个文件中通常是不可行的。无论您在`dependOn:`中写了什么，该指令都会在`entry`对象的正下方有一个键，比如本例中的`shared`，如果一个包有多个依赖项，那么它就是一个字符串数组。为不同的包创建多个`dependOn`名称允许您定义多个共享入口点，这些入口点的路径反映了您的 React 应用程序的结构。

# 将内容的长列表重构为单独的 XHR 调用

如果您的 React 应用程序中有任何长的文本字符串数组，这些可能会降低加载时间。尝试创建一个 API 端点来提供这些数据，然后在运行时使用`node-fetch`来检索这些数据，在请求完成时使用进度指示器作为占位符。您可以在加载额外的包之前使用代码分割来获取内容，这减少了用户与应用程序交互之前的呈现时间。

[react-window](https://github.com/bvaughn/react-window) 模块被设计成获取长的内容列表。然而，它还有一个额外的性能优化。它不是获取整个列表，而是只获取适合视窗的数量，然后发出一个 DOM 更新。如果出于某种原因，您的列表及其所有属性有几兆大，这将非常有用。有时候会这样。

此外，您可以设置您的 API 端点来预取请求，这将使服务器在您准备发出实际的 API 调用时缓存响应。在某些情况下，这可以加快获取长内容列表的时间。

# 使用摇树

树抖动是从捆绑包中消除死代码的过程。要做到这一点，您必须只从模块中导入您需要的函数(也就是说，不要全部导入)，并且您必须将`"sideEffects": false`放在 package.json 中与`name`属性相同的级别上。您也可以将其添加到 Webpack 配置文件中的`rules`属性对象下。

副作用是任何模块，当导入时，除了从模块导入项目之外，还运行一些后台函数。Webpack 希望确保从包中移除未使用的函数不会意外地阻止重要代码的运行。如果有这样的模块，您应该将它们的文件名作为字符串数组包含在`sideEffects`属性中，Webpack 会将它们保存在包中。

注意，要做到这一点，你必须在你的文件中使用 [ES2015 导入语法](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import)。

# 使用服务人员

适用于各种 web apps，不反应 app*本身*。

服务工作者是页面在后台部署的 Javascript 文件。它通过缓存“安装”事件侦听器中指定的所有文件来“安装”该文件。然后，它通过发送一个`window.postMessage()`调用与页面通信，其数据随后被网页上的“消息”事件监听器截获。

但是，服务人员如何知道与哪个页面进行通信呢？原来`postMessage()`还带有一个 origin 参数，告诉浏览器应该将消息广播到哪些页面。因此浏览器窗口中具有相同原点的选项卡都将接收到该消息。

所以服务人员不会真的进行一对一的信息传递，除非只有一个匹配的页面。可以把它想象成一个发布-订阅通道，所有相同来源的打开页面都将从消息中获得数据。请记住，源是由主机名或域名、端口号和协议(HTTP 或 HTTPS)组成的元组。

服务人员可以通过缓存安装时指定的文件，然后在“消息”有效负载中返回这些文件来打开页面，从而提高应用程序的性能。这些文件有效地缓存在浏览器中，因此应用程序可以使用这种方法来读取 CSS 文件、字体和 HTML 中定义的其他依赖项，如`<script>`标记。它不适合缓存包(使用 Webpack 服务器代替)，也没有指定来源，你在你的应用程序中创建了安全漏洞。

Google Developers 在他们的文档中有一些很棒的服务工作者事件的代码样本。他们还有一个[老教程](https://developers.google.com/web/ilt/pwa/introduction-to-service-worker)，解释服务人员如何工作。

我希望这篇文章对你寻求让你的应用反应更快有所帮助。如果你有任何其他的表演想法，请在下面的评论中告诉我。