<html>
<head>
<title>Composition vs Inheritance In the Real World (With Java Examples)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">现实世界中的组合与继承(带Java示例)</h1>
<blockquote>原文：<a href="https://medium.com/codex/composition-vs-inheritance-in-the-real-world-with-java-examples-89761b64efb8?source=collection_archive---------1-----------------------#2021-03-14">https://medium.com/codex/composition-vs-inheritance-in-the-real-world-with-java-examples-89761b64efb8?source=collection_archive---------1-----------------------#2021-03-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/3929bcc93a4b1da63f7723384de559a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*phYqGLUiO52S8kFjZbxsnw.png"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">图片由:我。我是程序员，不是平面设计师…</figcaption></figure><h2 id="40e5" class="hv hw hx bd b fp hy hz ia ib ic id dx ie translated" aria-label="kicker paragraph"><a class="ae ge" href="http://medium.com/codex" rel="noopener">法典</a></h2><div class=""/><p id="1f4b" class="pw-post-body-paragraph jd je hx jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">作为一个目光炯炯、思维敏捷的大学毕业生，进入了软件工程的世界，我已经准备好停止学习，开始行动。当然是开玩笑啦！每一个有一点真实世界经验的开发人员都知道一半的工作——如果不是更多的话——是学习。行业的语言和工具不断完善；开源库的出现，消除了为常见问题维护内部解决方案的必要性；新的硬件经常改变工程师们在可维护性、可读性、可伸缩性和性能之间权衡的话题。在这个不断变化的技术世界中，学习不仅仅是保持领先的必要条件，学习<em class="kb">就是</em>游戏。</p><h1 id="6b98" class="kc kd hx bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">"你必须忘掉你学过的东西。"-尤达</h1><p id="a8ae" class="pw-post-body-paragraph jd je hx jf b jg la ji jj jk lb jm jn jo lc jq jr js ld ju jv jw le jy jz ka hb bi translated">尽管不断发展的技术占据了程序员日常学习的很大一部分，但我们通常认为理所当然的抽象概念和设计哲学需要像我们的教育程序一样受到重视。如果不强化抽象工具集，代码的味道和过时的模式将不可避免地进入人们的工作中。即使在团队中，也很容易熟悉彼此的风格并满足于坏习惯，这样，尽管定期进行代码审查或使用源代码分析(SCA)工具，他们仍然会出现在主代码库中。正如绝地大师尤达告诉卢克·天行者的那样，我们也应该抛弃我们已经学到的东西，避免以某种方式做事，因为历史上我们就是这样做的。这将确保我们总是编写具有表现力和可读性的代码。</p><h1 id="eb15" class="kc kd hx bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">那么这些和<em class="lf">构图vs传承</em>有什么关系呢？</h1><p id="f42f" class="pw-post-body-paragraph jd je hx jf b jg la ji jj jk lb jm jn jo lc jq jr js ld ju jv jw le jy jz ka hb bi translated">在回答这个问题之前，我们需要定义我们的术语。当我们在面向对象编程中谈论<em class="kb">组合</em>时，我们指的是<a class="ae lg" href="https://en.wikipedia.org/wiki/Object_composition" rel="noopener ugc nofollow" target="_blank"> <em class="kb">对象组合</em> </a>:一个对象由其他对象组成的概念。相反，我们有<em class="kb">继承</em>。假设我们有两个对象:Droid A和Droid B。说Droid B <em class="kb">从Droid A继承了</em>就是说Droid B明确地表达了与Droid A的关系，使得Droid B具有与Droid A相同的所有属性和功能，但是Droid A不一定具有Droid B的额外属性和功能。如果这些是不熟悉的术语，那么它们就不是您要找的机器人。</p><p id="2707" class="pw-post-body-paragraph jd je hx jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">好了，足够的星球大战参考。</p><p id="e2e8" class="pw-post-body-paragraph jd je hx jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">认识到坏习惯并抛弃它们与正确使用组合和继承特别相关。这种滥用不仅会导致相关代码的可读性和可维护性差，也会导致其继承者和创作者的可读性和可维护性差。当然，基本的多态原理通常被正确地应用在像<em class="kb">数据类</em>(即那些主要目的是<a class="ae lg" href="https://en.wikipedia.org/wiki/Coupling_(computer_programming)" rel="noopener ugc nofollow" target="_blank">紧密耦合</a>一组相关的属性——数据)和基本的应用程序流中，然而(也许并不令人惊讶)在学术和技术博客中发现的理论和这些概念的真实世界实现之间存在明显的脱节。我们试图用组合和继承来解决的现实世界的问题，往往与我们在文学作品中可能找到的简单例子相去甚远。许多Java开发人员都见过类似下面的例子:</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="a403" class="lq kd hx lm b fi lr ls l lt lu">public class Animal {<br/>  . . .<br/>}</span><span id="fd63" class="lq kd hx lm b fi lv ls l lt lu">public class Dog extends Animal {<br/>  . . .<br/>}</span><span id="fc92" class="lq kd hx lm b fi lv ls l lt lu">public class Bird extends Animal {<br/>  . . .<br/>}</span></pre><p id="891d" class="pw-post-body-paragraph jd je hx jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">这样的例子可能包括与动物的腿的数量或它是否能飞有关的属性(我们可以争论这些是否是好的属性，但那是另一篇文章)。然而，现实是，软件工程师经常遇到没有明显层次关系的对象，如动物、汽车或任何其他陈词滥调的例子。</p><p id="dd5f" class="pw-post-body-paragraph jd je hx jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">看看下面的Java代码:</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="6a73" class="lq kd hx lm b fi lr ls l lt lu">public interface TaskScheduler {</span><span id="fbb3" class="lq kd hx lm b fi lv ls l lt lu">  schedule(Runnable runnable, CronTrigger cronTrigger);</span><span id="0465" class="lq kd hx lm b fi lv ls l lt lu">}</span><span id="2dfc" class="lq kd hx lm b fi lv ls l lt lu">public abstract class AbstractTask implements Runnable {</span><span id="67e7" class="lq kd hx lm b fi lv ls l lt lu">  private final Logger logger = . . .;</span><span id="0ee3" class="lq kd hx lm b fi lv ls l lt lu">  private final String taskName;<br/>  private final TaskScheduler taskScheduler;<br/>  private Future taskFuture;</span><span id="be68" class="lq kd hx lm b fi lv ls l lt lu"><br/>  public AbstractTask(String taskName, TaskScheduler taskScheduler) {<br/>    this.taskName = taskName;<br/>    this.taskScheduler = taskScheduler;<br/>  }</span><span id="5096" class="lq kd hx lm b fi lv ls l lt lu">  @Override<br/>  public final void run() {<br/>    logger.info("Running Task: " + getTaskName());<br/>    runTask();<br/>    logger.info("Completed Task: " + getTaskName());<br/>  }</span><span id="fac0" class="lq kd hx lm b fi lv ls l lt lu">  protected abstract void runTask();</span><span id="8443" class="lq kd hx lm b fi lv ls l lt lu">  public String getTaskName() {<br/>    return taskName;<br/>  }</span><span id="2c93" class="lq kd hx lm b fi lv ls l lt lu">  public void schedule(String cronExpression) {<br/>    // code to validate cronExpression<br/>    CronTrigger cronTrigger = new CronTrigger(cronExpression);<br/>    taskFuture = taskScheduler.schedule(this, cronTrigger);<br/>  }<br/>  <br/>  public void unschedule() {<br/>    if (taskFuture != null) {<br/>      taskFuture.cancel();<br/>    }<br/>    taskFuture = null;<br/>  }</span><span id="5091" class="lq kd hx lm b fi lv ls l lt lu">}</span></pre><p id="2f8e" class="pw-post-body-paragraph jd je hx jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">这个例子的灵感来自我最近参与的一个开源项目。对某些人来说，这个类可能看起来不错——它很短，只包含几个字段，方法也不太复杂——然而，它体现了多态性的优点和缺点。</p><p id="5dfe" class="pw-post-body-paragraph jd je hx jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">让我们一次看一种方法:</p><ol class=""><li id="3cca" class="lw lx hx jf b jg jh jk jl jo ly js lz jw ma ka mb mc md me bi translated"><code class="du mf mg mh lm b">run()</code>方法继承自<code class="du mf mg mh lm b">Runnable</code>接口。稍后我们看到对<code class="du mf mg mh lm b">taskScheduler.schedule(this, cronTrigger)</code>的调用，因此我们可以推断出<code class="du mf mg mh lm b">AbstractTask</code>实现<code class="du mf mg mh lm b">Runnable</code>的原因很可能是因为它本该被<code class="du mf mg mh lm b">TaskScheduler</code>消费。<code class="du mf mg mh lm b">run()</code>还有另外一个目的。因为它是一个<code class="du mf mg mh lm b">final</code>方法，所以它为所有实现者创建了一致的行为:在任务执行的开始和结束时进行日志记录。</li><li id="28bd" class="lw lx hx jf b jg mi jk mj jo mk js ml jw mm ka mb mc md me bi translated">跟随<code class="du mf mg mh lm b">run()</code>的是<code class="du mf mg mh lm b">runTask()</code>方法。它被声明为<code class="du mf mg mh lm b">abstract</code>，因此留给实现者来编写，但是它与<code class="du mf mg mh lm b">run()</code>的关系展示了继承在现实世界中的强大用途。<code class="du mf mg mh lm b">run()</code>方法向它的子类保证，在调用<code class="du mf mg mh lm b">runTask()</code>之前的最后一个操作和之后的第一个操作都会记录一致的消息。无论<code class="du mf mg mh lm b">runTask()</code>是如何实现的，当<code class="du mf mg mh lm b">AbstractTask’s</code> <code class="du mf mg mh lm b">run()</code>方法被多态调用时，<code class="du mf mg mh lm b">runTask()</code>会被准确地调用到需要的地方。虽然在这个例子中，一致的行为是日志记录，并且<code class="du mf mg mh lm b">runTask()</code>没有参数，但是这段代码的精神展示了继承的优点，因为它为所有子类创建了一致性，从实现者那里移除了责任(日志记录)，并且它没有偏离类的目的(作为<code class="du mf mg mh lm b">Runnable</code>)。</li><li id="0d15" class="lw lx hx jf b jg mi jk mj jo mk js ml jw mm ka mb mc md me bi translated"><code class="du mf mg mh lm b">getTaskName()</code>可能看起来是一个无害的<em class="kb"> getter </em>，但是它作为<code class="du mf mg mh lm b">public</code>会在<code class="du mf mg mh lm b">AbstractTask's</code>目的上产生歧义。通常，<em class="kb"> getter </em>是在<em class="kb">数据类</em>中找到的方法，但是这个类是<code class="du mf mg mh lm b">Runnable</code>，这意味着它不仅仅存储数据。在<code class="du mf mg mh lm b">run()</code>方法中<code class="du mf mg mh lm b">getTaskName()</code>方法被调用了两次，这是我们在这个例子中看到的唯一用法，但是它还能有什么其他用法呢？如果已经声明了<code class="du mf mg mh lm b">protected</code>，我们可以假设<code class="du mf mg mh lm b">AbstractTask</code>的作者认为子类访问可能是有用的，但是为什么它可能是有用的仍然不清楚。<code class="du mf mg mh lm b">TaskScheduler::schedule</code>是外部定义的并且消费<code class="du mf mg mh lm b">Runnable</code>的事实表明它与<code class="du mf mg mh lm b">getTaskName()</code>无关。这展示了继承和类本身的缺点:<code class="du mf mg mh lm b">AbstractTask</code>包括getter和<code class="du mf mg mh lm b">Runnable‘s</code> <code class="du mf mg mh lm b">run()</code>作为其<em class="kb">公共API </em>的一部分，使得类的目的不明确。这是数据类还是应该运行的东西？</li><li id="62d2" class="lw lx hx jf b jg mi jk mj jo mk js ml jw mm ka mb mc md me bi translated">接下来是<code class="du mf mg mh lm b">schedule()</code>法。它获取它的<code class="du mf mg mh lm b">String</code>参数，验证它(尽管为了简化示例忽略了代码)，基于<code class="du mf mg mh lm b">String</code>构造一个新的<code class="du mf mg mh lm b">CronTrigger</code>，然后将那个<code class="du mf mg mh lm b">CronTrigger</code>连同<code class="du mf mg mh lm b">AbstractTask</code> ( <code class="du mf mg mh lm b">this</code>)的实例传递给<code class="du mf mg mh lm b">taskScheduler</code>的<code class="du mf mg mh lm b">schedule</code>方法。这应该会引发一些危险信号。首先，我们已经确定了<code class="du mf mg mh lm b">AbstractTask</code>的主要目的是成为<code class="du mf mg mh lm b">Runnable</code>，因此让<code class="du mf mg mh lm b">public</code>方法做其他事情应该受到质疑。第二个也是更重要的问题是，我们将一个<code class="du mf mg mh lm b">AbstractTask</code>的实例传递给一个不知道什么是<code class="du mf mg mh lm b">AbstractTask</code>的外部库。既然没有明确使用<code class="du mf mg mh lm b">AbtractTask</code>的东西，为什么还要费力去创建它呢？当然，有些情况下这可能是有意义的，我们讨论了由<code class="du mf mg mh lm b">run()</code> / <code class="du mf mg mh lm b">runTask()</code>串联创建的日志一致性，但在这种情况下，<code class="du mf mg mh lm b">AbstractTask</code>似乎想要被某个东西(即<code class="du mf mg mh lm b">TaskScheduler</code>)消费，但这种意图的表达从其API中并不清楚。总之，定义如何运行任务和如何调度任务可能是两个独立的问题，至少需要两个对象。此外，在自己的私有方法中使用<code class="du mf mg mh lm b">AbstractTask</code>削弱了它需要成为自己的对象的理由。把这个记为老虎钳。</li><li id="347d" class="lw lx hx jf b jg mi jk mj jo mk js ml jw mm ka mb mc md me bi translated">虽然<code class="du mf mg mh lm b">unschedule()</code>并不与所有与<code class="du mf mg mh lm b">schedule()</code>相同的物体互动，但它的哲学目的是撤销时间安排。同样，它在<code class="du mf mg mh lm b">AbstractTask</code>中的出现也是一种多态的恶习。</li></ol><p id="a7dd" class="pw-post-body-paragraph jd je hx jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我们对这些方法的分析分为两条规则:利用机会从子类中抽象出冗余代码，避免通过公共API表达多种目的。</p><h1 id="3ca6" class="kc kd hx bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">公共、受保护、最终、抽象</h1><p id="e7b4" class="pw-post-body-paragraph jd je hx jf b jg la ji jj jk lb jm jn jo lc jq jr js ld ju jv jw le jy jz ka hb bi translated">所有优秀的开发人员都应该努力避免重复代码。当你是一个存储库的唯一维护者时，这看起来很容易，但是很难做到。对于已经在同一个代码库上花费了数百个小时的人来说似乎显而易见的事情可能会迷惑代码库的新手，即使这个新手是一个经验丰富的程序员。为了避免这种情况，我们必须小心编写表达性API，其目的对于必须使用它们的任何人来说都是不言而喻的。幸运的是，Java给了我们四个强大的工具，当它们经过深思熟虑地结合在一起时，就可以做到这一点。</p><p id="dbf3" class="pw-post-body-paragraph jd je hx jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">当设计一个抽象类时，通常有一些功能是所有实现类都必须以相同的方式执行的。这就是<code class="du mf mg mh lm b">public</code>和<code class="du mf mg mh lm b">final</code>发挥作用的地方。<code class="du mf mg mh lm b">public</code>方法定义你的API他们回答这个问题，“这个类<em class="kb">是用来做什么的？”方法上的<code class="du mf mg mh lm b">final</code>关键字用于表达在每个子类中应该一致的东西。</em></p><p id="517c" class="pw-post-body-paragraph jd je hx jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated"><code class="du mf mg mh lm b">protected</code>和<code class="du mf mg mh lm b">abstract</code>也经常配合得最好。通常，一个类是抽象的原因是因为我们知道我们希望<em class="kb">做某事，但是我们不知道<em class="kb">如何做。抽象类声明<code class="du mf mg mh lm b">abstract</code>方法来把<em class="kb">如何</em>留给别人。尽管我们有时不知道任何细节<em class="kb">如何</em>执行一个任务，并且必须求助于<code class="du mf mg mh lm b">public abstract</code>方法，但更多时候子类最终会共享许多相同的步骤来完成一个给定的任务。这就是<code class="du mf mg mh lm b">protected</code>方法的闪光之处。</em></em></p><p id="3777" class="pw-post-body-paragraph jd je hx jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">以创建一个抽象概念<code class="du mf mg mh lm b">DocumentCreator</code>为例，它接受<code class="du mf mg mh lm b">DocumentParts</code>(一个数据类)的<code class="du mf mg mh lm b">List</code>，并返回一个<code class="du mf mg mh lm b">String</code>，表示以特定方式格式化的文档(例如HTML、Markdown、PDF等)。).</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="8f1c" class="lq kd hx lm b fi lr ls l lt lu">public class DocumentPart {</span><span id="67cc" class="lq kd hx lm b fi lv ls l lt lu">  public final int fontSize;<br/>  public final boolean bold;<br/>  public final boolean italic;<br/>  public final String text;<br/>  . . . <br/>}</span><span id="31e8" class="lq kd hx lm b fi lv ls l lt lu">public interface DocumentCreator {</span><span id="7a94" class="lq kd hx lm b fi lv ls l lt lu">  /**<br/>   * Creates a document by first italicizing (if necessary),<br/>   * emboldening (if necessary), and finally resizing each <br/>   * DocumentPart's text.<br/>   */<br/>  String createDocument(List&lt;DocumentPart&gt; documentParts);</span><span id="6d6b" class="lq kd hx lm b fi lv ls l lt lu">}</span></pre><p id="e229" class="pw-post-body-paragraph jd je hx jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">为了这个例子，我们假设所有的文档都必须按照以下顺序格式化:斜体、加粗、调整大小。(我知道……也许不是最现实的例子，但也不是完全不合理。)而不是把这个接口的全部留给未来的维护者，让我们写一个有表达力的抽象类来清楚地说明一个实现需要提供什么功能。</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="e70e" class="lq kd hx lm b fi lr ls l lt lu">public abstract class DocumentCreator {</span><span id="377a" class="lq kd hx lm b fi lv ls l lt lu">  public final String createDocument(List&lt;DocumentPart&gt; documentParts) {<br/>    StringBuilder documentBuilder = new StringBuilder();<br/>    for (DocumentPart part : documentParts) {<br/>        String formattedText = formatDocumentPart(part);<br/>        documentBuilder.append(formattedText);<br/>    }<br/>    return documentBuilder.toString();<br/>  }<br/>  <br/>  private String formatDocumentPart(DocumentPart part) {<br/>    String formattedText = part.text;<br/>    if (part.italic) {<br/>        formattedText = italicize(formattedText);<br/>    }<br/>    <br/>    if (part.bold) {<br/>        formattedText = embolden(formattedText);<br/>    }<br/>    <br/>    return resize(formattedText, part.fontSize);<br/>  }<br/>  <br/>  protected abstract String italicize(String text);<br/>  <br/>  protected abstract String embolden(String text);<br/>  <br/>  protected abstract String resize(String text, int fontSize);<br/>  <br/>}</span></pre><p id="419c" class="pw-post-body-paragraph jd je hx jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">现在，实现者不需要考虑操作的顺序，甚至不需要考虑样板字符串的构建，它只需要知道如何接受一个<code class="du mf mg mh lm b">String</code>并输出一个斜体、加粗或调整大小的版本的<code class="du mf mg mh lm b">String</code>。让我们来看看它的实际应用:</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="7791" class="lq kd hx lm b fi lr ls l lt lu">public class HTMLDocumentCreator extends DocumentCreator {<br/>  <br/>  protected String italicize(String text) {<br/>    return String.format("&lt;i&gt;%s&lt;/i&gt;", text);<br/>  }<br/>  <br/>  protected String embolden(String text) {<br/>    return String.format("&lt;b&gt;%s&lt;/b&gt;", text);<br/>  }<br/>  <br/>  protected String resize(String text, int fontSize) {<br/>    // We'll use px in this simple example<br/>    return String.format("&lt;span style="font-size: %dpx;"&gt;%s&lt;/span&gt;", fontSize, text);<br/>  }<br/>  <br/>}</span></pre><p id="5c95" class="pw-post-body-paragraph jd je hx jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">这看起来比每个子类都必须编写一个带有循环的方法、执行自己的字符串构建、<em class="kb">和</em>无论如何都需要定义那些格式化方法要好得多。此外(假设超类中没有错误)，子类不需要担心在字符串连接逻辑中出错，而任何<code class="du mf mg mh lm b">DocumentCreator</code>都希望一致地执行字符串连接逻辑。这说明了正确使用几个基本概念可以缩小误差范围，并为代码库的维护者提供更清晰的API。</p><p id="828e" class="pw-post-body-paragraph jd je hx jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">尽管这些规则中的许多对经验丰富的Java程序员来说应该是显而易见的，但令人惊讶的是我经常遇到它们被滥用的情况。</p><h1 id="11f3" class="kc kd hx bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">单一责任</h1><p id="75d2" class="pw-post-body-paragraph jd je hx jf b jg la ji jj jk lb jm jn jo lc jq jr js ld ju jv jw le jy jz ka hb bi translated">说到设计原则的滥用，你可能认为我们上一个例子中的设计看起来还是不太对。如果你这么想，你就有所发现了。再次查看我们的<code class="du mf mg mh lm b">HTMLDocumentCreator</code>，我们注意到在实现中实际上没有任何文档创建代码。即使直觉告诉我们，我们将在超类中发现这一点，但这仍然不能解释为什么这个类似乎是关于字符串格式的，尽管它应该是创建文档的。尽管我们的例子仍然正确地抽象出了<em class="kb">不常见的逻辑</em>，但是它这样做的方式产生了一个问题:<code class="du mf mg mh lm b">DocumentCreator</code>不仅负责将文档的片段放在一起，还负责格式化这些片段。我可以懒洋洋地把这归因于它是一个不完美的例子(不可否认它是)，但它实际上是我们从分解<code class="du mf mg mh lm b">AbstractTask</code>例子得出的第二个结论的完美延续。</p><p id="f2a4" class="pw-post-body-paragraph jd je hx jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我们在<code class="du mf mg mh lm b">AbstractTask</code>中发现的第二个问题是它含糊不清的公共API。<code class="du mf mg mh lm b">DocumentCreator</code>演示了其受保护API的类似问题。公共API表示类和它的消费者之间的契约，而受保护的API表示类和它的子类之间的契约。通过定义仅仅基于<em class="kb">格式</em>而不是<em class="kb">文档创建</em>的<code class="du mf mg mh lm b">abstract</code>方法，<code class="du mf mg mh lm b">DocumentCreator</code>在正确委派其职责方面有所欠缺。现在从概念上讲，格式化是文档创建的一个必要部分——特别是在我们的例子中——但是它有两个特点，这使它在当前的实现中显得格格不入。首先，它的实现不影响创建文档的步骤；这使它成为抽象的候选，但并不意味着它在<code class="du mf mg mh lm b">DocumentCreator</code>中不合适。然而决定性的品质是第二个:格式化可以完全独立。正是这个事实让<code class="du mf mg mh lm b">HTMLDocumentCreator</code>显得“关”了。如果你还没有猜到，这就是构图发挥作用的地方。</p><p id="0eb1" class="pw-post-body-paragraph jd je hx jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">上述两个品质是<em class="kb">单一责任原则</em>的基础。从第一个例子开始，我就一直在暗示这个原则。它本质上声明了一个类在一个应用程序的功能(或者甚至是一个应用程序的一个子部分)中应该只有一个职责。让我们把这个想法应用到<code class="du mf mg mh lm b">DocumentCreator</code>中:</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="96a6" class="lq kd hx lm b fi lr ls l lt lu">public abstract class DocumentPartFormatter {<br/>  <br/>  public final format(DocumentPart part) {<br/>    String formattedText = part.text;<br/>    if (part.italic) {<br/>        formattedText = italicize(formattedText);<br/>    }<br/>    <br/>    if (part.bold) {<br/>        formattedText = embolden(formattedText);<br/>    }<br/>    <br/>    return resize(formattedText, part.fontSize);<br/>  }<br/>  <br/>  protected abstract String italicize(String text);<br/>  <br/>  protected abstract String embolden(String text);<br/>  <br/>  protected abstract String resize(String text, int fontSize);<br/>  <br/>}</span><span id="6e40" class="lq kd hx lm b fi lv ls l lt lu">public class DocumentCreator {</span><span id="9bbe" class="lq kd hx lm b fi lv ls l lt lu">  private final DocumentPartFormatter formatter;<br/>  <br/>  public DocumentCreator(DocumentPartFormatter formatter) {<br/>    this.formatter = formatter;<br/>  }</span><span id="d1c0" class="lq kd hx lm b fi lv ls l lt lu">  public final String createDocument(List&lt;DocumentPart&gt; documentParts) {<br/>    StringBuilder documentBuilder = new StringBuilder();<br/>    for (DocumentPart part : documentParts) {<br/>        String formattedText = formatter.format(part);<br/>        documentBuilder.append(formattedText);<br/>    }<br/>    return documentBuilder.toString();<br/>  }<br/>  <br/>}</span></pre><p id="274f" class="pw-post-body-paragraph jd je hx jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">这还差不多。使用composition，<code class="du mf mg mh lm b">DocumentCreator</code>单独负责将列表<code class="du mf mg mh lm b">DocumentParts</code>转换成列表<code class="du mf mg mh lm b">String</code>，而<code class="du mf mg mh lm b">DocumentPartFormatter</code>单独负责实际的格式化。虽然格式化有三种形式(由抽象方法定义)，但这三个概念应该紧密耦合到一个格式化程序中(我们不希望文档使用HTML的格式进行斜体显示，使用Markdown的格式调整大小)。现在让我们看看<code class="du mf mg mh lm b">DocumentPartFormatter</code>的实现会是什么样子。</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="ff1b" class="lq kd hx lm b fi lr ls l lt lu">public class HTMLDocumentPartFormatter extends <!-- -->DocumentPartFormatter <!-- -->{<br/>  <br/>  protected String italicize(String text) {<br/>    return String.format("&lt;i&gt;%s&lt;/i&gt;", text);<br/>  }<br/>  <br/>  protected String embolden(String text) {<br/>    return String.format("&lt;b&gt;%s&lt;/b&gt;", text);<br/>  }<br/>  <br/>  protected String resize(String text, int fontSize) {<br/>    return String.format("&lt;span style="font-size: %dpx;"&gt;%s&lt;/span&gt;", fontSize, text);<br/>  }<br/>  <br/>}</span></pre><p id="604f" class="pw-post-body-paragraph jd je hx jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">它看起来几乎与<code class="du mf mg mh lm b">HTMLDocumentCreator</code>的实现相同，但是在“格式化程序”中使用<em class="kb">斜体、</em>加粗和<em class="kb">调整</em>大小比在“文档创建程序”中更有意义。现在我们已经完善了我们的实现，让我们看看如何使用它。</p><ol class=""><li id="506a" class="lw lx hx jf b jg jh jk jl jo ly js lz jw ma ka mb mc md me bi translated">标准使用案例:</li></ol><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="475c" class="lq kd hx lm b fi lr ls l lt lu">DocumentPartFormatter htmlFormatter = new HTMLDocumentPartFormatter();<br/>DocumentCreator htmlCreator = new DocumentCreator(htmlFormatter);</span></pre><p id="f78a" class="pw-post-body-paragraph jd je hx jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">2.在某些情况下，比如一个Spring框架应用程序，使用一个<code class="du mf mg mh lm b">HTMLDocumentCreator</code>类作为Spring组件可能仍然有意义(这是一个如何使用Spring的简单例子):</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="1982" class="lq kd hx lm b fi lr ls l lt lu">@Component<br/>public class HTMLDocumentPartFormatter extends DocumentPartFormatter {<br/>  . . .<br/>}<br/>  <br/>@Component<br/>public class HTMLDocumentCreator extends DocumentCreator {<br/>  <br/>  @Autowired<br/>  protected HTMLDocumentCreator(HTMLDocumentPartFormatter formatter) {<br/>    super(formatter);<br/>  }<br/>  <br/>}</span></pre><p id="91aa" class="pw-post-body-paragraph jd je hx jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">组合不仅在我们的<code class="du mf mg mh lm b">DocumentCreator</code>实现中提供了更多的灵活性，它还给我们的应用程序提供了一个新的工具<code class="du mf mg mh lm b">DocumentPartFormatter</code>，现在可以单独使用(和测试)。</p><h1 id="3cd8" class="kc kd hx bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">结论</h1><p id="fe12" class="pw-post-body-paragraph jd je hx jf b jg la ji jj jk lb jm jn jo lc jq jr js ld ju jv jw le jy jz ka hb bi translated">即使对于有经验的软件工程师来说，对代码气味的自满也会导致坏习惯。反过来，坏习惯会导致对基本开发原则的偶尔滥用，膨胀成不可维护的代码库。在面向对象编程中，这些问题通常表现为组合和继承这两个最重要的设计工具的不恰当使用。Java开发人员在实现这些模式时必须保持警惕，并在误用开始渗入他们的工作时重新学习它们。</p><p id="68ce" class="pw-post-body-paragraph jd je hx jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">正确使用的话，继承和组合可以创建非常有表现力的API，并显著提高应用程序的可读性和可维护性。如果使用不当，他们会通过制造大量的技术债务来拖垮代码库，并使责任纠缠不清，以至于必须重写大量代码才能使事情回到正轨。</p><p id="6785" class="pw-post-body-paragraph jd je hx jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我希望上面的例子和分析可以用来展示组合和继承的好与坏——优点和缺点——以帮助您设计出更好的代码，让其他人乐于维护。</p></div></div>    
</body>
</html>