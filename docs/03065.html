<html>
<head>
<title>Method inlining in Java</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java中的方法内联</h1>
<blockquote>原文：<a href="https://medium.com/codex/method-inlining-in-java-84caec9b3e18?source=collection_archive---------5-----------------------#2021-08-17">https://medium.com/codex/method-inlining-in-java-84caec9b3e18?source=collection_archive---------5-----------------------#2021-08-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/c05e9c7fc67a44dee671cd5347a2aff6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1372/format:webp/1*fa5-2FrzJHSpckWYx__mJg.png"/></div><figcaption class="im in et er es io ip bd b be z dx translated">方法内联示例。</figcaption></figure><p id="ca12" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">本文旨在介绍方法内联并演示其效果。</p></div><div class="ab cl jo jp gp jq" role="separator"><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt"/></div><div class="hb hc hd he hf"><p id="6bb8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">TL；默认情况下，DR <br/> </strong>方法内联是启用的，不应该禁用。这是一种编译器优化，本质上是用方法的内容替换方法调用。</p></div><div class="ab cl jo jp gp jq" role="separator"><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt"/></div><div class="hb hc hd he hf"><p id="27e0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们来谈谈Java中的编译器优化。HotSpot JVM实时(JIT)编译器可以执行大量的优化，例如但不限于:</p><ul class=""><li id="a1fa" class="jv jw hi is b it iu ix iy jb jx jf jy jj jz jn ka kb kc kd bi translated">何时在主存上使用寄存器存储值。</li><li id="26bf" class="jv jw hi is b it ke ix kf jb kg jf kh jj ki jn ka kb kc kd bi translated">跳过方法查找。</li><li id="6576" class="jv jw hi is b it ke ix kf jb kg jf kh jj ki jn ka kb kc kd bi translated">转义分析(-XX:+DoEscapeAnalysis，-XX:-DoEscapeAnalysis)</li><li id="5369" class="jv jw hi is b it ke ix kf jb kg jf kh jj ki jn ka kb kc kd bi translated">内联(-XX:+内联，-XX:-内联)</li></ul><h2 id="eb3b" class="kj kk hi bd kl km kn ko kp kq kr ks kt jb ku kv kw jf kx ky kz jj la lb lc ld bi translated">方法内联</h2><p id="7b18" class="pw-post-body-paragraph iq ir hi is b it le iv iw ix lf iz ja jb lg jd je jf lh jh ji jj li jl jm jn hb bi translated">使用以下标志激活/禁用它(默认情况下激活)。大多数java真/假标志使用-XX:[+，-]FLAG的语法来设置真或假[1]。</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="8075" class="kj kk hi lo b fi ls lt l lu lv">-XX:+Inline (enables)<br/>-XX:-Inline (disables)</span></pre><p id="ac4f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">内联是一种优化，在这种情况下，编译器确定不需要某个方法，并用简单的语句替换了该方法调用。编译器基本上执行了与我在下面的<strong class="is hj">例子中手动完成的相同的优化。</strong></p><figure class="lj lk ll lm fd ij"><div class="bz dy l di"><div class="lw lx l"/></div><figcaption class="im in et er es io ip bd b be z dx translated">“手动”方法内联</figcaption></figure><p id="73ec" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在Java的早期版本中，执行这种手动内联曾经是获得更好性能的常用方法。显然我们不应该再这样做了，因为编译器已经为我们处理了。</p></div><div class="ab cl jo jp gp jq" role="separator"><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt"/></div><div class="hb hc hd he hf"><p id="c901" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">那么，这能带来多大的改善呢？我构建了一个极端的例子来演示其效果，见下文。</p><figure class="lj lk ll lm fd ij"><div class="bz dy l di"><div class="lw lx l"/></div><figcaption class="im in et er es io ip bd b be z dx translated">方法内联测试代码。</figcaption></figure><p id="5e66" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">代码基本上执行了大量的获取和设置，主要是设置值(注意Point#setX和Point#setY内部的循环)。</p><p id="eb1f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">内联启用</strong></p><p id="7b8d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果我们不带任何参数运行这个例子(-XX:+Inline默认启用)，我们可以看到执行时间接近于0。</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="1563" class="kj kk hi lo b fi ls lt l lu lv">&gt; javac MethodInlining.java</span><span id="b84e" class="kj kk hi lo b fi ly lt l lu lv">&gt; java MethodInlining</span><span id="b4ee" class="kj kk hi lo b fi ly lt l lu lv">Running pid: 41301<br/>Elapsed time (ms): 0<br/>Point[x=49995000, y=49995000]</span></pre><p id="8db1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">内联被禁用</strong></p><p id="2bb0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们将其与禁用内联进行比较。</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="f994" class="kj kk hi lo b fi ls lt l lu lv">&gt; javac MethodInlining.java</span><span id="1b25" class="kj kk hi lo b fi ly lt l lu lv">&gt; java -XX:-Inline MethodInlining</span><span id="386a" class="kj kk hi lo b fi ly lt l lu lv">Running pid: 41303<br/>Elapsed time (ms): 9754<br/>Point[x=49995000, y=49995000]</span></pre><p id="298b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">测试现在花了将近10秒钟。).这里我们有一个极端的例子，方法调用开销占用了大部分时间。显然，您不会在野外看到这种情况，但是，如果禁用了内联，您可能会看到30–50%的性能下降[2]。</p></div><div class="ab cl jo jp gp jq" role="separator"><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt"/></div><div class="hb hc hd he hf"><h2 id="20cb" class="kj kk hi bd kl km kn ko kp kq kr ks kt jb ku kv kw jf kx ky kz jj la lb lc ld bi translated">JVM中的日志内联</h2><p id="b552" class="pw-post-body-paragraph iq ir hi is b it le iv iw ix lf iz ja jb lg jd je jf lh jh ji jj li jl jm jn hb bi translated">为了深入了解JVM以及它何时内联方法，可以使用一些标志。</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="1cd6" class="kj kk hi lo b fi ls lt l lu lv">&gt; javac MethodInlining.java</span><span id="6018" class="kj kk hi lo b fi ly lt l lu lv">&gt; java -XX:+UnlockDiagnosticVMOptions -XX:+PrintInlining MethodInlining</span><span id="98b5" class="kj kk hi lo b fi ly lt l lu lv">...<br/>@ 22   MethodInlining$Point::setX (19 bytes)   inline (hot)<br/>  @ 9   MethodInlining$Point::setXInside (6 bytes)   accessor<br/>...<br/>@ 32   MethodInlining$Point::setY (19 bytes)   inline (hot)<br/>  @ 9   MethodInlining$Point::setYInside (6 bytes)   accessor<br/>...</span></pre><p id="5a87" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这告诉你编译器已经内联了这个方法。运行没有内联的示例，我们可以注意到不同之处。</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="efe3" class="kj kk hi lo b fi ls lt l lu lv">&gt; javac MethodInlining.java</span><span id="2725" class="kj kk hi lo b fi ly lt l lu lv">&gt; java -XX:-Inline -XX:+UnlockDiagnosticVMOptions -XX:+PrintInlining MethodInlining</span><span id="81cf" class="kj kk hi lo b fi ly lt l lu lv">...<br/>@ 9   MethodInlining$Point::setXInside (6 bytes)   not inlineable<br/>@ 9   MethodInlining$Point::setYInside (6 bytes)   not inlineable<br/>...</span></pre><p id="c44b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后，方法什么时候被内联？这取决于这个方法有多热门(它被调用的频率)以及它的大小。如果一个方法被确定为热的并且适合内联，那么当它小于下面的标志(以字节为单位)时，它将被内联。</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="04ea" class="kj kk hi lo b fi ls lt l lu lv">&gt; java -XX:+PrintFlagsFinal -version | grep FreqInlineSize</span><span id="12cf" class="kj kk hi lo b fi ly lt l lu lv">intx FreqInlineSize = 325 {pd product} {default}</span><span id="6a7d" class="kj kk hi lo b fi ly lt l lu lv">openjdk version "13.0.2" 2020-01-14<br/>OpenJDK Runtime Environment (build 13.0.2+8)<br/>OpenJDK 64-Bit Server VM (build 13.0.2+8, mixed mode, sharing)</span></pre><p id="cf32" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">或者，只有当它小于下面的标志(以字节为单位)时，才有资格进行内联。</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="b0b6" class="kj kk hi lo b fi ls lt l lu lv">&gt; java -XX:+PrintFlagsFinal -version | grep MaxInlineSize</span><span id="0d5a" class="kj kk hi lo b fi ly lt l lu lv">intx MaxInlineSize = 35 {product} {default}</span><span id="0b52" class="kj kk hi lo b fi ly lt l lu lv">openjdk version "13.0.2" 2020-01-14<br/>OpenJDK Runtime Environment (build 13.0.2+8)<br/>OpenJDK 64-Bit Server VM (build 13.0.2+8, mixed mode, sharing)</span></pre></div><div class="ab cl jo jp gp jq" role="separator"><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt"/></div><div class="hb hc hd he hf"><p id="d95d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">参考文献</strong></p><p id="40f9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">[1]Java HotSpot VM Options<br/><a class="ae lz" href="https://www.oracle.com/java/technologies/javase/vmoptions-jsp.html" rel="noopener ugc nofollow" target="_blank">https://www . Oracle . com/Java/technologies/javase/VM Options-JSP . html</a></p><p id="2f90" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">[2] Java性能Scott Oaks的权威指南</p></div></div>    
</body>
</html>