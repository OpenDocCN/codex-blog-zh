<html>
<head>
<title>Kubernetes 101 Notes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes 101笔记</h1>
<blockquote>原文：<a href="https://medium.com/codex/kubernetes-101-notes-853fbf2d6d24?source=collection_archive---------17-----------------------#2021-08-28">https://medium.com/codex/kubernetes-101-notes-853fbf2d6d24?source=collection_archive---------17-----------------------#2021-08-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="4749" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">写这篇文章是为了收集不同来源的笔记。</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/c3842787943f243b32e4509624c01b56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZYHZhCRYFw_6zmN1i8nErw.png"/></div></div></figure><p id="c868" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">“Kubernetes是一个可移植、可扩展的开源平台，用于管理容器化的工作负载和服务，有利于声明式配置和自动化。它有一个庞大的、快速增长的生态系统。Kubernetes的服务、支持和工具随处可见。[0]"</p><p id="84bf" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">你至少需要知道以下术语。</p><h1 id="c148" class="kf kg hi bd kh ki kj kk kl km kn ko kp io kq ip kr ir ks is kt iu ku iv kv kw bi translated"><strong class="ak">豆荚</strong></h1><p id="4eda" class="pw-post-body-paragraph jj jk hi jl b jm kx ij jo jp ky im jr js kz ju jv jw la jy jz ka lb kc kd ke hb bi translated">可以部署在库伯内特的最小单位。</p><p id="6230" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">实际上，pod是一个或多个协同工作的容器，为系统的一部分提供服务。</p><p id="cbbd" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">每个pod都有一个唯一的IP地址。</p><p id="2983" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">pod中的容器可以通过本地主机相互通信。</p><p id="7a94" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">但大多数情况下，每个舱都包含一个容器。</p><p id="905a" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj">"注意:</strong>将多个协同定位和共同管理的容器组合在一个Pod中是一种相对高级的用例。您应该只在容器紧密耦合的特定情况下使用这种模式"[3]。</p><h1 id="2b89" class="kf kg hi bd kh ki kj kk kl km kn ko kp io kq ip kr ir ks is kt iu ku iv kv kw bi translated"><strong class="ak">副本集</strong></h1><p id="3f96" class="pw-post-body-paragraph jj jk hi jl b jm kx ij jo jp ky im jr js kz ju jv jw la jy jz ka lb kc kd ke hb bi translated">“副本集的目的是在任何给定时间保持一组稳定的副本盒运行。因此，它通常用于保证指定数量的相同pod的可用性。”</p><p id="df0d" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">介绍状态管理</p><h1 id="4dd4" class="kf kg hi bd kh ki kj kk kl km kn ko kp io kq ip kr ir ks is kt iu ku iv kv kw bi translated"><strong class="ak">部署</strong></h1><p id="1637" class="pw-post-body-paragraph jj jk hi jl b jm kx ij jo jp ky im jr js kz ju jv jw la jy jz ka lb kc kd ke hb bi translated">副本集之上的抽象级别</p><p id="f529" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">部署创建和更新副本集</p><h1 id="d8a9" class="kf kg hi bd kh ki kj kk kl km kn ko kp io kq ip kr ir ks is kt iu ku iv kv kw bi translated"><strong class="ak">配置图</strong></h1><p id="b3a4" class="pw-post-body-paragraph jj jk hi jl b jm kx ij jo jp ky im jr js kz ju jv jw la jy jz ka lb kc kd ke hb bi translated">用于覆盖特定于容器的数据，如</p><ul class=""><li id="8be5" class="lc ld hi jl b jm jn jp jq js le jw lf ka lg ke lh li lj lk bi translated">配置文件</li><li id="e0de" class="lc ld hi jl b jm ll jp lm js ln jw lo ka lp ke lh li lj lk bi translated">环境变量</li><li id="735f" class="lc ld hi jl b jm ll jp lm js ln jw lo ka lp ke lh li lj lk bi translated">数据的整个目录</li></ul><p id="1f00" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">“应用程序有时会将配置作为常量存储在代码中。这违反了要求<strong class="jl hj">将配置与代码</strong>严格分离的十二要素。不同部署的配置差异很大，但代码不会。”[5]这就是为什么使用ConfigMap来处理这种情况。</p><p id="4d36" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">当改变时在容器内自动更新</p><p id="5a86" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">最佳实践是版本化配置映射并执行滚动更新</p><p id="a9d9" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">"配置映射可以作为数据卷装入。配置映射也可以由系统的其他部分使用，而不直接暴露给Pod。例如，配置映射可以保存系统的其他部分应该用于配置的数据。[4]</p><h2 id="6942" class="lq kg hi bd kh lr ls lt kl lu lv lw kp js lx ly kr jw lz ma kt ka mb mc kv md bi translated">将配置图用作Pod中的文件</h2><p id="827a" class="pw-post-body-paragraph jj jk hi jl b jm kx ij jo jp ky im jr js kz ju jv jw la jy jz ka lb kc kd ke hb bi translated">要在Pod的卷中使用配置图，请执行以下操作:</p><ol class=""><li id="7fd6" class="lc ld hi jl b jm jn jp jq js le jw lf ka lg ke me li lj lk bi translated">创建配置映射或使用现有配置映射。多个窗格可以引用同一个配置图。</li><li id="0deb" class="lc ld hi jl b jm ll jp lm js ln jw lo ka lp ke me li lj lk bi translated">修改Pod定义，在<code class="du mf mg mh mi b">.spec.volumes[]</code>下添加一个卷。将该卷命名为任意名称，并设置一个<code class="du mf mg mh mi b">.spec.volumes[].configMap.name</code>字段来引用您的ConfigMap对象。</li><li id="19f4" class="lc ld hi jl b jm ll jp lm js ln jw lo ka lp ke me li lj lk bi translated">向每个需要配置映射的容器添加一个<code class="du mf mg mh mi b">.spec.containers[].volumeMounts[]</code>。将<code class="du mf mg mh mi b">.spec.containers[].volumeMounts[].readOnly = true</code>和<code class="du mf mg mh mi b">.spec.containers[].volumeMounts[].mountPath</code>指定为您希望配置图出现的未使用的目录名。</li><li id="8dc4" class="lc ld hi jl b jm ll jp lm js ln jw lo ka lp ke me li lj lk bi translated">修改您的图像或命令行，以便程序在该目录中查找文件。ConfigMap <code class="du mf mg mh mi b">data</code>映射中的每个键都成为<code class="du mf mg mh mi b">mountPath</code>下的文件名。</li></ol><p id="5289" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这是一个在卷中装载配置图的Pod示例:</p><pre class="iy iz ja jb fd mj mi mk ml aw mm bi"><span id="5d36" class="lq kg hi mi b fi mn mo l mp mq"><strong class="mi hj">apiVersion</strong>: v1<br/><strong class="mi hj">kind</strong>: Pod<br/><strong class="mi hj">metadata</strong>:<br/>  <strong class="mi hj">name</strong>: mypod<br/><strong class="mi hj">spec</strong>:<br/>  <strong class="mi hj">containers</strong>:<br/>  - <strong class="mi hj">name</strong>: mypod<br/>    <strong class="mi hj">image</strong>: redis<br/>    <strong class="mi hj">volumeMounts</strong>:<br/>    - <strong class="mi hj">name</strong>: foo<br/>      <strong class="mi hj">mountPath</strong>: "/etc/foo"<br/>      <strong class="mi hj">readOnly</strong>: <strong class="mi hj">true</strong><br/>  <strong class="mi hj">volumes</strong>:<br/>  - <strong class="mi hj">name</strong>: foo<br/>    <strong class="mi hj">configMap</strong>:<br/>      <strong class="mi hj">name</strong>: myconfigmap</span></pre><p id="59a5" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">当卷中当前消耗的配置映射被更新时，投影的键最终也被更新。kubelet在每次定期同步时检查安装的配置图是否是新的。然而，kubelet使用其本地缓存来获取配置图的当前值。缓存的类型可使用<a class="ae mr" href="https://kubernetes.io/docs/reference/config-api/kubelet-config.v1beta1/" rel="noopener ugc nofollow" target="_blank"> KubeletConfiguration结构</a>中的<code class="du mf mg mh mi b">ConfigMapAndSecretChangeDetectionStrategy</code>字段进行配置。ConfigMap可以通过观察器(默认)、基于ttl或通过将所有请求直接重定向到API服务器来传播。因此，从更新配置映射到将新密钥投射到Pod的总延迟可能与kubelet同步周期+缓存传播延迟一样长，其中缓存传播延迟取决于所选的缓存类型(它等于观察传播延迟、缓存的ttl或相应的零)。”[4]</p><h1 id="673e" class="kf kg hi bd kh ki kj kk kl km kn ko kp io kq ip kr ir ks is kt iu ku iv kv kw bi translated"><strong class="ak">服务</strong></h1><p id="1fbc" class="pw-post-body-paragraph jj jk hi jl b jm kx ij jo jp ky im jr js kz ju jv jw la jy jz ka lb kc kd ke hb bi translated">"定义一个可以用来指一组pod的DNS项目</p><p id="9d93" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">为pod组提供一致的端点</p><p id="37d3" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">不同类型的集群IP、节点端口、负载平衡器</p><ul class=""><li id="4af7" class="lc ld hi jl b jm jn jp jq js le jw lf ka lg ke lh li lj lk bi translated"><code class="du mf mg mh mi b">ClusterIP</code>:公开集群内部IP上的服务。选择该值将使服务只能从集群内部访问。这是默认的<code class="du mf mg mh mi b">ServiceType</code>。</li><li id="ed16" class="lc ld hi jl b jm ll jp lm js ln jw lo ka lp ke lh li lj lk bi translated"><code class="du mf mg mh mi b"><a class="ae mr" href="https://kubernetes.io/docs/concepts/services-networking/service/#nodeport" rel="noopener ugc nofollow" target="_blank">NodePort</a></code>:在一个静态端口暴露每个节点的IP上的服务(<code class="du mf mg mh mi b">NodePort</code>)。自动创建一个<code class="du mf mg mh mi b">ClusterIP</code>服务，<code class="du mf mg mh mi b">NodePort</code>服务将路由到该服务。您将能够通过请求<code class="du mf mg mh mi b">&lt;NodeIP&gt;:&lt;NodePort&gt;</code>从集群外部联系<code class="du mf mg mh mi b">NodePort</code>服务。</li><li id="4dbf" class="lc ld hi jl b jm ll jp lm js ln jw lo ka lp ke lh li lj lk bi translated"><code class="du mf mg mh mi b"><a class="ae mr" href="https://kubernetes.io/docs/concepts/services-networking/service/#loadbalancer" rel="noopener ugc nofollow" target="_blank">LoadBalancer</a></code>:使用云提供商的负载均衡器对外公开服务。外部负载平衡器路由到的<code class="du mf mg mh mi b">NodePort</code>和<code class="du mf mg mh mi b">ClusterIP</code>服务是自动创建的。"</li></ul><h1 id="5026" class="kf kg hi bd kh ki kj kk kl km kn ko kp io kq ip kr ir ks is kt iu ku iv kv kw bi translated"><strong class="ak">入口</strong></h1><p id="aa55" class="pw-post-body-paragraph jj jk hi jl b jm kx ij jo jp ky im jr js kz ju jv jw la jy jz ka lb kc kd ke hb bi translated">"定义群集外的流量如何路由到群集内。</p><p id="a7f4" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">用来向世界展示Kubernetes的服务</p><p id="03be" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">基于主机和路径等因素将流量路由到内部服务</p><p id="155f" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">入口通常由负载均衡器(Nginx、HAProxy等)实现</p><p id="c80a" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">就像第7层负载平衡器。</p><p id="7664" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">开发入口是为了降低云中的负载平衡器成本。如果我们为每个服务使用一个负载均衡器(服务类型-&gt;负载均衡器)，成本会非常高。这就是我们使用入口的原因。</p><p id="1a17" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我将像这样为不同的主题合并资源。回购:</p><div class="ms mt ez fb mu mv"><a href="https://github.com/yunuskilicdev/notes" rel="noopener  ugc nofollow" target="_blank"><div class="mw ab dw"><div class="mx ab my cl cj mz"><h2 class="bd hj fi z dy na ea eb nb ed ef hh bi translated">GitHub-yunuskilidev/notes:收集不同来源的笔记</h2><div class="nc l"><h3 class="bd b fi z dy na ea eb nb ed ef dx translated">从不同的来源收集笔记。在GitHub上创建一个帐户，为yunuskilidev/notes开发做贡献。</h3></div><div class="nd l"><p class="bd b fp z dy na ea eb nb ed ef dx translated">github.com</p></div></div><div class="ne l"><div class="nf l ng nh ni ne nj jh mv"/></div></div></a></div><p id="0e87" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">0-)<a class="ae mr" href="https://kubernetes.io/docs/concepts/overview/what-is-kubernetes/" rel="noopener ugc nofollow" target="_blank">https://kubernetes . io/docs/concepts/overview/what-is-kubernetes/</a></p><p id="3252" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">1-)【https://www.youtube.com/watch?v=5h1TCrh_hZ0 T2】</p><p id="e121" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">2-)【https://www.cncf.io/blog/2019/12/16/kubernetes-101/】T4</p><p id="0d81" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">3-)<a class="ae mr" href="https://kubernetes.io/docs/concepts/workloads/pods/" rel="noopener ugc nofollow" target="_blank">https://kubernetes.io/docs/concepts/workloads/pods/</a></p><p id="0448" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">4-)<a class="ae mr" href="https://kubernetes.io/docs/concepts/configuration/configmap/" rel="noopener ugc nofollow" target="_blank">https://kubernetes . io/docs/concepts/configuration/config map/</a></p><p id="a740" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">5-)<a class="ae mr" href="https://12factor.net/config" rel="noopener ugc nofollow" target="_blank">https://12factor.net/config</a></p></div></div>    
</body>
</html>