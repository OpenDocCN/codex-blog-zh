<html>
<head>
<title>Big Data Analyzed Fast &amp; Easy for Python Users</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python用户可以快速轻松地分析大数据</h1>
<blockquote>原文：<a href="https://medium.com/codex/big-data-analyzed-fast-easy-for-python-users-34ab8af6fbc?source=collection_archive---------9-----------------------#2021-10-13">https://medium.com/codex/big-data-analyzed-fast-easy-for-python-users-34ab8af6fbc?source=collection_archive---------9-----------------------#2021-10-13</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/173883152c000467646504d67f14ec9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:544/format:webp/1*n0G_dp60vZdRfdJuG4yWJw.png"/></div></figure><p id="7c6b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这篇文章是写给所有热爱Pandas、Scikit-Learn、Numpy的数据科学家/分析师朋友的，他们希望将他们的分析应用于更大的数据集，而不必用另一种语言重写代码。</p><p id="5a36" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">一如既往，我将努力保持这篇文章简洁、简单和有用。我也很想收到你的来信！</p><p id="86fc" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">随着工作项目的最后期限即将到来，我们都希望进行渐进式的改变，而不是革命性的改变来完成工作，不是吗？试试Dask &amp;让我知道它如何为你工作。</p><h1 id="af27" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">达斯克，怎么了？</h1><figure class="kj kk kl km fd ij er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es ki"><img src="../Images/80359d9edcb6978138d5b50f091a5644.png" data-original-src="https://miro.medium.com/v2/resize:fit:906/format:webp/1*hcJLGvmpBhfnG0lCxR5cqg.png"/></div></div></figure><p id="db19" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><a class="ae kr" href="https://github.com/dask/dask" rel="noopener ugc nofollow" target="_blank"> Dask </a>在某种意义上类似于Spark，你可以水平扩展来处理大量数据。但这是不同的，因为Dask是用Python编写的，并且支持Pandas和Scikit这样的库——开箱即用。</p><h1 id="f1bb" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">它是如何工作的？</h1><blockquote class="ks kt ku"><p id="954b" class="im in kv io b ip iq ir is it iu iv iw kw iy iz ja kx jc jd je ky jg jh ji jj hb bi translated">Dask遵循<strong class="io hj">惰性计算</strong>机制，只有在明确请求时才会执行计算。</p></blockquote><p id="769a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">它使用numpy和pandas，从某种意义上说，它扩展了这些包来处理太大而无法保存在内存中的数据处理问题。它将较大的处理任务分解成许多由<code class="du kz la lb lc b">numpy</code>或<code class="du kz la lb lc b">pandas</code>处理的较小任务，然后将结果重新组合成一个连贯的整体。这发生在一个无缝接口的背后，该接口被设计成模仿<code class="du kz la lb lc b">numpy</code> / <code class="du kz la lb lc b">pandas</code>接口。</p><h1 id="74fc" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated"><strong class="ak"> Dask好在:</strong></h1><blockquote class="ks kt ku"><p id="50b8" class="im in kv io b ip iq ir is it iu iv iw kw iy iz ja kx jc jd je ky jg jh ji jj hb bi translated">Dask在处理千兆字节的海量数据方面比pandas和Spark等直播数据表现得更好</p><p id="b90c" class="im in kv io b ip iq ir is it iu iv iw kw iy iz ja kx jc jd je ky jg jh ji jj hb bi translated">Dask绕过了全局解释器锁(GIL ),而<strong class="io hj">通过内部分块python对象并并行处理它们来利用多CPU内核</strong>。</p><p id="ea6d" class="im in kv io b ip iq ir is it iu iv iw kw iy iz ja kx jc jd je ky jg jh ji jj hb bi translated">它提供<strong class="io hj">调试</strong>和诊断，通过仪表板，您可以看到跨机器的性能</p><p id="6872" class="im in kv io b ip iq ir is it iu iv iw kw iy iz ja kx jc jd je ky jg jh ji jj hb bi translated">一次读取多个CSV文件就像Spark一样(我很快会给你看类似的东西)</p></blockquote><p id="6627" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">DASK在单个CPU上处理大型数据集，利用单个机器或机器集群上的多个内核进行并行计算。</p><p id="7134" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">那么这对你意味着什么呢？对于喜欢在咖啡馆工作或在国家公园观鸟的人来说，使用Dask，你的整个数据集将在你喝咖啡时在一台典型的笔记本电脑上处理。</p><div class="kj kk kl km fd ab cb"><figure class="ld ij le lf lg lh li paragraph-image"><img src="../Images/88e8bea8966407cbbebcd48ea2b8bac7.png" data-original-src="https://miro.medium.com/v2/resize:fit:874/format:webp/1*eMK30pA6YKMN2pz5BvJfng.png"/></figure><figure class="ld ij lj lf lg lh li paragraph-image"><img src="../Images/2a5520c09a83e70029a1e088515eac86.png" data-original-src="https://miro.medium.com/v2/resize:fit:802/format:webp/1*M98iIeIIGYCRkuXsju87Pg.png"/><figcaption class="lk ll et er es lm ln bd b be z dx lo di lp lq translated">这就是我，想象未来的自己，原谅我。</figcaption></figure></div><p id="8e0a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在我开始之前，让我给你一个高层次的介绍，不使用任何单词。要了解更多关于Dask的信息，我鼓励您阅读<a class="ae kr" href="https://dask.org/" rel="noopener ugc nofollow" target="_blank">Dask:Python中的可伸缩分析</a>中的文档。</p><figure class="kj kk kl km fd ij er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es lr"><img src="../Images/d9a37ee330d7e2e99228e8b021146500.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7ts_7ZHqHwru2UsOmTLGwA.png"/></div></div></figure><h1 id="fe63" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated"><strong class="ak">Dask数据帧的用例:</strong></h1><p id="e66c" class="pw-post-body-paragraph im in hi io b ip ls ir is it lt iv iw ix lu iz ja jb lv jd je jf lw jh ji jj hb bi translated">为了便于说明，让我引入一些简单的代码来一次处理一部分纽约出租车数据。这是在我的S3桶休息。</p><p id="5430" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在我们的遗愿清单中，我们都有特定的旅游景点。这些地方是你愿意花任何钱去的，而且你甚至会慷慨地给带你去的人小费。</p><div class="kj kk kl km fd ab cb"><figure class="ld ij lx lf lg lh li paragraph-image"><img src="../Images/94eb4407587e207e038052e684656284.png" data-original-src="https://miro.medium.com/v2/resize:fit:610/format:webp/1*GWaSbRz7Kwws2Gh_4iXDtw.png"/></figure><figure class="ld ij ly lf lg lh li paragraph-image"><img src="../Images/f77a42bdd7227a27b88a8e1b3b0339c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:572/format:webp/1*e--RcbNR89Bdug-2gFMzwg.png"/></figure></div><p id="2e8f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我要找到人们花费超过300美元到达的所有地点，并给司机超过30%的小费。对于出租车司机来说，去这些地方是实现现金流最大化的机会。</p><p id="aaec" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果你看一下我们声明了<code class="du kz la lb lc b">Client</code>的代码，这意味着同一会话中的任何操作都将默认使用它来进行计算。通过不带任何参数地调用它，Dask自动启动一个本地集群来运行工作。这是我最喜欢Dask的一点——与为本地开发设置Spark的过程相比，我发现Dask工具的易用性是它最大的优势之一。</p><p id="0c1b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果我们检查您的对象，我们将看到对一个<code class="du kz la lb lc b">dask.Delayed</code>对象的引用，而不是我们数据的实际表示。这是因为当我们声明操作时，Dask调度程序正在懒洋洋地构建一个执行图，所以现在的对象只是Dask正在计划的步骤的一个表示。该图实际上不会计算任何东西，直到我们明确地告诉它，允许调度程序在幕后优化它的操作。</p><p id="97b1" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">回到这个关于“懒惰”的话题。只有当你在<code class="du kz la lb lc b">dask.dataframe</code>上调用<code class="du kz la lb lc b">compute</code>时，图中的所有任务才会被执行。嘣！</p><pre class="kj kk kl km fd lz lc ma mb aw mc bi"><span id="d09b" class="md jl hi lc b fi me mf l mg mh"><strong class="lc hj">import </strong>math<br/><strong class="lc hj">import </strong>numpy <strong class="lc hj">as </strong>np<br/><strong class="lc hj">import </strong>s3fs<br/><strong class="lc hj">import </strong>pandas <strong class="lc hj">as </strong>pd<br/><strong class="lc hj">from </strong>dask.distributed <strong class="lc hj">import </strong>Client<br/><strong class="lc hj">import </strong>dask.dataframe <strong class="lc hj">as </strong>dd<br/><br/>taxi_info = dd.read_csv(<br/>    <strong class="lc hj">'s3://abhinaya321/2019_yellow_trip_data.csv'</strong>,<br/><br/>    storage_options={<strong class="lc hj">'anon'</strong>: <strong class="lc hj">True</strong>, <strong class="lc hj">'use_ssl'</strong>: <strong class="lc hj">False</strong>}<br/>)<br/><br/><strong class="lc hj">def </strong>filter(df: dd.DataFrame) -&gt; dd.DataFrame:<br/>    <em class="kv">"""Process data"""<br/>    </em><strong class="lc hj">return </strong>(<br/>        df[[<br/>            <strong class="lc hj">'VendorID'</strong>,<strong class="lc hj">'PULocationID'<br/>            </strong>, <strong class="lc hj">'total_amount'</strong>,<strong class="lc hj">'fare_amount'</strong>, <strong class="lc hj">'tip_amount'<br/>        </strong>]]<br/><br/>        .assign(tip_percent=(<strong class="lc hj">lambda </strong>df: (<br/>            ( df.tip_amount)/df.fare_amount)<br/>           ))<br/><br/>        .query(<strong class="lc hj">'tip_percent &gt;= 0.3 &amp; total_amount &gt;= 200'</strong>)<br/>        <em class="kv">#.drop(['fare_Amount', 'tip_amount'], axis=1)<br/>        </em>.rename(columns={<strong class="lc hj">'PULocationID'</strong>: <strong class="lc hj">'Expensive_locations_loved_by_customers'</strong>})<br/>        .groupby([<strong class="lc hj">'Expensive_locations_loved_by_customers'</strong>])<br/>        .sum()<br/><br/><br/><br/>    )<br/><br/><strong class="lc hj">def </strong>result(df: dd.DataFrame) -&gt; pd.DataFrame:<br/>    <em class="kv">"""Execute dask task graph and compute final results"""<br/>    </em><strong class="lc hj">return </strong>(<br/>        df<br/>        .compute()<br/><br/>    )<br/><br/><strong class="lc hj">if </strong>__name__ == <strong class="lc hj">"__main__"</strong>:<br/>    client = Client()<br/><br/>    taxi_data = dd.read_csv(<br/>        <strong class="lc hj">'s3://abhinaya321/2019_yellow_trip_data.csv'</strong>,<br/>        storage_options={<strong class="lc hj">'anon'</strong>: <strong class="lc hj">True</strong>, <strong class="lc hj">'use_ssl'</strong>: <strong class="lc hj">False</strong>}<br/>    )<br/><br/>    filtered_data = filter(taxi_info)<br/>    fare = result(filtered_data)<br/><br/>    print(fare.to_string())</span></pre><figure class="kj kk kl km fd ij er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es mi"><img src="../Images/af5fde35a2f255c46e5f87312208631b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uQsywA8ok4KoLE04uaoUrw.png"/></div></div><figcaption class="lk ll et er es lm ln bd b be z dx translated">哇，有些人给了很多小费。嗯…有些交易看起来真的很可疑！！</figcaption></figure><p id="f1c0" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果您在笔记本电脑上运行这段代码，Dask会在后台的多个内核上运行任务。因此，如果你的机器上有四个内核，处理速度大约是使用<code class="du kz la lb lc b">pandas</code>的四倍。</p><p id="9763" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在单台机器上，这难道不是很好的性能提升吗？完全相同的代码运行在多达数百台机器的分布式集群上。当你放松的时候，任务调度程序会在后台处理所有的事情！</p><h1 id="0845" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">【Dask箱包的使用案例</h1><ul class=""><li id="93ff" class="mj mk hi io b ip ls it lt ix ml jb mm jf mn jj mo mp mq mr bi translated">它只是一个Python对象的并行集合，即一个更大集合的分区。通常在处理<strong class="io hj">半或非结构化数据</strong> <br/> <em class="kv">时使用，例如</em> JSON、日志文件或文本数据。此外，用户定义的python object.inclusion。</li></ul><p id="0bda" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">今天让我们来读一个JSON文件。</p><pre class="kj kk kl km fd lz lc ma mb aw mc bi"><span id="d584" class="md jl hi lc b fi me mf l mg mh"><strong class="lc hj">import </strong>dask.bag <strong class="lc hj">as </strong>db<br/><br/><strong class="lc hj">if </strong>__name__ == <strong class="lc hj">"__main__"</strong>:<br/>    client = Client()<br/><br/><br/>    print((db.read_text(<strong class="lc hj">'https://archive.analytics.mybinder.org/events-2018-11-03.jsonl'</strong>).take(3)))</span><span id="3791" class="md jl hi lc b fi ms mf l mg mh"><strong class="lc hj">Your output</strong></span><span id="ee1b" class="md jl hi lc b fi ms mf l mg mh">('{"timestamp": "2018-11-03T00:00:00+00:00", "schema": "binderhub.jupyter.org/launch", "version": 1, "provider": "GitHub", "spec": "Qiskit/qiskit-tutorial/master", "status": "success"}\n', '{"timestamp": "2018-11-03T00:00:00+00:00", "schema": "binderhub.jupyter.org/launch", "version": 1, "provider": "GitHub", "spec": "ipython/ipython-in-depth/master", "status": "success"}\n', '{"timestamp": "2018-11-03T00:00:00+00:00", "schema": "binderhub.jupyter.org/launch", "version": 1, "provider": "GitHub", "spec": "QISKit/qiskit-tutorial/master", "status": "success"}\n')</span><span id="5990" class="md jl hi lc b fi ms mf l mg mh">Process finished with exit code 0</span></pre><p id="b5dd" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">启动Dask客户端是可选的。它将启动仪表板&amp;我们可以用它来深入了解计算。</p><pre class="kj kk kl km fd lz lc ma mb aw mc bi"><span id="b255" class="md jl hi lc b fi me mf l mg mh"><strong class="lc hj">if </strong>__name__ == <strong class="lc hj">"__main__"</strong>:<br/>    client = Client(threads_per_worker=1,<br/>                n_workers=4,<br/>                memory_limit=<strong class="lc hj">'2GB'</strong>)<br/>    print(client)</span></pre><figure class="kj kk kl km fd ij er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es mt"><img src="../Images/02ca459329e0c8e7ce9a53b26f582eed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a6niiRoB-8v7AGqdELNZ4A.png"/></div></div></figure><p id="29d4" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">mybinder.org团队维护着一个索引文件，它指向所有其他可用的JSON数据文件。让我们把它转换成我们接下来要阅读的URL列表。</p><pre class="kj kk kl km fd lz lc ma mb aw mc bi"><span id="723a" class="md jl hi lc b fi me mf l mg mh"><strong class="lc hj">import </strong>json<br/><strong class="lc hj">import </strong>dask.bag <strong class="lc hj">as </strong>db<br/><strong class="lc hj">from </strong>dask.distributed <strong class="lc hj">import </strong>Client, progress<br/>print(db.read_text(<strong class="lc hj">'https://archive.analytics.mybinder.org/index.jsonl'</strong>).map(json.loads).compute())</span></pre><figure class="kj kk kl km fd ij er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es mu"><img src="../Images/b0d1b8b16d33c023bcb53773e27b5637.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kFLzF2hw2w1l9h_lDMGPAQ.png"/></div></div></figure><pre class="kj kk kl km fd lz lc ma mb aw mc bi"><span id="10cd" class="md jl hi lc b fi me mf l mg mh"><strong class="lc hj">if </strong>__name__ == <strong class="lc hj">"__main__"</strong>:<br/>    client = Client(threads_per_worker=1,<br/>                n_workers=4,<br/>                memory_limit=<strong class="lc hj">'2GB'</strong>)<br/>    <em class="kv">#print(client)<br/><br/><br/>    #print((db.read_text('https://archive.analytics.mybinder.org/events-2018-11-03.jsonl').take(3)))<br/>    #print(db.read_text('https://archive.analytics.mybinder.org/index.jsonl').map(json.loads).compute())<br/>    </em>filenames = (db.read_text(<strong class="lc hj">'https://archive.analytics.mybinder.org/index.jsonl'</strong>)<br/>               .map(json.loads)<br/>               .pluck(<strong class="lc hj">'name'</strong>)<br/>               .compute())<br/><br/>    filenames = [<strong class="lc hj">'https://archive.analytics.mybinder.org/' </strong>+ fn <strong class="lc hj">for </strong>fn <strong class="lc hj">in </strong>filenames]<br/>    print(filenames[:5])</span></pre><figure class="kj kk kl km fd ij er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es mv"><img src="../Images/e578c8b3d619ce8ad1c929b8c36046c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*knrcWRmSi52esf5d1lbW0g.png"/></div></div></figure><h2 id="a77f" class="md jl hi bd jm mw mx my jq mz na nb ju ix nc nd jy jb ne nf kc jf ng nh kg ni bi translated">创建所有事件的包</h2><p id="07d2" class="pw-post-body-paragraph im in hi io b ip ls ir is it lt iv iw ix lu iz ja jb lv jd je jf lw jh ji jj hb bi translated">我们现在在URL列表周围创建一个<a class="ae kr" href="https://docs.dask.org/en/latest/bag.html" rel="noopener ugc nofollow" target="_blank"> Dask包</a>，然后在每一行调用<code class="du kz la lb lc b">json.loads</code>函数，将这些JSON编码的文本行转换成更容易操作的Python字典。</p><pre class="kj kk kl km fd lz lc ma mb aw mc bi"><span id="fe35" class="md jl hi lc b fi me mf l mg mh">events = db.read_text(filenames).map(json.loads)<br/>print(events.take(2))</span></pre><p id="9b98" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">输出:</p><p id="39b2" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">({ '时间戳':' 2018–11–03t 00:00:00+00:00 '，' schema ':' binder hub . jupyter . org/launch '，'版本':1，' provider': 'GitHub '，' spec ':' Qiskit/Qiskit-tutorial/master '，' status': 'success'}，{ '时间戳':' 2018–11–03t 00:00+00:00 '，' schema ':' binder hub . jupyter . org/launch '，'版本':1</p><h2 id="8b53" class="md jl hi bd jm mw mx my jq mz na nb ju ix nc nd jy jb ne nf kc jf ng nh kg ni bi translated">最流行的活页夹</h2><p id="eb58" class="pw-post-body-paragraph im in hi io b ip ls ir is it lt iv iw ix lu iz ja jb lv jd je jf lw jh ji jj hb bi translated">让我们做一个简单的频率统计来找出那些运行最频繁的绑定。</p><pre class="kj kk kl km fd lz lc ma mb aw mc bi"><span id="43c0" class="md jl hi lc b fi me mf l mg mh">events.pluck('spec').frequencies(sort=<strong class="lc hj">True</strong>).take(20)</span><span id="b18f" class="md jl hi lc b fi ms mf l mg mh">(('ipython/ipython-in-depth/master', 7762385), ('jupyterlab/jupyterlab-demo/master', 2821333), ('jupyterlab/jupyterlab-demo/try.jupyter.org', 1592894), ('binder-examples/requirements/master', 456104), ('ines/spacy-io-binder/live', 331727), ('binder-examples/r/master', 234404), ('bokeh/bokeh-notebooks/master', 227438), ('DS-100/textbook/master', 221404), ('ELC/8fdc0f490b3058872a7014f01416dfb6/master', 186711), ('ines/spacy-course/binder', 184140), ('explosion/spacy-io-binder/spacy.io', 153913), ('QuantStack/xeus-cling/stable', 152866), ('joelachance/thebelab-requirements/master', 131813), ('qiskit-community/qiskit-textbook/thebe-stable', 124913), ('explosion/spacy-io-binder/live', 122298), ('SamLau95/nbinteract/master', 105686), ('Petlja/Informatika_VIII-files/master', 102967), ('Petlja/AnalizaPodatakaGim2/master', 98921), ('numba/numba-examples/master', 96241), ('binder-examples/demo-julia/master', 91046))</span></pre><h2 id="bc5f" class="md jl hi bd jm mw mx my jq mz na nb ju ix nc nd jy jb ne nf kc jf ng nh kg ni bi translated">转换为Dask数据帧</h2><p id="df3a" class="pw-post-body-paragraph im in hi io b ip ls ir is it lt iv iw ix lu iz ja jb lv jd je jf lw jh ji jj hb bi translated">最后，我们可以将我们的Python字典包转换成一个<a class="ae kr" href="https://docs.dask.org/en/latest/dataframe.html" rel="noopener ugc nofollow" target="_blank"> Dask数据帧</a>，然后进行更多类似熊猫的计算。</p><p id="c817" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们将做和上面一样的计算，现在用熊猫语法。</p><pre class="kj kk kl km fd lz lc ma mb aw mc bi"><span id="5f70" class="md jl hi lc b fi me mf l mg mh">df = events.to_dataframe()<br/>print(df.head())</span></pre><p id="fd8e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">时间戳…状态<br/>0 2018–11–03 00:00+00:00…成功<br/>1 2018–11–03 00:00+00:00…成功<br/>2 2018–11–03 00:00+00:00…成功<br/>3 2018–11–03 00:01:00+00:00…成功</p><h2 id="36d4" class="md jl hi bd jm mw mx my jq mz na nb ju ix nc nd jy jb ne nf kc jf ng nh kg ni bi translated">记忆犹新</h2><p id="2800" class="pw-post-body-paragraph im in hi io b ip ls ir is it lt iv iw ix lu iz ja jb lv jd je jf lw jh ji jj hb bi translated">这个数据集非常适合内存。让我们避免每次操作时都下载数据，而是将数据保存在本地内存中。</p><pre class="kj kk kl km fd lz lc ma mb aw mc bi"><span id="b0d8" class="md jl hi lc b fi me mf l mg mh">df = df.persist()</span></pre><h2 id="294c" class="md jl hi bd jm mw mx my jq mz na nb ju ix nc nd jy jb ne nf kc jf ng nh kg ni bi translated">调查像Gitlab这样的提供商</h2><p id="fb3f" class="pw-post-body-paragraph im in hi io b ip ls ir is it lt iv iw ix lu iz ja jb lv jd je jf lw jh ji jj hb bi translated">GitHub上大多数绑定器被指定为git仓库，但不是全部。让我们再调查一些。</p><pre class="kj kk kl km fd lz lc ma mb aw mc bi"><span id="48c4" class="md jl hi lc b fi me mf l mg mh"><strong class="lc hj">import</strong> <strong class="lc hj">urllib</strong></span><span id="a661" class="md jl hi lc b fi ms mf l mg mh">df.provider.value_counts().compute()</span></pre><figure class="kj kk kl km fd ij er es paragraph-image"><div class="er es nj"><img src="../Images/662e638d78cd8e81076309ec8c858b55.png" data-original-src="https://miro.medium.com/v2/resize:fit:846/format:webp/1*jQZoPcgWuTJDjBXXTbbu9w.png"/></div></figure><pre class="kj kk kl km fd lz lc ma mb aw mc bi"><span id="bfb7" class="md jl hi lc b fi me mf l mg mh">Gitlab = (df[df.provider == <strong class="lc hj">'Git'</strong>]<br/>.spec<br/>.apply(urllib.parse.unquote, meta=(<strong class="lc hj">'spec'</strong>, object))<br/>.value_counts()</span></pre><figure class="kj kk kl km fd ij er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es nk"><img src="../Images/ecceb60121e47759f7116f0757dcfcef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fwL7PGj_Y2FVgpN4FNJRbg.png"/></div></div></figure><p id="d6db" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这是给你的Dask Dataframe！</p><h1 id="1fb4" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated"><strong class="ak">结论</strong></h1><p id="ac42" class="pw-post-body-paragraph im in hi io b ip ls ir is it lt iv iw ix lu iz ja jb lv jd je jf lw jh ji jj hb bi translated">作为一个分布式计算和数据处理系统，Dask邀请一个<a class="ae kr" href="https://docs.dask.org/en/latest/spark.html" rel="noopener ugc nofollow" target="_blank">自然比较Spark </a>。对于numpy/pandas/sklearn用户来说，它所提供的一切都变得更容易理解、更容易和更自然，它的数组和数据帧有效地将numpy的数组和pandas的数据帧纳入了一个计算机集群。此外，由于Dask是一个原生的Python工具，安装和调试要简单得多:Dask及其相关工具可以简单地安装在一个普通的Python环境中，使用<code class="du kz la lb lc b">pip</code>或<code class="du kz la lb lc b">conda</code>，调试非常简单，这使得它在繁忙的日子里非常方便！</p></div></div>    
</body>
</html>