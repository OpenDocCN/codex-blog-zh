<html>
<head>
<title>Deducing Emails for Recruiting and Marketing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">推断招聘和营销的电子邮件</h1>
<blockquote>原文：<a href="https://medium.com/codex/email-tool-for-recruiters-and-marketers-25b7753938d5?source=collection_archive---------17-----------------------#2021-03-20">https://medium.com/codex/email-tool-for-recruiters-and-marketers-25b7753938d5?source=collection_archive---------17-----------------------#2021-03-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><h2 id="3a8d" class="hg hh hi bd b fp hj hk hl hm hn ho dx hp translated" aria-label="kicker paragraph"><a class="ae ge" href="http://medium.com/codex" rel="noopener">法典</a></h2><div class=""/><p id="7441" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">导师:陈思宁</p><figure class="jn jo jp jq fd jr er es paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="er es jm"><img src="../Images/a53266d1e2620604eeba48bc244b443b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JgMMwzOo38aUncvmKCWDdA.png"/></div></div><figcaption class="jy jz et er es ka kb bd b be z dx translated">https://hipwallpaper.com/marketing-wallpapers/<a class="ae kc" href="https://hipwallpaper.com/marketing-wallpapers/" rel="noopener ugc nofollow" target="_blank"/></figcaption></figure><h1 id="ee1d" class="kd ke hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">介绍</h1><p id="e94b" class="pw-post-body-paragraph io ip hi iq b ir lb it iu iv lc ix iy iz ld jb jc jd le jf jg jh lf jj jk jl hb bi translated">Linkedin允许招聘人员通过信息和电子邮件联系潜在的候选人。然而，这个工具不仅需要一个付费的招聘人员帐户，而且Linkedin上也不是每个人都提供他们的电子邮件。我想创建一个工具，从一个人的名字和隶属关系(公司/大学)推断出电子邮件地址。</p><figure class="jn jo jp jq fd jr er es paragraph-image"><div class="er es lg"><img src="../Images/8304ab2a423f89bfdd78ae5ca5f97e52.png" data-original-src="https://miro.medium.com/v2/resize:fit:1086/format:webp/1*aSRQ5wo7rnH1grw7SDtsTA.png"/></div><figcaption class="jy jz et er es ka kb bd b be z dx translated">【https://resources.workable.com/tutorial/recruiting-linkedin T4】</figcaption></figure><h1 id="f587" class="kd ke hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">它是如何工作的</h1><p id="8e97" class="pw-post-body-paragraph io ip hi iq b ir lb it iu iv lc ix iy iz ld jb jc jd le jf jg jh lf jj jk jl hb bi translated">给定一个人的姓名和所属机构，我的工具将基于从已知电子邮件中获得的模板生成一封电子邮件。</p><p id="ba8c" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">例如，如果我是sophiezhao@fb.com脸书公司的一名员工，我的电子邮件看起来可能会像这样。我的Python代码会推断出[first_name][last_name]@fb.com是脸书邮件的<strong class="iq hs">模板</strong>。然后，它将能够生成一封电子邮件的约翰史密斯作为johnsmith@fb.com。注意邮件格式为handle.domain(需要给我们公司的<strong class="iq hs">域</strong><em class="lh">fb.com</em>才能推导出<strong class="iq hs">句柄</strong> <em class="lh"> johnsmith)。</em></p><p id="546b" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">我们首先从已知的电子邮件(<strong class="iq hs">播种电子邮件</strong>)中推导出模板，这些模板保存在以我们个人联系人的电子邮件为起点的数据库中:</p><figure class="jn jo jp jq fd jr er es paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="er es li"><img src="../Images/86d125b7de712652d5089eb24db9e0d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WLqHU4nNzQxQh7G7xFh3Fg.png"/></div></div><figcaption class="jy jz et er es ka kb bd b be z dx translated">基于种子数据库从模板生成电子邮件的示例</figcaption></figure><p id="a476" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">为此，我使用了Python中的各种库和函数。首先，我使用了一个从Gmail下载的电子表格，其中包含了人们的姓名和电子邮件信息。这些数据需要在一个<strong class="iq hs"> CSV </strong>文件中进行清理，以删除空条目和不存在的名称，如“通知”或“2293ef1a80fb00de1631299”接下来，我将这些数据保存到一个包含<strong class="iq hs">个人资料</strong>的字典中，该字典将每个人的信息映射到他们的电子邮件来自的<strong class="iq hs">公司</strong>。最后，Python算法从这些配置文件中生成模板，并将它们映射到每个公司的电子邮件域。这些模板允许我假设一个人的电子邮件地址，只要我知道他们的名字和公司的域名。</p></div><div class="ab cl lj lk gp ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="hb hc hd he hf"><h1 id="1302" class="kd ke hi bd kf kg lq ki kj kk lr km kn ko ls kq kr ks lt ku kv kw lu ky kz la bi translated">正在清除种子数据库中的数据</h1><p id="5617" class="pw-post-body-paragraph io ip hi iq b ir lb it iu iv lc ix iy iz ld jb jc jd le jf jg jh lf jj jk jl hb bi translated">Gmail保存了我以前发过邮件的人的数据。通过将我的联系人导出到Google CSV，我拥有了一个包含联系人姓名和电子邮件的电子表格。</p><figure class="jn jo jp jq fd jr er es paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="er es lv"><img src="../Images/8bf8a7b068073b69d641bd4a0131faa5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iEYK__6dB8mToduP8bl5-w.png"/></div></div><figcaption class="jy jz et er es ka kb bd b be z dx translated">从应用程序中导出Gmail联系人</figcaption></figure><p id="5a00" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">但是，该文件没有每个用户的准确名称，许多条目是空的。原因有很多:谷歌没有所有人的所有可能信息，有些人会用化名，很多邮件来自销售或自动回复机。因此，<strong class="iq hs">我需要清理数据，直到它只包含已知的全名、名、姓和电子邮件。</strong></p><p id="f9a4" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">我首先从Gmail中读取CSV文件中的原始数据。编码语句允许程序读取文件中的所有字符。</p><pre class="jn jo jp jq fd lw lx ly lz aw ma bi"><span id="4cc9" class="mb ke hi lx b fi mc md l me mf">import csv<br/>csv = csv.reader(open('Gmail-contacts', encoding='utf-8'))</span></pre><p id="740f" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">我删除了数据的第一行，这是每一列的标签。然后，我编写了两个函数来检查1)空条目和2)非字母名称。</p><pre class="jn jo jp jq fd lw lx ly lz aw ma bi"><span id="6294" class="mb ke hi lx b fi mc md l me mf"><em class="lh">#</em><strong class="lx hs"><em class="lh">checks if null value exists in row</em></strong><em class="lh"><br/></em>def isNotNull():<br/>    if row[0] != <strong class="lx hs">'' </strong>and row[1] != <strong class="lx hs">'' </strong>and row[2] != <strong class="lx hs">'' </strong>and row[3] != <br/>    <strong class="lx hs">''</strong>:<br/>        return True<br/>    return False<br/><br/><em class="lh">#</em><strong class="lx hs"><em class="lh">checks if first and last name are string</em></strong><em class="lh"><br/></em>def rowIsString():<br/>    if all(x.isalpha() or x.isspace() for x in row[0]) and<br/>    row[1].isalpha() and row[2].isalpha():<br/>        return True<br/>    return False</span></pre><p id="0461" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">为了删除别名或非真实姓名，我使用了names_dataset中的NameDataset，它可以在下面的github页面中找到:【https://github.com/philipperemy/name-dataset<a class="ae kc" href="https://github.com/philipperemy/name-dataset" rel="noopener ugc nofollow" target="_blank"/></p><pre class="jn jo jp jq fd lw lx ly lz aw ma bi"><span id="a030" class="mb ke hi lx b fi mc md l me mf">from names_dataset import NameDataset<br/>n = NameDataset()</span></pre><p id="6e1f" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">该数据集检查Gmail给出的名字和姓氏是否是现有的名字，而不是像“回复”或“通知”这样的词或像“2293ef1a80fb00de1631299”这样的随机字符串</p><pre class="jn jo jp jq fd lw lx ly lz aw ma bi"><span id="d3d9" class="mb ke hi lx b fi mc md l me mf">#<strong class="lx hs"><em class="lh">checks if firstname is a known first name<br/></em></strong>n.search_first_name(firstname)</span><span id="23c7" class="mb ke hi lx b fi mg md l me mf">#<strong class="lx hs"><em class="lh">checks if lastname is a known last name<br/></em></strong>n.search_last_name(lastname)</span></pre><p id="4032" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">接下来，下面的代码使用这些清理函数在字典中生成人的配置文件。</p><pre class="jn jo jp jq fd lw lx ly lz aw ma bi"><span id="d15d" class="mb ke hi lx b fi mc md l me mf">profiles = [] #<strong class="lx hs"><em class="lh">list of dictionary of profiles<br/></em></strong>domain_handle = {} #<strong class="lx hs"><em class="lh">dictionary that maps domains to handles</em></strong></span><span id="8e3c" class="mb ke hi lx b fi mg md l me mf">for row in csv:</span><span id="3fb8" class="mb ke hi lx b fi mg md l me mf">    profile = {"name": row[0].lower(), "firstname": row[1].lower(), <br/>    "lastname": row[2].lower(), "email": row[3].lower(), "handle": <br/>    row[3].split("@")[0].lower(), "domain": row[3].split("@")<br/>    [1].lower()}</span><span id="f55d" class="mb ke hi lx b fi mg md l me mf">    profiles.append(profile)<br/>    domain = profile["domain"]</span><span id="21e0" class="mb ke hi lx b fi mg md l me mf">    #<strong class="lx hs"><em class="lh">mapping profiles to domains<br/>    </em></strong>if domain in domain_handle.keys():<br/>        domain_handle[domain].append(profile)<br/>    else:<br/>        domain_handle[domain] = [profile]</span></pre><p id="f38c" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">配置文件的示例:</p><pre class="jn jo jp jq fd lw lx ly lz aw ma bi"><span id="289e" class="mb ke hi lx b fi mc md l me mf">#<strong class="lx hs"><em class="lh">dictionary containing a person's full name, first name, last name, and email information.</em></strong></span><span id="0251" class="mb ke hi lx b fi mg md l me mf">{"name": "sophie zhao",<br/>"firstname": "sophie",<br/>"lastname": "zhao",<br/>"email": "sophiezhao@fb.com",<br/>"handle": "sophiezhao",<br/>"domain": "fb.com"}</span></pre><p id="7691" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">以及domain_handle字典中的一个示例键值对:</p><pre class="jn jo jp jq fd lw lx ly lz aw ma bi"><span id="0015" class="mb ke hi lx b fi mc md l me mf">#<strong class="lx hs"><em class="lh">mapping email domains to their profiles</em></strong></span><span id="ff1e" class="mb ke hi lx b fi mg md l me mf">{"fb.com":[{"name": "sophie zhao", "firstname": "sophie",<br/>            "lastname": "zhao", "email": "sophiezhao@fb.com", <br/>            "handle": "sophiezhao", "domain": "fb.com"},</span><span id="133f" class="mb ke hi lx b fi mg md l me mf">           {"name": "sining chen", "firstname": "sining",<br/>            "lastname": "chen", "email": "s.chen@company.com",<br/>            "handle": "siningchen", "domain": "company.com"}]}</span></pre><p id="0662" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">在将每个人的信息分类到这样的字典中之后，我可以继续为每个领域生成模板。</p><h2 id="2f74" class="mb ke hi bd kf mh mi mj kj mk ml mm kn iz mn mo kr jd mp mq kv jh mr ms kz ho bi translated">正在生成句柄模板</h2><p id="edab" class="pw-post-body-paragraph io ip hi iq b ir lb it iu iv lc ix iy iz ld jb jc jd le jf jg jh lf jj jk jl hb bi translated">为了从每个电子邮件句柄生成一个模板，我按照字符类型来分隔句柄。这允许我根据句柄是字符串、特殊字符还是数字来分别识别句柄的每个部分。这使用Python的正则表达式(regex)库来分离不同类型的字符。</p><pre class="jn jo jp jq fd lw lx ly lz aw ma bi"><span id="d605" class="mb ke hi lx b fi mc md l me mf">import re</span><span id="b8a3" class="mb ke hi lx b fi mg md l me mf">def chartype(char):</span><span id="56a8" class="mb ke hi lx b fi mg md l me mf">    #<strong class="lx hs"><em class="lh">checks if char is in the alphabet<br/></em></strong>    if re.findall("[a-zA-Z]", char.lower()):<br/>        return "string"</span><span id="6b20" class="mb ke hi lx b fi mg md l me mf">    #<strong class="lx hs"><em class="lh">checks if char is any of the listed special characters<br/></em></strong>    elif char in "!#$%&amp;'*+-/=?^_`{|}~.":<br/>        return "special"</span><span id="699f" class="mb ke hi lx b fi mg md l me mf">    #<strong class="lx hs"><em class="lh">otherwise, char is a number<br/></em></strong>    else:<br/>        return "num"</span></pre><p id="a865" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">当我遍历句柄时，它会在两个相邻字符的字符类型不同的地方进行拆分。</p><pre class="jn jo jp jq fd lw lx ly lz aw ma bi"><span id="8423" class="mb ke hi lx b fi mc md l me mf">split_handle = [] #<strong class="lx hs"><em class="lh">list of handle parts split by character type</em></strong></span><span id="19f4" class="mb ke hi lx b fi mg md l me mf">for i in range(len(handle) - 1):<br/>    if chartype(handle[i]) != chartype(handle[i + 1]):<br/>        split_handle.append(handle_copy[start:i + 1])<em class="lh"><br/>        </em>start = i + 1<br/>split_handle.append(handle_copy[start:])</span></pre><p id="4cfb" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">示例:</p><p id="56d7" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">sophie.zhao → [“苏菲”，“.”，“赵”]</p><p id="4aff" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">sophiezhao70 → ["sophiezhao "，" 70"]</p><p id="a10a" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">我现在可以单独处理手柄的每个部分来创建模板。电子邮件句柄的每个部分可以是字符串、特殊字符或数字。</p><p id="7fac" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated"><strong class="iq hs">案例一:手柄部分是一根绳子</strong></p><p id="3d55" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">我假设句柄中的字符串是由这个人的名字、姓氏、两者或他们名字的一部分组成的。因此，模板需要反映每个名字在句柄中有多少个字符以及顺序。</p><p id="bb5a" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">苏菲·赵的例子:</p><p id="0b62" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">Handle: <strong class="iq hs"> zsoph </strong> →姓氏的1个字母，名字的4个字母</p><p id="800f" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">模板:[["姓氏"，1]，["名字"，4]]</p><p id="51a3" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">句柄:<strong class="iq hs">赵</strong> →姓氏全称(使用长度0)</p><p id="c4f4" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">模板:[["姓氏"，0]]</p><p id="dea2" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">我用了两个函数来推导字符串的模板。</p><p id="cc81" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">1.<strong class="iq hs"> num_match(haystack，needle) </strong>在一个较长的字符串<em class="lh"> haystack中查找子字符串<em class="lh"> needle </em>。</em>该函数将返回存在于句柄部分的名字的长度。我会发现在<em class="lh"> zsoph </em>中有4个字母<em class="lh"> sophie </em>。注意，这个函数假设我们只取干草堆的第一部分。我做这个假设是基于电子邮件通常不使用名字的中间或结尾作为句柄(更有可能是<em class="lh"> zsoph </em>而不是z <em class="lh"> phie </em>)。</p><pre class="jn jo jp jq fd lw lx ly lz aw ma bi"><span id="e8c8" class="mb ke hi lx b fi mc md l me mf">def num_match(haystack, needle):<br/>    if needle[0] in haystack:<br/>        for i in range(len(needle)+1):<br/>            needle_part = needle[:len(needle)-i+1]<br/>            start = haystack.find(needle_part)<br/>            if start &gt; -1:<br/>                return len(needle_part)<br/>    return 0</span></pre><p id="b0e6" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">2.<strong class="iq hs"> matchname(string) </strong>最后将字符串的识别部分按顺序添加到模板中。</p><pre class="jn jo jp jq fd lw lx ly lz aw ma bi"><span id="11ea" class="mb ke hi lx b fi mc md l me mf">def matchname(string):<br/>    template = []<br/>    match_len = num_match(string, profile["firstname"])<br/>    #<strong class="lx hs"><em class="lh">checks if the part of the first name identified comes <br/>    before or after the part of the last name<br/></em></strong>    if string[:match_len] == profile["firstname"][:match_len]:<br/>        template.append(["firstname", match_len])<br/>        template.append(["lastname", len(string)-match_len])<br/>    else:<br/>        template.append(["lastname", len(string) - match_len])<br/>        template.append(["firstname", match_len])<br/>    return template</span></pre><p id="c8d7" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated"><strong class="iq hs">情况2:手柄部分是特殊字符</strong></p><p id="ebf7" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">对于特殊字符，模板的相应部分将只是该特殊字符。</p><p id="fd83" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">示例:</p><p id="871a" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">sophie.zhao → [["firstname "，0]，" "，["姓氏"，0]]</p><p id="e711" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated"><strong class="iq hs">情况3:手柄部分是一个数字</strong></p><p id="fe8f" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">在处理数字时，我用“num”来表示句柄中有多少个数字。在生成未来的电子邮件时，num值将被替换为0。这是因为程序无法推断出这些数字的来源。这些数字可以用来区分不同姓名的人，或者只是随机的。所以，我干脆用0做占位符。</p><p id="93cc" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">示例:</p><p id="0ed7" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">sophiezhao70 → [["名字"，0]，["姓氏"，0]，["数字"，2]]</p><p id="fa0a" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">下面的代码将句柄的每个部分翻译成它们在模板中相应的位置。</p><pre class="jn jo jp jq fd lw lx ly lz aw ma bi"><span id="117b" class="mb ke hi lx b fi mc md l me mf">for element in split_handle:</span><span id="d0db" class="mb ke hi lx b fi mg md l me mf">    if chartype(element[0]) == "string":<br/>        for i in range(len(matchname(element))):<br/>            template.append(matchname(element)[i])</span><span id="e9c7" class="mb ke hi lx b fi mg md l me mf">    elif element[0] in "!#$%&amp;'*+-/=?^_`{|}~.":<br/>        template.append(element)</span><span id="6538" class="mb ke hi lx b fi mg md l me mf">    else:<br/>        template.append(["num", len(element)])</span></pre><p id="ee35" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated"><strong class="iq hs">补充说明:</strong>如果算法找不到一个名字的实例，那么它的长度将是0，所以我把它们去掉了。此外，如果名字的一部分实际上是完整的名或姓，我将长度替换为0，以表示应该使用完整的长度。</p><p id="fd6f" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">一旦每个句柄被转换成模板并映射到相应的域，我就可以使用这些模板来生成新的电子邮件地址。</p><h2 id="5afc" class="mb ke hi bd kf mh mi mj kj mk ml mm kn iz mn mo kr jd mp mq kv jh mr ms kz ho bi translated">生成新电子邮件</h2><figure class="jn jo jp jq fd jr er es paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="er es mt"><img src="../Images/68d8e3b37896e07d7bb8f79bb1bad382.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9iYrQi2aADswPZy5YwmVHQ.png"/></div></div><figcaption class="jy jz et er es ka kb bd b be z dx translated"><a class="ae kc" href="https://marketingland.com/7-email-trends-die-2016-160925" rel="noopener ugc nofollow" target="_blank">https://marketingland.com/7-email-trends-die-2016-160925</a></figcaption></figure><p id="4ec2" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">生成一封电子邮件的先决条件是要有这个人的名字，姓氏和公司的电子邮件域。假设我有一个域句柄的模板，我可以根据我所拥有的人名和域模板的信息简单地转换每个部分。</p><pre class="jn jo jp jq fd lw lx ly lz aw ma bi"><span id="14c3" class="mb ke hi lx b fi mc md l me mf">#<strong class="lx hs"><em class="lh">domain_template is a dictionary of templates mapped to domains</em></strong></span><span id="728a" class="mb ke hi lx b fi mg md l me mf">#<strong class="lx hs"><em class="lh">profile is where I would store the information of the person whom I'm generating an email for.</em></strong></span><span id="6cb2" class="mb ke hi lx b fi mg md l me mf">#<strong class="lx hs"><em class="lh">Generates all possible emails based on templates that exist for each domain</em></strong></span><span id="49f2" class="mb ke hi lx b fi mg md l me mf">for template in domain_template[profile['domain']]:</span><span id="293f" class="mb ke hi lx b fi mg md l me mf">    email_handle = ""</span><span id="96f3" class="mb ke hi lx b fi mg md l me mf">    for element in template:<br/>        try:<br/>            #<strong class="lx hs"><em class="lh">if part is a special character, simply add the <br/>            element to the handle<br/>            </em></strong>email_handle = email_handle + element</span><span id="4df7" class="mb ke hi lx b fi mg md l me mf">        except:<br/>            length = element[1]<br/>            #<strong class="lx hs"><em class="lh">add 0s in instances of numbers<br/></em></strong>            if element[0] == "num":<br/>                email_handle = email_handle + "0"*length</span><span id="0e8e" class="mb ke hi lx b fi mg md l me mf">            #<strong class="lx hs"><em class="lh">add full or parts of first and last names <br/></em></strong>           elif length == 0:<br/>                part = profile[element[0]]<br/>                email_handle = email_handle + part</span><span id="69a8" class="mb ke hi lx b fi mg md l me mf">            else:<br/>                part = profile[element[0]]<br/>                email_handle = email_handle + part[:length]</span><span id="ec7c" class="mb ke hi lx b fi mg md l me mf">    #<strong class="lx hs"><em class="lh">finally, add on given domain</em></strong><br/>    email = email_handle + "@" + email_domain</span></pre><p id="31db" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">全名约翰·史密斯的例子:</p><p id="0b3a" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">[["名字"，0]，" "，["姓氏"，0]]→john.smith@fb.com</p><p id="9172" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">[["姓氏"，2]，["名字"，4]，["数字"，2]]→smjohn00@fb.com</p><p id="15fe" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">有了这个算法，我可以成功地根据人们的姓名和公司域名，生成他们的电子邮件地址的假设。</p></div><div class="ab cl lj lk gp ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="hb hc hd he hf"><h1 id="008c" class="kd ke hi bd kf kg lq ki kj kk lr km kn ko ls kq kr ks lt ku kv kw lu ky kz la bi translated">接通率</h1><p id="901c" class="pw-post-body-paragraph io ip hi iq b ir lb it iu iv lc ix iy iz ld jb jc jd le jf jg jh lf jj jk jl hb bi translated">我的成功宣言中的关键词是“假设”。一路上，我做了许多假设，而且如果没有过多的信息和细节，我根本无法推断出电子邮件地址的因素。</p><p id="2aec" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">我的电子邮件地址数据集包含405个可测试的电子邮件地址。我用这个数据集创建了模板，然后用相同的电子邮件地址测试模板，看看我是否能复制它们。</p><p id="acfa" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">使用所有的邮件，我可以成功地复制出<strong class="iq hs"> 45.9% </strong>封邮件。</p><p id="3909" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">然后我只使用了以. edu结尾的131封邮件，换句话说，我只测试了大学机构的邮件，这排除了带有Gmail和雅虎域名以及其他公司的个人邮件。</p><p id="8d9e" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">使用来自大学机构的电子邮件，成功率为<strong class="iq hs"> 48.1 </strong> %。</p><figure class="jn jo jp jq fd jr er es paragraph-image"><div class="er es mu"><img src="../Images/172febcd0c0d25904cc98f02d6899ef3.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*1-p0iIiTB2XMezpMUvSRag.jpeg"/></div><figcaption class="jy jz et er es ka kb bd b be z dx translated">【https://clipartstation.com/steps-to-success-clipart-9/ T4】</figcaption></figure><p id="8055" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">虽然第二个成功率看起来差别不大，但它要准确得多。45.9%的第一成功率包括个人邮件。我的算法为每个域名存储了所有可能的模板，所以它为Gmail和Yahoo地址生成了许多模板。因此，虽然它可以成功地复制这些电子邮件，但正确的电子邮件将隐藏在十几个其他可能性中。另一方面。edu的电子邮件格式较少变化，这使得成功率更有意义，在现实世界中可能更准确。</p><p id="8218" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">这导致我们进入我的程序的限制和假设。</p><h1 id="b1e6" class="kd ke hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">限制和假设</h1><p id="9f67" class="pw-post-body-paragraph io ip hi iq b ir lb it iu iv lc ix iy iz ld jb jc jd le jf jg jh lf jj jk jl hb bi translated">虽然该程序可以成功地生成模板并复制不到50%的电子邮件，但它存在以下假设和限制的缺陷。</p><h2 id="9185" class="mb ke hi bd kf mh mi mj kj mk ml mm kn iz mn mo kr jd mp mq kv jh mr ms kz ho bi translated">1.多种可能性</h2><p id="c30c" class="pw-post-body-paragraph io ip hi iq b ir lb it iu iv lc ix iy iz ld jb jc jd le jf jg jh lf jj jk jl hb bi translated">如前所述，该程序根据我为每个域找到的模板为每个人生成可能的电子邮件。因此，我们实际上不知道哪个电子邮件是正确的。然而，如果你不介意通过电子邮件发送所有的可能性，这不是一个大问题，因为正确的可能就在其中。</p><figure class="jn jo jp jq fd jr er es paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="er es mv"><img src="../Images/518ca4130c471faf660bd06ea8b79073.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rl5XpY4a-6e4UvNnsWet-g.png"/></div></div><figcaption class="jy jz et er es ka kb bd b be z dx translated"><a class="ae kc" href="https://www.pngkey.com/detail/u2q8w7o0o0q8o0o0_dice-vector/" rel="noopener ugc nofollow" target="_blank">https://www.pngkey.com/detail/u2q8w7o0o0q8o0o0_dice-vector/</a></figcaption></figure><h2 id="d78e" class="mb ke hi bd kf mh mi mj kj mk ml mm kn iz mn mo kr jd mp mq kv jh mr ms kz ho bi translated">2.任意数字</h2><p id="054e" class="pw-post-body-paragraph io ip hi iq b ir lb it iu iv lc ix iy iz ld jb jc jd le jf jg jh lf jj jk jl hb bi translated">试图生成电子邮件的一个主要障碍是数字。由于确定一个人的电子邮件中数字的原因非常困难，有时甚至不可能，这就限制了模板。例如，如果约翰·史密斯的电子邮件是johnsmith7@fb.com，数字7可能是随机的，约翰的偏好，或者基于生成脸书电子邮件的系统，但本质上我不知道7来自哪里。因此，成功率会因每个电子邮件模板而降低，包括需要用0替换的数字。</p><h2 id="ba1d" class="mb ke hi bd kf mh mi mj kj mk ml mm kn iz mn mo kr jd mp mq kv jh mr ms kz ho bi translated">3.别名</h2><p id="00d7" class="pw-post-body-paragraph io ip hi iq b ir lb it iu iv lc ix iy iz ld jb jc jd le jf jg jh lf jj jk jl hb bi translated">尤其是对于私人邮件，一个人的邮箱地址也不一定反映他的真实姓名。这些案例包括像magic.unicorn@gmail.com这样的网络别名和像j.m.smith@gmail.com这样的名字变体，其中第一个“m”来自约翰的中间名，这一点没有被考虑在内。具体到我的数据，有很多邮件使用了一个人的本名，而Gmail只给了我他们的英文名。这些都是导致算法不准确的问题。</p></div><div class="ab cl lj lk gp ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="hb hc hd he hf"><h1 id="e0ec" class="kd ke hi bd kf kg lq ki kj kk lr km kn ko ls kq kr ks lt ku kv kw lu ky kz la bi translated">摘要</h1><p id="dd63" class="pw-post-body-paragraph io ip hi iq b ir lb it iu iv lc ix iy iz ld jb jc jd le jf jg jh lf jj jk jl hb bi translated">最终，对于那些电子邮件纯粹由一个人的名字、姓氏和特殊字符组成的公司和直觉来说，我的程序取得了巨大的成功。然而，由于电子邮件的复杂性，该计划的成功率下降。这个故事展示了我在Linkedin的招聘工具的启发下推断电子邮件的尝试。</p><figure class="jn jo jp jq fd jr er es paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="er es mw"><img src="../Images/2655f355e19bc3fd54f66a3c50b69ebb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*US-9b3JMQvY3ekH2rxInSg.png"/></div></div><figcaption class="jy jz et er es ka kb bd b be z dx translated"><a class="ae kc" href="https://www.pinclipart.com/maxpin/TRxbT/" rel="noopener ugc nofollow" target="_blank">https://www.pngkey.com/detail/u2q8w7o0o0q8o0o0_dice-vector/</a></figcaption></figure><h1 id="d244" class="kd ke hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">后续步骤</h1><p id="5f09" class="pw-post-body-paragraph io ip hi iq b ir lb it iu iv lc ix iy iz ld jb jc jd le jf jg jh lf jj jk jl hb bi translated">理想情况下，一个web应用程序将接受一个人的全名和公司，并推断出他们的电子邮件。该应用程序必须由一个大型数据库支持，该数据库已经为必要的公司及其域推导出模板。</p><p id="608a" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">也许通过为该程序可以成功推断的电子邮件类型设置更多指导原则，该算法在关注某一类别的机构时会有更高的成功率。这是一个值得进一步研究的课题。</p><p id="4cfa" class="pw-post-body-paragraph io ip hi iq b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl hb bi translated">此外，这个故事中没有包括的一个因素是公司与其领域的联系。通常，我们知道某人的名字和公司，但是与他们公司相关的电子邮件域是什么？因此，一个额外的层将从公司的名称中得出公司的域名，这可能使用类似的策略，如正则表达式和字符串相似性。</p></div></div>    
</body>
</html>