<html>
<head>
<title>Async and Distributed Python Server with Uvicorn, Starlette and Ray</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带有Uvicorn、Starlette和Ray的异步分布式Python服务器</h1>
<blockquote>原文：<a href="https://medium.com/codex/async-and-distributed-python-server-with-uvicorn-starlette-and-ray-185828ad2555?source=collection_archive---------6-----------------------#2021-08-06">https://medium.com/codex/async-and-distributed-python-server-with-uvicorn-starlette-and-ray-185828ad2555?source=collection_archive---------6-----------------------#2021-08-06</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/7ac830baad6b0df190c0d3af72449f97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*33BSfncAgxHAc14flTcgPA.jpeg"/></div></div></figure><p id="3641" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Python目前在数据科学领域占据主导地位，因此许多公司都在用它构建服务器应用程序。 <strong class="is hj"> <em class="jo">异步Python</em></strong><em class="jo"/><strong class="is hj"><em class="jo">uvicon</em></strong><em class="jo"/><strong class="is hj"><em class="jo">Starlette</em></strong><em class="jo">和</em><strong class="is hj"><em class="jo">Ray</em></strong><em class="jo">是创建可伸缩的分布式服务器应用的绝佳机会。</em></p><h2 id="5b46" class="jp jq hi bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj bi translated">介绍</h2><p id="5505" class="pw-post-body-paragraph iq ir hi is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hb bi translated">作为一名系统架构师，我经常担心我们所做的是否是“可伸缩的”。但这意味着什么呢？可伸缩性有许多方面，它高度依赖于应用程序环境。例如，与服务静态网站相比，移动应用的后端可伸缩性有着非常不同的要求。我所关心的那种应用</p><ul class=""><li id="7133" class="kp kq hi is b it iu ix iy jb kr jf ks jj kt jn ku kv kw kx bi translated">通常基于网络；</li><li id="0cbf" class="kp kq hi is b it ky ix kz jb la jf lb jj lc jn ku kv kw kx bi translated">有几个用户；</li><li id="a704" class="kp kq hi is b it ky ix kz jb la jf lb jj lc jn ku kv kw kx bi translated">并且经常处理数据。</li></ul><p id="3d5a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">数据处理的后端通常是用Python而不是更快的Java编写的。</p><p id="27bc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">三年前，我去了伦敦的PyCon。我震惊地发现，包括银行在内的许多组织都在运行用Python编写的服务器应用程序。很公平，银行没有用它们来进行纳秒级的高频交易，但我一直认为这些家伙只使用Java或者更快的东西，比如C++。</p><p id="5202" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如今，我们还为客户提供用Python编写的后端。在处理数据时，这种语言是非常宝贵的，数据科学家喜欢它。任何与数据科学家一起工作的人都理解将他们的Python脚本转换成可以在生产中运行的东西的痛苦。想象一下，必须把每一个剧本翻译成不同的语言，混乱就完成了。每次我这样做的时候，我发誓下次我会照原样运行脚本！</p><p id="dbbc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Python并不是最快的选择，但当涉及到处理数据时，用户习惯于等待比加载网页更长的时间。所以至少现在，这种语言将继续主导数据处理、争论、人工智能等。</p><p id="be5f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">例如，Instagram多年来在Python服务器上进行了大量投资。例如，他们发布了自己的Python 3.8编译，试图提高服务器的性能:</p><blockquote class="ld le lf"><p id="6b2c" class="iq ir jo is b it iu iv iw ix iy iz ja lg jc jd je lh jg jh ji li jk jl jm jn hb bi translated">Cinder是Instagram内部面向性能的CPython 3.8量产版。(<a class="ae lj" href="https://github.com/facebookincubator/cinder" rel="noopener ugc nofollow" target="_blank">来源</a>)</p><p id="c172" class="iq ir jo is b it iu iv iw ix iy iz ja lg jc jd je lh jg jh ji li jk jl jm jn hb bi translated">Instagram服务器是一个几百万行的Python庞然大物，移动速度很快。(<a class="ae lj" href="https://instagram-engineering.com/python-at-scale-strict-modules-c0bb9245c834" rel="noopener ugc nofollow" target="_blank">来源</a>)</p></blockquote><p id="69ae" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">好吧，但是为来自Python服务器的中等数量的请求提供服务怎么样呢？Python不是单线程的吗？是的，这是一个问题。幸运的是，这个问题有一些可能的解决方案。</p><h2 id="e9ba" class="jp jq hi bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj bi translated"><a class="ae lj" href="https://www.uvicorn.org/" rel="noopener ugc nofollow" target="_blank">uv icon</a>+<a class="ae lj" href="https://www.starlette.io/" rel="noopener ugc nofollow" target="_blank">Starlette</a>+async进行加工</h2><p id="61c1" class="pw-post-body-paragraph iq ir hi is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hb bi translated">异步服务器很容易推理，它们使得从一个CPU中获取更多资源变得简单。当服务器等待HTTP请求返回时，它可以处理其他任务。就这么简单。下面是一个简单的异步Uvicorn服务器示例:</p><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="32a3" class="jp jq hi lp b fi lt lu l lv lw">from starlette.applications import Starlette<br/>from starlette.requests import Request<br/>from starlette.responses import JSONResponse, PlainTextResponse<br/>from starlette.routing import Route</span><span id="9714" class="jp jq hi lp b fi lx lu l lv lw">async def homepage(req: Request):<br/>    return PlainTextResponse("ok: service is running")</span><span id="9fcf" class="jp jq hi lp b fi lx lu l lv lw">async def echo(req: Request):<br/>    try:<br/>        res = await req.json()</span><span id="9732" class="jp jq hi lp b fi lx lu l lv lw">    except Exception as err:<br/>        res = {"message": "failed JSON message"}</span><span id="6d27" class="jp jq hi lp b fi lx lu l lv lw">    return JSONResponse(res)</span><span id="189e" class="jp jq hi lp b fi lx lu l lv lw">app = Starlette(<br/>    debug=True,<br/>    routes=[<br/>        Route("/", homepage, methods=["GET"]),<br/>        Route("/echo", echo, methods=["POST"]),<br/>    ],<br/>)</span></pre><p id="2eb5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">要启动该服务器，您只需运行以下命令:</p><p id="d3fa" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du ly lz ma lp b">uvicorn main:app --workers 2</code></p><p id="134f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">假设上面的脚本在一个名为<code class="du ly lz ma lp b">main.py</code>的文件中。</p><p id="360c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">恭喜你。您刚刚启动了一个包含三个Python进程、主进程和两个worker/children的HTTP服务器。使用worker很有帮助，因为它们是独立的python进程，如果一个worker很忙，另一个worker可以处理传入的请求。Uvicorn似乎对可以启动的工作线程数量没有限制，但是每个工作线程都是一个独立的进程，不管当前的服务器负载如何，它都会占用资源。每个进程也异步执行请求。</p><p id="60cc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当服务器需要做一些繁重的工作时，例如处理大量数据、运行ETL等，这些工作人员就会出现问题。工作器是用来处理请求的，所以像ETLs这样长时间运行的东西是个坏主意。它们设计了一个响应分钟级请求的超时，这对请求有意义，但对更长的计算没有意义。输入ray.io！</p><h2 id="745f" class="jp jq hi bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj bi translated"><a class="ae lj" href="https://ray.io/" rel="noopener ugc nofollow" target="_blank">面向分布式计算的Ray.io </a></h2><p id="d642" class="pw-post-body-paragraph iq ir hi is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hb bi translated">Ray是Python生态系统中相对较新的成员。我认为是在2018年首次公开宣布。Ray填补了一个重要的空白，即在集群中编排多个python进程的能力。它是专门为处理大量数据进行ML训练而设计的。Ray允许您用自己的资源启动一个actor进程，并耐心等待结果变得可用。</p><p id="d668" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一个合理的场景是向服务器发送请求来运行ETL过程。请求会立即得到“ok，ETL正在运行”的回答，而实际的数据处理工作则交给了Ray，用户可以稍后回来检查结果。Ray本身可以根据需求无缝扩展。</p><p id="f994" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是一个简单的例子，展示了如何创建一个使用光线演员的Uvicorn服务器。</p><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="69dc" class="jp jq hi lp b fi lt lu l lv lw">import ray<br/>from starlette.applications import Starlette<br/>from starlette.responses import JSONResponse, PlainTextResponse<br/>from starlette.routing import Route<br/>from starlette.requests import Request</span><span id="7d63" class="jp jq hi lp b fi lx lu l lv lw"><a class="ae lj" href="http://twitter.com/ray" rel="noopener ugc nofollow" target="_blank">@ray</a>.remote<br/>class EchoActor(object):<br/>    def __init__(self):<br/>        pass</span><span id="85a4" class="jp jq hi lp b fi lx lu l lv lw">def response(self, jsonMessage: dict):<br/>        return JSONResponse(jsonMessage)</span><span id="2afb" class="jp jq hi lp b fi lx lu l lv lw">ray.init()<br/>ray.nodes()</span><span id="ce1e" class="jp jq hi lp b fi lx lu l lv lw">async def echo(req: Request):</span><span id="7c85" class="jp jq hi lp b fi lx lu l lv lw">    echoBot = EchoActor.remote()<br/>    try:<br/>        res = await req.json()</span><span id="da19" class="jp jq hi lp b fi lx lu l lv lw">    except Exception as err:<br/>        res = {"message": "failed JSON message"}</span><span id="2a2e" class="jp jq hi lp b fi lx lu l lv lw">    remoteJob = await echoBot.response.remote(res)</span><span id="c5c2" class="jp jq hi lp b fi lx lu l lv lw">    return remoteJob</span><span id="a6c7" class="jp jq hi lp b fi lx lu l lv lw">app = Starlette(<br/>    debug=True,<br/>    routes=[<br/>        Route("/echo", echo, methods=["POST"]),<br/>    ],<br/>)</span></pre><h2 id="6400" class="jp jq hi bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj bi translated">结论</h2><p id="239c" class="pw-post-body-paragraph iq ir hi is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hb bi translated">计算的参与者模型及其在分布式/并行计算中的应用并不新鲜。Scala + Akka的演员已经有10多年了。很高兴看到类似的概念最终在Python环境中可用。与Akka相比，一个主要的区别是光线演员的开销。在Ray中，它们是独立的Python进程，每个进程都有自己的内存和CPU需求。初始化一个新的光线角色需要一点时间，或者至少比Akka中相同的步骤要长得多。因此，上下旋转光线演员需要小心，但这仍然比从头开始创建相同的功能要容易得多(也更少错误)。相比之下，Akka演员非常轻，足迹最小；以至于你可以轻松地在内存中运行10，000多个。</p><p id="bc45" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">就完整性而言，Uvicorn workers非常类似于Ray actors，但是它们实际上是用来处理服务器请求的，而不是根据需求进行伸缩。</p><p id="1e8c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">简而言之，Ray并不完美，但它为Python生态系统增加了一个重要的功能，并且与Uvicron这样的异步服务器框架相结合，它走了很长的路！</p><p id="5f72" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jo">我的名字叫尼克·瓦克莱夫，我是</em><a class="ae lj" href="https://techccino.com/" rel="noopener ugc nofollow" target="_blank"><em class="jo">Techccino Ltd</em></a><em class="jo">的创始人。如果你有兴趣构建自己的网络应用</em> <a class="ae lj" href="https://techccino.com" rel="noopener ugc nofollow" target="_blank"> <em class="jo">联系</em> </a> <em class="jo">。</em></p></div></div>    
</body>
</html>