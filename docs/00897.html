<html>
<head>
<title>Creating a Playlist using Classification Algorithm</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用分类算法创建播放列表</h1>
<blockquote>原文：<a href="https://medium.com/codex/creating-a-playlist-using-classification-algorithm-300a4fb0bcaf?source=collection_archive---------3-----------------------#2021-03-24">https://medium.com/codex/creating-a-playlist-using-classification-algorithm-300a4fb0bcaf?source=collection_archive---------3-----------------------#2021-03-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><h2 id="3836" class="hg hh hi bd b fp hj hk hl hm hn ho dx hp translated" aria-label="kicker paragraph"><a class="ae ge" href="http://medium.com/codex" rel="noopener">法典</a></h2><div class=""/><figure class="ev ex ip iq ir is er es paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="er es io"><img src="../Images/00717b5af794741a17bfeb314eb32a14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4TjV_yyta3pm53cJyoWKLg.jpeg"/></div></div></figure><p id="bb71" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">我是Spotify的《发现周刊》的忠实粉丝。也许让我在周一早上醒来的唯一原因。如果你正在使用Spotify，你可能也会对Discover Weekly这个功能印象深刻。Spotify如何非常理解你的音乐品味。《发现周刊》是激励我做这个项目的主要原因。在这个项目中，我将向您展示如何制作适合您音乐品味的播放列表。为此，你需要一个现有的30首歌曲的播放列表，其中前15首是你最喜欢的歌曲，后15首是你最不喜欢的歌曲(我知道很难找到你不喜欢的歌曲，但你不得不这样做)。一旦你拿到这个，我们就可以开始了。</p><p id="8aba" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">我将在Jupyter笔记本上做这个项目。首先，你必须安装这个程序中需要用到的所有软件包。我将使用spotipy、pandas、matplotlib、scikit-learn和pydotplus。要安装这些软件包，你只需输入以下命令。一旦安装了这些包，我们就可以开始编码了。</p><pre class="jx jy jz ka fd kb kc kd ke aw kf bi"><span id="8410" class="kg kh hi kc b fi ki kj l kk kl">pip install spotipy<br/>pip install matplotlib<br/>pi install pandas<br/>pip install scikit-learn<br/>pip install pydotplus</span></pre><p id="a545" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">我们要做的第一件事是获得一个访问令牌。它可以用来读取播放列表，并修改它们等。</p><pre class="jx jy jz ka fd kb kc kd ke aw kf bi"><span id="5e83" class="kg kh hi kc b fi ki kj l kk kl">import spotipy<br/>from spotipy.oauth2 import SpotifyClientCredentials<br/>import spotipy.util as util</span><span id="9c58" class="kg kh hi kc b fi km kj l kk kl">cid =’4a8f691d58c34c059a235249fa877f6e’ # Client ID; copy this from your app created on beta.developer.spotify.com<br/>secret = ‘9b9a8e97d24c4688abb5f188a2d80de3’ # Client Secret; copy this from your app<br/>username = ‘31obxjrwpdtksnjtof7oopbelnwq' # </span><span id="a04f" class="kg kh hi kc b fi km kj l kk kl">#for avaliable scopes see <a class="ae kn" href="https://developer.spotify.com/web-api/using-scopes/" rel="noopener ugc nofollow" target="_blank">https://developer.spotify.com/web-api/using-scopes/</a><br/>scope = ‘user-library-read playlist-modify-public playlist-read-private’</span><span id="aa2e" class="kg kh hi kc b fi km kj l kk kl">redirect_uri=’<a class="ae kn" href="http://localhost:3000/callback'" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/callback'</a></span><span id="842b" class="kg kh hi kc b fi km kj l kk kl">client_credentials_manager = SpotifyClientCredentials(client_id=cid, client_secret=secret)</span><span id="7234" class="kg kh hi kc b fi km kj l kk kl">sp = spotipy.Spotify(client_credentials_manager=client_credentials_manager)</span><span id="6956" class="kg kh hi kc b fi km kj l kk kl">token = util.prompt_for_user_token(username, scope, cid, secret, redirect_uri)</span><span id="5043" class="kg kh hi kc b fi km kj l kk kl">if token:<br/> sp = spotipy.Spotify(auth=token)<br/>else:<br/> print(“Can’t get token for”, username)</span></pre><p id="507f" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">接下来我们要做的是获得你的播放列表Id，从播放列表页面的URL中复制并粘贴到SourcePLaylist Id中。首先，它提取曲目名称和Id，然后提取播放列表中这些歌曲的音频特征。如果你想知道更多关于音频功能的信息，请查看上一篇文章。我们创建一个具有列名Id、轨道名和几个音频特征的数据帧。每行代表一首歌曲及其功能。</p><figure class="jx jy jz ka fd is er es paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="er es ko"><img src="../Images/977a0ddd402ec62ebad1de0743ff8551.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jIJOGAYum3ygjl5vK3ucRw.png"/></div></div><figcaption class="kp kq et er es kr ks bd b be z dx translated">创建播放列表的用户的用户名</figcaption></figure><figure class="jx jy jz ka fd is er es paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="er es ko"><img src="../Images/005f298906381c035ab695c2cdfd5ac2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ig5NoTR7_1BeHFIVmmqHcw.png"/></div></div><figcaption class="kp kq et er es kr ks bd b be z dx translated">URL显示播放列表Id</figcaption></figure><pre class="jx jy jz ka fd kb kc kd ke aw kf bi"><span id="35a7" class="kg kh hi kc b fi ki kj l kk kl">import pandas as pd</span><span id="f818" class="kg kh hi kc b fi km kj l kk kl">playlistCreatorUserName='UserName of user who created the playlist'<br/>sourcePlaylistID = ‘PlaylistId’<br/>sourcePlaylist = sp.user_playlist(playlistCreatorUserName, sourcePlaylistID);<br/>tracks = sourcePlaylist[“tracks”];<br/>songs = tracks[“items”];</span><span id="80fe" class="kg kh hi kc b fi km kj l kk kl">track_ids = []<br/>track_names = []</span><span id="6a94" class="kg kh hi kc b fi km kj l kk kl">for i in range(0, len(songs)):<br/> if songs[i][‘track’][‘id’] != None: <br/> track_ids.append(songs[i][‘track’][‘id’])<br/> track_names.append(songs[i][‘track’][‘name’])</span><span id="1791" class="kg kh hi kc b fi km kj l kk kl">features = []<br/>for i in range(0,len(track_ids)):<br/> audio_features = sp.audio_features(track_ids[i])<br/> for track in audio_features:<br/> features.append(track)<br/> <br/>playlist_df = pd.DataFrame(features, index = track_names)</span></pre><p id="fad5" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">我将使用分类来区分我喜欢和不喜欢的歌曲。首先，我创建了一个包含30个元素的数组，其中前15个是1，表示我喜欢的歌曲，接下来的15个是0。如果您的播放列表包含超过30首歌曲，您可以创建一个播放列表中歌曲数量的数组。我将这个数组作为最后一列添加到数据框“isLike”中。因此，当您查看数据框时，可以看到最后一列只包含1和0。我将根据“Id”对该数据框进行排序，从而对其进行洗牌。</p><pre class="jx jy jz ka fd kb kc kd ke aw kf bi"><span id="5dbe" class="kg kh hi kc b fi ki kj l kk kl">playlist_df=playlist_df[[“id”, “acousticness”, “danceability”, “duration_ms”, <br/> “energy”, “instrumentalness”, “key”, “liveness”,<br/> “loudness”, “mode”, “speechiness”, “tempo”, “valence”]]</span><span id="363e" class="kg kh hi kc b fi km kj l kk kl">import numpy as np<br/>N = 30<br/>K = 15 # K zeros, N-K ones<br/>arr = np.array([1] * K + [0] * (N-K))</span><span id="01db" class="kg kh hi kc b fi km kj l kk kl">playlist_df[‘isLike’]=arr</span><span id="abba" class="kg kh hi kc b fi km kj l kk kl">playlist_df=playlist_df.sort_values(by='id', ascending=False)</span></pre><p id="d1f2" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">现在我们有了数据，你要做的就是找到与数据非常吻合的算法。我这里用的是KNN，邻居n= 4，你也可以用n=5。首先，你必须从skleran.model导入train _ test _ split】我的X将只包含音频功能，所以我会删除它的其余列。Y是目标变量，所以它只包含列“isLike”。</p><pre class="jx jy jz ka fd kb kc kd ke aw kf bi"><span id="8851" class="kg kh hi kc b fi ki kj l kk kl">X= playlist_df.drop([‘id’, ‘isLike’], axis=1) <br/>Y=playlist_df[‘isLike’]</span></pre><p id="6bca" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">我将用75%的数据来训练我的模型，剩下的25%来测试它。我们必须导入一个标准的缩放器来缩放输入变量x_test和x_train。然后我们从sklearn导入KNeighborsClassifier，用x_train和y_train拟合模型。然后，我们用x_test测试模型。我们将借助混淆矩阵将分类器给出的输出与原始x_test进行比较，并确定其准确性。您的模型现在已经准备好了。</p><pre class="jx jy jz ka fd kb kc kd ke aw kf bi"><span id="204e" class="kg kh hi kc b fi ki kj l kk kl">from sklearn.model_selection import train_test_split<br/>x_train, x_test, y_train, y_test= train_test_split(X, Y, test_size= 0.25, random_state=0)</span><span id="7f02" class="kg kh hi kc b fi km kj l kk kl">from sklearn.preprocessing import StandardScaler <br/>st_x= StandardScaler() <br/>x_train= st_x.fit_transform(x_train) <br/>x_test= st_x.transform(x_test)</span><span id="7bea" class="kg kh hi kc b fi km kj l kk kl">from sklearn.neighbors import KNeighborsClassifier <br/>classifier= KNeighborsClassifier(n_neighbors=4, metric=’minkowski’, p=2 ) <br/>classifier.fit(x_train, y_train)</span><span id="3c00" class="kg kh hi kc b fi km kj l kk kl">y_pred= classifier.predict(x_test)</span><span id="c903" class="kg kh hi kc b fi km kj l kk kl">from sklearn.metrics import confusion_matrix <br/>cm= confusion_matrix(y_test, y_pred)</span><span id="8dc3" class="kg kh hi kc b fi km kj l kk kl">from sklearn import metrics</span><span id="5b6b" class="kg kh hi kc b fi km kj l kk kl">print(metrics.accuracy_score(y_test, y_pred))</span></pre><p id="91d0" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">现在，为了获得推荐，我们创建了一个数组来存储sp.recomendations的输出，包括歌曲id和曲目名称。我们设置了5首歌曲的限制，并将我已经喜欢的歌曲的id传递给推荐方法。正如我们之前所做的，我们获取了推荐歌曲的音频特征，并创建了一个数据帧。因此，我们将有新的歌曲和它们的音频特征，我们应用我们的分类器来预测我们是否会喜欢特定歌曲和它的音频特征，就像我们测试模型一样。现在我们将得到一个数组y_pred。将该数组作为最后一列添加到新数据框中，并对“isLike”等于1的歌曲的id进行排序。我们创建一个新的播放列表。我把它命名为“KNN播放列表”。<br/>然后我把这些歌添加到新的播放列表中。</p><pre class="jx jy jz ka fd kb kc kd ke aw kf bi"><span id="85cd" class="kg kh hi kc b fi ki kj l kk kl">rec_tracks = []<br/>for i in playlist_df[playlist_df[‘isLike’]==1][‘id’].values.tolist():<br/> rec_tracks += sp.recommendations(seed_tracks=[i], limit=5, max_instrumentalness=max(playlist_df[‘instrumentalness’]), min_instrumentalness=min(playlist_df[‘instrumentalness’]),max_tempo=max(playlist_df[‘tempo’]),min_tempo=min(playlist_df[‘tempo’]))[‘tracks’];</span><span id="8daf" class="kg kh hi kc b fi km kj l kk kl">rec_track_ids = []<br/>rec_track_names = []<br/>for i in rec_tracks:<br/> rec_track_ids.append(i[‘id’])<br/> rec_track_names.append(i[‘name’])</span><span id="bbea" class="kg kh hi kc b fi km kj l kk kl">rec_features = []<br/>for i in range(0,len(rec_track_ids)):<br/> rec_audio_features = sp.audio_features(rec_track_ids[i])<br/> for track in rec_audio_features:<br/> rec_features.append(track)<br/> <br/>rec_playlist_df = pd.DataFrame(rec_features, index = rec_track_ids)<br/>rec_playlist_df.head()</span><span id="cbff" class="kg kh hi kc b fi km kj l kk kl">rec_playlist_df=rec_playlist_df[[“id”,”acousticness”, “danceability”, “duration_ms”, <br/> “energy”, “instrumentalness”, “key”, “liveness”,<br/> “loudness”, “mode”, “speechiness”, “tempo”, “valence”]]</span><span id="5639" class="kg kh hi kc b fi km kj l kk kl">x_final= rec_playlist_df[[“acousticness”, “danceability”, “duration_ms”, <br/> “energy”, “instrumentalness”, “key”, “liveness”,<br/> “loudness”, “mode”, “speechiness”, “tempo”, “valence”]]</span><span id="cffc" class="kg kh hi kc b fi km kj l kk kl">rec_playlist_df_scaled = StandardScaler().fit_transform(x_final)</span><span id="ed0e" class="kg kh hi kc b fi km kj l kk kl">y_pred=classifier.predict(rec_playlist_df_scaled)</span><span id="2b08" class="kg kh hi kc b fi km kj l kk kl">rec_playlist_df[‘isLike’]=np.array(y_pred)</span><span id="37d7" class="kg kh hi kc b fi km kj l kk kl">recs_to_add =rec_playlist_df[rec_playlist_df[‘isLike’]==1][‘id’].values.tolist()</span><span id="e647" class="kg kh hi kc b fi km kj l kk kl">playlist_recs = sp.user_playlist_create('your username', <br/> name=’KNN Playlist 1')</span><span id="4765" class="kg kh hi kc b fi km kj l kk kl">sp.user_playlist_add_tracks('your username', playlist_recs[‘id’], recs_to_add);</span></pre><p id="a5b6" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">所以现在就这样了。请查看该项目的<a class="ae kn" href="https://github.com/Appuaravind98/RecommendationPlaylist" rel="noopener ugc nofollow" target="_blank"> GitHub回购</a>。分享你的想法。谢谢你。</p></div></div>    
</body>
</html>