<html>
<head>
<title>Animated FlatList in React Native</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React Native中的动画平面列表</h1>
<blockquote>原文：<a href="https://medium.com/codex/animated-flatlist-in-react-native-7cd1119bb5ca?source=collection_archive---------0-----------------------#2021-05-14">https://medium.com/codex/animated-flatlist-in-react-native-7cd1119bb5ca?source=collection_archive---------0-----------------------#2021-05-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="98e9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在最近的React Native项目中，我被要求以一种比不使用任何动画渲染每个项目更有吸引力的方式来可视化一个项目列表。通过这种方式，我们希望为我们的整体互动应用程序外观和感觉做出更多贡献。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/619f013b5747f810aae02e5dee738547.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*pYJXyWxFdoIeql4nAlBvxw.gif"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">不同的动画配置</figcaption></figure><p id="da51" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">TLDR；</strong>React Native中动画化平面列表的模块在npmjs.com<a class="ae jt" href="https://www.npmjs.com/package/@ja-ka/react-native-fade-in-flatlist" rel="noopener ugc nofollow" target="_blank">可用</a>。该代码在github.com的<a class="ae jt" href="https://github.com/ja-ka/react-native-fade-in-flatlist" rel="noopener ugc nofollow" target="_blank">上公开。去看看，借给它一颗星！</a></p></div><div class="ab cl ju jv gp jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="hb hc hd he hf"><p id="28f0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如你在上面的图片中看到的，要求是动画的项目给一个平面列表一个接一个，但渲染必须是可定制的。我们希望控制渲染每个项目需要多长时间，在渲染第一个项目之前有一个可选的初始延迟，以及让用户有机会控制并行渲染多少个项目。当然，与直接使用基本的React Native FlatList组件相比，使用这个库不需要用户做任何不同的事情。</p><p id="b48e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，我创建了一个简单的包装React Native的FlatList组件的包装器。我已经添加了额外的道具和一些配置动画所需的默认值。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="kb kc l"/></div></figure><p id="cb2d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我使用React Native的动画库来制作每个项目的动画。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="kb kc l"/></div></figure><p id="a12b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因为我们通常需要线性动画，所以Animated.timing函数是正确的选择。所需的配置参数可以很容易地从我们为新组件引入的附加属性中获得。此动画的总持续时间可以计算为每个项目的持续时间与要制作动画的所有项目的数量的乘积。我们选择线性缓动，并将to值设置为动画+ 1的项目，因为索引为0的第一个项目在下一个项目从索引1开始渲染时应该完全可见，依此类推。</p><p id="a816" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">值得注意的是，我们仅使用一个单一的平面列表全局动画值来控制所有项目淡入的不透明度。这样，所有的项目，不管它们是什么时候被渲染的，都会以一种全局控制的方式淡入淡出，从而坚持调用者提供的配置。</p><p id="c92b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来，为了淡入一个项目，我们需要处理它的不透明度。不透明度在相应动画值的下限为0，在上限达到1。由于我们需要动画显示两者，即要呈现的实际项目和可选分隔符，我们创建了一个名为FadeInComponent的新组件，它根据给定的索引和配置处理其子组件中的淡入淡出。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="kb kc l"/></div></figure><p id="70c5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">moveBy值允许我们将多个要并行制作动画的项目“组合在一起”，其中第一个项目从t=0开始可见，下一个项目从t=0+1开始-(1-1/ <number of="" parallel="" items="">)。</number></p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kd"><img src="../Images/9cfc3a896fc8304e84df3db204a34c76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sLAdvtZPoOLuJzOJvtUJAQ.png"/></div></div></figure><p id="e44c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了便于理解，矩形之间增加了空间。实际上，每个块都直接跟随它的后继块。请原谅我的绘画技巧。；-)</p><p id="c139" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果要并行渲染的项目数为1，则项目会一个接一个地渲染，正如您在开头的动画gif中看到的那样(左视图)。当您开始增加要并行渲染的项目数时，除了第一个块之外的所有块都将向左移动上述公式的量。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ke"><img src="../Images/f25e67857867da36ee26ec993967edd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QF6cnpdqub34woCneOAQdg.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">再说一次，我不是PowerPoint专家</figcaption></figure><p id="f754" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">平行项目的数量越多，块越向左移动。</p><p id="0ba9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来，让我们淡入物品，最后！</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="kb kc l"/></div></figure><p id="000a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如你所注意到的，我们现在正在处理renderItem函数。我们用自己的内部renderItem函数包装原始RenderItem函数，我们将其重命名为original renderItem函数。根据要淡入多少项的配置，我们的内部renderItem函数要么在我们的内部FadeInComponent中包装要呈现的组件，要么直接返回原始RenderItem函数的结果。</p><p id="1138" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是你可能会问，可选的分隔符呢？</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="kb kc l"/></div></figure><p id="04c1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了以同样的方式处理分隔符，我们还创建了一个内部分隔符组件，并用它包装提供的ItemSeparatorComponent。React Native的FlatList组件提供了一种便捷的方式来处理依赖于前导或尾随项的分隔符的不透明度。使用info.separators.updateProps函数，我们可以将各个属性传递给Separator功能组件。因为我们需要告诉当前项的前导分隔符淡入当前索引是什么，并且为了避免呈现期间无效的setState调用，我们将更新分隔符的props包装到一个useEffect钩子中。</p><p id="ab19" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">就是这样！</strong>我们现在可以很好地动画我们的平面列表。此外，使用这个库是小菜一碟，因为只需用新的FadeInFlatList组件替换React Native的FlatList，并可选地覆盖动画项目的默认值。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="kb kc l"/></div></figure><p id="903f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">更新后的组件看起来没什么不同，但现在很好地淡入了要呈现的项目。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="kb kc l"/></div></figure><p id="8ce3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">尽情享受吧！</p></div></div>    
</body>
</html>