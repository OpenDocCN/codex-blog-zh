<html>
<head>
<title>Setting up MLFlow for ultralytics/YOLOv5</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为ultralytics/YOLOv5设置MLFlow</h1>
<blockquote>原文：<a href="https://medium.com/codex/setting-up-mlflow-for-ultralytics-yolov5-1380b5f8cac5?source=collection_archive---------0-----------------------#2021-06-25">https://medium.com/codex/setting-up-mlflow-for-ultralytics-yolov5-1380b5f8cac5?source=collection_archive---------0-----------------------#2021-06-25</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/f52880bf6e8ee658dec1a4bcc60d9ffa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1326/format:webp/1*sZ7iJ1qP9USYl0RZTNowGg.png"/></div><figcaption class="im in et er es io ip bd b be z dx translated"><a class="ae iq" href="https://mlflow.org/docs/latest/index.html" rel="noopener ugc nofollow" target="_blank">https://mlflow.org/docs/latest/index.html</a></figcaption></figure><p id="1a83" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">最近我决定设置YOLOv5来使用MLFlow APIs。虽然YOLOv5提供了权重和偏差(wandb)集成，但wandb是一种专有技术，而MLFlow仍然是一种开源软件。此外，作为一名ML工程师，MLFlow对我来说似乎更直观，而不是DevOps。</p><p id="e14d" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">作为一名ML工程师，我更习惯于从概念到生产建立模型，而不太担心所使用的基础设施。因此，我一直在寻找平台无关的解决方案，MLFlow对我来说是一个完美的选择。MLFlow不需要设置特定的基础设施。您可以设计您的ML管道，然后根据您的需要进行调整。例如，由于我没有AWS的开发环境，我可以用我的本地配置来设置开发环境。然后，当转移到生产时，我可以设置AWS配置。</p><p id="bbba" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">好吧，你可以说这很麻烦，因为我不会有一个接近生产环境的开发环境。但这有助于我让事情开始运转。</p><p id="022c" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">也就是说，让我们开始吧。</p><p id="b86e" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">首先，让我们克隆ultralytics/yolov5 git存储库:</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="d403" class="jy jz hi ju b fi ka kb l kc kd">git clone <a class="ae iq" href="https://github.com/ultralytics/yolov5.git" rel="noopener ugc nofollow" target="_blank">https://github.com/ultralytics/yolov5.git</a></span></pre><p id="c032" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated"><code class="du ke kf kg ju b">ultralytics/yolov5</code> repo已经包含了一个Dockerfile，它带有运行培训和测试任务的容器映像。因此，我们将利用这一点。此外，由于我们已经有了<code class="du ke kf kg ju b">wandb</code>集成，我们可以利用现有的格式通过MLFlow进行日志记录。</p><p id="3505" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">在深入细节之前，我们需要将MLFlow库安装到我们的Python3环境中。为此，我们创造了一个独立的<code class="du ke kf kg ju b">virtualenv</code>:</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="f704" class="jy jz hi ju b fi ka kb l kc kd">virtualenv -p python3 env<br/>pip install mlflow</span></pre><p id="2aab" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">安装MLFlow后，我们需要启动服务器。在这里，我们将启动我们主机中的服务器:</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="f945" class="jy jz hi ju b fi ka kb l kc kd"><strong class="ju hj">mlflow</strong> server \ <br/>--backend-store-uri sqlite:///<strong class="ju hj">mlflow</strong>.db \<br/>--default-artifact-root ./artifacts \<br/>--host 0.0.0.0 --port 8000 &amp;</span></pre><p id="293a" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">MLFlow支持不同的存储和数据库系统，用于记录参数、指标和模型。但是，需要注意的是:<strong class="it hj"> MLFlow不上传工件</strong>。也就是说，如果您使用本地设置，没有第三方存储系统，如AWS S3或Databricks文件系统，您将无法上传您的工件。</p><p id="9f72" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">设置MLFlow服务器后，我们需要从MLFlow跟踪API开始，以便存储参数和指标。</p><p id="031c" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">在<code class="du ke kf kg ju b">train.py</code>脚本中，我们在<code class="du ke kf kg ju b">main()</code>中插入下面一行:</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="cace" class="jy jz hi ju b fi ka kb l kc kd">mlflow.set_experiment("ultralytics/yolov5")<br/>mlflow.start_run()</span></pre><p id="0fcb" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">同样，在<code class="du ke kf kg ju b">main</code>例程结束时，我们需要结束实验:</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="095a" class="jy jz hi ju b fi ka kb l kc kd">mlflow.end_run()</span></pre><p id="2e3a" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">在<code class="du ke kf kg ju b">train()</code>函数中，我们插入了日志记录函数:</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="fd71" class="jy jz hi ju b fi ka kb l kc kd"># Log</span><span id="cdd8" class="jy jz hi ju b fi kh kb l kc kd">tags = ['train/box_loss', 'train/obj_loss', 'train/cls_loss', 'metrics/precision', 'metrics/recall', 'metrics/mAP_0.5', 'metrics/mAP_0.5:0.95','val/box_loss', 'val/obj_loss', 'val/cls_loss', 'x/lr0', 'x/lr1', 'x/lr2']</span><span id="89ea" class="jy jz hi ju b fi kh kb l kc kd">for x, tag in zip(list(mloss[:-1]) + list(results) + lr, tags):<br/>    # existing code (...)<br/>    tag = re.sub('[^a-zA-Z0-9\/\_\-\. ]', '-', tag)<br/>    # we remove not allowed characters from the tags.<br/>    mlflow.log_metric(tag, float(x))</span></pre><p id="04d2" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">就这样，我们已经介绍了<strong class="it hj">物流跟踪API </strong>。现在，我们继续学习MLFlow项目API。跟踪处理日志记录，项目处理打包ML代码，以确保实验的可重复性和可重用性。</p><p id="4e85" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">对于MLFlow项目，我们创建一个文件<code class="du ke kf kg ju b">MLproject</code>:</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="39e0" class="jy jz hi ju b fi ka kb l kc kd">name: ultralytics/yolov5</span><span id="0d48" class="jy jz hi ju b fi kh kb l kc kd">docker_env:<br/>  image: ultralytics/yolov5:latest<br/>  network: host # This can be commented if the URI can be accessed externally.</span><span id="4153" class="jy jz hi ju b fi kh kb l kc kd">entry_points:<br/>  main:<br/>    parameters:<br/>      data_file: {type: string, default: "./data/coco128.yaml"}<br/>      cfg_file: {type: string, default: "./models/yolov5s.yaml"}<br/>      batch_size: {type: int, default: 16}<br/>      workers: {type: int, default: 2}<br/>    command: |<br/>      python train.py \<br/>      --data {data_file} \<br/>      --cfg {cfg_file} \<br/>      --batch-size {batch_size} \<br/>      --workers {workers}</span></pre><p id="e5f1" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">注意我们是如何使用docker图像<code class="du ke kf kg ju b">ultralytics/yolov5:latest</code>的。因此，我们需要从存储库中遇到的<code class="du ke kf kg ju b">Dockerfile</code>构建这个映像。为了构建图像，我们运行:</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="44d8" class="jy jz hi ju b fi ka kb l kc kd">t=ultralytics/yolov5:latest &amp;&amp; sudo docker build -t $t .</span></pre><p id="0b3e" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">成功构建映像后，我们可以运行<code class="du ke kf kg ju b">MLproject</code>，但是在此之前，我们需要设置<code class="du ke kf kg ju b">MLFLOW_TRACKING_URI</code>，因为我们使用的是非默认的URI。</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="a56c" class="jy jz hi ju b fi ka kb l kc kd">export MLFLOW_TRACKING_URI="http://0.0.0.0:8000"</span></pre><p id="15ac" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">注意<code class="du ke kf kg ju b">http://</code>，如果它不存在，它将失败。现在我们可以运行<code class="du ke kf kg ju b">MLproject</code>。</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="cff5" class="jy jz hi ju b fi ka kb l kc kd"><strong class="ju hj">mlflow</strong> run \<br/>--experiment-name ultralytics/yolov5 . \<br/>-P workers=8 \ <br/>-A gpus=all</span></pre><p id="7dd3" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated"><code class="du ke kf kg ju b">-P</code>标志设置在<code class="du ke kf kg ju b">MLproject</code>文件中定义的参数。<code class="du ke kf kg ju b">-A</code>标志设置可输入到<code class="du ke kf kg ju b">docker run</code>命令的附加参数。因此，<code class="du ke kf kg ju b">-A gpus=all</code>启用了docker容器的GPU驱动程序。</p><p id="8c76" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">就这样，我们处理了MLFlow Projects API，用于将ML代码打包成可重用和可复制的组件。</p><p id="8cda" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">最后，我们需要服务这些模型，为此，我们将使用<strong class="it hj"> MLFlow Models API </strong>来打包<em class="ki">训练过的</em>模型，并通过REST API部署它。</p><p id="0ee7" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">首先，我们需要定义模型特征，包括输入和输出张量的定义。我们使用函数<code class="du ke kf kg ju b">mlflow.models.signature.infer_signature</code>获得了模型签名。</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="0340" class="jy jz hi ju b fi ka kb l kc kd">from mlflow.models.signature import infer_signature</span><span id="1eb5" class="jy jz hi ju b fi kh kb l kc kd"># we init the signature object<br/>def train():<br/>    # previous code (...) </span><span id="5465" class="jy jz hi ju b fi kh kb l kc kd">    signature = None<br/>   <br/>    # existing code (...)</span><span id="2313" class="jy jz hi ju b fi kh kb l kc kd">    # Forward<br/>    with amp.autocast(enabled=cuda):<br/>    pred = model(imgs)  # forward<br/>    <br/>    # It produces the signature to MLFlow model if is not set yet.</span><span id="0e5f" class="jy jz hi ju b fi kh kb l kc kd">    if signature is None:<br/>        signature = infer_signature(<br/>                        imgs.cpu().numpy(),<br/>                        pred[0].detach().cpu().numpy()<br/>                    )</span></pre><p id="924e" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">所获得的签名将定义用户必须如何将其张量输入到REST API端点，并且还定义了预期的输出。</p><p id="7f7f" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">获得ModelSignature之后，我们需要将模型保存为MLmodel格式。</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="2c59" class="jy jz hi ju b fi ka kb l kc kd">def train():<br/>   <br/>     if best_fitness == fi:<br/>         torch.save(ckpt, best)<br/>         # Store the best model in the MLmodel format. <br/>         mlflow.pytorch.log_model(<br/>             ckpt['model'], <br/>             "yolov5", <br/>             signature=signature<br/>         )</span></pre><p id="4b9d" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">观察我们如何不保存整个模型元数据<code class="du ke kf kg ju b">ckpt</code>，而是只存储存储在<code class="du ke kf kg ju b">ckpt['model']</code>中的权重。</p><p id="5974" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">设置好<code class="du ke kf kg ju b">MLmodel</code>后，我们可以再次运行来获取它。</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="2532" class="jy jz hi ju b fi ka kb l kc kd"><strong class="ju hj">mlflow</strong> run \<br/>--experiment-name ultralytics/yolov5 . \<br/>-P workers=8 \ <br/>-A gpus=all</span></pre><p id="384d" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">MLFlow将创建一个文件夹<code class="du ke kf kg ju b">yolov5</code>到你的<code class="du ke kf kg ju b">runs:/some-run-uuid/yolov5</code>中，存储在你的<code class="du ke kf kg ju b">./artifacts</code>文件夹中。尽管如此，我们可以为打包的模型构建一个docker映像:</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="5350" class="jy jz hi ju b fi ka kb l kc kd">mlflow models build-docker -m "runs:/some-run-uuid/yolov5" -n "yolov5-mlflow-deploy"</span></pre><p id="d4cb" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">然后，我们可以通过以下方式在主机上的端口<code class="du ke kf kg ju b">5001</code>公开该模型:</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="43be" class="jy jz hi ju b fi ka kb l kc kd">docker run -p 5001:8080 "yolov5-mlflow-deploy"</span></pre><p id="76bd" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">瞧！</p><p id="c399" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated"><strong class="it hj">故障排除:</strong></p><p id="65f5" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">由于我的Python、Pytorch和Torchvision版本在<code class="du ke kf kg ju b">conda</code>时不可用，我遇到了一个特殊的问题，因为MLFlow是在<code class="du ke kf kg ju b">conda</code>之上构建其环境的，我不得不手动将这些版本重新调整到<code class="du ke kf kg ju b">conda.yaml</code>文件中。</p><p id="10b3" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">此外，需要注意的是MLFlow模型中的<code class="du ke kf kg ju b">build-docker</code>仍然不提供GPU支持。您可能可以通过将标准的<code class="du ke kf kg ju b">Dockerfile</code>修改为<code class="du ke kf kg ju b">mlflow</code>库来实现这一点，但是我们稍后会谈到这一点。</p><p id="d548" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">无论如何，如果对你有用，请告诉我！</p><p id="4298" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">亲切的问候，</p><p id="a19d" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">克里斯托夫。</p></div></div>    
</body>
</html>