<html>
<head>
<title>Introduction to Kotlin for Java developers — Part 2: classes and objects</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向Java开发人员的Kotlin介绍—第2部分:类和对象</h1>
<blockquote>原文：<a href="https://medium.com/codex/introduction-to-kotlin-for-java-developers-part-2-classes-and-objects-dbafe7cb177d?source=collection_archive---------11-----------------------#2021-06-26">https://medium.com/codex/introduction-to-kotlin-for-java-developers-part-2-classes-and-objects-dbafe7cb177d?source=collection_archive---------11-----------------------#2021-06-26</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es im"><img src="../Images/aa0852893e691143c84e1b1cd82266dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*cTOSWA1rjzyQlvW4.png"/></div></div></figure></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><p id="9a67" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">在这个系列的第二部分中，我将带您游览Kotlin中的类和对象。我将概述它们在哪些方面与Java不同。我希望你喜欢读这篇文章，就像我喜欢写它一样！如果你做到了，别忘了鼓掌:-)</p><p id="8559" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">该系列的其他部分:</p><ul class=""><li id="650c" class="jw jx hi ja b jb jc jf jg jj jy jn jz jr ka jv kb kc kd ke bi translated"><a class="ae kf" rel="noopener" href="/codex/things-to-love-in-kotlin-coming-from-java-8-part-1-functions-and-operators-40aea17c8854">面向Java开发人员的Kotlin介绍—第1部分:函数和操作符</a></li><li id="cfba" class="jw jx hi ja b jb kg jf kh jj ki jn kj jr kk jv kb kc kd ke bi translated"><a class="ae kf" rel="noopener" href="/codex/introduction-to-kotlin-for-java-developers-part-3-generics-21e1646ec2ae">面向Java开发人员的Kotlin介绍—第3部分:泛型</a></li></ul></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><h1 id="c8e9" class="kl km hi bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">1.构造器</h1><p id="e231" class="pw-post-body-paragraph iy iz hi ja b jb lj jd je jf lk jh ji jj ll jl jm jn lm jp jq jr ln jt ju jv hb bi translated">当Kotlin第一次出现时，类只能有一个构造函数:主构造函数。就像Kotlin函数一样(不像Java函数)，它的参数可以有默认值，构造函数调用可以通过名称引用参数。这通常消除了在Java中定义重载的需要。在98%的用例中，主构造函数就足够了。</p><p id="3251" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">二级构造函数在2015年晚些时候被添加到语言中(见发布说明<a class="ae kf" href="https://blog.jetbrains.com/kotlin/2015/03/kotlin-m11-is-out/" rel="noopener ugc nofollow" target="_blank">这里</a>)，只是为了确保与需要多个构造函数的Java层次结构兼容(见规范<a class="ae kf" href="https://github.com/JetBrains/kotlin/blob/master/spec-docs/secondary-constructors.md" rel="noopener ugc nofollow" target="_blank">这里</a>)。我不会在这篇文章中描述它们。如有必要，请参见此处的文档<a class="ae kf" href="https://kotlinlang.org/docs/classes.html#secondary-constructors" rel="noopener ugc nofollow" target="_blank">和</a>。尽可能使用有意义的名称来命名工厂函数，如这里的<a class="ae kf" href="https://kotlinlang.org/docs/coding-conventions.html#factory-functions" rel="noopener ugc nofollow" target="_blank">所述。</a></p><p id="f4f2" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">主构造函数是通过在类名后面添加一个参数列表来定义的。类的主体可以有属性初始值设定项和初始值设定项块。两者都可以引用主构造函数参数，并且都在调用主构造函数时执行。任何以var的val为前缀的构造函数参数和任何属性初始值设定项都是属性定义。任何属性(无论是val还是var，是否可为null)都不能不初始化，否则会发生编译器错误。</p><p id="c753" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">示例:</p><figure class="in io ip iq fd ir"><div class="bz dy l di"><div class="lo lp l"/></div></figure><p id="7ba7" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated"><a class="ae kf" href="https://kotlinlang.org/docs/classes.html#constructors" rel="noopener ugc nofollow" target="_blank">科特林文档</a></p><h1 id="7d5c" class="kl km hi bd kn ko lq kq kr ks lr ku kv kw ls ky kz la lt lc ld le lu lg lh li bi translated">2.遗产</h1><p id="f056" class="pw-post-body-paragraph iy iz hi ja b jb lj jd je jf lk jh ji jj ll jl jm jn lm jp jq jr ln jt ju jv hb bi translated">默认情况下，Kotlin类是final类。只有标有<code class="du lv lw lx ly b">open</code>关键字的类是可继承的。继承是在类头中定义的，方法是在主构造函数定义后使用冒号，然后调用超类主构造函数。</p><p id="e093" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">示例:</p><figure class="in io ip iq fd ir"><div class="bz dy l di"><div class="lo lp l"/></div></figure><p id="ee70" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">方法不能被覆盖，除非用关键字<code class="du lv lw lx ly b">open</code>声明。覆盖超类方法的方法必须用<code class="du lv lw lx ly b">override</code>关键字声明。这提供了以下好处:</p><ul class=""><li id="9c27" class="jw jx hi ja b jb jc jf jg jj jy jn jz jr ka jv kb kc kd ke bi translated">如果用<code class="du lv lw lx ly b">override</code>标记的方法实际上没有覆盖任何东西，编译器将产生一个错误。例如，这可能是因为超类中的一个open方法被重命名，而覆盖没有被重命名。</li><li id="403f" class="jw jx hi ja b jb kg jf kh jj ki jn kj jr kk jv kb kc kd ke bi translated">如果一个没有用<code class="du lv lw lx ly b">override</code>关键字标记的方法与一个超类方法同名，编译器将产生一个错误，从而隐藏它。这样，通过选择一个已经被超类中的一个方法使用的名字的意外重写就不会发生。</li></ul><p id="7367" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated"><a class="ae kf" href="https://kotlinlang.org/docs/inheritance.html" rel="noopener ugc nofollow" target="_blank">科特林文档</a></p><h1 id="acc6" class="kl km hi bd kn ko lq kq kr ks lr ku kv kw ls ky kz la lt lc ld le lu lg lh li bi translated">3.性能</h1><p id="8840" class="pw-post-body-paragraph iy iz hi ja b jb lj jd je jf lk jh ji jj ll jl jm jn lm jp jq jr ln jt ju jv hb bi translated">在Java中，属性是在类的每个实例中保留的存储位置，它保存一个值，可以通过名称引用。它通常与getter和setter方法成对出现。在Java中，getter和setter方法必须显式写出。</p><p id="a674" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">在Kotlin中，属性是可以通过名称引用的getter/setter对。但是在Java中你可以写<code class="du lv lw lx ly b">obj.getProp()</code>，在Kotlin中你只需写<code class="du lv lw lx ly b">obj.prop</code>，同样的<code class="du lv lw lx ly b">obj.setProp(value)</code>变成了<code class="du lv lw lx ly b">obj.prop = value</code>。当使用<code class="du lv lw lx ly b">val</code>关键字定义属性时，它不能有setter。属性可能对应于也可能不对应于存储位置。当它出现时，存储位置被称为“后备字段”。</p><p id="d7da" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">在Kotlin中定义属性的语法如下:</p><figure class="in io ip iq fd ir"><div class="bz dy l di"><div class="lo lp l"/></div></figure><p id="c31e" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">当您没有显式指定它们时，Kotlin会给您默认的getters和setters，如下所示:</p><figure class="in io ip iq fd ir"><div class="bz dy l di"><div class="lo lp l"/></div></figure><p id="bb96" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">…其中<code class="du lv lw lx ly b">field</code>是指支持字段的关键字。当getter和setter都不引用支持字段时，Kotlin不会创建一个。例如，该属性没有支持字段:</p><figure class="in io ip iq fd ir"><div class="bz dy l di"><div class="lo lp l"/></div></figure><p id="59eb" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated"><a class="ae kf" href="https://kotlinlang.org/docs/properties.html" rel="noopener ugc nofollow" target="_blank">科特林文档</a></p><h2 id="49ba" class="lz km hi bd kn ma mb mc kr md me mf kv jj mg mh kz jn mi mj ld jr mk ml lh mm bi translated">3.1委托属性</h2><p id="a2ea" class="pw-post-body-paragraph iy iz hi ja b jb lj jd je jf lk jh ji jj ll jl jm jn lm jp jq jr ln jt ju jv hb bi translated">如果您发现自己一遍又一遍地编写相同的getters和setters，您可能希望使用委托对象。语法如下:</p><figure class="in io ip iq fd ir"><div class="bz dy l di"><div class="lo lp l"/></div></figure><p id="f751" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">委托对象必须实现<code class="du lv lw lx ly b">getValue</code>和一个<code class="du lv lw lx ly b">setValue</code>方法。科特林提供了一些有用的委托实现，比如<code class="du lv lw lx ly b">lazy</code>:</p><figure class="in io ip iq fd ir"><div class="bz dy l di"><div class="lo lp l"/></div></figure><p id="2683" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated"><a class="ae kf" href="https://kotlinlang.org/docs/delegated-properties.html" rel="noopener ugc nofollow" target="_blank">科特林文档</a></p><h2 id="99d7" class="lz km hi bd kn ma mb mc kr md me mf kv jj mg mh kz jn mi mj ld jr mk ml lh mm bi translated">3.2属性和继承</h2><p id="9eea" class="pw-post-body-paragraph iy iz hi ja b jb lj jd je jf lk jh ji jj ll jl jm jn lm jp jq jr ln jt ju jv hb bi translated">因为在Kotlin (getter / setter)中，属性基本上是一对函数，所以它可以被标记为抽象的，并且可以被覆盖，就像常规函数一样:</p><figure class="in io ip iq fd ir"><div class="bz dy l di"><div class="lo lp l"/></div></figure><p id="3c26" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated"><a class="ae kf" href="https://kotlinlang.org/docs/inheritance.html#overriding-properties" rel="noopener ugc nofollow" target="_blank">科特林文档</a></p><h1 id="7b79" class="kl km hi bd kn ko lq kq kr ks lr ku kv kw ls ky kz la lt lc ld le lu lg lh li bi translated">4.接口</h1><p id="0f5e" class="pw-post-body-paragraph iy iz hi ja b jb lj jd je jf lk jh ji jj ll jl jm jn lm jp jq jr ln jt ju jv hb bi translated">在Kotlin中，接口就像一个抽象类，除了它不能保存状态(因为没有状态要初始化，所以接口不能有构造函数)。如果你对为什么没有状态感兴趣，看看这里的<a class="ae kf" href="https://blog.jetbrains.com/kotlin/2011/08/multiple-inheritance-part-2-possible-directions/" rel="noopener ugc nofollow" target="_blank"/>。你可以<em class="mn">声明属性，只要它们是抽象的或者没有支持字段(=状态)。也可以声明私有函数。</em></p><p id="ec84" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">接口允许多重继承，但是如果一个非私有函数是从多个超接口继承的，你必须明确当这个函数在子类的实例上被调用时该做什么。为此，您必须重写有问题的函数并实现它:</p><figure class="in io ip iq fd ir"><div class="bz dy l di"><div class="lo lp l"/></div></figure><p id="71f2" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated"><a class="ae kf" href="https://kotlinlang.org/docs/interfaces.html" rel="noopener ugc nofollow" target="_blank">科特林文档</a></p><h1 id="483d" class="kl km hi bd kn ko lq kq kr ks lr ku kv kw ls ky kz la lt lc ld le lu lg lh li bi translated">5.密封类</h1><p id="a2e1" class="pw-post-body-paragraph iy iz hi ja b jb lj jd je jf lk jh ji jj ll jl jm jn lm jp jq jr ln jt ju jv hb bi translated">密封类是这样一个类，它只能在声明到的同一个包和编译模块中被子类化。任何在其他地方声明的子类都会产生编译错误。这意味着所有可能的子类在编译时都是已知的。</p><p id="8684" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">下面是一个密封类及其子类的示例:</p><figure class="in io ip iq fd ir"><div class="bz dy l di"><div class="lo lp l"/></div></figure><p id="d977" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">在<code class="du lv lw lx ly b">when</code>语句中使用密封类时，密封类的作用就显现出来了:</p><figure class="in io ip iq fd ir"><div class="bz dy l di"><div class="lo lp l"/></div></figure><p id="4f28" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">不仅如果覆盖了所有的情况，else语句是不需要的，而且更重要的是，如果你添加了另一个子类，编译器将在没有覆盖新子类的每个<code class="du lv lw lx ly b">when</code>表达式上产生错误。</p><p id="af28" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated"><a class="ae kf" href="https://kotlinlang.org/docs/sealed-classes.html" rel="noopener ugc nofollow" target="_blank">科特林文档</a></p><h1 id="9c77" class="kl km hi bd kn ko lq kq kr ks lr ku kv kw ls ky kz la lt lc ld le lu lg lh li bi translated">6.目标</h1><h2 id="cb10" class="lz km hi bd kn ma mb mc kr md me mf kv jj mg mh kz jn mi mj ld jr mk ml lh mm bi translated">6.1对象表达式</h2><p id="0174" class="pw-post-body-paragraph iy iz hi ja b jb lj jd je jf lk jh ji jj ll jl jm jn lm jp jq jr ln jt ju jv hb bi translated">当涉及到匿名类时，Kotlin没有与Java相同的语法。要在Kotlin中声明和实例化匿名类，请使用对象表达式:</p><figure class="in io ip iq fd ir"><div class="bz dy l di"><div class="lo lp l"/></div></figure><p id="b14e" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">在Kotlin中创建接口或抽象类的一次性实现时，对象表达式非常方便。</p><p id="584a" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">就像匿名函数一样，对象表达式可以从封闭范围访问变量，从而创建闭包:</p><figure class="in io ip iq fd ir"><div class="bz dy l di"><div class="lo lp l"/></div></figure><p id="923a" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated"><a class="ae kf" href="https://kotlinlang.org/docs/object-declarations.html#object-expressions" rel="noopener ugc nofollow" target="_blank">科特林文档</a></p><h2 id="887c" class="lz km hi bd kn ma mb mc kr md me mf kv jj mg mh kz jn mi mj ld jr mk ml lh mm bi translated">6.2对象声明</h2><p id="7e94" class="pw-post-body-paragraph iy iz hi ja b jb lj jd je jf lk jh ji jj ll jl jm jn lm jp jq jr ln jt ju jv hb bi translated">对象不一定是匿名的，它们也可以被命名，因此定义了单例:</p><figure class="in io ip iq fd ir"><div class="bz dy l di"><div class="lo lp l"/></div></figure><p id="846b" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">你可以直接用名字来引用一个对象:<code class="du lv lw lx ly b">DataProviderManager.registerDataProvider(...)</code></p><p id="0379" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated"><a class="ae kf" href="https://kotlinlang.org/docs/object-declarations.html#object-declarations-overview" rel="noopener ugc nofollow" target="_blank">科特林文档</a></p><h2 id="2af4" class="lz km hi bd kn ma mb mc kr md me mf kv jj mg mh kz jn mi mj ld jr mk ml lh mm bi translated">6.3伴随对象</h2><p id="712b" class="pw-post-body-paragraph iy iz hi ja b jb lj jd je jf lk jh ji jj ll jl jm jn lm jp jq jr ln jt ju jv hb bi translated">Kotlin没有静态字段和方法。相反，它有伴侣对象。</p><p id="800e" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">当一个对象在一个类中被声明时，它可以用关键字<code class="du lv lw lx ly b">companion</code>来标记。这些对象的成员可以简单地用类名来引用:</p><figure class="in io ip iq fd ir"><div class="bz dy l di"><div class="lo lp l"/></div></figure><p id="6fc9" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated"><a class="ae kf" href="https://kotlinlang.org/docs/object-declarations.html#companion-objects" rel="noopener ugc nofollow" target="_blank">科特林文档</a></p><h1 id="5a64" class="kl km hi bd kn ko lq kq kr ks lr ku kv kw ls ky kz la lt lc ld le lu lg lh li bi translated">7.对象析构</h1><p id="b317" class="pw-post-body-paragraph iy iz hi ja b jb lj jd je jf lk jh ji jj ll jl jm jn lm jp jq jr ln jt ju jv hb bi translated">一个对象可以在赋值时分解成它的组成部分，如下所示:</p><figure class="in io ip iq fd ir"><div class="bz dy l di"><div class="lo lp l"/></div></figure><p id="e85f" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">要做到这一点，只需提供<code class="du lv lw lx ly b">component1...N</code>函数并将它们标记为操作符。</p><p id="181b" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated"><a class="ae kf" href="https://kotlinlang.org/docs/destructuring-declarations.html" rel="noopener ugc nofollow" target="_blank">科特林文档</a></p><h1 id="fda0" class="kl km hi bd kn ko lq kq kr ks lr ku kv kw ls ky kz la lt lc ld le lu lg lh li bi translated">8.数据类别</h1><p id="56c8" class="pw-post-body-paragraph iy iz hi ja b jb lj jd je jf lk jh ji jj ll jl jm jn lm jp jq jr ln jt ju jv hb bi translated">当一个类用关键字<code class="du lv lw lx ly b">data</code>标记时，Kotlin会根据主构造函数中声明的属性自动生成以下函数(仅在主构造函数中) :</p><ul class=""><li id="b6fb" class="jw jx hi ja b jb jc jf jg jj jy jn jz jr ka jv kb kc kd ke bi translated"><code class="du lv lw lx ly b">equals()</code> / <code class="du lv lw lx ly b">hashCode()</code></li><li id="72f1" class="jw jx hi ja b jb kg jf kh jj ki jn kj jr kk jv kb kc kd ke bi translated"><code class="du lv lw lx ly b">toString()</code>的形式<code class="du lv lw lx ly b">"User(name=John, age=42)"</code></li><li id="5775" class="jw jx hi ja b jb kg jf kh jj ki jn kj jr kk jv kb kc kd ke bi translated"><code class="du lv lw lx ly b">component1...N</code>功能对应于其声明顺序中的属性</li><li id="c44e" class="jw jx hi ja b jb kg jf kh jj ki jn kj jr kk jv kb kc kd ke bi translated"><code class="du lv lw lx ly b">copy()</code>功能</li></ul><p id="6365" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">如果这些自动生成的实现之一不符合您的需要，只需定义您自己的实现，它将优先于生成的实现。</p><p id="312f" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated"><a class="ae kf" href="https://kotlinlang.org/docs/data-classes.html" rel="noopener ugc nofollow" target="_blank">科特林文档</a></p><h1 id="05eb" class="kl km hi bd kn ko lq kq kr ks lr ku kv kw ls ky kz la lt lc ld le lu lg lh li bi translated">资源</h1><p id="c004" class="pw-post-body-paragraph iy iz hi ja b jb lj jd je jf lk jh ji jj ll jl jm jn lm jp jq jr ln jt ju jv hb bi translated"><a class="ae kf" href="https://kotlinlang.org/docs/home.html" rel="noopener ugc nofollow" target="_blank">科特林文档</a></p><p id="8ca1" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated"><a class="ae kf" href="https://play.kotlinlang.org/" rel="noopener ugc nofollow" target="_blank">科特林游乐场</a></p><p id="4f9d" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated"><a class="ae kf" href="https://play.kotlinlang.org/koans/overview" rel="noopener ugc nofollow" target="_blank">科特林公案</a></p></div></div>    
</body>
</html>