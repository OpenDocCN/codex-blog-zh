<html>
<head>
<title>Create WebSocket Playground</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">创建WebSocket游乐场</h1>
<blockquote>原文：<a href="https://medium.com/codex/create-websocket-playground-12e3ab8ecf7c?source=collection_archive---------1-----------------------#2021-12-27">https://medium.com/codex/create-websocket-playground-12e3ab8ecf7c?source=collection_archive---------1-----------------------#2021-12-27</a></blockquote><div><div class="dt gx gy gz ha hb"/><div class="hc hd he hf hg"><div class=""/><p id="2d51" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">作为初学者，WebSocket对我来说是个谜。</p><blockquote class="je"><p id="c0f7" class="jf jg hj bd jh ji jj jk jl jm jn jd dy translated">我只需要设置一次！一个隧道！？</p></blockquote><p id="d9a0" class="pw-post-body-paragraph ig ih hj ii b ij jo il im in jp ip iq ir jq it iu iv jr ix iy iz js jb jc jd hc bi translated">在开始的时候，我找到了很多资源，这些资源讨论了什么是WebSockets，它们是如何使用的，以及它们应该在哪里/什么时候使用。但是我想使用它，运行它——一个<em class="jt">快速&amp;肮脏</em>的设置。我想检查不同的情况，尤其是浏览器失去连接时的行为。<em class="jt">(如果你想知道Chrome和Firefox上的网络套接字在连接断开时的不同表现。这并不奇怪！)</em></p><p id="3455" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">这个博客是设置WebSockets并对其进行实验的快速指南。但首先要快速介绍一下WebSockets。</p><h1 id="9421" class="ju jv hj bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">3w——什么、为什么和谁</h1><p id="da1a" class="pw-post-body-paragraph ig ih hj ii b ij ks il im in kt ip iq ir ku it iu iv kv ix iy iz kw jb jc jd hc bi translated">WebSockets用于在客户端(浏览器)和服务器之间打开一个<strong class="ii hk">交互式&amp;持久通道</strong>。客户端<em class="jt">根据需要建立和关闭</em>连接。WebSockets可以设计为支持<em class="jt">单向</em>或<em class="jt">双向</em>通信流。</p><figure class="ky kz la lb fe lc es et paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="es et kx"><img src="../Images/b249a912cbb61f7c08733e06c5ed94c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_m5QvqJU1W2BWrQt27sj8g.png"/></div></div><figcaption class="lj lk eu es et ll lm bd b be z dy translated"><em class="ln">单向</em>或<em class="ln">双向</em>与WebSockets通信的流程。</figcaption></figure><p id="1675" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">我们可以在许多网站上找到这些协议。考虑一下<a class="ae lo" href="https://stackoverflow.com/" rel="noopener ugc nofollow" target="_blank">堆栈溢出</a>。如果你花足够的时间在这个网站上，你可以看到网络套接字在发挥作用。新活动通过WebSocket连接发送到客户端。</p><figure class="ky kz la lb fe lc es et paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="es et lp"><img src="../Images/6f9839dd97e82f6fc9555c2eee283bdc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X5K51gXVFXAgFpMP65S0BQ.png"/></div></div><figcaption class="lj lk eu es et ll lm bd b be z dy translated">Stackoverflow使用draw.io的恐怖模仿——Web Sockets实时。</figcaption></figure><p id="13a3" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">要在任何网站上查看WebSocket请求，您可以—</p><ol class=""><li id="6b38" class="lq lr hj ii b ij ik in io ir ls iv lt iz lu jd lv lw lx ly bi translated">在浏览器中打开开发者工具。</li><li id="0e9e" class="lq lr hj ii b ij lz in ma ir mb iv mc iz md jd lv lw lx ly bi translated">切换到网络选项卡。</li><li id="56a0" class="lq lr hj ii b ij lz in ma ir mb iv mc iz md jd lv lw lx ly bi translated">过滤<code class="dv me mf mg mh b">ws</code>请求。</li><li id="ab5f" class="lq lr hj ii b ij lz in ma ir mb iv mc iz md jd lv lw lx ly bi translated">选择<code class="dv me mf mg mh b">ws</code>请求并检查正在进行的通信的消息选项卡。</li></ol><figure class="ky kz la lb fe lc es et paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="es et mi"><img src="../Images/cbddef68afddd708011043fb680d3335.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gEm095o6oVYhgmWQo6IqPA.png"/></div></div><figcaption class="lj lk eu es et ll lm bd b be z dy translated">在开发者工具中识别WebSockets请求。</figcaption></figure><p id="9b4c" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">你可能已经猜到了，WebSockets是客户机和服务器的合资企业。以下链接提供了所需的详细设置和工具。</p><ol class=""><li id="b752" class="lq lr hj ii b ij ik in io ir ls iv lt iz lu jd lv lw lx ly bi translated"><a class="ae lo" href="https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API" rel="noopener ugc nofollow" target="_blank">web socket API(web sockets)</a></li><li id="775a" class="lq lr hj ii b ij lz in ma ir mb iv mc iz md jd lv lw lx ly bi translated"><a class="ae lo" href="https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API/Writing_WebSocket_client_applications" rel="noopener ugc nofollow" target="_blank">编写WebSocket客户端应用程序</a></li><li id="1225" class="lq lr hj ii b ij lz in ma ir mb iv mc iz md jd lv lw lx ly bi translated"><a class="ae lo" href="https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API/Writing_WebSocket_servers" rel="noopener ugc nofollow" target="_blank">编写WebSocket服务器</a></li></ol><p id="4a76" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">或者你可以从WebSockets工具中选择。</p><p id="8c97" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">但是如果你只是像我一样需要快速设置，你只熟悉JavaScript <em class="jt">继续</em>阅读。</p><h1 id="b156" class="ju jv hj bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">网络插座游乐场</h1><p id="19e2" class="pw-post-body-paragraph ig ih hj ii b ij ks il im in kt ip iq ir ku it iu iv kv ix iy iz kw jb jc jd hc bi translated">在操场上，我们将实现服务器-客户端WebSocket连接的最基本实现，如下图所示。</p><figure class="ky kz la lb fe lc es et paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="es et mj"><img src="../Images/9b238a78837ad860b18be789d5fd9499.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TNtf0wyso1rqkQft4uxvkQ.png"/></div></div><figcaption class="lj lk eu es et ll lm bd b be z dy translated">一点要求</figcaption></figure><p id="f45f" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">我们将建立WebSocket连接，传递一些消息，然后从客户端关闭连接。</p><h2 id="ef88" class="mk jv hj bd jw ml mm mn ka mo mp mq ke ir mr ms ki iv mt mu km iz mv mw kq mx bi translated">设置项目</h2><p id="d193" class="pw-post-body-paragraph ig ih hj ii b ij ks il im in kt ip iq ir ku it iu iv kv ix iy iz kw jb jc jd hc bi translated">我们将建立一个NodeJS开发环境(快速简单)。<em class="jt">如果您是新手，需要更多关于如何设置NodeJS项目的详细信息，请查看</em> <a class="ae lo" href="https://levelup.gitconnected.com/set-up-and-run-a-simple-node-server-project-38b403a3dc09" rel="noopener ugc nofollow" target="_blank"> <em class="jt">设置并运行一个简单的节点服务器项目</em> </a> <em class="jt">和</em><a class="ae lo" href="https://developer.mozilla.org/en-US/docs/Learn/Server-side/Express_Nodejs" rel="noopener ugc nofollow" target="_blank"><em class="jt">Express web framework(Node.js/JavaScript)</em></a><em class="jt">。如果不需要，可以忽略Express部分。我们将只使用NodeJS。</em></p><p id="88ed" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">我们的项目结构将只包括两个文件— <code class="dv me mf mg mh b">client.js</code>和<code class="dv me mf mg mh b">server.js</code>。</p><pre class="ky kz la lb fe my mh mz na aw nb bi"><span id="e0a4" class="mk jv hj mh b fj nc nd l ne nf">- ws_starter<br/>| - client.js<br/>| - server.js<br/>| - package.json</span></pre><p id="bb97" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">我们将使用NodeJS Web Socket库— <code class="dv me mf mg mh b">ws</code>。</p><blockquote class="ng nh ni"><p id="f16d" class="ig ih jt ii b ij ik il im in io ip iq nj is it iu nk iw ix iy nl ja jb jc jd hc bi translated">ws是一个简单易用、速度极快且经过全面测试的WebSocket客户端和服务器实现。</p></blockquote><h2 id="82fa" class="mk jv hj bd jw ml mm mn ka mo mp mq ke ir mr ms ki iv mt mu km iz mv mw kq mx bi translated">设置服务器</h2><figure class="ky kz la lb fe lc es et paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="es et nm"><img src="../Images/3058c0208e356fe2943402597e3f42e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cMrYwaxkACfm2PxTi9YFLg.png"/></div></div><figcaption class="lj lk eu es et ll lm bd b be z dy translated">服务器会做什么？</figcaption></figure><p id="fd81" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">一旦客户端向服务器请求<code class="dv me mf mg mh b">connection</code>，服务器就可以向客户端发送<code class="dv me mf mg mh b">send</code>消息或者监听来自客户端的<code class="dv me mf mg mh b">message</code>。</p><pre class="ky kz la lb fe my mh mz na aw nb bi"><span id="8e8d" class="mk jv hj mh b fj nc nd l ne nf">// server.js</span><span id="4b30" class="mk jv hj mh b fj nn nd l ne nf">const WebSocket = require("ws");</span><span id="82b0" class="mk jv hj mh b fj nn nd l ne nf">// Create a web socket connection at port 8080.<br/>// This is where the client will keep listening to.<br/>const wss = new WebSocket.Server({ port: 8080 });</span><span id="b364" class="mk jv hj mh b fj nn nd l ne nf">wss.on("connection", (ws) =&gt; {<br/>  ws.send("SERVER: Connection established");</span><span id="be6d" class="mk jv hj mh b fj nn nd l ne nf">function pingClient() {<br/>    ws.send("SERVER: PING");<br/>  }</span><span id="e9e2" class="mk jv hj mh b fj nn nd l ne nf">// Keep pinging the client every 4 seconds.<br/>  const ping = setInterval(pingClient, 4000);</span><span id="353f" class="mk jv hj mh b fj nn nd l ne nf">// Listen to the message coming from client.<br/>  ws.on("message", (message) =&gt; {<br/>    console.log(`${new Date().toLocaleTimeString()}: ${message}`);<br/>  });</span><span id="756a" class="mk jv hj mh b fj nn nd l ne nf">// Clearing up when client closes web socket connection<br/>  ws.on("close", () =&gt; {<br/>    clearInterval(ping);<br/>    console.log("Connection closed.");<br/>  });<br/>});</span></pre><p id="55f5" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">这是所有需要的，现在我们将启动服务器。打开项目根目录的终端并运行节点服务器。</p><pre class="ky kz la lb fe my mh mz na aw nb bi"><span id="e525" class="mk jv hj mh b fj nc nd l ne nf">node server</span></pre><p id="5693" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">WebSocket服务器在<code class="dv me mf mg mh b">localhost:8080</code>运行。</p><h2 id="3a03" class="mk jv hj bd jw ml mm mn ka mo mp mq ke ir mr ms ki iv mt mu km iz mv mw kq mx bi translated">设置客户端</h2><figure class="ky kz la lb fe lc es et paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="es et no"><img src="../Images/982777339f696ee8a911139eac96dc0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fBEvuHoXeTJptEfp9BBs8A.png"/></div></div><figcaption class="lj lk eu es et ll lm bd b be z dy translated">客户会怎么做？</figcaption></figure><p id="d01a" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">客户机将与WebSocket服务器建立<code class="dv me mf mg mh b">connection</code>,然后一旦连接打开就发送初始消息。有一个<code class="dv me mf mg mh b">onerror</code>事件用于处理错误，例如网络错误，或者客户端丢失了来自服务器的任何传入消息。10秒钟后，WebSocket连接关闭。</p><pre class="ky kz la lb fe my mh mz na aw nb bi"><span id="d152" class="mk jv hj mh b fj nc nd l ne nf">// client.js</span><span id="333b" class="mk jv hj mh b fj nn nd l ne nf">const WebSocket = require("ws");<br/>const url = "ws://localhost:8080";<br/>const connection = new WebSocket(url);</span><span id="9479" class="mk jv hj mh b fj nn nd l ne nf">let introduceStop;</span><span id="2d40" class="mk jv hj mh b fj nn nd l ne nf">connection.onopen = () =&gt; {<br/>  // After connection opens send message to server.<br/>  connection.send("CLIENT: PONG");</span><span id="4948" class="mk jv hj mh b fj nn nd l ne nf">// After 10 seconds close web socket connection.<br/>  introduceStop = setTimeout(function () {<br/>    console.log(<br/>      `${new Date().toLocaleTimeString()}: Client closing WebSocket connection`<br/>    );<br/>    connection.close();<br/>  }, 10000);<br/>};</span><span id="acf5" class="mk jv hj mh b fj nn nd l ne nf">// Catch error while web socket connection is open.<br/>// After `onerror`, `onclose` will be triggered.<br/>connection.onerror = (error) =&gt; {<br/>  console.log(`Web socket error: ${error}`);<br/>};</span><span id="8842" class="mk jv hj mh b fj nn nd l ne nf">// Keep reading messages from server.<br/>connection.onmessage = (event) =&gt; {<br/>  console.log(`${new Date().toLocaleTimeString()} ${event.data}`);<br/>};</span><span id="a142" class="mk jv hj mh b fj nn nd l ne nf">// Clear things once web socket connection is closed.<br/>connection.onclose = () =&gt; {<br/>  clearTimeout(introduceStop);<br/>  console.log("Web Socket connection properly closed.");<br/>};</span></pre><p id="b9ad" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">对于客户端，您可以使用您的项目或者在终端中运行以下内容。</p><pre class="ky kz la lb fe my mh mz na aw nb bi"><span id="e026" class="mk jv hj mh b fj nc nd l ne nf">node client</span></pre><p id="67c0" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">现在，客户机和服务器都已启动并运行，我们可以继续处理终端了。</p><h2 id="b8c6" class="mk jv hj bd jw ml mm mn ka mo mp mq ke ir mr ms ki iv mt mu km iz mv mw kq mx bi translated">测试WebSocket游乐场</h2><p id="4227" class="pw-post-body-paragraph ig ih hj ii b ij ks il im in kt ip iq ir ku it iu iv kv ix iy iz kw jb jc jd hc bi translated">我们分别为服务器和客户端启动了两个终端。如果我们在分割窗口中打开它们，我们可以看到以下行为。</p><figure class="ky kz la lb fe lc es et paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="es et np"><img src="../Images/637b4497c1cc5765bc863364ac3e9d8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*674l3B9DSKZeqwQplTJspw.gif"/></div></div><figcaption class="lj lk eu es et ll lm bd b be z dy translated">WebSocket Playground in Motion |使用<a class="ae lo" href="https://www.canva.com/create/gif-maker/" rel="noopener ugc nofollow" target="_blank"> Canva </a>制作</figcaption></figure><p id="a608" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">这就是我们在操场上需要的一切。我们有一个服务器，我们可以修改它来发送任何数据或实现更多功能。我们不需要让客户呆在同一个地方。我们只需要建立WebSocket连接并保持服务器活动。</p><p id="e837" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">上述设置的代码可从<a class="ae lo" href="https://github.com/darshna09/websocket_mindmapping" rel="noopener ugc nofollow" target="_blank">darshna 09/web socket _ mind mapping</a>获得。</p><h1 id="210a" class="ju jv hj bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">参考</h1><ol class=""><li id="735c" class="lq lr hj ii b ij ks in kt ir nq iv nr iz ns jd lv lw lx ly bi translated">【快递网络框架(Node.js/JavaScript)【T2 T3】| MDN</li><li id="06a8" class="lq lr hj ii b ij lz in ma ir mb iv mc iz md jd lv lw lx ly bi translated"><a class="ae lo" href="https://developer.mozilla.org/en-US/docs/Learn/Server-side/Node_server_without_framework" rel="noopener ugc nofollow" target="_blank">没有框架的Node.js服务器</a> | Level Up编码|中</li></ol></div></div>    
</body>
</html>