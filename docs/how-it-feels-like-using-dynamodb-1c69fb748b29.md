# 我希望在使用 DynamoDB 之前知道的事情

> 原文：<https://medium.com/codex/how-it-feels-like-using-dynamodb-1c69fb748b29?source=collection_archive---------2----------------------->

## 考虑使用 DynamoDB 吗？你应该事先知道这些搜索限制。

![](img/d5b4b108b73491acbad9401511350a5d.png)

数据分区是构建分布式数据存储系统的方法之一

D ynamoDB 的点播计费非常非常有诱惑力。您按请求付费，而不是 24/7 服务器运行时间。不需要选择实例大小—您可以免费获得几乎“无限”的可伸缩性。作为一个 NoSQL 数据库，DynamoDB 是文档风格、无模式的对象存储。一切似乎变得更加灵活和简单。

但是当我发现我不能像以前那样搜索数据时，我感到很惊讶。我来自 Postgres，习惯于在表之间链接列，存储结构化的压缩数据。当我试图在 DynamoDB 中搜索时，有这么多的怪癖和限制——为什么我不能做一些如此琐碎和常见的事情？

事不宜迟，让我们看看在 DynamoDB 中查询时需要注意什么。我希望我事先知道。我确信他们会让你大吃一惊(我的肯定会)。

# 令人讨厌的查询限制

*惯坏警报:不便多于限制*。

## 限制 1:如果你需要搜索，你不能改变一个字段

*(更准确地说，对于“搜索方式”我是指按字段查询)*

在 SQL 中，你可以通过`WHERE field1=value1 AND field2=value2 AND field3=value3 ..`和任意多的字段&条件进行查询，就像完全免费一样。当然，如果应用程序需要，你可以对表中的条目进行头部更新`field1`或`field2`，这有什么大不了的？除了主键，我觉得有权完全控制任何字段值！

在 DynamoDB 中你不能这样做。如果要通过`field1`进行查询，最好将`field1`设置为只读——一旦创建了对象，就不能更新该字段！什么？Ughh！

感觉好压抑好窒息？有一个新鲜空气的小窗口:你可以移除`field1`或将其添加回来。这是您可以在可查询字段上执行的唯一变异操作(我使用术语字段，因为它在 SQL 中似乎更常见，但是 DynamoDB 更经常使用术语“属性”；在本文中，它们是可以互换的)。这被称为“稀疏索引”技术。稀疏指数有一些重要的指标。如果字段值需要更新，您只能以二进制、布尔方式查询**——查询字段是否存在。**

你问:“这不是应该是必备功能吗？！我需要更新一个字段，我们需要通过它进行查询。”例如，您有一个名为`status`的字段。它的值可以是`Running`、`Failed`或`Completed`，这个字段必须能够更新，我们需要在`status`上查询应用程序的搜索功能才能工作！可以，稀疏索引可以满足这种需要，但是需要额外的工作。它是这样工作的:你创建另一个名为`isRunning`、`isFailed`或`isCompleted`的字段，你现在可以查询这些字段来搜索你想要的项目。当然，您需要在更新`status`值时通过删除或添加来维护这些额外的字段。

## 限制#2:最多只能搜索两个字段

更糟糕的是:其中一个只能做“精确匹配”搜索，并且你必须在查询时指定这个，不能是可选的！这是“分区键”，就像 SQL 中的主键一样。

为了灵活起见，您实际上只有一个字段，即“排序关键字”——您可以使用所有优秀的`=`、`>`、`<`、`BETWEEN`、`STARTS WITH`操作符，而且它是可选的。但是请记住，只有一个像这样的字段允许查询！真的吗？！

由于 query 的这种巨大限制，你被迫结合各种替代方式，尝试你能做的一切，只要它在合理的时间内获得你的 app 需要的数据。是的，现在您的 DynamoDB 模式设计需要绞尽脑汁。

目前我所知道的替代方案(随着我在旅途中不断学习，这个列表可能会增加)

*   在通过 1~2 个字段进行查询后，结果大小是否减少到只有几个项目？如果是这样，现在可以使用扫描来过滤更多的字段。
*   我们真的需要按那么多字段进行查询吗？该应用程序可能不需要过滤一切。给我更多的应用程序访问模式的细节，甚至谈判，只要重要的用户需求得到满足
*   创建多个 GSI(全局二级索引),因此，即使您只能在一个 GSI 中查询最多两个不同的字段，希望多个 GSI 可以覆盖您的大部分应用访问模式(不过，同时查询两个以上的字段是不可能的)
*   将几个字段连接成一个字段有助于查询更多字段。参见“**选择分区键**的困境”一节中的示例。
*   …更多方式？

通常，作为排序关键字的时间戳字段对于减少结果查询的大小是足够有效的。然后，使用扫描或其他技术来进一步过滤其他字段也是可以的。

# 更多恼人的事实…

我们来谈谈设计 DynamoDB 模式时的棘手话题。

## 选择分区键的困境

基数——描述集合变化程度的术语。基数大，变化多。基数低，只有几种。

人们建议避免热键——这意味着与其他分区相比，一个数据分区被访问得过于频繁，性能可能会受到阻碍。因此，您应该选择高基数的字段作为分区键。然而，一个巨大的缺点是它会使查询变得困难——查询总是需要你提供精确的分区键(上面提到的“精确匹配”)。这有什么不好？如果一个字段基数很高，那么当你需要搜索时，很可能不容易知道它的值。一个极端的例子是 UUID——最大基数，但是除了一个单项 Get 操作之外，对于查询或搜索几乎没有用处。

您会问:我可以选择一个字段作为分区键来帮助查询吗——以帮助缩小结果范围？是的，你可以，但有成本。一种技术是将多个字段连接成一个字段。例如，您有一个包含字段`property1`、`property2`、`property3`、`property4`的对象。你可以连接它们中的几个，比如前两个字段，作为分区键，就像`property1Value-property2Value`。现在查询的时候可以免费按 property1 和 property2 查询，实现`WHERE property1=property1Value AND property2=property2Value`。精彩！对吗？等等，串联的`property1Value-property2Value`提供了足够的基数吗？如果不是，那么嗯嗯，热键问题。如果是的话，接下来的第一个问题是你必须**总是** **为查询指定**属性 1 和属性 2，不能像只有`WHERE property1=property1Value`或`WHERE property2=property2Value`一样是可选的。第二个问题是，如果您为基表选择分区键，这些字段必须为所有项目提供非空值。这可能很烦人，因为你已经准备好灵活地使用 NoSQL，现在你又说我们需要一些非空的字段？！

人们经常做的是创建 GSI 来解决第二个问题——在 GSI 中，分区键可以为空。所以第二个问题解决了。为了解决第一个问题…你不得不忍受它，这是使用分区键查询的代价。因此，您可以明智地选择分区键，考虑是否要连接，如果是，则连接多少个字段，因为一旦连接，您将需要在查询中指定它们。

**我想说的是，当选择基表的分区键时，忘记辅助查询，只使用 UUID 或你确定所有项目都有非空值的字段。然后，由于 UUID 对于查询是无用的，您创建 GSI 以便您可以选择另外两个字段在**上查询。

或者，如果您确实想使用分区键进行查询，这在 GSI 也是不可避免的，无论如何您总是需要分区键进行查询，所以您选择了一些低基数字段作为分区键，比如值为“已提供”、“已批准”或“已发布”的“状态”字段，那么您就要担心热键了。我发现这很令人困惑，**一方面查询要求分区键，只能做精确匹配，所以你想选择一个没有太多变化的字段，使应用程序的搜索灵活&易于使用，但另一方面这导致热键问题。** Boom，DynamoDB 还能用吗？嗯，你可能会忘记热键。我在 AWS 博客上看到一些文章，说 DynamoDB 最终会在检测到某个特定分区受到大量关注时为您进行数据节点复制和负载平衡。这个提议对 GSI 来说是正确的，但对 LSI(本地二级指数)来说不是。

# 不太真实的 DynamoDB 最佳实践

现在让我们来谈谈陷阱——您认为它们是要遵循的“最佳实践”,然而，并不一定如此！

## 不要使用扫描

众所周知，扫描会检查每个数据库项目，会降低数据库性能，成本高、速度慢、不可扩展。查询快速、高效。

但这并不意味着我们应该排除使用扫描，即使我们认真考虑可伸缩性和性能。尤其是当您有复杂的访问模式和数据形状时，更是如此。

所以使用 scan 就可以了，只是，要确保要扫描的项目“不要太大”。当它处于中间时——有点大，但不太大，或者你不确定未来——你仍然可以首先尽力考虑查询(索引)或其他替代方法。

扫描操作不仅被`Table.scan()`使用，还被查询`Table.query(FilterExpression=...)`过滤使用。**一种常见的方法是首先通过查询两个字段(分区键、排序键)来缩小结果大小，然后应用一个过滤器(扫描)。当然，在您的双字段查询**之后，结果大小最好足够小。因此，选择哪两个字段进行查询是至关重要的，这可能是最大的一部分，你会纠结，询问更多关于应用程序的访问模式，并来回切换。希望创建 GSI 能给你足够的灵活性。

就是这样！使用 DynamoDB 时的“怪癖”。它们不会限制你完成非常复杂的查询，但是需要额外的认知负荷，这是我在这篇文章中想要向你展示的要点。最后，摆脱像外键和表这样的 SQL 方式肯定需要时间。它没有 SQL 提供的方便、灵活的查询，但是我们应该问自己:我们真的需要所有这些吗？我们能放下什么？你可能听说过 NoSQL 强迫你计划你的应用程序访问模式，甚至每个模式的规模。因为你要应对这些巨大的限制。

最后，我让步了——也许不便之处在于 DynamoDB 开箱即用的可伸缩性和性能的成本。以上是对 DynamoDB 的一个简单介绍。这个集思广益的过程发生在我终于有机会为消费品从头到尾编排一个 DynamoDB 表的时候。

我希望这篇文章能让你知道，如果你来自 SQL 并决定使用 DynamoDB，你需要做些什么。对我来说，一旦我有了更多的见解，就会有更多的帖子。