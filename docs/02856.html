<html>
<head>
<title>React Navigation: Deep Linking with authentication</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React导航:带身份验证的深度链接</h1>
<blockquote>原文：<a href="https://medium.com/codex/react-navigation-deep-linking-with-authentication-9056eb4a0456?source=collection_archive---------2-----------------------#2021-08-09">https://medium.com/codex/react-navigation-deep-linking-with-authentication-9056eb4a0456?source=collection_archive---------2-----------------------#2021-08-09</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="277b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最近，我有机会使用<a class="ae jd" href="https://reactnavigation.org/" rel="noopener ugc nofollow" target="_blank"> React导航</a>解决了一个<a class="ae jd" href="https://reactnative.dev/" rel="noopener ugc nofollow" target="_blank"> React原生</a>应用中的深度链接。就像其他银行应用程序一样，重要的屏幕位于身份验证层之后。</p><h1 id="83c7" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">问题</h1><p id="8a85" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">在这些应用程序中，用户每次打开应用程序时都必须进行身份验证。所有特定于用户的信息都在这堵认证墙后面。这使得深度链接有点棘手，因为一些路线在应用程序加载后就不可用了。</p><p id="4326" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">理想情况下，应用程序应该记得在身份验证成功时触发深层链接。但是，对于每个应用程序，成功的身份验证可能有不同的意义。</p><h1 id="a5c8" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">解决办法</h1><p id="b1a7" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">我创建了一个队列上下文提供程序，它将保存一组失败的深层链接。导航器中的一个屏幕可以订阅一个事件类型，当用户成功登陆时将触发该事件类型。</p><h1 id="6011" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">步骤1:检查深层链接是否失败</h1><p id="667b" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">在这个故事发生的时候，我正在和<code class="du kh ki kj kk b"><a class="ae jd" href="https://www.npmjs.com/package/@react-navigation/native" rel="noopener ugc nofollow" target="_blank">@react-navigation/native = "6.0.0"</a></code>一起工作。为了检查深层链接是否失败，我必须监听URL事件，并使用名为<code class="du kh ki kj kk b">checkDeepLinkResult</code>的客户助手函数将深层链接的URL与<a class="ae jd" href="https://reactnavigation.org/docs/configuring-links" rel="noopener ugc nofollow" target="_blank">链接模式</a>进行比较。</p><pre class="kl km kn ko fd kp kk kq kr aw ks bi"><span id="f5a5" class="kt jf hi kk b fi ku kv l kw kx">import { createRef } from 'react';<br/>import {<br/>  PartialState,<br/>  NavigationAction,<br/>  NavigationState,<br/>  getStateFromPath,<br/>  getPathFromState,<br/>  getActionFromState,<br/>  NavigationContainerRef,<br/>} from '<a class="ae jd" href="http://twitter.com/react" rel="noopener ugc nofollow" target="_blank">@react</a>-navigation/native';</span><span id="7472" class="kt jf hi kk b fi ky kv l kw kx">import { linking } from '../nav';</span><span id="6b2c" class="kt jf hi kk b fi ky kv l kw kx">export const DeepLinkSchema = 'RNDeepLinkAuth://';<br/>export const navigationRef = createRef&lt;NavigationContainerRef&lt;any&gt;&gt;();</span><span id="59d9" class="kt jf hi kk b fi ky kv l kw kx">const cleanPathStr = (path: string) =&gt; {<br/>  const queryVairablesIndex = path.indexOf('?');<br/>  if (queryVairablesIndex === -1) {<br/>    return path;<br/>  }<br/>  return path.substr(0, queryVairablesIndex);<br/>};</span><span id="91d6" class="kt jf hi kk b fi ky kv l kw kx">export const checkDeepLinkResult = (url: string) =&gt; {<br/>  const extractedUrl = url.replace(DeepLinkSchema, '');</span><span id="3f32" class="kt jf hi kk b fi ky kv l kw kx">const currentState = navigationRef.current?.getRootState() as NavigationState;</span><span id="edae" class="kt jf hi kk b fi ky kv l kw kx">const linkState = getStateFromPath(<br/>    extractedUrl,<br/>    linking.config as any,<br/>  ) as PartialState&lt;NavigationState&gt;;</span><span id="aceb" class="kt jf hi kk b fi ky kv l kw kx">const currentPath = cleanPathStr(getPathFromState(currentState));</span><span id="d157" class="kt jf hi kk b fi ky kv l kw kx">const linkPath = cleanPathStr(getPathFromState(linkState));</span><span id="7f37" class="kt jf hi kk b fi ky kv l kw kx">const action = getActionFromState(linkState) as NavigationAction;</span><span id="4bf6" class="kt jf hi kk b fi ky kv l kw kx">return {<br/>    action,<br/>    linkPath,<br/>    didDeepLinkLand: currentPath === linkPath,<br/>  };<br/>};</span></pre><h1 id="de91" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">步骤2:存储失败的深层链接</h1><p id="7f8b" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">为了存储失败的深层链接，我创建了一个名为<code class="du kh ki kj kk b">DeepLinkProvider</code>的提供者。该提供程序将跟踪数组中所有失败的深层链接。</p><pre class="kl km kn ko fd kp kk kq kr aw ks bi"><span id="7ad3" class="kt jf hi kk b fi ku kv l kw kx">import React, {<br/>  useState,<br/>  createContext,<br/>  FunctionComponent,<br/>  useCallback,<br/>} from 'react';</span><span id="3de8" class="kt jf hi kk b fi ky kv l kw kx">import { DeepLinkEnum } from '../hooks';</span><span id="fee5" class="kt jf hi kk b fi ky kv l kw kx">export interface IDeepLink {<br/>  id: string;<br/>  type: DeepLinkEnum;<br/>  action: () =&gt; void | Promise&lt;void&gt;;<br/>}</span><span id="7b37" class="kt jf hi kk b fi ky kv l kw kx">export type DeepLinkContextType = {<br/>  deepLinksState: IDeepLink[];<br/>  addDeepLink: (link: IDeepLink) =&gt; void;<br/>  removeDeepLink: (id: string) =&gt; void;<br/>};</span><span id="9c50" class="kt jf hi kk b fi ky kv l kw kx">export const DeepLinkContext = createContext&lt;DeepLinkContextType&gt;({<br/>  deepLinksState: [],<br/>  addDeepLink: () =&gt; {},<br/>  removeDeepLink: () =&gt; {},<br/>});</span><span id="adbc" class="kt jf hi kk b fi ky kv l kw kx">export const DeepLinkProvider: FunctionComponent&lt;unknown&gt; = ({ children }) =&gt; {<br/>  const [deepLinksState, setDeepLinksState] = useState&lt;IDeepLink[]&gt;([]);</span><span id="bc64" class="kt jf hi kk b fi ky kv l kw kx">const addDeepLink = useCallback((link: IDeepLink) =&gt; {<br/>    setDeepLinksState(prevDeepLinks =&gt; [...prevDeepLinks, link]);<br/>  }, []);</span><span id="95c6" class="kt jf hi kk b fi ky kv l kw kx">const removeDeepLink = useCallback((id: string) =&gt; {<br/>    setDeepLinksState(prevDeepLinks =&gt;<br/>      prevDeepLinks.filter(link =&gt; link.id !== id),<br/>    );<br/>  }, []);</span><span id="2bd8" class="kt jf hi kk b fi ky kv l kw kx">return (<br/>    &lt;DeepLinkContext.Provider<br/>      value={{ deepLinksState, addDeepLink, removeDeepLink }}&gt;<br/>      {children}<br/>    &lt;/DeepLinkContext.Provider&gt;<br/>  );<br/>};</span></pre><h1 id="5f93" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">步骤3:向提供者添加失败的深层链接</h1><pre class="kl km kn ko fd kp kk kq kr aw ks bi"><span id="6d23" class="kt jf hi kk b fi ku kv l kw kx">const { <br/>  action,<br/>  linkPath, <br/>  didDeepLinkLand,<br/>} = checkDeepLinkResult(url);</span><span id="9bea" class="kt jf hi kk b fi ky kv l kw kx">if (!didDeepLinkLand) {<br/>  addDeepLink({<br/>    id: linkPath,<br/>    type: DeepLinkEnum.NAVIGATION,<br/>    action: () =&gt; navigationRef.current?.dispatch(action),<br/>  });<br/>}</span></pre><h1 id="0c15" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">步骤4:订阅失败的深层链接</h1><p id="4a40" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">一旦设置了深度链接提供者，并通过添加失败的深度链接来利用它，屏幕就可以订阅一个事件类型。一旦用户登陆订阅屏幕，深层链接将在挂载时触发。</p><pre class="kl km kn ko fd kp kk kq kr aw ks bi"><span id="7994" class="kt jf hi kk b fi ku kv l kw kx">useDeepLinks([DeepLinkEnum.NAVIGATION]);</span></pre><h1 id="89d5" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">示例应用程序</h1><p id="8ae1" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">我已经制作了一个<a class="ae jd" href="https://github.com/ximxim/RNDeepLinkAuth" rel="noopener ugc nofollow" target="_blank">示例应用程序</a>来更详细地展示这个解决方案。该应用程序的导航设置如下:</p><figure class="kl km kn ko fd la er es paragraph-image"><div class="er es kz"><img src="../Images/1a37ef18e434bfbe4fdb4d481b705e18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*o_3Gr-iIOl5_PZm6UFhpRw.png"/></div></figure><p id="9e7d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">试用示例应用程序，如果有任何问题或反馈，请留下评论。我很乐意听到其他人如何在他们的应用程序中解决类似的问题。</p><h1 id="5467" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">奖金</h1><p id="45a6" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">这种基础设施的一个好处是添加自定义的深层链接并订阅这些链接。例如，用户同意在登录后听到报价。我们可以添加深层链接并订阅它。</p><pre class="kl km kn ko fd kp kk kq kr aw ks bi"><span id="28c9" class="kt jf hi kk b fi ku kv l kw kx">addDeepLink({<br/>  id: 'someId',<br/>  type: DeepLinkEnum.OFFER,<br/>  action: () =&gt; showOfferModal(),<br/>});</span></pre><p id="e39a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jd" href="https://github.com/ximxim/RNDeepLinkAuth" rel="noopener ugc nofollow" target="_blank"> Github </a></p></div></div>    
</body>
</html>