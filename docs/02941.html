<html>
<head>
<title>ANTLR Magic — Developing Mainframe Language Applications Using Language Recognizer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">ANTLR Magic——使用语言识别器开发大型机语言应用程序</h1>
<blockquote>原文：<a href="https://medium.com/codex/antlr-magic-developing-mainframe-language-applications-using-language-recognizer-5262726e1e93?source=collection_archive---------4-----------------------#2021-08-12">https://medium.com/codex/antlr-magic-developing-mainframe-language-applications-using-language-recognizer-5262726e1e93?source=collection_archive---------4-----------------------#2021-08-12</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="5049" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你有没有想过编写自己的语言应用程序，并将其集成到一个IDE中？</p><p id="91db" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">每个开发人员都有自己喜欢的IDE来帮助他们开发应用程序。所以，让我们换一种方式来问这个问题，你有没有想过这些ide是如何提供现代编码和调试体验的？回答这个问题可能并不简单。因此，让我们用一种更简单的方式，用实际的例子来描述它是如何实现的，以及使用哪种技术(例如，Java、ANTLR、VSCode、Typescript、LSP、DAP等。)支持哪个部分[组件，特性]，以及那些组件如何协同工作。</p><p id="b22c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在开始开发任何语言应用程序之前，您需要了解该语言的语法，并且需要有一个语言识别工具(例如ANTLR[1])，它理解该语言并使用预定义的语言语法生成解析器。此外，要将语言应用程序与ide集成以提供现代编码和调试体验，您需要实现一个语言服务器和一个客户端，它们必须符合LSP [2]和DAP [3]规范。</p><p id="c4bd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我之前的博客中，我已经描述了这些规范的作用:LSP带来了现代编辑能力的魔力，而DAP提供了现代调试体验。在本文中，我将向您展示ANTLR带来的<strong class="ih hj">魔力</strong>，以及它在构建语言应用程序(例如COBOL语言支持、JCL、REXX等)中的作用。).</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/d53cb38b5c8c7e618a291837d1954490.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*p4fnTRmp1UiGFa9Y"/></div></div></figure><p id="5f50" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">作为一个案例研究，为了学习ANTLR的技术方面，您将创建一个样例Java应用程序，它允许我们编写最短的COBOL程序。要开始开发，首先使用命令行工具尝试手动下载jar文件，然后在不同的ide上使用ANTLR插件切换到Maven。然后逐步应用ANTLR特性。</p><p id="d416" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请记住，您在这里看到的许多代码片段并不完整，因此只需参考GitHub repo即可获得完整的示例。示例应用程序的源代码在<a class="ae jd" href="https://github.com/asatklichov/antlr-magic" rel="noopener ugc nofollow" target="_blank">这里</a>是公开的。</p><h1 id="fe22" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">ANTLR v4入门</h1><p id="046d" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">1989年，Terence Parr教授在创建基于计算机的语言识别方面迈出了重要的一步，这是一个递归下降解析工具——ANTLR。ANTLR(另一个语言识别工具)是一个强大的解析器生成器，用于读取、处理、执行或翻译结构化文本或二进制文件[4]。在生成的解析器执行之前，它在运行时动态地而不是静态地执行语法分析。它还简化了许多步骤，使得创建语言识别器和解析器更加容易和方便。ANTLR被广泛用于编写新语言的解释器和编译器，或者构建工具和框架，或者分析日志。例如:Hibernate使用ANTLR解析和处理HQL查询，而Elasticsearch使用它进行无痛查询。在Groovy、Ruby、Go、Swift、Python、Apache Spark、Intellij IDEA、WebLogic、JBoss Rules等中也有ANTLR的其他用法。</p><p id="6821" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">安装ANTLR </strong></p><p id="808f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">ANTLR是用Java编写的(所以一个先决条件是你应该至少安装了Java 7)，它由两个主要部分组成:ANTLR工具(命令行工具)，用于将你的语法翻译成Java语言(或其他目标语言:JavaScript、Python、Ruby、C#等)的解析器/词法分析器。)和运行生成的解析器/词法分析器所需的运行时。</p><p id="6c86" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要手动安装ANTLR<a class="ae jd" href="https://www.antlr.org/download.html" rel="noopener ugc nofollow" target="_blank">下载</a>最新的"<a class="ae jd" href="https://www.antlr.org/download/antlr-4.9.2-complete.jar%20" rel="noopener ugc nofollow" target="_blank"><em class="kt">ANTLR-4 . x . x-complete . jar</em></a>并将其添加到类路径中。jar文件包含运行ANTLR工具所需的所有依赖项，以及编译和执行ANTLR生成的识别器所需的运行时库。然而，为了使所有的<strong class="ih hj"> antlr4 </strong>和<strong class="ih hj"> grun </strong>命令正常工作，请遵循<a class="ae jd" href="https://github.com/antlr/antlr4/blob/master/doc/getting-started.md" rel="noopener ugc nofollow" target="_blank">不同操作系统</a>的说明。下面是在OSX[4]上的安装步骤</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es ku"><img src="../Images/16344d82a59e7f19169c1d05865d2881.png" data-original-src="https://miro.medium.com/v2/resize:fit:1120/format:webp/1*p3LbQEDl3lM_FGru1fk8Ag.png"/></div></figure><p id="23f3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">或者，要通过构建工具安装ANTLR，可以使用Maven或Gradle，也可以将ANTLR插件集成到您喜欢的ide中(参见将生成的解析器集成到项目中一节)。</p><h1 id="1d48" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">ANTLR4语法简介</h1><p id="aa52" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">使用<a class="ae jd" href="https://en.wikipedia.org/wiki/Context-free_grammar" rel="noopener ugc nofollow" target="_blank">上下文无关语法</a>指定语言，使用<a class="ae jd" href="https://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_Form" rel="noopener ugc nofollow" target="_blank">扩展的巴克斯-诺尔形式</a> (EBNF)表达。识别语言的程序被称为<strong class="ih hj">解析器</strong>或<strong class="ih hj">语法分析器</strong>。ANTLR允许你定义你的计算机语言的“语法”,它通过一组规则提供了一种方便的和开发者友好的定义语言语法的方式。<strong class="ih hj">规则</strong>由一系列<strong class="ih hj">标记</strong>和<strong class="ih hj">动作</strong>组成，它们定义了一条语句应该如何用您的源语言编写，以便能够被正确地识别和解析。ANTLR语法结构的一般形式如下所示:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es kv"><img src="../Images/c58c107d106bc13481bff8de698e804d.png" data-original-src="https://miro.medium.com/v2/resize:fit:418/format:webp/1*kmFxqjmR0bdxcaCfm_Gn9g.png"/></div></figure><p id="69d4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">包含语法X的文件名必须称为X <strong class="ih hj"> .g4 </strong>。您可以按任意顺序指定元素(选项、导入、令牌规范和操作)。选项、导入和令牌规范最多只能有一个。所有这些元素都是可选的，除了语法头(语法名)和规则。必须至少定义一个规则，否则没有任何规则的语法是没有意义的。规则采用以下基本形式:rule name:alternative 1 |…| alternativeN；</p><p id="f360" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">定义语法有两种方法:自顶向下和自底向上。</p><p id="57f5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">自顶向下</strong>从用您的语言编写的文件的一般组织开始。像在Java(或者其他现有语言COBOL，C++等。):包声明、导入、类型声明、构造函数、方法等。当你对语言或语法本身有扎实的知识时，这种方法是很好的。然后，您开始定义代表整个文件的规则，它包括其他子规则。</p><p id="4b8d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在<strong class="ih hj">自底向上</strong>方法中，您首先关注小元素:定义如何捕获令牌，以及如何定义基本表达式。然后，移动到下一个更高级别的元素，并为整个文件逐步构建规则。这种方法有助于关注每一个细节，但在大多数情况下，你对产品及其未来的了解较少。</p><p id="4c2a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们定义一个组合语法(在一个语法下定义的解析器和词法分析器)，它将帮助我们使用COBOL编程语言编写一个最短的程序(考虑下面的代码)。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es kw"><img src="../Images/3d7f916fe87e3760f5be37a79ef1f62a.png" data-original-src="https://miro.medium.com/v2/resize:fit:726/format:webp/1*7NdELYfgmzNwO5m8X-F9aQ.png"/></div></figure><p id="373e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以你需要提供描述这种语言的规则。它们可以是数据格式、图表或任何用文本表示的结构。规则元素指定解析器在给定时刻应该做什么，就像编程语言中的语句一样。这些元素可以是规则、标记或类似表达式的字符串。解析器规则名称必须以小写字母开头，词法分析器规则必须以大写字母开头。有关规则的更多信息，请参考<a class="ae jd" href="https://github.com/antlr/antlr4/blob/master/doc/index.md" rel="noopener ugc nofollow" target="_blank"> ANTLR4文档</a>。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es kx"><img src="../Images/52f8ede62ed1a87fc1e07bed1f77cd2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:916/format:webp/1*r-HukBnQZnIhtJsYXcgTRQ.png"/></div></figure><h1 id="318b" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">执行ANTLR和测试识别器</h1><p id="714f" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">一旦安装了ANTLR并正确设置了类路径，就可以找到ANTLR工具和名为TestRig(测试语法的实用工具)的运行时。为了快速启动工具，最好为两者创建一个方便的别名或批处理文件:参见<a class="ae jd" href="https://github.com/asatklichov/antlr-magic/tree/main/using-antlr-cmd" rel="noopener ugc nofollow" target="_blank">批处理文件</a> : run1、run2、run3，分别用于CLASSPATH、Tool和TestRig。</p><p id="733a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">&gt; doskey<strong class="ih hj">antlr 4</strong>= Java org . antlr . v4 . tool $ *</p><p id="2eac" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">&gt; doskey<strong class="ih hj">grun</strong>= Java org . antlr . v4 . GUI . test rig $ *</p><p id="e1e6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后使用<strong class="ih hj"> antlr4 </strong>命令将语法转换成程序，程序可以识别语法所描述的语言中的句子。详细执行步骤见<a class="ae jd" href="https://github.com/asatklichov/antlr-magic/blob/main/using-antlr-cmd/__how-to-run.txt" rel="noopener ugc nofollow" target="_blank">操作指南</a>文件。</p><p id="c7c9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">&gt; antlr 4 shortestcobolgrammar . G4//生成antlr工件，将语法翻译成可执行的Java代码</p><p id="5c3b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在你可以看到一些生成的文件，它们的名字分别是ShortestCobolGrammarLexer.java、ShortestCobolGrammarParser.java……还有*。令牌文件。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es ky"><img src="../Images/2c7e7ae3b3abc3b71168f12ad0497c8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1290/0*vlMT66muZ0fpICxS"/></div></figure><p id="8482" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您调用ANTLR工具而没有任何命令行参数&gt; antlr4，您将得到一条帮助消息，显示您在运行它时可以指定的选项。例如，您可以指定目标语言，生成JS/TS、Python、C#、C++或其他语言的解析器，以便支持其他目标语言。</p><p id="155e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">&gt; antlr 4-d language = JavaScript shortestcobolgrammar . G4</p><p id="7ad5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">&gt; antlr 4-d language = python 3 shortestcobolgrammar . G4</p><p id="658b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">另一个非常方便的选择是产生访问者，或者排除听众等等。ANTLR从语法中生成一个解析器，该解析器可以构建解析树，还可以生成一个监听器(或访问者),这使得对感兴趣的短语的识别很容易做出响应。</p><p id="2571" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">&gt; antlr 4-visitor shortest cobol . G4//创建侦听器和访问者</p><p id="a153" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">&gt; antlr 4-visitor-no-listener shortest cobol . G4//仅创建访问者</p><p id="43ec" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了测试你的语法，使用带有真实输入的<strong class="ih hj"> grun </strong> (TestRig)程序。TestRig使用Java反射来执行编译后的识别器。这就是为什么您必须编译生成的Java源文件。</p><p id="509e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">&gt; javac ShortestCobolGrammar*。Java语言（一种计算机语言，尤用于创建网站）</p><p id="fb88" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">TestRig接受一个语法名称、一个类似于main()方法的起始规则名称(例如cobolProgram)和各种选项(例如-- tokens，以显示检测到的标记),这些选项决定了您想要的输出。要测试语法，请按如下方式启动grun:</p><p id="41c5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">&gt; grun shortestcobolgrammar cobolprogram–tokens//for:eof #在Unix上键入ctrl-D (^D ),在Windows上键入Ctrl+Z</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/42c8ee2beea529bcbfaa6b1180364202.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*YvFT4RYyYuE8utwp"/></div></div></figure><p id="6b4d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Grun <em class="kt"> ( &gt; grun) </em>还有几个有用的选项:-tree，-tokens，-gui，-ps，-diagnostics等。</p><p id="adbc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要可视化输入的解析树(AST ),请使用-gui选项。解析器获取一段文本，并将其转换成一个有组织的结构(即:解析树)，也称为抽象语法树(AST)。</p><p id="d0cd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">&gt; grun shortest cobol grammar cobol program–GUI</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es kz"><img src="../Images/cab7acb96187d130838d2d9db79bc882.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*757Py-pwxq__u8mN"/></div></div></figure><p id="6dd2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">备注</strong>:如果你修改了语法文件，那么你需要重新生成文件。因此，不要依赖你对生成文件的编码，而是用你自己的类来扩展它们，例如，供听众和访问者使用。</p><h1 id="2867" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">ANTLR的实际工作原理</h1><p id="3ed7" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">ANTLR通过分析您提供的语法(如<a class="ae jd" href="https://github.com/asatklichov/antlr-magic/blob/main/using-antlr-cmd/ShortestCobolGrammar.g4" rel="noopener ugc nofollow" target="_blank"> ShortestCobolGrammar.g4 </a>)或取自<a class="ae jd" href="https://github.com/antlr/grammars-v4" rel="noopener ugc nofollow" target="_blank">现有语法</a>)自动为您生成词法分析器和解析器。默认情况下，ANTLR会读取一个语法，并为该语法定义的语言生成一个识别器。例如，下面的命令读取输入流，并且如果输入流不符合语法指定的语法，则生成错误。</p><p id="8b4f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">c:\ workspace-eclipse \ antlr-magic \ using-antlr-cmd &gt; grun shortest cobol grammar cobol program</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es la"><img src="../Images/64eb452e67d5f8bfe4184a996f997ae9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1176/format:webp/1*fsa58dlYUouvy78Z9e1zAg.png"/></div></figure><p id="3213" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果没有语法错误，那么默认操作就是退出，不打印任何消息。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es lb"><img src="../Images/7fc549fc980207bd68a5e63a1cef5e06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1192/format:webp/1*gd_rzv8a-OiwFm5P4K69vg.png"/></div></div></figure><p id="cb3b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">ANTLR可以生成<a class="ae jd" href="https://en.wikipedia.org/wiki/Lexical_analysis" rel="noopener ugc nofollow" target="_blank">词法分析器</a>、<a class="ae jd" href="https://en.wikipedia.org/wiki/Parser" rel="noopener ugc nofollow" target="_blank">解析器</a>、<a class="ae jd" href="https://en.wikipedia.org/w/index.php?title=Tree_parser&amp;action=edit&amp;redlink=1" rel="noopener ugc nofollow" target="_blank">树解析器</a>，以及组合的<a class="ae jd" href="https://en.wikipedia.org/w/index.php?title=Lexer-parser&amp;action=edit&amp;redlink=1" rel="noopener ugc nofollow" target="_blank">词法分析器</a>。解析器可以自动生成<a class="ae jd" href="https://en.wikipedia.org/wiki/Parse_tree" rel="noopener ugc nofollow" target="_blank">解析树</a>或者<a class="ae jd" href="https://en.wikipedia.org/wiki/Abstract_syntax_tree" rel="noopener ugc nofollow" target="_blank">抽象语法树</a>，可以用树解析器进一步处理【7】。</p><h1 id="d6b0" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">词法分析器和语法分析器</h1><p id="30c6" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">一个<strong class="ih hj">标记</strong>是一个字符序列，代表一段有意义的输入:通常是一个单词或标点符号，由词法分析器分离并传递给解析器。将字符分组为单词或符号(记号)的过程称为<strong class="ih hj">词法分析</strong>或简称为<strong class="ih hj">记号化</strong>。您将对输入进行分词(执行词法分析)的程序称为<strong class="ih hj">词法分析器</strong>(或<strong class="ih hj">分词器</strong>)。识别语言的程序被称为<strong class="ih hj">解析器</strong>或<strong class="ih hj">语法分析器</strong>。默认情况下，ANTLR生成的解析器构建一个数据结构，称为<strong class="ih hj">解析树</strong>或<strong class="ih hj">语法树</strong>(表示语法如何匹配输入)，记录解析器如何识别输入句子的结构及其组成短语。</p><p id="a58b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">解析<strong class="ih hj"> </strong> ( <strong class="ih hj">语法分析</strong>)是分析符合形式语法规则的自然语言、计算机语言或数据结构中的一串符号的过程。因此，正如您在下图中看到的，lexer首先运行，并将输入拆分成标记。然后，令牌流被传递给执行所有处理的解析器。ANTLR为您生成一个解析树，然后您可以用一个解析树遍历器来处理它。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es lc"><img src="../Images/1ecb314cb6339e3689d1db8e92c25336.png" data-original-src="https://miro.medium.com/v2/resize:fit:1396/0*ZnOU4d9D7pQgwSW-"/></div></div></figure><p id="bcd1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">图4:图示了语言识别器的基本数据流[4]</p><h1 id="e551" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">将生成的解析器集成到项目中</h1><p id="646f" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">ANTLR工具和运行时，称为TestRig程序，在处理语法初稿时非常有用。一旦语法有了良好的开端，就可以将ANTLR生成的代码集成到更大的应用程序中。要将它集成到您的项目中，您可以使用Maven或Gradle来构建应用程序，并在编码过程中使用ANTLR开发工具(ide的插件)的强大功能。</p><p id="d0fa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，让我们将antlr-runtime依赖项和antlr-maven-plug-in添加到pom.xml中。基本上，使用ANTLR Maven插件，您遵循与命令行方法相同的步骤(准备语法、生成源代码和创建侦听器)。因此，您将您的语法直接放在<strong class="ih hj"> src/main/antlr4/ </strong>下，并且由于我们的配置，Maven确保在运行了&gt; mvn clean install之后，在对应于它们的包的目录中生成了词法分析器和语法分析器</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es ld"><img src="../Images/93140e18311ffb54e3663bf995759342.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*r_1qttILJWNS2ACZ"/></div></div></figure><h1 id="f6b3" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">ANTLR开发工具</h1><p id="e0cd" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">有几个ide的ANTLR插件:Intellij、Eclipse、VS Code，还有许多其他的。这些插件在ANTLR开发过程中非常方便。您只需在插件编辑器中打开语法文件，就可以获得快速修复、语法着色、代码完成、语法和语义错误检查、代码导航、定位声明等支持。你可以做重构，你可以测试你的语法，生成解析树，并以不同的格式保存为图片。铁路图和ATN图也非常有助于可视化规则类型(解析器、词法分析器、片段)。</p><p id="91e6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">月蚀</strong><a class="ae jd" href="https://marketplace.eclipse.org/category/free-tagging/antlr-antlr4-antlrv4-v4" rel="noopener ugc nofollow" target="_blank">T5】ANTLR 4 IDET7】</a></p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es ld"><img src="../Images/784cd90bce7d69657f71afc754c5a532.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*REHdTDMRfDp9pdNr"/></div></div></figure><p id="84ea" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> Vscode扩展:</strong> <a class="ae jd" href="https://marketplace.visualstudio.com/items?itemName=mike-lischke.vscode-antlr4" rel="noopener ugc nofollow" target="_blank"> ANTLR4语法语法支持</a></p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es ld"><img src="../Images/563503ae4674ada5b098ed433b85b4e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5PZRvE0tzxBXMgfx"/></div></div></figure><p id="7c89" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">IntelliJ</strong>T14<strong class="ih hj">ANTLR v4</strong>T17】</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es ld"><img src="../Images/01cedd98322f51ce3ebca85c5bd10b57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*E8visgyG5MuQ4Dys"/></div></div></figure><h1 id="4f83" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">ANTLR还能做什么？</h1><p id="e30b" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">继续使用ShortestCobolGrammar示例，下一个目标是了解ANTLR还能做什么(侦听器、访问者、错误处理等等)。</p><p id="1782" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是，在这之前，让我们把合并的语法分成两个独立的语法，一个用于词法分析器，一个用于语法分析器。然后通过将lexer语法导入解析器语法来重用它。这种方法促进了良好的软件设计(代码重用和单一责任原则)，特别是当您有大量语法并且应用程序将并行支持多种语言时。</p><p id="8ee2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要创建一个只允许解析器规则(<a class="ae jd" href="https://github.com/asatklichov/antlr-magic/blob/main/src/main/antlr4/net/sahet/parsers/ShortestCobolParser.g4" rel="noopener ugc nofollow" target="_blank"> ShortestCobolParser.g4 </a>)或词法分析器规则(<a class="ae jd" href="https://github.com/asatklichov/antlr-magic/blob/main/src/main/antlr4/net/sahet/parsers/ShortestCobolLexer.g4" rel="noopener ugc nofollow" target="_blank"> ShortestCobolLexer.g4 </a>)的解析器语法，请使用下面的头。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es ky"><img src="../Images/9907308c6fc11171980c9b9f7cf29762.png" data-original-src="https://miro.medium.com/v2/resize:fit:1290/format:webp/1*r6JQV_-PmDVV9rHmJ9r2cw.png"/></div></div></figure><p id="0504" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要了解有关规则定义的更多信息，请参考<a class="ae jd" href="https://github.com/antlr/antlr4/blob/master/doc/lexer-rules.md" rel="noopener ugc nofollow" target="_blank">词法分析器规则</a>和<a class="ae jd" href="https://github.com/antlr/antlr4/blob/master/doc/parser-rules.md" rel="noopener ugc nofollow" target="_blank">语法分析器规则</a>。</p><p id="e9ce" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">仅有语法是不够的——解析树遍历器</p><p id="a221" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你必须记住解析器不能检查语义。解析器应该只检查语法。ANTLR v4鼓励你保持语法的整洁，并鼓励你使用解析树遍历器(监听器或访问者)来实现特定于应用程序的代码，例如执行语义检查(验证代码，或添加特定的逻辑检查等)。).侦听器和访问者是非常方便的机制，因为它们将应用程序逻辑排除在语法之外，并保持语法应用程序的独立性和编程语言的不可知性。因此，您可以使用相同的语法为任何目标语言(Java、JS、C++等)生成语言识别器。).</p><p id="4be7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">ANTLR在其运行时库中支持两种树遍历机制:解析树侦听器(默认)和解析树访问者。ANTLR自动生成这些树遍历器，可以用来访问树的节点以执行应用程序逻辑。</p><p id="602a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">解析树监听器</strong></p><p id="6efd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">默认情况下，ANTLR自动生成一个解析树监听器接口，带有一个base-listener类，它是该接口的一个空实现。侦听器机制的美妙之处在于，您不需要自己进行任何树遍历，侦听器方法由ANTLR提供的walker对象自动调用(隐式访问它们的子对象)。</p><p id="bfe7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们使用一个侦听器机制，一旦显示文本不是以单词“Hello”开头，就打印一条错误消息。要编写一个对输入做出反应的程序(回调方法)，你所要做的就是在一个新的子类<a class="ae jd" href="https://github.com/asatklichov/antlr-magic/blob/main/src/main/java/net/sahet/parse/tree/walkers/ShortestCobolParserListenerImpl.java" rel="noopener ugc nofollow" target="_blank"><em class="kt">shortestcobolparserlistener</em></a>中实现一些方法(处理进入和退出的规则，例如<em class="kt"> enterDisplayStatement和</em> exitDisplayStatement)，该子类扩展了<em class="kt">ShortestCobolParserBaseListener。</em></p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es le"><img src="../Images/c0d3ca58d8de0af810da2c771aa8f343.png" data-original-src="https://miro.medium.com/v2/resize:fit:1130/format:webp/1*hWb-0_QuW1y-A35TkXwxaA.png"/></div></figure><p id="2e97" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">只需构建Maven项目并运行程序<em class="kt"> CobolProgListenerDemo </em>来查看错误消息。</p><p id="34a6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">c:\ workspace-eclipse \ antlr-magic &gt; mvn全新安装</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es ld"><img src="../Images/305410fad2288aa2eb0b038abaa6f865.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0K_jfWf00hzYVBb-"/></div></div></figure><p id="7d81" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">练习:为了巩固您的知识，为COBOL AreaA和AreaB职位定义一条错误消息。</p><p id="cea8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">游客树行者</strong></p><p id="e6a0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如您所看到的，侦听器机制是自动的，但是有些情况下您希望手动控制遍历并显式调用方法来访问子节点。因此，创建侦听器的替代方法是创建访问者。使用访问者机制，您可以显式地控制流并返回您想要的值。要生成访问者树遍历器，使用<em class="kt">–visitor</em>选项，然后ANTLR生成一个访问者接口，带有一个base-visitor类，该类是该接口的一个空实现。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es lf"><img src="../Images/ac43ae55423a6c026c63bcb55948c75d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/0*vfGEW5bmG-GBhEot"/></div></figure><p id="fd3c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们使用访问者机制来调整显示文本，并添加逻辑(例如，从输入消息中计算散列)。为了对这个需求进行编程，您需要创建一个新的子类<a class="ae jd" href="https://github.com/asatklichov/antlr-magic/blob/main/src/main/java/net/sahet/parse/tree/walkers/ShortestCobolParserVisitorImpl.java" rel="noopener ugc nofollow" target="_blank"><em class="kt">ShortestCobolParserVisitorImpl</em></a>，它扩展了<em class="kt">ShortestCobolParserBaseVisitor&lt;T&gt;(T—用于返回类型)</em>，并实现了满足业务逻辑所需的方法(只需要在节点的子节点上调用visit())。</p><p id="d148" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">c:\ workspace-eclipse \ antlr-magic &gt; mvn全新安装</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es ld"><img src="../Images/53aedb82f9598d7a2d4e7a53e0a532e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*z9nyusu2TIJDSag2"/></div></div></figure><p id="8e75" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">树木行走机构的区别</strong></p><p id="1d47" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">树遍历机制<strong class="ih hj"> </strong>的主要区别在于:</p><ol class=""><li id="0de4" class="lg lh hi ih b ii ij im in iq li iu lj iy lk jc ll lm ln lo bi translated">与侦听器不同，用户在子节点上显式调用访问者。忘记在节点的子节点上调用visit()意味着这些子树不会被访问。简单地说，在来访者中，你可以在树上行走，而在听者中，你只对树行者做出反应。</li><li id="08cc" class="lg lh hi ih b ii lp im lq iq lr iu ls iy lt jc ll lm ln lo bi translated">侦听器方法(void)不能返回值，而访问者方法可以返回任何自定义类型。对于侦听器，您将不得不使用可变变量来存储值，而对于访问者则没有这样的需要。</li><li id="6f35" class="lg lh hi ih b ii lp im lq iq lr iu ls iy lt jc ll lm ln lo bi translated">侦听器使用在堆上分配的显式堆栈，而访问者使用调用堆栈来管理树遍历。这意味着访问者的大量输入可能会导致嵌套很深的ast上的堆栈溢出异常，而侦听器不会有任何问题。</li><li id="2437" class="lg lh hi ih b ii lp im lq iq lr iu ls iy lt jc ll lm ln lo bi translated">两种树遍历机制都使用深度优先(当一个节点被访问时，它的子节点将被访问)类型的搜索。</li><li id="d17f" class="lg lh hi ih b ii lp im lq iq lr iu ls iy lt jc ll lm ln lo bi translated">访问者和侦听器之间的最大区别是访问者不需要ParseTreeWalker，例如，比较代码<em class="kt"> CobolProgListenerDemo和</em> CobolProgVisitorDemo。</li><li id="2823" class="lg lh hi ih b ii lp im lq iq lr iu ls iy lt jc ll lm ln lo bi translated">此外，侦听器使用<a class="ae jd" href="https://github.com/antlr/antlr4/blob/master/runtime/Java/src/org/antlr/v4/runtime/tree/ParseTreeWalker.java" rel="noopener ugc nofollow" target="_blank"> ParseTreeWalker </a>中的walker算法，访问者使用<a class="ae jd" href="https://github.com/antlr/antlr4/blob/master/runtime/Java/src/org/antlr/v4/runtime/tree/ParseTreeVisitor.java" rel="noopener ugc nofollow" target="_blank">AbstractParseTreeVisitor</a><em class="kt">中的算法。</em>两者都“考虑”所有节点，这就是性能差异较小的原因，即使侦听器机制看起来更快。除了实现差异之外，访问者调用还涉及一般返回类型处理的开销。这应该会对任何现代JVM的性能产生无缝的影响。</li></ol><p id="77d1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有关更多ANTLR特性或功能(错误处理机制、动作和语义谓词等)，请参考Terence Parr的书<a class="ae jd" href="https://pragprog.com/titles/tpantlr2/the-definitive-antlr-4-reference/" rel="noopener ugc nofollow" target="_blank">‘The Definitive ANTLR 4 Reference’</a>。</p><h1 id="77f8" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">构建语言应用程序</h1><p id="9317" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">为了使IDE支持现代编码和调试体验，您需要实现一个基于LSP[8]和DAP[9]规范的语言服务器和客户端，并将它们集成到IDE中。为了成为客户端，代码编辑器(或IDE)添加了一个小的扩展，它提供了一个与语言无关的前端编辑功能，而不需要知道语言的语义[见图3]。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es lu"><img src="../Images/a62b6a7e896560e7144c657b05bff095.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dsGJCukY9Fo7lJxyE9lE9g.png"/></div></div><figcaption class="lv lw et er es lx ly bd b be z dx translated">图3: LSP架构为我们提供了选择任何技术组合的灵活性(可以是TS/Python，或者TS/C++，或者TS/TS ),以独立地实现客户端和语言服务器</figcaption></figure><p id="e772" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jd" rel="noopener" href="/modern-mainframe/lsp-magic-mainframe-language-support-in-modern-ides-4ea3d81259b3">语言服务器</a>提供语言语义，一次只为一个客户服务。它监听编辑器的元状态，并基于使用ANTLR的语法或语义分析，返回一组动作。这种通信基于由<a class="ae jd" href="http://www.jsonrpc.org/specification" rel="noopener ugc nofollow" target="_blank"> JSON RPC v2.0 </a>扩展版本定义的规则。为了将一致的体验扩展到调试，应该集成<a class="ae jd" rel="noopener" href="/modern-mainframe/dap-magic-modern-debugging-experience-for-mainframe-software-deecb40df4c8"> DAP技术</a>[9]。</p><p id="628c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> LSP对大型机编程语言的支持</strong></p><p id="5398" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">基于上述LSP架构，Broadcom提供了多个专用于特定语言的扩展，如<a class="ae jd" href="https://marketplace.visualstudio.com/items?itemName=broadcomMFD.cobol-language-support" rel="noopener ugc nofollow" target="_blank"> COBOL语言支持</a>、<a class="ae jd" href="https://marketplace.visualstudio.com/items?itemName=broadcomMFD.hlasm-language-support" rel="noopener ugc nofollow" target="_blank"> HLASM语言支持</a>、<a class="ae jd" href="https://marketplace.visualstudio.com/items?itemName=broadcomMFD.jcl-language-support" rel="noopener ugc nofollow" target="_blank"> JCL语言支持</a>和<a class="ae jd" href="https://marketplace.visualstudio.com/items?itemName=broadcomMFD.lsp-for-rexx" rel="noopener ugc nofollow" target="_blank"> REXX </a>。此外，为了一次安装所有的扩展，mainframe <a class="ae jd" href="https://marketplace.visualstudio.com/items?itemName=broadcomMFD.code4z-extension-pack" rel="noopener ugc nofollow" target="_blank"> Code4z </a>扩展对于市场中的VS代码编辑器是免费的，它也可以在Eclipse忒伊亚云编辑器中使用。</p><p id="bf89" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对COBOL的LSP支持是一个开源项目(使用的技术有:Java、ANTLR、VSCode、Typescript、LSP、DAP等。)在Eclipse许可下<a class="ae jd" href="https://github.com/eclipse/che-che4z-lsp-for-cobol" rel="noopener ugc nofollow" target="_blank"> che-che4z-lsp-for-COBOL </a>。COBOL语言支持扩展为您提供了语言感知特性，如:自动完成、高亮显示、诊断和对文件扩展名的复制支持。cob和. cbl。它还能够使用Zowe CLI z/OSMF配置文件连接到主机，以支持下载相关的复制本[8]。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es ld"><img src="../Images/dbd13aa50e31cd99b87149c428e92aba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*tfkKT-NzCOyL0lO3"/></div></div><figcaption class="lv lw et er es lx ly bd b be z dx translated">图4: COBOL语言支持用例图。Michelle是一名现代大型机开发人员，他使用VSCode开发COBOL应用程序。</figcaption></figure><p id="49e1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">code4z团队使用COBOL的IBM语言参考、CICS和z/Os的SQL构建了用于COBOL语言支持的<a class="ae jd" href="https://github.com/eclipse/che-che4z-lsp-for-cobol/tree/development/server/src/main/antlr4/org/eclipse/lsp/cobol/core/parser" rel="noopener ugc nofollow" target="_blank">语法</a>，并使用ANTLR v.4应用语法和语义分析，这些语法和语义分析为语言服务器提供与用例相关的诊断【参见图4】(LSP语言服务器支持的所有特性都可以在<a class="ae jd" href="https://langserver.org/" rel="noopener ugc nofollow" target="_blank">这里</a>找到)。</p><p id="3888" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">总结</strong></p><p id="4d2c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">本文讨论了“使用语言识别器开发大型机语言应用程序”这一主题，首先阐述了一个示例应用程序。然后在接下来的部分中，将描述ANTLR的特性和功能，并使用这些特性实现实际的例子。因此，您已经了解了现代编码和调试经验是如何开发并集成到基于ANTLR(处理结构化文本的解析器生成器)、LSP(提供语言智能)、DAP(提供调试)和VSCode技术的ide中的。</p><p id="de1c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如有更多问题，您可以通过Slack联系我们:<a class="ae jd" href="http://che4z.slack.com/" rel="noopener ugc nofollow" target="_blank">che4z.slack.com</a></p><p id="1e3d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">参考文献</strong></p><p id="340a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">[1]<a class="ae jd" href="https://github.com/antlr/antlr4/blob/master/doc/getting-started.md" rel="noopener ugc nofollow" target="_blank">https://github . com/antlr/antlr 4/blob/master/doc/getting-started . MD</a></p><p id="a862" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">[2]<a class="ae jd" href="https://microsoft.github.io/language-server-protocol/specifications/specification-current/" rel="noopener ugc nofollow" target="_blank">https://Microsoft . github . io/language-server-protocol/specification/specification-current/</a></p><p id="8eda" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">[3]<a class="ae jd" href="https://microsoft.github.io/debug-adapter-protocol/" rel="noopener ugc nofollow" target="_blank">https://microsoft.github.io/debug-adapter-protocol/</a></p><p id="5a6c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">[4]<a class="ae jd" href="https://pragprog.com/titles/tpantlr2/the-definitive-antlr-4-reference/" rel="noopener ugc nofollow" target="_blank">https://pragprog . com/titles/tpantlr 2/the-definitive-antlr-4-reference/</a></p><p id="f976" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">【https://www.antlr.org/tools.html T2】</p><p id="77cb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">[6]https://tomassetti.me/antlr-mega-tutorial/<a class="ae jd" href="https://tomassetti.me/antlr-mega-tutorial/" rel="noopener ugc nofollow" target="_blank"/></p><p id="ddaa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">[7]<a class="ae jd" href="https://en.wikipedia.org/wiki/ANTLR" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/ANTLR</a></p><p id="b322" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">[8]<a class="ae jd" rel="noopener" href="/modern-mainframe/lsp-magic-mainframe-language-support-in-modern-ides-4ea3d81259b3">https://medium . com/modern-mainframe/LSP-magic-mainframe-language-support-in-modern-ides-4ea 3d 81259 B3</a></p><p id="433b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">[9]<a class="ae jd" rel="noopener" href="/modern-mainframe/dap-magic-modern-debugging-experience-for-mainframe-software-deecb40df4c8">https://medium . com/modern-mainframe/DAP-magic-modern-debugging-experience-for-mainframe-software-deec b40 df 4c 8</a></p><p id="c2e4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">开源库:<a class="ae jd" href="https://github.com/eclipse/che-che4z" rel="noopener ugc nofollow" target="_blank">https://github.com/eclipse/che-che4z</a></p></div></div>    
</body>
</html>