<html>
<head>
<title>Programming with Functions #6 — Thread safety</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">函数编程#6 —线程安全</h1>
<blockquote>原文：<a href="https://medium.com/codex/programming-with-functions-6-thread-safety-7a5e1b361c8e?source=collection_archive---------12-----------------------#2021-03-23">https://medium.com/codex/programming-with-functions-6-thread-safety-7a5e1b361c8e?source=collection_archive---------12-----------------------#2021-03-23</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><h2 id="aeab" class="hg hh hi bd b fp hj hk hl hm hn ho dx hp translated" aria-label="kicker paragraph"><a class="ae ge" href="http://medium.com/codex" rel="noopener">法典</a></h2><div class=""/><figure class="ev ex io ip iq ir"><div class="bz dy l di"><div class="is it l"/></div></figure><p id="3f7c" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">不可变性如何帮助线程安全的简单答案是— <a class="ae js" href="https://makingthematrix.medium.com/programming-with-functions-5-immutability-41611bb7a044" rel="noopener">基本上与懒惰</a>相同。如果数据没有改变，这意味着任何数量的线程都可以在任何时候访问它，并且它们不会互相干扰。但是当然，运行一个程序的全部意义在于，我们想要用数据做一些事情，而不仅仅是读取数据。程序运行的数据必须在某个时间点发生变化，因此如果程序运行在两个或更多线程上，这些线程可以访问数据并得到不同的结果。这里没有灵丹妙药。函数式编程不会将您从所有源于可变数据共享访问的错误中解救出来。但是会有帮助的。</p><p id="9865" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">举个例子，我们来讨论一些我在Android平台工作时经常看到的事情。显示元素——一排排带有标题的按钮、带有图片的磁贴等。—通过“适配器”完成。适配器根据来自某个数据源的数据，保存一个外部提供给它的项目列表。当数据改变时，元素列表被更新，适配器被提示刷新并显示根据新的项目列表创建的元素。使用可变集合的适配器代码的简化版本如下所示:</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="3218" class="kc kd hi jy b fi ke kf l kg kh">import scala.collection.mutable</span><span id="f617" class="kc kd hi jy b fi ki kf l kg kh">class DataSet {<br/>  val items = mutable.ListBuffer[Item]()<br/>  def onClick(itemIndex: Int): Unit = <br/>    doStuffOnItem(items(itemIndex))<br/>}</span><span id="5a24" class="kc kd hi jy b fi ki kf l kg kh">private val dataSet = new DataSet</span><span id="e286" class="kc kd hi jy b fi ki kf l kg kh">def updateList(newItems: List[Item]): Unit = {<br/>  dataSet.items.clear()<br/>  dataSet.items.appendAll(newItems)<br/>  notifyDataSetChanged()<br/>}</span><span id="38bc" class="kc kd hi jy b fi ki kf l kg kh">case class ButtonHolder(view: View, dataSet: DataSet)<br/>  extends RecyclerView.ViewHolder(view) {<br/>  override def onClick(v: View): Unit = <br/>    dataSet.onClick(getAdapterPosition)<br/>}</span></pre><p id="667a" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们有一个类，比如说<code class="du kj kk kl jy b">DataSet</code>，它保存了一个可变的<code class="du kj kk kl jy b">ListBuffer</code>项，然后我们有一个方法<code class="du kj kk kl jy b">onClick</code>，它获取该项的索引，然后我们对该项进行处理。然后我们在这里创建一个数据集作为<code class="du kj kk kl jy b">val</code> —不可变的。然后我们有一个方法<code class="du kj kk kl jy b">updateList</code>，它从外部获得一个新的项目列表，然后我们将数据集中的项目更改为这些新项目，我们<code class="du kj kk kl jy b">notifyDataSetChanged()</code>(Android使用该方法来刷新屏幕)。然后对于每一项，我们有<code class="du kj kk kl jy b">case class ButtonHolder</code>，它获取显示按钮的视图，并获取数据集，当用户单击屏幕上的按钮时，这个<code class="du kj kk kl jy b">onClick</code>方法被调用，然后这个<code class="du kj kk kl jy b">onClick</code>方法用<code class="du kj kk kl jy b">getAdapterPosition</code>调用<code class="du kj kk kl jy b">DataSet.onClick</code>——即按钮在按钮列表中的位置。</p><figure class="jt ju jv jw fd ir er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es km"><img src="../Images/f1dde2b3a24cac1bc2074d2b2765960b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*TBip4ZyRGmwtsl1W"/></div></div></figure><p id="7506" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">让我们假设当用户点击(或“点击”屏幕上的一个显示按钮)时，调用<code class="du kj kk kl jy b">ButtonHolder.onClick</code>方法。按钮持有者知道它在适配器中的位置，该位置对应于用来创建和显示给定元素的项目的索引。我们不想在<code class="du kj kk kl jy b">ButtonHolder</code>中有太多的逻辑，所以我们只是在数据集中调用<code class="du kj kk kl jy b">onClick</code>方法，赋予它按钮的位置。现在，请注意按钮持有人在构造函数中获得了对数据集的引用，然后在数据集内我们有了一个<code class="du kj kk kl jy b">mutable.ListBuffer</code>。</p><p id="9444" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在一般情况下，它工作得很好。适配器在<code class="du kj kk kl jy b">updateList</code>方法中接收新项目列表，旧列表被清除，其内容被新项目替换，然后<code class="du kj kk kl jy b">notifyDataSetChanged()</code>被调用——这是来自Android SDK的一个方法，使用项目来创建和显示按钮。每个按钮都是从一个项目创建的，当它被点击时，我们可以访问相应的项目并做一些事情。</p><p id="322d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">问题是，n <code class="du kj kk kl jy b">otifyDataSetChanged()</code>只通知Android数据集发生变化(d'oh)。然后，Android被允许在它认为合适的时候刷新屏幕——不一定是马上。那么，如果我们同时注册了一次点击，会发生什么呢？我们在屏幕上仍然有旧的按钮座。它将接收点击，然后用它原来的位置调用<code class="du kj kk kl jy b">DataSet.onClick</code>。但是数据集中的数据已经不同了，新的位置可能指向与我们期望的不同的项目，或者它可能根本不指向任何东西。我们不能让它发生。方法是将分配给<code class="du kj kk kl jy b">val</code>的数据集中的可变集合替换为分配给<code class="du kj kk kl jy b">var</code>的数据集中的不可变集合。</p><pre class="jt ju jv jw fd jx jy jz ka aw kb bi"><span id="9cc1" class="kc kd hi jy b fi ke kf l kg kh">case class DataSet(items: List[Item] = Nil) {<br/>  def onClick(itemIndex: Int): Unit = <br/>    doStuffOnItem(items(itemIndex))<br/>}</span><span id="254e" class="kc kd hi jy b fi ki kf l kg kh">private var dataSet = DataSet</span><span id="6da3" class="kc kd hi jy b fi ki kf l kg kh">def updateList(newItems: List[Item]): Unit = {<br/>  dataSet = DataSet(newItems)<br/>  notifyDataSetChanged()<br/>}</span><span id="a1d1" class="kc kd hi jy b fi ki kf l kg kh">case class ButtonHolder(view: View) extends RecyclerView.ViewHolder(view) {<br/>  private var dataSet = Option.empty[DataSet]</span><span id="ce71" class="kc kd hi jy b fi ki kf l kg kh">  def bind(dataSet: DataSet): Unit = <br/>    this.dataSet = Some(dataSet)<br/>  <br/>  override def onClick(v: View): Unit = <br/>    dataSet.foreach(_.onClick(getAdapterPosition))<br/>}</span></pre><p id="d85e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">所以现在我们又有了case类<code class="du kj kk kl jy b">DataSet</code>,它接受一个项目列表。然后我们有了<code class="du kj kk kl jy b">onClick</code>方法，和之前的那个很像。这里我们有一个数据集，它是一个变量，在<code class="du kj kk kl jy b">updateList</code>中，当我们获取新项目列表时，我们用包含新项目的新数据集替换该数据集。然后我们叫<code class="du kj kk kl jy b">notifyDataSetChanged()</code>。在<code class="du kj kk kl jy b">case class ButtonHolder</code>中，我们现在有了一个<code class="du kj kk kl jy b">var dataSet</code>，我们将它绑定到——bind也是Android使用的一个方法——然后我们有了调用<code class="du kj kk kl jy b">DataSet.onClick</code>方法的onClick方法，假设数据集已经“绑定”到按钮座。</p><figure class="jt ju jv jw fd ir er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es km"><img src="../Images/3cc6034b226a3b7d0e55e05568b5c6a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*I_GF9hfHXWXSKjMh"/></div></div></figure><p id="b4ba" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在，当一个按钮持有者接收到一个点击，并把它和它的位置一起传递给<code class="du kj kk kl jy b">DataSet.onClick</code>时，我们可以确定我们将操作用于创建按钮的同一个数据集。项目列表保持不变，直到Android实际决定刷新所有内容，然后它将使用bind方法来替换数据集——但此时，按钮在适配器中的位置也会改变，或者整个按钮将被重新创建。</p><p id="fc20" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">注意，它并不能解决我们所有的问题(毕竟我们不是在快乐的左上角，而是在不知何故的“meh”右上角)。例如，有可能两个线程同时处理更新，其中一个更新很快会被另一个更新所取代，我们可能会以不一致而告终。另一个线程将假设结果与它所计算的一样，也许以后会尝试访问一个不存在的元素。有许多事情可以尝试，但是这是一个相当高级的话题，超出了本系列的范围。</p><p id="4713" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">最后一个提示:尽量总是使用原始数据源。不要在缓存中存储可变引用的副本——当原始引用发生变化时，您的副本将会过时。相反，保持对封装数据并控制其变化的实体的不可变引用，并在需要数据时访问它。一种方法是在代码中引入依赖注入。你可以在软件工厂的网站上了解更多信息。他们也有自己的DI框架，叫做<a class="ae js" href="https://github.com/softwaremill/macwire" rel="noopener ugc nofollow" target="_blank"> macwire </a>，我们在工作中使用它，我对此非常满意。</p><p id="d3cd" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在某种程度上，这种方法间接地促进了拥有单一真理来源的想法。对于程序中的每个数据集，应该只有一个保存它的地方，并且应该有一个统一的方法来访问和更新它。没有重复，没有角落案件偷偷摸摸的黑客。内存缓存——是的，但前提是从外部看不到它们。如果另一段代码想要从数据源中检索一个元素，它不应该知道或者甚至不应该关心该元素是否来自缓存。</p><figure class="jt ju jv jw fd ir er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es km"><img src="../Images/d3727349da5aa6d5438818f51ab5a34e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*tSSGhSBJFzILWQ4d"/></div></div></figure><p id="c281" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">哦，还有最后一个提示:永远不要使用分配给<code class="du kj kk kl jy b">var</code>的可变集合。如果你觉得不得不使用它，那只能说明代码有可怕的错误。</p><p id="cf9e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这就是我为你准备的关于线程安全的全部内容。在下一个视频中，我们将讨论一些表达式和纯函数的概念。感谢观看。如果你有任何问题或者因为其他原因想联系我，你可以在下面留言。或者你也可以在推特上找到我。</p><p id="48fe" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">下次见。</p><p id="1c75" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">先前:<a class="ae js" href="https://makingthematrix.medium.com/programming-with-functions-5-immutability-41611bb7a044" rel="noopener">用函数#5编程:不变性</a></p><p id="01bc" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">顺便说一下，如果你有兴趣在Android上编写Scala…<a class="ae js" href="https://makingthematrix.wordpress.com/2021/03/17/scala-on-android/" rel="noopener ugc nofollow" target="_blank">https://makthematrix . WordPress . com/2021/03/17/Scala-on-Android/</a></p></div></div>    
</body>
</html>