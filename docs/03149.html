<html>
<head>
<title>Develop Your Own x86 Operating System(OS) #6</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">开发您自己的x86操作系统(OS) #6</h1>
<blockquote>原文：<a href="https://medium.com/codex/develop-your-own-x86-operating-system-os-6-68605f50d522?source=collection_archive---------7-----------------------#2021-08-20">https://medium.com/codex/develop-your-own-x86-operating-system-os-6-68605f50d522?source=collection_archive---------7-----------------------#2021-08-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="9bea" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">中断处理和从键盘读取输入。</h2></div><p id="c6cd" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您的操作系统目前支持许多功能。由于您的操作系统被开发为在控制台上产生输出，因此通过这篇文章，让我们看看如何改进我们的操作系统以从键盘获得输入。操作系统必须能够处理<em class="jt">中断</em>，以便从键盘读取信息。因此，我们也将讨论操作系统系统开发中的中断处理。</p><p id="020a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果您还没有阅读关于在操作系统中通过段(分段)访问内存的系列文章的第四篇，您可以从<a class="ae ju" href="https://isuruni-rathnayaka0508.medium.com/develop-your-own-x86-operating-system-os-5-27743b500fab" rel="noopener">这里</a>阅读它，因为它的内容对于了解本文的内容非常重要。</p><figure class="jw jx jy jz fd ka er es paragraph-image"><div class="er es jv"><img src="../Images/378551e46186b422d3cec9f3d13596fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XPmM7xRusmsn7Xcio1-uSA.png"/></div></figure><h1 id="bdd7" class="kd ke hi bd kf kg kh ki kj kk kl km kn io ko ip kp ir kq is kr iu ks iv kt ku bi translated">中断</h1><p id="8459" class="pw-post-body-paragraph ix iy hi iz b ja kv ij jc jd kw im jf jg kx ji jj jk ky jm jn jo kz jq jr js hb bi translated"><strong class="iz hj">中断</strong>是一种需要立即关注的情况，导致微处理器暂时工作在不同的任务上，然后返回到之前的任务。中断可以是内部的也可以是外部的。</p><p id="6761" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在x86处理器中，有3种类型的中断:硬件中断、软件中断和异常。</p><p id="86b3" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">硬件中断</strong>由硬件设备触发。当硬件设备(如键盘、串口或定时器)向CPU发出设备状态已经改变的信号时，就会发生这种情况。然后处理器停止正在做的事情，执行处理硬件中断的代码。硬件中断通常是异步的——它们的发生与发出时正在执行的指令无关。例如:当你在键盘上打字时，键盘触发一个硬件中断并处理键盘输入(通常是将你按下的键读入内存中的缓冲区)。</p><p id="db65" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">软件中断</strong>用于将控制转移给操作系统内核中的功能。软件中断由<em class="jt"> int </em>汇编代码指令触发，通常用于系统调用。例如:指令“int 14h”触发中断0x14。</p><p id="6d16" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">异常</strong>由CPU自身生成，以响应程序错误，例如当程序引用它无权访问的内存时，或者当程序将一个数除以零时。这些中断被称为异常。处理器将检测到这个问题，并将控制转移给一个处理程序来处理这个异常。这个处理程序可能会在更改一些值后重新执行有问题的代码，或者如果做不到这一点，导致异常终止的程序。</p><p id="3ba5" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">中断条件向处理器发出警报，并在允许时请求处理器中断当前正在执行的指令。如果请求被接受，处理器通过暂停其当前活动、保存其状态并执行一个名为<em class="jt">中断处理程序</em>的函数来处理该中断。</p><h1 id="99a4" class="kd ke hi bd kf kg kh ki kj kk kl km kn io ko ip kp ir kq is kr iu ks iv kt ku bi translated">中断处理程序</h1><p id="5a6f" class="pw-post-body-paragraph ix iy hi iz b ja kv ij jc jd kw im jf jg kx ji jj jk ky jm jn jo kz jq jr js hb bi translated">中断处理是识别已经发生的准确中断并对识别的中断执行相关响应的过程。<strong class="iz hj">中断处理程序</strong>的工作是服务中断并阻止它中断。中断有三种不同的处理程序:</p><ul class=""><li id="d83c" class="la lb hi iz b ja jb jd je jg lc jk ld jo le js lf lg lh li bi translated">任务处理程序</li><li id="0d21" class="la lb hi iz b ja lj jd lk jg ll jk lm jo ln js lf lg lh li bi translated">中断处理程序</li><li id="0b6a" class="la lb hi iz b ja lj jd lk jg ll jk lm jo ln js lf lg lh li bi translated">陷阱处理器</li></ul><p id="46ae" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">任务处理程序使用特定于英特尔x86版本的功能。中断处理程序和陷阱处理程序之间的唯一区别是中断处理程序禁用中断，这意味着在处理中断的同时不欢迎任何中断。在我们的过程中，我们将使用陷阱处理程序，并根据需要手动禁用中断。</p><p id="151a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在x86架构中，中断由<strong class="iz hj">中断描述符表(IDT) </strong>处理。</p><h1 id="01cf" class="kd ke hi bd kf kg kh ki kj kk kl km kn io ko ip kp ir kq is kr iu ks iv kt ku bi translated"><strong class="ak">中断描述符表(IDT) </strong></h1><p id="291f" class="pw-post-body-paragraph ix iy hi iz b ja kv ij jc jd kw im jf jg kx ji jj jk ky jm jn jo kz jq jr js hb bi translated">中断描述符表(IDT)是一个x86系统表，包含中断处理程序的描述符(IDT为每个中断描述一个中断处理程序)。处理器使用IDT来确定对中断和异常的正确响应。IDT有256个条目，其中中断编号从0到255。中断<em class="jt"> i </em>的处理程序定义在表中第<em class="jt">和</em>位置。</p><figure class="jw jx jy jz fd ka er es paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="er es lo"><img src="../Images/2ef8cd23d182ed2df3e9a8b564e17a1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uO4zOn7fHv2PNP_EZ2-6tg.png"/></div></div><figcaption class="lt lu et er es lv lw bd b be z dx translated">“英特尔架构软件开发人员手册中的IDT”</figcaption></figure><p id="016c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">中断描述符表类似于我们在上一篇文章《结构》中讨论的全局描述符表。在实施IDT之前，一定要确保您有一个工作的GDT。</p><h2 id="d256" class="lx ke hi bd kf ly lz ma kj mb mc md kn jg me mf kp jk mg mh kr jo mi mj kt mk bi translated">在IDT中创建条目</h2><p id="024e" class="pw-post-body-paragraph ix iy hi iz b ja kv ij jc jd kw im jf jg kx ji jj jk ky jm jn jo kz jq jr js hb bi translated">IDT条目被称为盖茨。它可以包含中断门、任务门和陷阱门。中断处理程序的IDT中的一个条目由64位组成。最高32位如下图所示:</p><figure class="jw jx jy jz fd ka er es paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="er es ml"><img src="../Images/1d5fc515dfc2d7e3c016baf01f888f94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iQ4jtHfy-dTDysy3GRRk4A.png"/></div></div></figure><p id="d013" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">下图显示了最低的32位:</p><figure class="jw jx jy jz fd ka er es paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="er es ml"><img src="../Images/1656bee289fc6a8f10c2c6a02cb34df3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JCVaInZactGFCcn8sGi8zw.png"/></div></div></figure><p id="263a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">偏移量是一个指向要执行的代码的指针，可能是一个汇编代码标签。例如，要为代码从<em class="jt"> 0xDEADBEEF </em>开始并在特权级别0下运行的处理程序创建一个条目，将使用两个字节<em class="jt"> 0xDEAD8E00 </em>和<em class="jt"> 0x0008BEEF </em>。</p><p id="177d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果idt被表示为一个<em class="jt">无符号整数IDT，</em>那么为了将上面的例子注册为中断0(被零除)的处理程序，将使用下面的代码:</p><p id="be37" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">idt [0] = 0xDEAD8E00</p><p id="82d1" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">idt [1] = 0x0008BEEF</p><p id="8f4d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">不要使用字节或无符号整数，最好使用我们在上一篇文章中讨论过的打包结构，使代码更具可读性。</p><p id="bd57" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了创建一个到IDT的入口，首先在工作目录中创建一个名为interrupts.h的文件来保存下面的C函数声明:</p><figure class="jw jx jy jz fd ka"><div class="bz dy l di"><div class="mm mn l"/></div></figure><figure class="jw jx jy jz fd ka er es paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="er es mo"><img src="../Images/b343f7101a50b7f0b837daf4e5c10d15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_isHTYzTG7C2IrMFZEETHA.png"/></div></div><figcaption class="lt lu et er es lv lw bd b be z dx translated">“现在你会在你的工作目录中看到interrupts.h”</figcaption></figure><p id="8408" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们现在跳过函数定义，因为我们必须学习更多来提出它们。</p><h2 id="c008" class="lx ke hi bd kf ly lz ma kj mb mc md kn jg me mf kp jk mg mh kr jo mi mj kt mk bi translated">装载IDT</h2><p id="3a2e" class="pw-post-body-paragraph ix iy hi iz b ja kv ij jc jd kw im jf jg kx ji jj jk ky jm jn jo kz jq jr js hb bi translated">IDT加载有<em class="jt"> lidt </em>汇编代码指令，该指令获取表中第一个元素的地址。我们包装这条指令，并在C中使用它，如下所示:</p><figure class="jw jx jy jz fd ka"><div class="bz dy l di"><div class="mm mn l"/></div></figure><p id="de9f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在您的工作目录中创建idt.s，并将上面的代码保存在其中，如下图所示:</p><figure class="jw jx jy jz fd ka er es paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="er es mp"><img src="../Images/78dd125ea135c2ecae4cff9e08999ad2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X63p68N3-0dzmeedAebGUg.png"/></div></div><figcaption class="lt lu et er es lv lw bd b be z dx translated">"现在你会看到idt.s文件"</figcaption></figure><h1 id="d34d" class="kd ke hi bd kf kg kh ki kj kk kl km kn io ko ip kp ir kq is kr iu ks iv kt ku bi translated">处理中断</h1><p id="0b9a" class="pw-post-body-paragraph ix iy hi iz b ja kv ij jc jd kw im jf jg kx ji jj jk ky jm jn jo kz jq jr js hb bi translated">当中断发生时，CPU将把有关中断的一些信息压入堆栈，然后在IDT中查找适当的中断处理程序并跳转到它。中断时的堆栈如下所示:</p><pre class="jw jx jy jz fd mq mr ms mt aw mu bi"><span id="cd6e" class="lx ke hi mr b fi mv mw l mx my">[esp + 12] eflags<br/>[esp + 8]  cs<br/>[esp + 4]  eip<br/>[esp]      error code?</span></pre><p id="18fe" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">错误代码后面的问号是因为不是所有的中断都会产生一个<em class="jt">错误代码</em>。将错误代码放入堆栈的特定CPU中断是8、10、11、12、13、14和17。中断处理程序可以使用错误代码来获取有关已发生中断的更多信息。此外，中断号不会被压入堆栈。因此，只有知道正在执行的代码才能识别已经发生的中断。例如:如果为中断14注册的处理程序正在执行，那么中断14已经发生。</p><p id="c81c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一旦中断处理程序完成了它的任务，它就使用<em class="jt"> iret </em>指令返回。指令<em class="jt"> iret </em>期望堆栈与中断时相同。因此，中断处理程序压入堆栈的任何值都应该从堆栈中弹出。在返回之前，<em class="jt"> iret </em>通过从堆栈中弹出值来恢复<em class="jt"> eflags </em>，然后最终跳转到堆栈上的值所指定的<em class="jt"> cs: eip </em>。</p><figure class="jw jx jy jz fd ka er es paragraph-image"><div class="er es mz"><img src="../Images/618c7e47904bbadb0d18c9958e647091.png" data-original-src="https://miro.medium.com/v2/resize:fit:934/format:webp/0*jnXkRIJi7gvP4vnU.png"/></div></figure><p id="44dd" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">中断处理程序使用的所有寄存器必须通过将它们压入堆栈来保存。因此，中断处理程序必须用汇编代码编写。原因是被中断的代码不知道这个中断，因此期望它的寄存器保持不变。但是，用汇编代码编写中断处理程序的所有逻辑将是令人厌烦的。因此，我们可以在汇编代码中创建一个处理程序，保存寄存器，调用C函数，恢复寄存器，最后执行<em class="jt"> iret </em>。</p><p id="a11c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">C处理程序应该获取寄存器的状态、堆栈的状态和中断的数量作为参数。可以使用以下定义:</p><figure class="jw jx jy jz fd ka"><div class="bz dy l di"><div class="mm mn l"/></div></figure><p id="d075" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在用上面的代码更新interrupts.h文件，如下所示:</p><figure class="jw jx jy jz fd ka er es paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="er es na"><img src="../Images/ed95456c4de8b341617ab9f921ee8cd8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q0sM4Snvzs_pvhP7RKvDQg.png"/></div></div><figcaption class="lt lu et er es lv lw bd b be z dx translated">"现在你的interrupts.h文件看起来像这样"</figcaption></figure><p id="9fe0" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">中断处理程序的功能定义也可以在以后的进一步研究中完成。</p><h1 id="97ed" class="kd ke hi bd kf kg kh ki kj kk kl km kn io ko ip kp ir kq is kr iu ks iv kt ku bi translated">创建通用中断处理程序</h1><p id="5fec" class="pw-post-body-paragraph ix iy hi iz b ja kv ij jc jd kw im jf jg kx ji jj jk ky jm jn jo kz jq jr js hb bi translated">编写一个通用的中断处理程序并不容易，因为CPU不会将中断号推入堆栈。让我们看看如何使用宏来完成它。为每个中断编写一个版本不是一个好主意，所以最好使用NASM的宏功能。由于只有一些中断产生错误代码，对于没有错误代码的中断，值0将被声明为“错误代码”。下面的代码显示了如何做到这一点:</p><figure class="jw jx jy jz fd ka"><div class="bz dy l di"><div class="mm mn l"/></div></figure><p id="e634" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在工作目录中创建interrupt_handler.s文件，并将上面的代码保存在其中:</p><figure class="jw jx jy jz fd ka er es paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="er es nb"><img src="../Images/d70e45ef36a7bf7e8a649f5d3b186a4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B6RxODvLwNirV7M03AyQ5A.png"/></div></div><figcaption class="lt lu et er es lv lw bd b be z dx translated">"现在你会看到interrupt_handler.s文件"</figcaption></figure><p id="e487" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">常见的中断处理程序执行以下操作:</p><ul class=""><li id="e879" class="la lb hi iz b ja jb jd je jg lc jk ld jo le js lf lg lh li bi translated">推送堆栈上的寄存器。</li><li id="7b4f" class="la lb hi iz b ja lj jd lk jg ll jk lm jo ln js lf lg lh li bi translated">调用C函数中断处理程序。</li><li id="6085" class="la lb hi iz b ja lj jd lk jg ll jk lm jo ln js lf lg lh li bi translated">从堆栈中弹出寄存器。</li><li id="4b4a" class="la lb hi iz b ja lj jd lk jg ll jk lm jo ln js lf lg lh li bi translated">给esp加8。</li><li id="10a1" class="la lb hi iz b ja lj jd lk jg ll jk lm jo ln js lf lg lh li bi translated">执行<em class="jt">指令</em>返回被中断的代码。</li></ul><p id="1da6" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">由于宏声明了全局标签，当创建IDT时，可以从C或汇编代码中访问中断处理程序的地址。</p><h1 id="1666" class="kd ke hi bd kf kg kh ki kj kk kl km kn io ko ip kp ir kq is kr iu ks iv kt ku bi translated">可编程中断控制器</h1><p id="3e3b" class="pw-post-body-paragraph ix iy hi iz b ja kv ij jc jd kw im jf jg kx ji jj jk ky jm jn jo kz jq jr js hb bi translated">可编程中断控制器用于管理来自不同硬件设备的硬件中断，并将它们发送到相应的系统中断。因此，为了首先开始使用硬件中断，必须配置可编程中断控制器(PIC)。PIC使得将硬件信号映射到中断成为可能。</p><p id="336d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">配置PIC的原因是:</p><ul class=""><li id="97ad" class="la lb hi iz b ja jb jd je jg lc jk ld jo le js lf lg lh li bi translated">重新映射中断。默认情况下，PIC使用中断0–15作为硬件中断，这与CPU中断相冲突。因此，PIC中断必须重新映射到另一个时间间隔。</li><li id="372c" class="la lb hi iz b ja lj jd lk jg ll jk lm jo ln js lf lg lh li bi translated">选择要接收的中断。</li><li id="b08d" class="la lb hi iz b ja lj jd lk jg ll jk lm jo ln js lf lg lh li bi translated">为PIC设置正确的模式。</li></ul><figure class="jw jx jy jz fd ka er es paragraph-image"><div class="er es nc"><img src="../Images/783283c8448875e7859b4b0e73588c17.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/0*nlAHjz9ce3BqiI3k.png"/></div></figure><p id="9d74" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">开始时只有一个PIC (PIC 1)和八个中断。由于增加了更多硬件，8次中断是不够的。因此，作为解决方案，另一个PIC (PIC 2)链接到第一个PIC上。</p><figure class="jw jx jy jz fd ka er es paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="er es nd"><img src="../Images/05a61874b97ab2ff2bfd872535749e83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dxFmANllteqgSHrfLp8Qaw.png"/></div></div></figure><p id="a436" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">来自PIC的每个中断必须通过向PIC发送确认该中断已被处理的消息来确认。如果这没有完成，PIC将不会产生更多的中断。</p><p id="1353" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">确认PIC中断的过程是通过向引发中断的PIC发送字节<em class="jt"> 0x20 </em>来完成的。因此，实现<em class="jt"> pic_acknowledge </em>功能可以如下进行:</p><figure class="jw jx jy jz fd ka"><div class="bz dy l di"><div class="mm mn l"/></div></figure><p id="0395" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了PIC的完整功能，让我们创建一个名为pic.h的文件，并在其中保存以下代码:</p><figure class="jw jx jy jz fd ka"><div class="bz dy l di"><div class="mm mn l"/></div></figure><figure class="jw jx jy jz fd ka er es paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="er es ne"><img src="../Images/fcddf3dd2d991266c32968cbb615bf0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mNI7v6Ifl_O1e_ydOpWE5Q.png"/></div></div><figcaption class="lt lu et er es lv lw bd b be z dx translated">“现在您将看到pic.h文件”</figcaption></figure><p id="8eb2" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">之后，包括<em class="jt"> pic_acknowledge </em>在内的函数定义应保存在一个名为pic.c的文件中，如下所示:</p><figure class="jw jx jy jz fd ka"><div class="bz dy l di"><div class="mm mn l"/></div></figure><figure class="jw jx jy jz fd ka er es paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="er es nf"><img src="../Images/91cfb0b91f2195ef89fe455df0820614.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w2T2QWMHF3AMWlHOzWmbzQ.png"/></div></div></figure><h1 id="e844" class="kd ke hi bd kf kg kh ki kj kk kl km kn io ko ip kp ir kq is kr iu ks iv kt ku bi translated">从键盘读取输入</h1><p id="8bc8" class="pw-post-body-paragraph ix iy hi iz b ja kv ij jc jd kw im jf jg kx ji jj jk ky jm jn jo kz jq jr js hb bi translated">现在我们的操作系统可以处理中断，所以我们准备好从键盘获取输入。在这一部分，让我们看看我们可以怎么做。</p><p id="a421" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">键盘不生成ASCII字符，而是生成扫描代码。扫描代码代表一个按钮，更具体地说，代表特定按钮的按压和释放。地址为<em class="jt"> 0x60 </em>的键盘数据I/O端口可用于读取代表刚刚按下的按钮的扫描代码。下面的示例显示了如何实现这一点:</p><figure class="jw jx jy jz fd ka"><div class="bz dy l di"><div class="mm mn l"/></div></figure><p id="a214" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">下一步是编写一个函数，将扫描代码翻译成相应的ASCII字符。为此，首先创建一个keyboard.h文件，并保存以下宏定义和函数声明:</p><figure class="jw jx jy jz fd ka"><div class="bz dy l di"><div class="mm mn l"/></div></figure><figure class="jw jx jy jz fd ka er es paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="er es ng"><img src="../Images/61f715aa16a1ebdea269998b5bd861eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QZZ8x7mrj7-5KhCxm9OI1g.png"/></div></div><figcaption class="lt lu et er es lv lw bd b be z dx translated">"现在你会看到keyboard.h文件"</figcaption></figure><p id="2e36" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，让我们用上述函数的定义创建keyboard.c文件:</p><figure class="jw jx jy jz fd ka"><div class="bz dy l di"><div class="mm mn l"/></div></figure><figure class="jw jx jy jz fd ka er es paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="er es nh"><img src="../Images/649cbe208a9dd51004beb9bd8fcb441f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9pWVVQiJHLlYKqpFYd9YIg.png"/></div></div><figcaption class="lt lu et er es lv lw bd b be z dx translated">"现在你会看到keyboard.c文件"</figcaption></figure><p id="c5b0" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">由于键盘中断是由PIC引发的，所以必须在键盘中断处理程序的末尾调用pic_acknowledge。此外，键盘不会给你任何更多的中断，直到你从键盘上读取扫描码。</p><p id="9afe" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，我们已经了解了创建我们之前跳过的interrupts.c文件的所有必要细节。它包含中断中所述功能的定义。h .以下代码可用于此:</p><figure class="jw jx jy jz fd ka"><div class="bz dy l di"><div class="mm mn l"/></div></figure><figure class="jw jx jy jz fd ka er es paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="er es ni"><img src="../Images/580030ef293690e5037359ff42357e0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KSU0eX5EG66zmOBQwZiMvQ.png"/></div></div><figcaption class="lt lu et er es lv lw bd b be z dx translated">“现在你会看到interrupts.c文件”</figcaption></figure><p id="3abf" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">以下两个函数应该包含在interrupts.h文件中，它们是NASM的包装器。</p><blockquote class="nj nk nl"><p id="3201" class="ix iy jt iz b ja jb ij jc jd je im jf nm jh ji jj nn jl jm jn no jp jq jr js hb bi translated">void load_idt(无符号int IDT _ address)；</p><p id="971f" class="ix iy jt iz b ja jb ij jc jd je im jf nm jh ji jj nn jl jm jn no jp jq jr js hb bi translated">void中断处理程序33()；</p></blockquote><p id="b48d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如下所示:</p><figure class="jw jx jy jz fd ka er es paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="er es np"><img src="../Images/7f041c66e7c8f26fc56f0391690191f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8jEx3giqBib3Y74MfKdTng.png"/></div></div><figcaption class="lt lu et er es lv lw bd b be z dx translated">"现在你的interrupts.h文件看起来像这样"</figcaption></figure><p id="3f33" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们从键盘输入的内容将输出到我们在以前的文章中介绍的com1.out文件中。所以，让我们对我们在serial_port.c文件和serial_port.h文件(在本系列的第四篇文章中创建)中声明的serial_write函数做一个小小的改动。使用以下函数定义更新serial_port.c文件，使用以下声明更新serial_port.h文件:</p><figure class="jw jx jy jz fd ka"><div class="bz dy l di"><div class="mm mn l"/></div></figure><figure class="jw jx jy jz fd ka er es paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="er es nd"><img src="../Images/351cf2d72d0bc2e2f678ccb807ce18b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xTbvrP05V_vnedu7dFeQbA.png"/></div></div><figcaption class="lt lu et er es lv lw bd b be z dx translated">“现在，您的serial_port.c和serial_port.h文件将如下所示”</figcaption></figure><p id="3abb" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">像往常一样，是时候更新我们的kmain.c文件了，如下所示:</p><figure class="jw jx jy jz fd ka"><div class="bz dy l di"><div class="mm mn l"/></div></figure><figure class="jw jx jy jz fd ka er es paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="er es nq"><img src="../Images/a7c91abb919c35a219a8b35e897e5d3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cl-EfqZiMd8-_rslwj01RA.png"/></div></div></figure><p id="dd96" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后更新Makefile的对象变量，如下所示:</p><figure class="jw jx jy jz fd ka er es paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="er es nr"><img src="../Images/b3760adf6d295969a31fab8043455599.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B3g0047OpLuSp-nzLMZgpQ.png"/></div></div><figcaption class="lt lu et er es lv lw bd b be z dx translated">"更新的生成文件"</figcaption></figure><p id="27bd" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">使用“make run”命令引导您的操作系统，并使用键盘在控制台上(标记的地方)输入您想要的内容。</p><figure class="jw jx jy jz fd ka er es paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="er es ns"><img src="../Images/3ee5dc18da84a51e58a3ff0406454956.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FKtzc5MNjomhWLGVyG-5vw.png"/></div></div></figure><p id="d096" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在用文本编辑器打开co1.out文件，您将看到您的输入保存在文件中。</p><figure class="jw jx jy jz fd ka er es paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="er es nh"><img src="../Images/0b81c0f033f4bd3603af026a0197e475.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8xh70zZaMMpRV6OE5skQVg.png"/></div></div><figcaption class="lt lu et er es lv lw bd b be z dx translated">“我输入欢迎使用myos，这是我的com1.out文件的样子”</figcaption></figure><p id="2669" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，您已经开发了自己的操作系统来处理中断并从键盘读取输入。在下一篇文章中，我们将讨论如何在内核模式下轻松执行一个小程序。从<a class="ae ju" href="https://isuruni-rathnayaka0508.medium.com/develop-your-own-x86-operating-system-os-7-49d494f5116b" rel="noopener">这里</a>读出来。</p><p id="f147" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">参考</p><p id="c8bb" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><a class="ae ju" href="https://littleosbook.github.io/" rel="noopener ugc nofollow" target="_blank"> LittleOSBook </a></p><p id="73e0" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><a class="ae ju" href="https://en.wikibooks.org/wiki/Microprocessor_Design/Interrupts" rel="noopener ugc nofollow" target="_blank">中断</a></p><p id="168f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><a class="ae ju" href="https://wiki.osdev.org/Interrupt_Descriptor_Table" rel="noopener ugc nofollow" target="_blank">中断描述符表</a></p><p id="c0a5" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><a class="ae ju" href="https://en.wikibooks.org/wiki/X86_Assembly/Programmable_Interrupt" rel="noopener ugc nofollow" target="_blank"> x86汇编/可编程中断控制器</a></p><p id="f8a1" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">希望你理解处理中断和从键盘读取输入的步骤。让我们来看看开发自己的x86操作系统(OS)系列的下一篇文章。非常感谢您的阅读！！！！！！！！！！</p><p id="4117" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">伊苏鲁尼·拉特纳亚卡</p></div></div>    
</body>
</html>