<html>
<head>
<title>Log Structured Merge (LSM) Trees</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">日志结构化合并(LSM)树</h1>
<blockquote>原文：<a href="https://medium.com/codex/understanding-log-structured-merge-lsm-trees-c4a0039f17a8?source=collection_archive---------10-----------------------#2021-03-25">https://medium.com/codex/understanding-log-structured-merge-lsm-trees-c4a0039f17a8?source=collection_archive---------10-----------------------#2021-03-25</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="94ff" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">许多数据库使用LSM树来存储需要高写吞吐量的数据。在这篇文章中，我们将通过设计和使用的数据结构。</p><p id="9f4f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了便于讨论，让我们假设我们只有键值对。另外，为了简单起见，我们假设键和值都是字符串。</p></div><div class="ab cl jd je gp jf" role="separator"><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji"/></div><div class="hb hc hd he hf"><h2 id="2628" class="jk jl hi bd jm jn jo jp jq jr js jt ju iq jv jw jx iu jy jz ka iy kb kc kd ke bi translated">仅附加日志文件</h2><p id="0381" class="pw-post-body-paragraph if ig hi ih b ii kf ik il im kg io ip iq kh is it iu ki iw ix iy kj ja jb jc hb bi translated">为了确保高写入率，我们需要顺序写入并减少随机写入。让我们从将键值写入一个只追加文件开始。</p><p id="b730" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们还在内存中维护一个哈希映射，它包含从文件开始的键和值。每当我们更新一个值时，我们就把散列表更新到文件中的新偏移量。</p><p id="5401" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于put(key，value ),我们只需添加到文件中。</p><p id="c89b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于get(key ),我们检查hashmap中的偏移量，并对该值的给定偏移量进行磁盘搜索。</p><p id="0dc9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于删除，我们在日志文件中写一个<strong class="ih hj"> tombstone </strong>条目，并在hashmap中更新它。我们需要tombstone，因为我们需要获得密钥被删除的信息。当我们在失败后重新构建hashmap时，以及在压缩的情况下，这很方便。</p></div><div class="ab cl jd je gp jf" role="separator"><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji"/></div><div class="hb hc hd he hf"><p id="d80b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们继续写入文件，我们最终将耗尽空间。因此，我们需要</p><h2 id="482d" class="jk jl hi bd jm jn jo jp jq jr js jt ju iq jv jw jx iu jy jz ka iy kb kc kd ke bi translated">压紧</h2><p id="75ac" class="pw-post-body-paragraph if ig hi ih b ii kf ik il im kg io ip iq kh is it iu ki iw ix iy kj ja jb jc hb bi translated">压缩实质上意味着从日志文件中删除一个键的所有实例，最新的实例除外。</p><p id="7d80" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当前一个文件已经达到指定的大小或密钥或任何其他参数的阈值时，让我们开始将文件分成片段并开始新的文件。</p><p id="98c6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此外，让我们为每个片段保留一个散列表。</p><p id="1c26" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在压缩中，我们取2个或更多的段，打开一个新文件，在新文件中插入所有带有最新值的键(仅一次),并针对这个新文件创建一个新索引。我们需要tombstone条目来删除压缩时删除的键。</p><p id="4aa7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦创建了新文件，我们就丢弃旧文件和旧索引。</p></div><div class="ab cl jd je gp jf" role="separator"><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji"/></div><div class="hb hc hd he hf"><h2 id="5ac9" class="jk jl hi bd jm jn jo jp jq jr js jt ju iq jv jw jx iu jy jz ka iy kb kc kd ke bi translated">表或排序字符串表</h2><p id="f11c" class="pw-post-body-paragraph if ig hi ih b ii kf ik il im kg io ip iq kh is it iu ki iw ix iy kj ja jb jc hb bi translated">SSTable是一个日志文件，具有以下两个属性。</p><p id="09db" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">a)它包含按排序顺序排列的记录，即日志文件中的键值对按键排序。</p><p id="6520" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">b)它只包含一个密钥一次。</p><p id="1527" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">SSTables比上面的日志文件提供了更好的性能，因为我们现在可以拥有稀疏的索引。如果对键进行排序，我们可以在索引映射中拥有更少的键。对于不在索引中的给定键(在内存映射中)，我们可以查找最近的可用键，并从该偏移量在文件中进行查找。</p><p id="2e2f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此外，这种结构现在允许范围查询，并允许任何给定键之间的数据。</p></div><div class="ab cl jd je gp jf" role="separator"><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji"/></div><div class="hb hc hd he hf"><p id="fadc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如何创建STables？</p><h2 id="d953" class="jk jl hi bd jm jn jo jp jq jr js jt ju iq jv jw jx iu jy jz ka iy kb kc kd ke bi translated">内存表</h2><p id="bcf9" class="pw-post-body-paragraph if ig hi ih b ii kf ik il im kg io ip iq kh is it iu ki iw ix iy kj ja jb jc hb bi translated">让我们首先维护一个存储键值对的内存数据结构，并在删除重复项的同时按排序顺序存储键。我们可以使用AVL树或红黑树。你可以把这些树想象成自我平衡的二叉查找树。一种二叉查找树，其中叶节点的高度差不大于1。</p><p id="46d6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">每当有写操作进入时，将其添加到内存平衡树结构中，这也被称为<strong class="ih hj"> memtable </strong>。</p><p id="9430" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">每当内存树的大小增加到指定的阈值时，该树就会以<strong class="ih hj">表</strong>的形式写入磁盘。该文件满足上述属性。</p></div><div class="ab cl jd je gp jf" role="separator"><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji"/></div><div class="hb hc hd he hf"><p id="16de" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">走旁门左道。假设我们需要检查一个键是否存在于一个列表中。让我们也声明，我们能够承受假肯定，即，当检查声明一个密钥存在，但实际上它不存在，但是我们不能承受假否定，即，当检查声明一个密钥不存在，但它存在。</p><p id="2ff8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们使用以下命令在列表中检查键</p><p id="d416" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">线性搜索—这将是O(n)</p><p id="dea6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">二分搜索法——这将是O(lg n)</p><p id="c3ca" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">布鲁姆滤镜</strong></p><figure class="kl km kn ko fd kp er es paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="er es kk"><img src="../Images/c042c78e910c7fe50835036df723a5ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TCikR0ne9mKImzaNNJavIw.jpeg"/></div></div></figure><p id="67ba" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们取一个m位数组。将每个位设为0。</p><p id="3600" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">同样，让我们假设k个散列函数。回想一下，对于任何给定的输入，散列函数都返回0-m之间的值。</p><p id="a26c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于给定的输入，说input(哇，多么有创意的名字)。</p><p id="2217" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于每个散列函数hj(其中j = 1到k)(在上面我们有k = 2，即2个散列函数)</p><p id="3fab" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">设置m[hj(inp)] = 1，即我们使用所有散列函数计算输入的散列。对于每个哈希函数，返回的索引被设置为1。在上面的例子中，散列函数返回索引1和4。</p><p id="af24" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了检查一个键是否存在，我们检查哈希函数返回的所有索引是否都设置为1。在上面的例子中，当检查输入1(另一个创意名称)时，我们检查m[h1(输入1)]…..m[hk(input1)]全部为1或不为1。</p><p id="5a8a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">复杂度= O(c) + pO(n)其中p =假阴性的概率，即布隆过滤器声明一个键存在，而它不存在。对于m和散列函数的确定值，p可以保持足够小，以使复杂度为常数。</p><p id="e8d2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">布隆过滤器没有删除机制。</p></div><div class="ab cl jd je gp jf" role="separator"><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji"/></div><div class="hb hc hd he hf"><p id="2b9d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">回到正轨</p><p id="0999" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">日志结构化合并树(LSM树)</strong></p><figure class="kl km kn ko fd kp er es paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="er es kw"><img src="../Images/44b4993e966ffc2ac7ebc712408c3c90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*okv6BKy-rbWYTfEOkSCRbA.jpeg"/></div></div></figure><p id="52c4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们已经有了创建LSM树的所有基本构件。</p><p id="3299" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">写</strong></p><p id="6fef" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们按照下面的步骤写。</p><ol class=""><li id="6cbb" class="kx ky hi ih b ii ij im in iq kz iu la iy lb jc lc ld le lf bi translated">每当我们得到一个写操作时，我们首先将它写入一个只附加的日志文件。这样做是为了确保我们可以在崩溃后恢复，也就是说，当memtable丢失时，我们使用这个只添加日志文件来创建memtable。</li><li id="0428" class="kx ky hi ih b ii lg im lh iq li iu lj iy lk jc lc ld le lf bi translated">我们将数据写入memtable。</li><li id="3e9d" class="kx ky hi ih b ii lg im lh iq li iu lj iy lk jc lc ld le lf bi translated">我们为这个密钥更新布隆过滤器中的比特</li><li id="ed8c" class="kx ky hi ih b ii lg im lh iq li iu lj iy lk jc lc ld le lf bi translated">当memtable超过大小时刷新(定义如下)。</li></ol><h2 id="80e6" class="jk jl hi bd jm jn jo jp jq jr js jt ju iq jv jw jx iu jy jz ka iy kb kc kd ke bi translated">阅读</h2><p id="ba85" class="pw-post-body-paragraph if ig hi ih b ii kf ik il im kg io ip iq kh is it iu ki iw ix iy kj ja jb jc hb bi translated">我们按照下面的步骤进行阅读。</p><ol class=""><li id="ab2c" class="kx ky hi ih b ii ij im in iq kz iu la iy lb jc lc ld le lf bi translated">我们检查布隆过滤器是否存在密钥。这避免了检查所有索引是否存在键。</li><li id="0ff6" class="kx ky hi ih b ii lg im lh iq li iu lj iy lk jc lc ld le lf bi translated">我们在memtable中查找密钥。最近一次写入会在这里。</li><li id="83fc" class="kx ky hi ih b ii lg im lh iq li iu lj iy lk jc lc ld le lf bi translated">我们检查索引映射中的键(按降序)，并找到包含该值的文件和偏移量。</li></ol><h2 id="9b74" class="jk jl hi bd jm jn jo jp jq jr js jt ju iq jv jw jx iu jy jz ka iy kb kc kd ke bi translated">其他操作很少</h2><p id="17fb" class="pw-post-body-paragraph if ig hi ih b ii kf ik il im kg io ip iq kh is it iu ki iw ix iy kj ja jb jc hb bi translated">为了确保内存中的数据结构不超过给定的大小，我们需要不时地将它刷新到磁盘。</p><h1 id="8488" class="ll jl hi bd jm lm ln lo jq lp lq lr ju ls lt lu jx lv lw lx ka ly lz ma kd mb bi translated">脸红</h1><p id="af36" class="pw-post-body-paragraph if ig hi ih b ii kf ik il im kg io ip iq kh is it iu ki iw ix iy kj ja jb jc hb bi translated">当memtable增长超过指定大小时，它的所有内容都被刷新到磁盘上的一个SSTable中。</p><ol class=""><li id="a7c8" class="kx ky hi ih b ii ij im in iq kz iu la iy lb jc lc ld le lf bi translated">Memtable被写入磁盘。</li><li id="a31b" class="kx ky hi ih b ii lg im lh iq li iu lj iy lk jc lc ld le lf bi translated">仅附加文件被丢弃，并创建一个新的仅附加文件。</li><li id="6bc5" class="kx ky hi ih b ii lg im lh iq li iu lj iy lk jc lc ld le lf bi translated">针对该文件创建一个索引hashmap，包含从文件开始的键和偏移量。每个表都有自己的索引。</li><li id="bfba" class="kx ky hi ih b ii lg im lh iq li iu lj iy lk jc lc ld le lf bi translated">创建一个新的memtable，所有新的写操作都被写入这个memtable和新的仅追加文件。</li></ol><h2 id="1d8a" class="jk jl hi bd jm jn jo jp jq jr js jt ju iq jv jw jx iu jy jz ka iy kb kc kd ke bi translated">压紧</h2><p id="1882" class="pw-post-body-paragraph if ig hi ih b ii kf ik il im kg io ip iq kh is it iu ki iw ix iy kj ja jb jc hb bi translated">随着时间的推移，文件/段的数量将会增加。为了减少磁盘空间，有时需要压缩。</p><p id="8088" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">压缩可以通过使用合并排序来完成。可以使用k路合并来合并这些表，并将其写入一个新文件。索引和旧文件将被丢弃，新段和新索引将用于读取。</p><h2 id="317a" class="jk jl hi bd jm jn jo jp jq jr js jt ju iq jv jw jx iu jy jz ka iy kb kc kd ke bi translated">为什么我们需要布鲁姆过滤器？</h2><p id="16ee" class="pw-post-body-paragraph if ig hi ih b ii kf ik il im kg io ip iq kh is it iu ki iw ix iy kj ja jb jc hb bi translated">当检查一个不存在的键时，我们需要检查多个索引。当索引的数量(等于段的数量)很大时，对于不存在的键，将需要在所有索引中查找。Bloom filter致力于减少这些索引中的查找次数。</p></div><div class="ab cl jd je gp jf" role="separator"><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji"/></div><div class="hb hc hd he hf"><h2 id="259e" class="jk jl hi bd jm jn jo jp jq jr js jt ju iq jv jw jx iu jy jz ka iy kb kc kd ke bi translated">摘要</h2><p id="102d" class="pw-post-body-paragraph if ig hi ih b ii kf ik il im kg io ip iq kh is it iu ki iw ix iy kj ja jb jc hb bi translated">虽然创建上述解决方案是为了提高写入吞吐量，但一般来说，它取决于许多其他因素，尤其是工作负载。这篇文章提供了一个概述和对LSM树如何工作的理解。这些树现在在很多数据库下使用，如Cassandra，InfluxDB等。</p></div></div>    
</body>
</html>