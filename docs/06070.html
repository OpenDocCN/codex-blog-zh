<html>
<head>
<title>Elixir for Haskell programmers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Haskell程序员的灵丹妙药</h1>
<blockquote>原文：<a href="https://medium.com/codex/elixir-for-haskell-programmers-54f3ba5e5ff6?source=collection_archive---------9-----------------------#2022-04-08">https://medium.com/codex/elixir-for-haskell-programmers-54f3ba5e5ff6?source=collection_archive---------9-----------------------#2022-04-08</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="f460" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">嗯，你可能在想<strong class="ih hj"> <em class="jd">“为什么Haskell开发者会对Elixir感兴趣？”</em> </strong>或<strong class="ih hj"> <em class="jd">“世界上没有多少Haskell开发人员，所以本指南不会很有用”</em> </strong>，主要原因是我只是想更多地谈论elixir以及与Haskell的差异和相似之处，而不考虑这种材料的未来用途，此外，Elixir是一种非常好的语言，并且有一个充满活力的社区，激励社区为传播Elixir这个词做出贡献。以及“<strong class="ih hj"> <em class="jd">为什么不为Elixir程序员设计一个Haskell？”</em> </strong>，因为Haskell已经是一门非常成熟的语言，有着令人难以置信的课程，甚至还有更令人难以置信的教授，我不知道我可以在哪里插入一些新的东西，而Elixir仍然是一门非常年轻的语言，有许多事情要做，以传播这种语言并使社区变得更强大。</p><p id="610e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">既然我已经恰当地介绍了原因，让我们从基础开始:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/beb24cc3af9cc0f6df50fcb317f8c2ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*rnbyY-qzpSPy_FUE"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated"><a class="ae ju" href="https://unsplash.com/@arjun_mj?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Arjun MJ </a>在<a class="ae ju" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="81fd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi jv translated"><span class="l jw jx jy bm jz ka kb kc kd di"> W </span>什么是仙丹？</p><p id="67dc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Elixir是一种运行在Erlang虚拟机上的函数式语言，由José Valim在前plataformatech(已被nubank收购)创建，同时，Elixir受到Ruby(José Valim曾经是rails核心团队的成员)、Clojure(Valim决定应用宏来使语言可扩展)和Erlang(这种风格的并发行为者模型更容易被人类理解，并且Erlang VM的所有功能都是容错和自愈的)的极大启发。</p><h2 id="e876" class="ke kf hi bd kg kh ki kj kk kl km kn ko iq kp kq kr iu ks kt ku iy kv kw kx ky bi translated">最基本的</h2><p id="70e2" class="pw-post-body-paragraph if ig hi ih b ii kz ik il im la io ip iq lb is it iu lc iw ix iy ld ja jb jc hb bi translated">如果不强调函数，这就不是一个合适的函数式语言介绍，现在让我们来深入了解一下elixir函数的语法:</p><pre class="jf jg jh ji fd le lf lg lh aw li bi"><span id="65c3" class="ke kf hi lf b fi lj lk l ll lm">defmodule Example do <br/>  def hi() do <br/>    IO.puts "Hello World"<br/>  end<br/>end</span><span id="5a6a" class="ke kf hi lf b fi ln lk l ll lm">Example.hi()</span></pre><p id="05bb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了能够在Elixir中使用模块函数，我需要首先创建一个模块(<strong class="ih hj"> <em class="jd"> defmodule </em> </strong>)，然后定义我的函数(用<strong class="ih hj"> <em class="jd"> def </em> </strong>关键字)，为了执行，我只需运行<strong class="ih hj"> <em class="jd"> Example.hi() </em> </strong>(在<a class="ae ju" href="https://replit.com/languages/elixir" rel="noopener ugc nofollow" target="_blank"> repl </a>上键入这段代码，然后点击run，应该会显示hello world)。</p><p id="2c51" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你认为该语法有一些类似c的代码，你猜对了，这是Ruby语言的灵感，我们必须打开和关闭块，但稍后我们会看到一些不键入这些块的方法。</p><p id="5a82" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Haskell中的等价物</p><pre class="jf jg jh ji fd le lf lg lh aw li bi"><span id="cace" class="ke kf hi lf b fi lj lk l ll lm">module Example</span><span id="5904" class="ke kf hi lf b fi ln lk l ll lm">hi = print "Hello World"</span></pre><h2 id="7b72" class="ke kf hi bd kg kh ki kj kk kl km kn ko iq kp kq kr iu ks kt ku iy kv kw kx ky bi translated">匿名函数</h2><p id="be8e" class="pw-post-body-paragraph if ig hi ih b ii kz ik il im la io ip iq lb is it iu lc iw ix iy ld ja jb jc hb bi translated">与Haskell相反，Elixir区分了模块函数和匿名函数，而在Haskell中两者是平等的。</p><p id="ad90" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Haskell中的示例</p><pre class="jf jg jh ji fd le lf lg lh aw li bi"><span id="6375" class="ke kf hi lf b fi lj lk l ll lm">domath x = x + 3</span><span id="76cf" class="ke kf hi lf b fi ln lk l ll lm">-- is equal to</span><span id="8735" class="ke kf hi lf b fi ln lk l ll lm">(\x -&gt; x+3)</span><span id="8079" class="ke kf hi lf b fi ln lk l ll lm">example = do<br/>  print $ map (domath)    [4] -- outputs [7]<br/>  print $ map (\x -&gt; x+3) [4] -- outputs [7]</span></pre><p id="67b8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">而长生不老药的等效性是不可能的:</p><pre class="jf jg jh ji fd le lf lg lh aw li bi"><span id="fae7" class="ke kf hi lf b fi lj lk l ll lm">defmodule MathMod do <br/>  def do_math(x) do <br/>    x+3<br/>  end</span><span id="2b62" class="ke kf hi lf b fi ln lk l ll lm">  def example() do <br/>    IO.inspect Enum.map([4], do_math)<br/>  end<br/>end</span><span id="824d" class="ke kf hi lf b fi ln lk l ll lm">MathMod.hi(4) # outputs 7<br/>MathMod.example() # outputs an error because passing module functons as a parameter generates an error</span></pre><p id="5b9d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了能够将函数作为参数传递，我需要像这样指定一个匿名函数:</p><pre class="jf jg jh ji fd le lf lg lh aw li bi"><span id="ad04" class="ke kf hi lf b fi lj lk l ll lm">defmodule MathMod do <br/>  def do_math(x) do <br/>    x+3<br/>  end</span><span id="4775" class="ke kf hi lf b fi ln lk l ll lm">  def example() do <br/>    IO.inspect Enum.map([4], fn x -&gt; x+3 end)<br/>  end<br/>end</span><span id="87f6" class="ke kf hi lf b fi ln lk l ll lm">MathMod.example() # outputs [7]</span></pre><p id="e396" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此外，为了区分函数，Elixir没有自动编译，所以我们必须手动编译我们的函数，并且只能编译匿名函数:</p><pre class="jf jg jh ji fd le lf lg lh aw li bi"><span id="17a8" class="ke kf hi lf b fi lj lk l ll lm">anFunc = fn x -&gt; fn y -&gt; x+y end end</span><span id="8c3c" class="ke kf hi lf b fi ln lk l ll lm">IO.puts anFunc.(3).(4) # outputs 7</span></pre><h2 id="e41e" class="ke kf hi bd kg kh ki kj kk kl km kn ko iq kp kq kr iu ks kt ku iy kv kw kx ky bi translated">缩短我们的功能</h2><p id="d30d" class="pw-post-body-paragraph if ig hi ih b ii kz ik il im la io ip iq lb is it iu lc iw ix iy ld ja jb jc hb bi translated">正如我之前提到的，我们可以通过不编写一些开闭父类或代码块来节省一些时间:</p><pre class="jf jg jh ji fd le lf lg lh aw li bi"><span id="e71a" class="ke kf hi lf b fi lj lk l ll lm">defmodule MathMod do <br/>  def do_math(x) do <br/>    x+3<br/>  end<br/>end</span><span id="f01c" class="ke kf hi lf b fi ln lk l ll lm"># is equal to</span><span id="cea6" class="ke kf hi lf b fi ln lk l ll lm">defmodule MathMod do <br/>  def do_math(x), do: x+3<br/>end</span></pre><p id="8f18" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此外:</p><pre class="jf jg jh ji fd le lf lg lh aw li bi"><span id="4a62" class="ke kf hi lf b fi lj lk l ll lm">defmodule MathMod do <br/>  def example() do <br/>    IO.inspect(Enum.map([4], fn x -&gt; x+3 end))<br/>  end<br/>end</span><span id="2495" class="ke kf hi lf b fi ln lk l ll lm"># is equal to</span><span id="6148" class="ke kf hi lf b fi ln lk l ll lm">defmodule MathMod do <br/>  def example, do: IO.inspect Enum.map([4], &amp;(&amp;1+3)) <br/>#notice that &amp;1 <br/># is an alias for the first parameter(the x) if our function had <br/># more parameters the alias would be &amp;2, &amp;3...&amp;n<br/>end</span></pre><p id="a7e7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">咻，我认为对于第一口Elixir，我们涵盖了一堆东西，可能这不是对初学者最友好的开始方式，但如果你熟悉Haskell，我试图让它尽可能地熟悉，我不知道我是否会继续并将它变成一个系列，但我仍然希望以某种方式为你的学习之旅做出贡献。</p><p id="e719" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">感谢阅读！再见:)</p></div></div>    
</body>
</html>