<html>
<head>
<title>Using Keys to Maintain Scroll State After an Orientation Change</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">方向改变后使用按键保持滚动状态</h1>
<blockquote>原文：<a href="https://medium.com/codex/maintaining-pageviews-current-page-after-orientation-changes-using-keys-ac0769234e09?source=collection_archive---------10-----------------------#2021-12-28">https://medium.com/codex/maintaining-pageviews-current-page-after-orientation-changes-using-keys-ac0769234e09?source=collection_archive---------10-----------------------#2021-12-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="0a73" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">颤振案例研究</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/2380b0b9c8c126a75e46b2106fc1a86b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JtrdPVSFC_qeCFobkFFKGw.jpeg"/></div></div></figure><p id="c2f3" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">欢迎阅读我们的<strong class="jl hj">案例研究系列</strong>的第二篇文章。如果你还没有看过第一篇关于在Android上使用Navigator 2.0时捕捉回按键的文章，请在这里查看<a class="ae kf" href="https://lp3.medium.com/flutter-case-study-catching-back-button-presses-on-android-when-using-navigator-2-0-d4d42e4718f6" rel="noopener"/>。今天，我们将讨论roll <code class="du kg kh ki kj b">Key</code>在微件重新创建之间维护<em class="kk">状态</em>的作用。在这个来自Flutter团队的精彩视频中，可以找到对<code class="du kg kh ki kj b">Key</code>及其与小部件的使用的精彩解释。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="kl km l"/></div></figure><p id="56a6" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">如果您想通过一个示例来更好地理解这一点，请留下来继续学习。</p><p id="3e4a" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><a class="ae kf" href="https://stackoverflow.com" rel="noopener ugc nofollow" target="_blank"> StackOverflow </a>上的用户希望在设备方向改变时提供不同的屏幕布局(横向&amp; <code class="du kg kh ki kj b">Column</code>为纵向<code class="du kg kh ki kj b">Row</code>)。当然，这对于使用<code class="du kg kh ki kj b">OrientationBuilder</code>小部件来说是小菜一碟。但是，用户注意到，当使用<code class="du kg kh ki kj b">PageView</code>改变设备方向时，当前页面索引丢失。这是因为方向改变时创建了一个新的<code class="du kg kh ki kj b">PageView</code>小部件，而<em class="kk">状态</em>丢失了。事实上，任何<code class="du kg kh ki kj b">Scrollable</code>或类似的有状态小部件都会发生同样的事情。通过运行下面的代码来亲自查看。</p><pre class="iy iz ja jb fd kn kj ko kp aw kq bi"><span id="6e4a" class="kr ks hi kj b fi kt ku l kv kw">class HomePage extends StatefulWidget {<br/>  @override<br/>  _HomePageState createState() =&gt; _HomePageState();<br/>}</span><span id="490a" class="kr ks hi kj b fi kx ku l kv kw">class _HomePageState extends State&lt;HomePage&gt; {<br/>  final _controller = PageController();<br/>  final _modes = ['Bike', 'Boat', 'Car', 'Foot'];<br/>  final _icons = [<br/>    Icons.directions_bike,<br/>    Icons.directions_boat_outlined,<br/>    Icons.directions_car,<br/>    Icons.directions_run,<br/>  ];<br/>  var _page = 0;</span><span id="cc46" class="kr ks hi kj b fi kx ku l kv kw">  Widget _buildHeader() {<br/>    return ColoredBox(<br/>      color: Colors.grey,<br/>      child: Center(<br/>        child: Text(<br/>          'Travel Information',<br/>          style: TextStyle(color: Colors.white, fontSize: 24.0),<br/>        ),<br/>      ),<br/>    );<br/>  }</span><span id="a8b3" class="kr ks hi kj b fi kx ku l kv kw">  @override<br/>  Widget build(BuildContext context) {<br/>    return Scaffold(<br/>      body: OrientationBuilder(builder: (context, orientation) {<br/>        return orientation == Orientation.portrait<br/>          ? Column(<br/>              children: [<br/>                Expanded(child: _buildHeader()),<br/>                Expanded(<br/>                  child: PageView(<br/>                    controller: _controller,<br/>                    children: _modes.map((mode) =&gt;<br/>                      Center(child:Text(mode))).toList(),<br/>                  ),<br/>                ),<br/>              ],<br/>            )<br/>          : Row(<br/>              children: [<br/>                Expanded(child: _buildHeader()),<br/>                Expanded(<br/>                  child: PageView(<br/>                    controller: _controller,<br/>                    children: _modes.map((mode) =&gt;<br/>                      Center(child: Text(mode))).toList(),<br/>                  ),<br/>                ),<br/>              ],<br/>            );<br/>      }),<br/>      bottomNavigationBar: BottomNavigationBar(<br/>        type: BottomNavigationBarType.fixed,<br/>        currentIndex: _page,<br/>        onTap: (page) {<br/>          setState(() =&gt; _page = page));<br/>          _controller.jumpToPage(page);<br/>        },<br/>        items: [<br/>          BottomNavigationBarItem(<br/>            icon: Icon(_icons[0]),<br/>            label: _modes[0],<br/>          ),<br/>          BottomNavigationBarItem(<br/>            icon: Icon(_icons[1]),<br/>            label: _modes[1],<br/>          ),<br/>          BottomNavigationBarItem(<br/>            icon: Icon(_icons[2]),<br/>            label: _modes[2],<br/>          ),<br/>          BottomNavigationBarItem(<br/>            icon: Icon(_icons[3]),<br/>            label: _modes[3],<br/>          ),<br/>        ],<br/>      ),<br/>    );<br/>  }<br/>}</span></pre><p id="6869" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">您会注意到，每次旋转设备时，<code class="du kg kh ki kj b">PageView</code>的当前页面都会重置，但<code class="du kg kh ki kj b">BottomNavigationBar</code>中的选定项目不会重置，这不仅会导致我们丢失位置，还会导致应用程序导航不同步。谢天谢地，有一个简单的解决方案。</p><p id="9759" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们可以创建一个<code class="du kg kh ki kj b">PageStorageKey</code>并将其传递给两个<code class="du kg kh ki kj b">PageView</code>小部件。这告诉Flutter框架，这实际上是同一个小部件，页面状态应该在实例之间维护。</p><pre class="iy iz ja jb fd kn kj ko kp aw kq bi"><span id="b5c7" class="kr ks hi kj b fi kt ku l kv kw">class _HomePageState extends State&lt;HomePage&gt; {<br/>  // create a PageStorageKey, passing in a value for identification<br/>  final _key = PageStorageKey('pageStorageKey');<br/>  final _controller = PageController();</span><span id="bbb6" class="kr ks hi kj b fi kx ku l kv kw">  ...<br/>  // pass to the Columns PageView<br/>  child: PageView(<br/>    key: _key,<br/>    controller: _controller,<br/>  ...<br/>  // pass to the Row's PageView<br/>  child: PageView(<br/>    key: _key,<br/>    controller: _controller,<br/>  ...<br/>}</span></pre><p id="0a90" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">现在你知道了！重新运行应用程序，你会注意到页面在方向变化之间保持导航同步，并保持用户的位置。如前所述，同样的方法将在<code class="du kg kh ki kj b">Scrollable</code>小部件之间保持<em class="kk">滚动状态</em>。我鼓励你试一试，如果你还没有看过，一定要看看文章顶部的视频。它将帮助您更深入地了解何时何地使用<em class="kk">键、</em>，以及哪种键适合特定情况。</p><p id="afb1" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">感谢您的阅读！如果你觉得这篇文章有帮助或者有趣，并且想阅读更多的案例研究，请鼓掌并关注。编码快乐！</p></div></div>    
</body>
</html>