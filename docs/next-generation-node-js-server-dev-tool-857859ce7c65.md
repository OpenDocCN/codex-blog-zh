# 下一代 Node.js 服务器开发工具

> 原文：<https://medium.com/codex/next-generation-node-js-server-dev-tool-857859ce7c65?source=collection_archive---------15----------------------->

![](img/4fd6e430c8c686abc9f80c67f795d70c.png)

插件节点

**TL；博士**

> *使用我制作的牛逼* [*vite 插件*](https://github.com/axe-me/vite-plugin-node) *实现快速节点服务器开发体验！喜欢就开始吧！*

# 动机

我最近在做一个相对较大的 nestjs 后端项目。缓慢的开发服务器让我发疯！每次代码更新，需要几秒钟来重启开发服务器。我尝试用 webpack 替换 nest CLI，希望 webpack HMR 可以帮助提高重新编译的速度。尽管 HMR 工作得很好，但在模块更新后，它仍然会重启 dev 服务器以使更新后的模块生效。这使得从 HMR 节省的时间都浪费了，因为服务器重启是相当耗时的，因为它需要杀死当前的进程，并重生一个新的。一个模块更新后服务器根本不需要重启怎么办？如果那些令人惊奇的新前端工具也适用于后端开发会怎么样？经过几天的研究/工作，我为 Vitejs 制作了一个插件，允许我用 vite 运行我的节点服务器！

# 石器时代后端工具

在进一步了解这个神奇的插件之前。让我们谈谈现在后端开发的现有开发工具。我会解释为什么没有一个是理想的。

## nodemon

这个工具背后的想法非常简单:

> *监视 node.js 应用程序中的任何变化，并自动重启服务器*

这对于编写一些启动时间可以忽略不计的小型纯 javascript 节点服务器很有好处。另一方面，这意味着大型项目的重新加载时间很慢，并且缺乏类型脚本支持。

## ts 节点

这是直接运行 typescript 文件的最流行的工具之一。然而，该工具本身不会为您处理服务器重载。您必须使用 nodemon 之类的工具来帮助您重新加载服务器。这意味着它也有 nodemon 带来的缺点。

## nodejs 寄存器/ esm 加载程序

很多人使用构建在 nodejs 之上的各种工具，这些工具需要 hook(或者 ESM 的新加载器)。这实际上是让 nodejs 原生支持运行 typescript 代码的一个非常聪明的方法。在此基础上实现 HMR 系统实际上也很容易。我们需要做的就是在缓存中缓存所有转换后的代码，并在模块更新后使缓存失效。然后下次当其他模块需要/导入该模块时，转换将重新编译更新后的模块。这有点像 JIT 编译，比从头开始编译要好得多。我实际上试图用 ESBuild/SWC 作为类型脚本编译器编写自己的 ESM 加载程序，并使用内存缓存来实现这个 POC。但是当它几乎完成一半时，我意识到我正在实现一些已经存在于 Vitejs 源代码中的东西！我在这里重新发明轮子！

# Vite 到底是什么？

来自 Vite github 描述:

> *Vite(法语“快速”的意思，读作/vit/)是一种新型的前端构建工具，可以显著改善前端开发体验。它由两大部分组成:*
> 
> *-一个开发服务器，通过本地 es 模块提供您的源文件，具有丰富的内置功能和惊人的快速热模块替换(HMR)。*
> 
> *-一个构建命令，将您的代码与 Rollup 捆绑在一起，预先配置为输出高度优化的静态资产用于生产。*
> 
> 此外，Vite 通过其插件 API 和 JavaScript API 具有高度的可扩展性，并支持完整的类型。

我知道，它本来是为前端开发做的。但我们一些调整，我们可以用它作为后端我保证！我们在描述中看到的一些关键词是`fast HMR`、`Dev Server`、`extensible`。请允许我解释我们如何在节点服务器开发中利用这些特性。

## 超快速 HMR

怎么会？Vite 在内部构建了一个模块图来跟踪所有的依赖项，并在开始时缓存所有转换后的源代码。这使得像 HMR 这样的 JIT 就像我们前面谈到的那样。

## 开发服务器

Vite 内部使用 connect 作为 HTTP 服务器，该服务器可通过 Vite 插件/javascript API 进行定制和扩展。这意味着我们可以将来自 vite dev 服务器的原始 nodejs HTTP 请求传递给我们自己的应用程序。所有这些便利的配置，如本地 https，对本地开发也非常有帮助。

## 高度可扩展

感谢出色的 API 设计。我们几乎可以自定义 vite 中的所有内容。默认情况下，Vite 使用 esbuild 来转换 typescript，想使用 swc 来处理一些 esbuild 还不支持的装饰特性吗？没问题，用 swc 插件处理 typescript 转换就行了，ez！pz！

## 最后一点，但并非最不重要

Vite 是尤雨溪创建的，他也是 Vue.js 的作者。我无耻地承认我是他的超级粉丝。艾凡总能找到非常独特的方法来解决一些常见的问题。

## Vite 节点插件

最后，我来介绍一下我的宝贝插件。回购位于[axe-me/vite-plugin-node](https://github.com/axe-me/vite-plugin-node)。如果试用后喜欢，请给它一颗星。

# 它是如何工作的？

Vite 设计有一个 middlewareMode，它允许我们在其他模块中以编程方式使用 vite。最初是为 SSR web app 做的。因此对于每个请求，vite 可以加载渲染器来呈现您对应用程序所做的最新更改。这个插件利用这个特性来加载和执行带有传入 HTTP 请求的服务器应用程序条目。

你可能会问是不是超级慢，因为它从入口重新编译/重新加载整个应用程序？答案是否定的，因为 vite 很聪明。请使用内置模块图作为缓存层，该图是在首次加载应用程序时构建的。在那之后，当你更新一个文件时，vite 将只使它自己和它的父模块无效，因此对于下一个请求，只有那些无效的模块需要重新编译，这是由于 ESBuild 和 SWC 的超级快。

# 怎么用？

你可以阅读回购的自述文件，因为这是唯一的真相文件来源。或者继续阅读这篇文章，先了解一些情况:

1.  用你最喜欢的软件包管理器安装 vite 和这个插件，这里用 npm 作为例子:

`npm install vite vite-plugin-node -D`

2.在您的项目根目录中创建一个`vite.config.ts`文件来配置 vite 以实际使用这个插件:

3.更新您的服务器条目以导出名为`viteNodeApp`或您配置的名称的应用。

*   ExpressJs

*   KoaJs

*   Fastify

*   NestJs

4.添加一个 npm 脚本来运行开发服务器:

`"scripts": { "dev": "vite" },`

5.运行脚本！`npm run dev`

## 自定义适配器

如果你最喜欢的框架还不被支持，你可以创建一个问题来请求它，或者使用`adapter`选项来告诉插件如何将请求传递给你的应用程序。您可以从`./src/server`文件夹中查看支持的框架是如何实现的。
举例:

```
import { defineConfig } from 'vite';
import { VitePluginNode } from 'vite-plugin-node';export default defineConfig({
  plugins: [
    ...VitePluginNode({
      adapter: function(app, req, res) {
        app(res, res)
      },
      appPath: './app.ts'
    })
  ]
})
```

# 例子

repo 中有一个包含不同用例的 examples 文件夹。

# 结束了

这个插件帮助我更有效率，只是因为我不需要等待几秒钟来重新加载服务器，这样我的大脑就可以不停地转动，中间没有任何休息。希望更多的人可以开始用我的插件来开发后端服务器。我的最终目标是取代 nodemon/ts-node 等石器时代的工具。
快乐编码！

![](img/6d0535a9bb564126cc86d046f6f74196.png)