<html>
<head>
<title>Difference Between NSOperation and Dispatch Queues</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">n操作队列和调度队列之间的差异</h1>
<blockquote>原文：<a href="https://medium.com/codex/difference-between-nsoperation-and-dispatch-queues-91eeaa0b8edf?source=collection_archive---------1-----------------------#2021-07-25">https://medium.com/codex/difference-between-nsoperation-and-dispatch-queues-91eeaa0b8edf?source=collection_archive---------1-----------------------#2021-07-25</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/f404767fa09038df60a0955259f414bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VjyutPvuHDzkADHoFstPNw.jpeg"/></div></div></figure><p id="d9a9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jo">并发性</em>意味着多个计算同时发生。无论我们喜欢与否，并发在现代编程中无处不在:</p><ul class=""><li id="9417" class="jp jq hi is b it iu ix iy jb jr jf js jj jt jn ju jv jw jx bi translated">网络中的多台计算机</li><li id="0141" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">在一台计算机上运行多个应用程序</li><li id="08e8" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">一台计算机中的多个处理器(今天，通常在一个芯片上有多个处理器内核)</li></ul><p id="d78f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">事实上，并发在现代编程中是必不可少的:</p><ul class=""><li id="5a7b" class="jp jq hi is b it iu ix iy jb jr jf js jj jt jn ju jv jw jx bi translated">网站必须同时处理多个用户。</li><li id="c98e" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">移动应用程序需要在服务器上进行一些处理(“在云端”)。</li><li id="30f5" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated">图形用户界面几乎总是需要不打断用户的后台工作。例如，当您还在编辑Java代码时，Eclipse就会编译它。</li></ul><p id="8938" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在未来，能够进行并发编程仍然很重要。处理器时钟速度不再增加。相反，每一代新的芯片都有更多的内核。因此，在未来，为了让计算运行得更快，我们必须将计算分成并发的部分。</p><p id="a4b5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以在开始写任何并发代码之前，先想想为什么需要并发，需要用哪个API来解决这个问题？在iOS中，我们有不同的API可以使用。在本教程中，我们将讨论两个最常用的API——操作和调度队列。</p><h1 id="30bb" class="kd ke hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">关于并发，你需要知道什么？</h1><blockquote class="lb lc ld"><p id="036b" class="iq ir jo is b it iu iv iw ix iy iz ja le jc jd je lf jg jh ji lg jk jl jm jn hb bi translated">在本教程中，我将解释理解并发性所需的一切，并消除您对并发性的所有恐惧。首先，我们建议看一下块(Swift中的闭包),因为它们在并发API中被大量使用。然后我们将讨论调度队列和操作队列。我将向您介绍每个并发概念、它们的区别以及如何实现它们。</p></blockquote><h1 id="e262" class="kd ke hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">大中央调度</h1><p id="1b61" class="pw-post-body-paragraph iq ir hi is b it lh iv iw ix li iz ja jb lj jd je jf lk jh ji jj ll jl jm jn hb bi translated">在iOS中使用Grand Central Dispatch在iOS应用程序中引入并发性和并行性，以便在后台执行多个繁重的任务，从而实现应用程序使用的流畅体验，因为主线程不受繁重的后台任务的影响。</p><p id="6728" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">GCD是在iOS 4中引入的，以避免任务的串行执行，因为串行执行可能会很痛苦。</p><p id="73fb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">串行执行不是一件理想的事情，因为一个任务正在等待处理器，直到另一个任务完成。如果当前执行的任务很重，而等待的任务很小，那该怎么办？因此，我们得到的是大量等待我们的小任务，直到大任务完成。</p><h1 id="4409" class="kd ke hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">调度队列</h1><p id="4c51" class="pw-post-body-paragraph iq ir hi is b it lh iv iw ix li iz ja jb lj jd je jf lk jh ji jj ll jl jm jn hb bi translated">调度队列是在应用程序中异步并发执行任务的一种简单方法。它们是你的应用程序以块(代码块)的形式提交任务的队列。有两种调度队列:(1)串行队列，(2)并发队列。在讨论区别之前，您需要知道分配给两个队列的任务是在不同的线程中执行的，而不是在创建它们的线程中执行的。换句话说，您创建代码块并提交给主线程中的调度队列。但是所有这些任务(代码块)将在单独的线程中运行，而不是在主线程中运行。</p><h1 id="bd0f" class="kd ke hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">什么是串行队列？</h1><p id="869a" class="pw-post-body-paragraph iq ir hi is b it lh iv iw ix li iz ja jb lj jd je jf lk jh ji jj ll jl jm jn hb bi translated">串行调度队列一次只执行一项任务。串行队列通常用于同步对特定值或资源的访问，以防止发生数据竞争。</p><h1 id="cc9f" class="kd ke hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">什么是并发队列？</h1><p id="5441" class="pw-post-body-paragraph iq ir hi is b it lh iv iw ix li iz ja jb lj jd je jf lk jh ji jj ll jl jm jn hb bi translated">并发队列允许我们同时执行多个任务。任务总是按照它们被添加的顺序开始，但是它们可以按照不同的顺序完成，因为它们可以并行执行。任务将在由调度队列管理的不同线程上运行。同时运行的任务数量是可变的，取决于系统条件。</p><h1 id="e914" class="kd ke hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">演示项目</h1><p id="7c6d" class="pw-post-body-paragraph iq ir hi is b it lh iv iw ix li iz ja jb lj jd je jf lk jh ji jj ll jl jm jn hb bi translated">在我们的演示项目中，我们有一个下载器来下载一些图像，向您展示GCD和Operation之间的区别。</p><p id="ef79" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">首先创建一个简单的应用程序。基于你的知识，你可以选择故事板或SwiftUI。在这个演示中，我们继续使用故事板界面。</p><figure class="ln lo lp lq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lm"><img src="../Images/7258e9cfaa21b28f04a11318dab1d208.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4Mq9sGKwVOnzzqx8qyLaew.png"/></div></div></figure><p id="dcf3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">创建项目后，打开Main.storyboard并放置四个UIImageView、一个UISlider和UIButton，如下图所示。</p><figure class="ln lo lp lq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lr"><img src="../Images/2c33919528b332217490fc00215c1152.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0QaqIvo0-i6ifMAxI3Kbhg.png"/></div></div></figure><p id="629e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在为图像和下载按钮和滑块的动作创建出口。</p><p id="9849" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了下载图片，我写了一个简单的下载器，放了4个图片url来下载并显示在我们的UIImageViews中。</p><figure class="ln lo lp lq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ls"><img src="../Images/2bd79881d45f7471795c70ce2845a04c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PimBsBguc_r-EDTkb80hnw.png"/></div></div></figure><p id="828f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">首先，我编写了<em class="jo"> regularDownload </em>函数，并在下载按钮按下时调用这个函数。你会发现你不能改变滑块的值，因为所有的图片都是在主线程中下载的。</p><figure class="ln lo lp lq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lt"><img src="../Images/534c8a586edd15236d670d97c5fbea21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q3TbWPQssHeFeOqEBsij2w.png"/></div></div></figure><p id="c236" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">每个下载器被认为是一个任务，所有的任务现在都在主队列中执行。现在让我们参考一个全局并发队列，它是默认的优先级队列。</p><figure class="ln lo lp lq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lu"><img src="../Images/61f95efaa34120c84b716633e0dc018e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KevVZ2SAEMNE2JACAEaQ4w.png"/></div></div></figure><p id="0a7a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们首先使用<em class="jo"> DispatchQueue.global </em>获得对默认并发队列的引用，然后在块中提交一个任务，下载第一个图像。一旦图像下载完成，我们向主队列提交另一个任务，用下载的图像更新图像视图。换句话说，我们将图像下载任务放在后台线程中，但是在主队列中执行与UI相关的任务。</p><p id="05cb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果您对其余的图像进行同样的操作，您的代码应该如下所示:</p><figure class="ln lo lp lq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lv"><img src="../Images/56a68d745e682c5e2a5e57a2cc6cea62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8jytIZ3jcoUqQJ4E4H2lIg.png"/></div></div></figure><p id="5c03" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，如果你用<em class="jo"> concurrentQueue </em>功能更改<em class="jo"> regularDownload </em>，应用程序应该会运行得更快，并且在下载图像时，你可以更改滑块的值。</p><h1 id="046b" class="kd ke hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">使用串行调度队列</h1><p id="9294" class="pw-post-body-paragraph iq ir hi is b it lh iv iw ix li iz ja jb lj jd je jf lk jh ji jj ll jl jm jn hb bi translated">这一次我们将使用一个串行队列来下载图像。使用串行队列时，您需要密切注意您引用的是哪个串行队列。每个应用程序都有一个默认的串行队列，它实际上是UI的主队列。所以请记住，当使用串行队列时，您必须创建一个新队列，否则您将在应用程序试图执行更新UI的任务时执行您的任务。这将导致破坏用户体验的错误和延迟。更改后，代码将如下所示:</p><figure class="ln lo lp lq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ls"><img src="../Images/56266de4c416efcc1aeae67a21eaf3dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qce-HXFbdgHDk65DOLMlPQ.png"/></div></div></figure><p id="721e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，如果您将<em class="jo"> concurrentQueue </em>更改为<em class="jo"> </em> serialQueue <em class="jo"> </em>函数，应用程序应该会像以前一样工作，但您应该注意两件事:</p><ol class=""><li id="fb75" class="jp jq hi is b it iu ix iy jb jr jf js jj jt jn lw jv jw jx bi translated">与同时排队的情况相比，下载图像需要较长的时间。原因是我们一次只加载一个图像。每个任务在执行前都要等待前一个任务完成。</li><li id="3441" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn lw jv jw jx bi translated">图像按照图像1、图像2、图像3和图像4的顺序加载。这是因为队列是一个串行队列，一次执行一个任务。</li></ol><h1 id="a458" class="kd ke hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">操作队列</h1><p id="d31e" class="pw-post-body-paragraph iq ir hi is b it lh iv iw ix li iz ja jb lj jd je jf lk jh ji jj ll jl jm jn hb bi translated">与GCD不同，操作队列不符合先进先出的顺序。以下是操作队列与调度队列的不同之处:</p><ol class=""><li id="ee9d" class="jp jq hi is b it iu ix iy jb jr jf js jj jt jn lw jv jw jx bi translated">在操作队列中，您可以为操作设置优先级，还可以为操作添加相关性，这意味着您可以定义某些操作仅在其他操作完成后执行。</li><li id="198c" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn lw jv jw jx bi translated">操作队列并发运行，如果您想将它们用作串行队列，您应该通过添加依赖关系来处理它。</li></ol><p id="0fe4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在让我们重写我们的项目演示，但这次我们将使用OperationQueues。首先在ViewController类中声明下面的变量:</p><pre class="ln lo lp lq fd lx ly lz ma aw mb bi"><span id="6f0f" class="mc ke hi ly b fi md me l mf mg"><strong class="ly hj">var</strong> queue = OperationQueue()</span></pre><p id="ffb9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">接下来，添加<em class="jo"> operationQueue </em>方法，并将其更改为serialQueue:</p><figure class="ln lo lp lq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lv"><img src="../Images/f73af4b4b0bda9c301c616be4e01bfbc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9OZoKQmJsONb0uD-KMUcsA.png"/></div></div></figure><p id="79eb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">正如您在上面的代码中看到的，您使用方法<em class="jo"> addOperation </em>创建一个带有给定块的新操作(或者我们在Swift中称之为闭包)。很简单吧？为了在主队列中执行任务，而不是像使用GCD时那样调用DispatchQueue.main.async，我们可以从operation queue(operation queue . main)中执行相同的操作，并在主队列中提交要执行的操作。</p><p id="bca4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你可以运行应用程序进行快速测试。如果代码输入正确，应用程序应该能够在后台下载图像，而不会阻止用户界面。</p><p id="86a5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在前面的例子中，我们使用addOperation方法在队列中添加操作。让我们看看如何使用BlockOperation来做同样的事情，但同时，给我们更多的功能和选项，如设置完成处理程序。</p><figure class="ln lo lp lq fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lv"><img src="../Images/e92d5d1cea10b618d3b8f8047409dc82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mwdMbQdPXfrrBNoOzi__Kw.png"/></div></div></figure><p id="7407" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，当操作完成时，将调用完成处理程序。为了简单起见，我们只记录一条简单的消息来表明操作已经完成。如果您运行演示，您会在控制台中看到类似这样的内容:</p><pre class="ln lo lp lq fd lx ly lz ma aw mb bi"><span id="492c" class="mc ke hi ly b fi md me l mf mg"><strong class="ly hj">Operation 4 completed</strong></span><span id="669b" class="mc ke hi ly b fi mh me l mf mg"><strong class="ly hj">Operation 3 completed</strong></span><span id="f3ac" class="mc ke hi ly b fi mh me l mf mg"><strong class="ly hj">Operation 1 completed</strong></span><span id="abf1" class="mc ke hi ly b fi mh me l mf mg"><strong class="ly hj">Operation 2 completed</strong></span></pre><h1 id="124b" class="kd ke hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">取消操作</h1><p id="a94b" class="pw-post-body-paragraph iq ir hi is b it lh iv iw ix li iz ja jb lj jd je jf lk jh ji jj ll jl jm jn hb bi translated">正如我之前提到的，BlockOperation允许您管理操作。现在让我们看看如何取消操作。为此，首先在下载按钮下面添加另一个按钮，并将其标题设置为取消。为了显示取消操作，我们在操作#2和操作#1之间建立了相关性，并在操作#3和操作#2之间建立了另一个相关性。现在，操作#2将在操作#1完成后开始，对于其他相关性也是如此。现在，为了取消操作，您需要调用<em class="jo"> cancelAllOperations()。</em></p><pre class="ln lo lp lq fd lx ly lz ma aw mb bi"><span id="dbee" class="mc ke hi ly b fi md me l mf mg"><strong class="ly hj">@IBAction</strong> <strong class="ly hj">func</strong> cancelBtnPressed(<strong class="ly hj">_</strong> sender: <strong class="ly hj">Any</strong>) {</span><span id="408b" class="mc ke hi ly b fi mh me l mf mg"><strong class="ly hj">    self</strong>.queue.cancelAllOperations()</span><span id="3cee" class="mc ke hi ly b fi mh me l mf mg">}</span></pre><p id="fa3a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在添加依赖项，并更改操作#1的完成块，如下所示:</p><pre class="ln lo lp lq fd lx ly lz ma aw mb bi"><span id="8116" class="mc ke hi ly b fi md me l mf mg">operation2.addDependency(operation1)</span><span id="1c5e" class="mc ke hi ly b fi mh me l mf mg">operation3.addDependency(operation2)</span><span id="646a" class="mc ke hi ly b fi mh me l mf mg">operation1.completionBlock = {</span><span id="3a34" class="mc ke hi ly b fi mh me l mf mg">    print("Operation 1 completed, cancelled: \(operation1.isCancelled)")</span><span id="1036" class="mc ke hi ly b fi mh me l mf mg">}</span></pre><p id="f13b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，如果您运行该项目并查看结果，您会看到操作#1或#4将首先执行，在操作#1完成后，操作#2执行，在操作#2完成后，您将看到操作#3执行。</p><p id="3d64" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">点击下载按钮后，按取消按钮。这将在操作#1完成后取消所有操作。事情是这样的:</p><p id="fed9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">取消永远不会影响操作#1，但是如果您足够快地点击取消按钮，操作#2被取消并且图像#2不被下载，因此由于操作#2和#3之间的相关性，第三个图像也不被下载，但是操作#4没有任何相关性并且并发运行。</p></div><div class="ab cl mi mj gp mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="hb hc hd he hf"><p id="44f2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我希望您更好地理解了Swift中GCD和操作队列之间的区别，并能够在您未来的项目中使用和集成它们。</p><p id="f76b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你也可以在这个<a class="ae mp" href="https://github.com/shayan77/Concurrency" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj"> <em class="jo">并发库</em> </strong> </a>找到完整的源代码。</p></div></div>    
</body>
</html>