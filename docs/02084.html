<html>
<head>
<title>Choosing the AWS serverless stack for a prototype (Detecting Paris’ locked bicycle stations 1/5)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">选择AWS无服务器堆栈作为原型(检测巴黎1/5的锁定自行车站)</h1>
<blockquote>原文：<a href="https://medium.com/codex/detecting-locked-bicycle-stations-an-aws-serverless-story-part-1-95dcdb477649?source=collection_archive---------2-----------------------#2021-06-29">https://medium.com/codex/detecting-locked-bicycle-stations-an-aws-serverless-story-part-1-95dcdb477649?source=collection_archive---------2-----------------------#2021-06-29</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/b9157d962c19788f22633fdf605e17d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Vy9KxwnX7Z6hooQYkiQ-2w.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">照片由纪尧姆·邦唐/巴黎市拍摄</figcaption></figure><blockquote class="iu iv iw"><p id="655c" class="ix iy iz ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">这一系列文章是关于我在学习如何使用AWS无服务器堆栈的同时，花了太多时间试图解决一个小问题(检测巴黎上锁的自行车站)。要查找其他文章，请跳到页面底部。</p></blockquote></div><div class="ab cl jw jx gp jy" role="separator"><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb"/></div><div class="hb hc hd he hf"><h1 id="748c" class="kd ke hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated"><strong class="ak">锁定和死站</strong></h1><p id="62fd" class="pw-post-body-paragraph ix iy hi ja b jb lb jd je jf lc jh ji ld le jl jm lf lg jp jq lh li jt ju jv hb bi translated">巴黎，2020年5月，第一次封锁结束。我决定和我的一些朋友一起去野餐。因此，像许多巴黎人一样，我正前往位于城市东部边缘的巴黎最大的公园——文森公园。</p><p id="a582" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji ld jk jl jm lf jo jp jq lh js jt ju jv hb bi translated">天气非常适合短途骑自行车，我很快租了一辆Velib，这是许多公共自行车中的一辆，可以在遍布城市的1500个车站中的任何一个出租和归还。到达公园附近后，我查看官方应用程序，寻找最近的有空位归还自行车的车站。当我靠近时，似乎有些不对劲。我看到几个人，困惑，试图出租或归还自行车。我叹气。车站被锁住了。死了。</p><blockquote class="iu iv iw"><p id="4855" class="ix iy iz ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">Velib创建于2007年，很快被证明是成功的，成为世界上使用最多的自行车共享平台之一。2017年，在最初的10年合同结束后，该市选择了一家新的运营商来管理和开发该网络。我们只能说改变并不顺利。三年后，主要问题已经解决，但Velib用户仍然面临两个常见的障碍:损坏的自行车没有被移出车站(这些自行车的座位被有问题的自行车手归还，以友好地警告下一个用户)，以及更罕见的情况是，车站被“锁定”几个小时，官方应用程序或网站上没有通知。</p></blockquote><p id="6495" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji ld jk jl jm lf jo jp jq lh js jt ju jv hb bi translated">找到另一个电台后，我加入我的朋友，用冰啤酒洗去我的不幸。但是我不能停止想它。这不是我第一次因为一个电台不能用而不得不去找另一个电台了。为什么官方app没有显示该站为死站？突然停租停还自行车的站不是很容易察觉吗？有了正确的数据会有多难？</p><h1 id="e49b" class="kd ke hi bd kf kg lj ki kj kk lk km kn ko ll kq kr ks lm ku kv kw ln ky kz la bi translated"><strong class="ak">Velib API</strong></h1><p id="fe74" class="pw-post-body-paragraph ix iy hi ja b jb lb jd je jf lc jh ji ld le jl jm lf lg jp jq lh li jt ju jv hb bi translated">幸运的是，Velib公开了一个<a class="ae lo" href="https://www.velib-metropole.fr/donnees-open-data-gbfs-du-service-velib-metropole" rel="noopener ugc nofollow" target="_blank">公共API </a>。同样的数据也可以在Paris <a class="ae lo" href="https://opendata.paris.fr/pages/home/" rel="noopener ugc nofollow" target="_blank"> OpenData </a>项目中找到，该项目合并并公开了许多关于巴黎的公共数据(如果你曾经寻找巴黎200，000棵树中每一棵树的数据集，它就在那里<a class="ae lo" href="https://opendata.paris.fr/explore/dataset/les-arbres" rel="noopener ugc nofollow" target="_blank"/>！).</p><p id="52a2" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji ld jk jl jm lf jo jp jq lh js jt ju jv hb bi translated">该API非常简单，有两个主要端点:</p><ul class=""><li id="48c9" class="lp lq hi ja b jb jc jf jg ld lr lf ls lh lt jv lu lv lw lx bi translated"><strong class="ja hj"> /station_status.json </strong>，实时(每分钟刷新一次)返回每个站点的内容和状态。</li><li id="ff88" class="lp lq hi ja b jb ly jf lz ld ma lf mb lh mc jv lu lv lw lx bi translated"><strong class="ja hj">/station _ information . JSON</strong>，返回每个站点的地理坐标和名称。</li></ul><pre class="md me mf mg fd mh mi mj mk aw ml bi"><span id="2623" class="mm ke hi mi b fi mn mo l mp mq">//station_status.json simplified structure<br/>{<br/>  "data": {<br/>    "stations": [<br/>      {<br/>        "is_installed": 0,<br/>        "is_renting": 0,<br/>        "is_returning": 0,<br/>        "num_bikes_available_types": [<br/>          {<br/>            "ebike": 0,<br/>            "mechanical": 0<br/>          }<br/>        ],<br/>        "num_docks_available": 0,<br/>        "station_id": 0<br/>      }<br/>    ]<br/>  }<br/>}</span><span id="a7db" class="mm ke hi mi b fi mr mo l mp mq">//station_informations.json simplified structure<br/>{<br/>  "data": {<br/>    "stations": [<br/>      {<br/>        "lat": 0,<br/>        "lon": 0,<br/>        "name": "string",<br/>        "station_id": 0<br/>      }<br/>    ]<br/>  }<br/>}</span></pre><p id="8dfe" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji ld jk jl jm lf jo jp jq lh js jt ju jv hb bi translated">我本可以希望得到更多。例如，将返回给定站的过去活动的端点。或者可能是一个回调端点，它会在每次自行车被租赁或归还到车站时警告我。<br/>但这很好。如果有足够的时间，我可以通过持续轮询<em class="iz"> /station-status </em>端点并馈送某种数据库来收集每个站点每分钟的活动。通过了解每个车站过去的活动，我应该能够知道某个车站何时停止租赁或归还自行车太久，并将其标记为“锁定”。很简单，对吧？</p><p id="081c" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji ld jk jl jm lf jo jp jq lh js jt ju jv hb bi translated">很久以来，我一直想了解更多关于卡夫卡和事件驱动架构的知识。接收和处理<em class="iz"> /station-status </em>端点的每次更新似乎非常适合这项技术。所以，卡夫卡，会的。</p><h1 id="08f1" class="kd ke hi bd kf kg lj ki kj kk lk km kn ko ll kq kr ks lm ku kv kw ln ky kz la bi translated">一次一个事件</h1><p id="c632" class="pw-post-body-paragraph ix iy hi ja b jb lb jd je jf lc jh ji ld le jl jm lf lg jp jq lh li jt ju jv hb bi translated">首先，快速复习一下卡夫卡。</p><blockquote class="iu iv iw"><p id="a3ca" class="ix iy iz ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">Kafka是一个可扩展的持久事件日志系统，最初是在LinkedIn上开发的，后来被开源了。它的一些最初的开发者离开LinkedIn创建了<a class="ae lo" href="https://www.confluent.io/" rel="noopener ugc nofollow" target="_blank"> Confluent </a>，一家致力于改善Kafka生态系统的公司。</p></blockquote><p id="bdaf" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji ld jk jl jm lf jo jp jq lh js jt ju jv hb bi translated">你可以通过两种方式与卡夫卡互动。作为发送要附加到日志(“主题”)的新事件的“生产者”。或者作为“消费者”,从主题接收事件。与消息队列相反，事件不会同步发送给使用者。它们存储在日志中，现在或以后都可以使用。卡夫卡跟踪每个消费者收到的最后一个事件，允许他们在自己的时间以自己的速度消费这些事件。如果使用者未能处理事件，事件本身不会丢失，并且可以重试。</p><figure class="md me mf mg fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ms"><img src="../Images/1a1c608d70fc8c6d59a40e10019e2250.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*uYY1QvPpgNcQD7N1ork8-w.gif"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">多重消费者的卡夫卡主题</figcaption></figure><p id="087f" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji ld jk jl jm lf jo jp jq lh js jt ju jv hb bi translated">这只有一个主题。但是没有什么能阻止消费者成为另一个话题的生产者。这样，您就可以构建一个对单一源事件做出反应的应用程序，以级联方式触发不同的服务。在卡夫卡的世界里，这种由主题、消费者和生产者组成的网络被称为拓扑。</p><figure class="md me mf mg fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mt"><img src="../Images/a61632a1f8ed2ee02341020ced41a6cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Y3NuOe5WshNlPwPMbwuRWQ.gif"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">虚构的卡夫卡拓扑:Youtube的视频导入过程</figcaption></figure><p id="2e34" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji ld jk jl jm lf jo jp jq lh js jt ju jv hb bi translated">这些服务中的每一个都是独立的。它们可以用不同的语言编写。它们可以是“实时”、重复批次或一次性导出。它们可以自行扩展。</p><p id="d856" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji ld jk jl jm lf jo jp jq lh js jt ju jv hb bi translated">尽管如此，所有这些服务都需要与Kafka交互，并且经常做类似的事情:按照给定的属性对事件进行分组，丢弃其中一些事件，…</p><p id="43c2" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji ld jk jl jm lf jo jp jq lh js jt ju jv hb bi translated">因此，发现专门用来处理这些常见任务的工具就不足为奇了。它们从轻量级库如<a class="ae lo" href="https://faust.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank"> Faust </a> (python)或<a class="ae lo" href="https://kafka.apache.org/documentation/streams/" rel="noopener ugc nofollow" target="_blank"> Kafka Streams </a> (java)到全平台如<a class="ae lo" href="https://flink.apache.org/" rel="noopener ugc nofollow" target="_blank"> Flink </a>。由于我对Java有一些经验，我会选择Kafka流。</p><blockquote class="iu iv iw"><p id="7473" class="ix iy iz ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">事件驱动架构不仅仅是卡夫卡的事情。其他工具可以和卡夫卡一起使用，甚至混合使用。例如，Flink支持各种事件源和接收器。</p></blockquote><h1 id="7b3b" class="kd ke hi bd kf kg lj ki kj kk lk km kn ko ll kq kr ks lm ku kv kw ln ky kz la bi translated">卡夫卡的代价</h1><p id="7c0d" class="pw-post-body-paragraph ix iy hi ja b jb lb jd je jf lc jh ji ld le jl jm lf lg jp jq lh li jt ju jv hb bi translated">有了这些新知识，我就可以开始构建一个<a class="ae lo" href="https://github.com/ouvreboite/velinfo_kafka_prototype" rel="noopener ugc nofollow" target="_blank">小应用</a>了，它能够接收Velib API数据并对其进行处理，以检测(非常不精确地)锁定的站点。</p><figure class="md me mf mg fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mu"><img src="../Images/786efa6a7d0b474f8d2f2bfc7d92d911.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TOBUeN_HPwnOAjJqGHhgZA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">基于卡夫卡的原型建筑</figcaption></figure><p id="5c64" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji ld jk jl jm lf jo jp jq lh js jt ju jv hb bi translated">几个星期后，这个应用程序迅速成长为一个相当大的Kafka+KafkaStream+PostgreSQL+spring boot+百里香叶的烂摊子。从单个Docker合成文件创建的整个基础设施使开发变得容易。</p><p id="38ac" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji ld jk jl jm lf jo jp jq lh js jt ju jv hb bi translated">为了更加符合Kafka的“事件日志”哲学，它首先将/station-status有效载荷转换为逐站增量更新。这基本上允许我设计应用程序的其余部分，就好像我可以订阅一个Velib端点，它会在每次自行车被租赁或归还到特定的站点时警告我。在此基础上，它计算每个工作站每小时的使用统计数据，并输入一个SQL数据库，该数据库本身用于锁定工作站检测。它还试图检测个别损坏的自行车，但没有太大的成功。</p><figure class="md me mf mg fd ij er es paragraph-image"><div class="er es mv"><img src="../Images/bc96937ecad02e5c010ed326b0af338e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1116/format:webp/1*lxCV2nXTsRYwERrB6ldejw.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">简化的卡夫卡拓扑</figcaption></figure><p id="4962" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji ld jk jl jm lf jo jp jq lh js jt ju jv hb bi translated">由此产生的Kafka拓扑非常简单(Kafka Stream创建额外的隐藏主题来维护其内部状态)。总的来说，使用的主题略多于10个。它“有效”。但是每次我关掉我的电脑或应用程序本身，我都会在我的每小时统计数据库中创建间隙。是时候部署到生产环境中了。</p><p id="47b1" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji ld jk jl jm lf jo jp jq lh js jt ju jv hb bi translated">这应该很简单，因为我只需要一个小型Kafka集群，包含大约10个主题和最少的复制，一个小型SQL实例和一两个服务器来运行其余的。由于更多地了解AWS也在我2020年的愿望清单上，我将尝试只利用AWS服务。</p><p id="1929" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji ld jk jl jm lf jo jp jq lh js jt ju jv hb bi translated">先说卡夫卡集群。有什么样的课程？</p><ul class=""><li id="2ee6" class="lp lq hi ja b jb jc jf jg ld lr lf ls lh lt jv lu lv lw lx bi translated"><strong class="ja hj">完全托管</strong>:我可以使用<a class="ae lo" href="https://aws.amazon.com/msk/" rel="noopener ugc nofollow" target="_blank"> AWS MSK </a>。最小的实例(Kafka.t3.small)每小时的成本为0.0456美元。我需要全职运营它，所以这意味着…每年400美元</li><li id="44ec" class="lp lq hi ja b jb ly jf lz ld ma lf mb lh mc jv lu lv lw lx bi translated"><strong class="ja hj">自我管理</strong>:我可以使用一个大约2GB内存的<a class="ae lo" href="https://aws.amazon.com/ec2/" rel="noopener ugc nofollow" target="_blank"> AWS EC2 </a>实例，并在上面安装Zookeeper和Kafka。t2.small每小时0.023美元，每年200美元。</li><li id="e345" class="lp lq hi ja b jb ly jf lz ld ma lf mb lh mc jv lu lv lw lx bi translated"><strong class="ja hj">容器</strong>:我也可以利用Docker并使用一个类似的EC2实例作为<a class="ae lo" href="https://aws.amazon.com/ecs" rel="noopener ugc nofollow" target="_blank"> AWS ECS </a>的一部分。这将简化设置，但仍然是每年200美元。</li><li id="1a7f" class="lp lq hi ja b jb ly jf lz ld ma lf mb lh mc jv lu lv lw lx bi translated"><a class="ae lo" href="https://aws.amazon.com/kinesis/" rel="noopener ugc nofollow" target="_blank"> <strong class="ja hj"> AWS Kinesis </strong> </a>:和卡夫卡很像，完全管理，看起来便宜很多。但它与Kafka Stream不兼容，这将意味着重写应用程序的很大一部分，并选择新的流框架。</li><li id="8d75" class="lp lq hi ja b jb ly jf lz ld ma lf mb lh mc jv lu lv lw lx bi translated"><strong class="ja hj">树莓派</strong>？我已经有一个树莓派了。我当然可以在上面安装我的Kafka集群，在我的家庭网关上打开正确的端口，并在AWS上托管应用程序的其余部分。我还需要向计算机之神祈祷，当我不在家修理它的时候，不要发生任何不好的事情。</li></ul><p id="933f" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji ld jk jl jm lf jo jp jq lh js jt ju jv hb bi translated">看起来我可以选择花费比我预期的更多的钱(这只是为了Kafka集群)或者大规模修改我的应用程序。也许真正的问题不是卡夫卡的成本。也许是因为我在选择我的架构时应该考虑到我的限制。</p><h1 id="9376" class="kd ke hi bd kf kg lj ki kj kk lk km kn ko ll kq kr ks lm ku kv kw ln ky kz la bi translated"><strong class="ak">回到绘图板</strong></h1><figure class="md me mf mg fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mw"><img src="../Images/7bad44c9c3861e6aa08096a8a19445e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*tLm03ilAB4h2E5dq"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">Diana Polekhina 在<a class="ae lo" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="3cd1" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji ld jk jl jm lf jo jp jq lh js jt ju jv hb bi translated">我对这个项目有什么期望？结果应该是什么样的？</p><ul class=""><li id="c10d" class="lp lq hi ja b jb jc jf jg ld lr lf ls lh lt jv lu lv lw lx bi translated">它应该在AWS上“生产”运行。</li><li id="2050" class="lp lq hi ja b jb ly jf lz ld ma lf mb lh mc jv lu lv lw lx bi translated">Velib全天候工作，我的应用程序也应该如此。</li><li id="154c" class="lp lq hi ja b jb ly jf lz ld ma lf mb lh mc jv lu lv lw lx bi translated">如果我的月用户少于100，我想每年花200€ max。</li><li id="e8e9" class="lp lq hi ja b jb ly jf lz ld ma lf mb lh mc jv lu lv lw lx bi translated">日常运作应该是最少的。</li><li id="258b" class="lp lq hi ja b jb ly jf lz ld ma lf mb lh mc jv lu lv lw lx bi translated">用户界面看起来应该没问题。</li></ul><p id="4a53" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji ld jk jl jm lf jo jp jq lh js jt ju jv hb bi translated">为了减轻我的负担，我还会定义我对这个项目的期望值。</p><ul class=""><li id="f5ef" class="lp lq hi ja b jb jc jf jg ld lr lf ls lh lt jv lu lv lw lx bi translated">卡夫卡不是强制性的。在这一点上，我觉得我已经了解了很多，宁愿专注于传递一些东西。</li><li id="f76b" class="lp lq hi ja b jb ly jf lz ld ma lf mb lh mc jv lu lv lw lx bi translated">锁定站检测不需要精确。我甚至不知道Velib API的数据是否准确。</li><li id="ff06" class="lp lq hi ja b jb ly jf lz ld ma lf mb lh mc jv lu lv lw lx bi translated">我不关心代码的质量。我对架构更感兴趣，并对AWS有更多的了解。</li><li id="00cf" class="lp lq hi ja b jb ly jf lz ld ma lf mb lh mc jv lu lv lw lx bi translated">用户界面将只有法语，因为Velib只在巴黎运行。</li><li id="c727" class="lp lq hi ja b jb ly jf lz ld ma lf mb lh mc jv lu lv lw lx bi translated">前端没什么特别的。我已经很熟悉Angular了，这样就够了。</li></ul><p id="e518" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji ld jk jl jm lf jo jp jq lh js jt ju jv hb bi translated">如果我对Kafka的小实验教会了我一件事，如果我想保持在我的预算内，我需要更好地了解AWS产品及其定价。所以我要花点时间去了解一下。</p><h1 id="cff9" class="kd ke hi bd kf kg lj ki kj kk lk km kn ko ll kq kr ks lm ku kv kw ln ky kz la bi translated">λ函数</h1><p id="3033" class="pw-post-body-paragraph ix iy hi ja b jb lb jd je jf lc jh ji ld le jl jm lf lg jp jq lh li jt ju jv hb bi translated">AWS是个大话题。每年都会增加新的服务，在试图了解这些服务时很容易迷失方向。为了帮助我专注于应用程序开发中最重要的服务，我决定通过<a class="ae lo" href="https://aws.amazon.com/certification/certified-developer-associate/" rel="noopener ugc nofollow" target="_blank"> AWS认证开发者助理</a>认证。这花了我几个月的时间，但是我对使用AWS能做什么和花费多少更有信心了。它让我发现了AWS的无服务器产品。</p><blockquote class="iu iv iw"><p id="1761" class="ix iy iz ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">脑海中已经有了一个副业项目，这有助于提取我一路上学到的大部分东西。所以如果你想通过这个认证，我只能建议你已经有了某种你想“移植”到AWS的项目</p></blockquote><p id="9444" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji ld jk jl jm lf jo jp jq lh js jt ju jv hb bi translated">那么这个无服务器的东西是什么呢？某个地方肯定有一些服务器，对吧？</p><p id="6520" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji ld jk jl jm lf jo jp jq lh js jt ju jv hb bi translated">假设您想要创建某种简单的web API。一个端点，GET <em class="iz"> /something </em>，使用NodeJs/Express用JavaScript编码。</p><figure class="md me mf mg fd ij er es paragraph-image"><div class="er es mx"><img src="../Images/8dfb6d257ddb910c284ed9ef57168b6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:876/1*3zL9nOVcb9actL_aHZtZqg.gif"/></div></figure><p id="a691" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji ld jk jl jm lf jo jp jq lh js jt ju jv hb bi translated"><strong class="ja hj">自管理:</strong>你租用一个“服务器”，例如，来自AWS的EC2实例。这个实例位于AWS内部的私有网络中(您的<a class="ae lo" href="https://aws.amazon.com/vpc/" rel="noopener ugc nofollow" target="_blank"> VPC </a>或“虚拟私有云”)。在这种情况下，你可以随意安装任何你想要的东西。例如NodeJs。然后您上传您的应用程序源代码/包/编译的工件，它将使用您安装的运行时运行。</p><p id="33d0" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji ld jk jl jm lf jo jp jq lh js jt ju jv hb bi translated">如果您想扩展您的应用程序，您可以租用几个EC2实例，并使用一个负载平衡器将传入的请求分派给它们。您需要类似地设置它们中的每一个。</p><figure class="md me mf mg fd ij er es paragraph-image"><div class="er es my"><img src="../Images/54f521935e4e90bfaf525d7dd40ae3ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:880/1*n6m6YY3hHtJ-miYMe8yAvw.gif"/></div></figure><p id="0e2e" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji ld jk jl jm lf jo jp jq lh js jt ju jv hb bi translated"><strong class="ja hj">容器平台:</strong>为了使伸缩更容易，简化新实例的创建，可以使用容器。要么通过在每个EC2实例上手动安装容器服务，要么通过使用ECS之类的容器平台。这个平台将为您管理EC2实例的供应。您只需要提供容器并指定要运行的实例数量。</p><p id="8026" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji ld jk jl jm lf jo jp jq lh js jt ju jv hb bi translated">但是，最终，您仍然拥有这些实例，它们是您的EC2机群的一部分，您可以手动连接到它们。</p><p id="7f53" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji ld jk jl jm lf jo jp jq lh js jt ju jv hb bi translated"><strong class="ja hj">关于自动缩放组的快速说明:</strong>使用自动缩放组，可以手动或自动设置您使用的实例数量。您将创建一个规则，定义实例的数量应该如何变化以及在什么范围内变化。CPU或内存的使用经常被用来触发这种扩展。这种规则可以是:</p><blockquote class="iu iv iw"><p id="cc6f" class="ix iy iz ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">“如果我的实例的CPU &gt; 80%,则将实例数量增加到10个。如果我的实例的CPU &lt; 30%，则将实例数量减少到1”。</p></blockquote><p id="5a0d" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji ld jk jl jm lf jo jp jq lh js jt ju jv hb bi translated">关键的一点是，你总是需要至少一个实例。</p><figure class="md me mf mg fd ij er es paragraph-image"><div class="er es mz"><img src="../Images/c003f560968bb7892edc48ac523c74c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:838/1*OemqkRM_w6X0N0oqbLJDyA.gif"/></div></figure><p id="c1e0" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji ld jk jl jm lf jo jp jq lh js jt ju jv hb bi translated"><strong class="ja hj"> Lambda </strong> : AWS Lambda是一个无服务器的计算平台。您不必编写一个完整的应用程序，而是将它分成更小的“功能”，每个功能都可以独立调用。</p><p id="63dd" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji ld jk jl jm lf jo jp jq lh js jt ju jv hb bi translated">每个函数都可以看作是一个小脚本，运行几秒或几分钟，执行一个特定的任务。例如，你可以有一个函数负责回答得到<em class="iz">/什么</em>。</p><p id="de7d" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji ld jk jl jm lf jo jp jq lh js jt ju jv hb bi translated">当一个Lambda被触发时，一个可用的服务器实例被从一个全局池中取出。您的源代码被部署到它上面并运行。然后您的代码被删除，实例被释放。</p><p id="da45" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji ld jk jl jm lf jo jp jq lh js jt ju jv hb bi translated">一个非常简单的Lambda函数代码可能是这样的:</p><pre class="md me mf mg fd mh mi mj mk aw ml bi"><span id="8394" class="mm ke hi mi b fi mn mo l mp mq">//a basic javascript lambda performing a REST call<br/>const https = require('https')<br/>let url = "<a class="ae lo" href="https://docs.aws.amazon.com/lambda/latest/dg/welcome.html" rel="noopener ugc nofollow" target="_blank">https://e</a>xample.com"</span><span id="8ad3" class="mm ke hi mi b fi mr mo l mp mq">exports.handler = async function(event) {<br/>  const promise = new Promise(function(resolve, reject) {<br/>    https.get(url, (res) =&gt; {<br/>        resolve(res.statusCode)<br/>      }).on('error', (e) =&gt; {<br/>        reject(Error(e))<br/>      })<br/>    })<br/>  return promise<br/>}</span></pre><p id="04a0" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji ld jk jl jm lf jo jp jq lh js jt ju jv hb bi translated">所以你的函数仍然在服务器上运行。但你不知道是哪一个，也不在乎。</p><p id="c8bf" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji ld jk jl jm lf jo jp jq lh js jt ju jv hb bi translated"><strong class="ja hj">成本呢？</strong></p><p id="ef94" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji ld jk jl jm lf jo jp jq lh js jt ju jv hb bi translated">对于<em class="iz">自管理的</em>和<em class="iz">容器平台</em>，这很简单:每个实例类型作为一个小时的成本。对于Lambdas来说，情况稍微复杂一点:对于一个基本的Lambda，每次调用的成本是每毫秒执行时间0.00000002美元(每百万0.20美元)+ $0.0000000021美元，最大的一次调用高达每毫秒0.0000001667美元。关于Lambda性能的更多信息，请参阅后续文章。</p><figure class="md me mf mg fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es na"><img src="../Images/9a35403488b7bfd106c250eb3b74d0cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kZxlMPHN-hshl6XaDeNIzQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">最小EC2实例和最小Lambda实例之间的成本比较</figcaption></figure><p id="dc1c" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji ld jk jl jm lf jo jp jq lh js jt ju jv hb bi translated">最大的好处是，不用的Lambda是免费的。因此，对于我的项目来说，观众非常有限，高峰使用时间大约在上午8点和下午5点，使用Lambdas而不是让EC2实例大部分时间无所事事是有意义的。</p><h1 id="5a7c" class="kd ke hi bd kf kg lj ki kj kk lk km kn ko ll kq kr ks lm ku kv kw ln ky kz la bi translated">无服务器产品</h1><p id="7cae" class="pw-post-body-paragraph ix iy hi ja b jb lb jd je jf lc jh ji ld le jl jm lf lg jp jq lh li jt ju jv hb bi translated">同样的原理不仅适用于计算:</p><ul class=""><li id="faa6" class="lp lq hi ja b jb jc jf jg ld lr lf ls lh lt jv lu lv lw lx bi translated">一个数据库？DynamoDb(您为创建/读取的项目数量付费)</li><li id="779a" class="lp lq hi ja b jb ly jf lz ld ma lf mb lh mc jv lu lv lw lx bi translated">文件服务器？S3(你为创建/读取的文件数量付费)</li><li id="3959" class="lp lq hi ja b jb ly jf lz ld ma lf mb lh mc jv lu lv lw lx bi translated">负载均衡器/路由器？API网关(您为被路由的请求数量付费)</li></ul><figure class="md me mf mg fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nb"><img src="../Images/587cffe4c1f6ad4159e99dc74e753201.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CXQjK4Uoyu7R-z2uu5bqVA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">当前的AWS无服务器产品</figcaption></figure><p id="878a" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji ld jk jl jm lf jo jp jq lh js jt ju jv hb bi translated">所有这些服务仍然依赖于服务器，但这些服务器是从客户机中抽象出来的，价格是根据使用情况而不是基础设施来确定的。</p><p id="6ffc" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji ld jk jl jm lf jo jp jq lh js jt ju jv hb bi translated">它们可以与经典应用程序一起使用。但是您也可以只使用无服务器服务来设计复杂的应用程序。让所有东西粘在一起的是λ函数。或者更确切地说，是什么触发了这些功能。</p><p id="a89d" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji ld jk jl jm lf jo jp jq lh js jt ju jv hb bi translated">休息电话？一份文件被推送到S3？SQS发来的新消息？卡夫卡主题中的新事件？几乎任何AWS服务都可以触发Lambda函数。AWS为更复杂的用例提供了事件管理器(如EventBridge)和调度器(如Step函数)。</p><p id="157e" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji ld jk jl jm lf jo jp jq lh js jt ju jv hb bi translated">有些触发器非常简单(“一发不可收拾”)，但有些可能更复杂。例如，DynamoDb(一个无服务器的文档数据库)可以将事件(对象插入/更新/删除)发布为一个“流”,它本身可以触发一个函数。订阅Dynamo流的每个函数都有自己的事件队列，可以按照自己的节奏处理这些事件。如果lambda调用失败，事件将被保留以允许重试。听起来有点像卡夫卡，不是吗？</p><p id="e115" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji ld jk jl jm lf jo jp jq lh js jt ju jv hb bi translated">因此，结合DynamoDb和Lambda，我可以重新创建与我的第一个卡夫卡原型相同的“拓扑”。</p><blockquote class="iu iv iw"><p id="0f27" class="ix iy iz ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">旁注。AWS真正的“无服务器”卡夫卡是Kinesis。但是，在2020年，DynamoDb只支持在DynamoDb流中发布事件。2021年增加了DynamoDb对Kinesis发布的支持。</p></blockquote><p id="8674" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji ld jk jl jm lf jo jp jq lh js jt ju jv hb bi translated">让我们回到成本上。在关于Kafka集群成本的最初讨论中，我没有提到的一件事是<a class="ae lo" href="https://aws.amazon.com/free" rel="noopener ugc nofollow" target="_blank"> AWS免费层</a>。</p><p id="66b4" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji ld jk jl jm lf jo jp jq lh js jt ju jv hb bi translated">为了吸引新客户，AWS在一些服务上提供免费服务。例如，您可以“免费”拥有一个小型EC2实例，但仅限于第一年。幸运的是，Lambda和DynamoDb的报价非常慷慨，最重要的是，它们不会过期。</p><figure class="md me mf mg fd ij er es paragraph-image"><div class="er es nc"><img src="../Images/049187976658148271ad11fe55010e61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1012/format:webp/1*jFyJUx25edUZZ0uMODYbUg.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">发电机和Lambda的AWS自由层</figcaption></figure><p id="5bdd" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji ld jk jl jm lf jo jp jq lh js jt ju jv hb bi translated">所以计划很简单:重新架构我的应用程序，以利用AWS无服务器服务(主要是Lambda和DynamoDb ),同时保持在自由层的约束范围内。</p><p id="9fc0" class="pw-post-body-paragraph ix iy hi ja b jb jc jd je jf jg jh ji ld jk jl jm lf jo jp jq lh js jt ju jv hb bi translated">《T2》第二部再见。</p><figure class="md me mf mg fd ij er es paragraph-image"><div class="er es nd"><img src="../Images/72cedb04646a2893131b10a3ed16c1e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:700/0*eVTuOt5mGhzMcNmQ"/></div></figure></div><div class="ab cl jw jx gp jy" role="separator"><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb"/></div><div class="hb hc hd he hf"><ul class=""><li id="8593" class="lp lq hi ja b jb jc jf jg ld lr lf ls lh lt jv lu lv lw lx bi translated"><a class="ae lo" rel="noopener" href="/codex/detecting-locked-bicycle-stations-an-aws-serverless-story-part-1-95dcdb477649">第1部分</a>:为原型选择AWS无服务器堆栈</li><li id="19fa" class="lp lq hi ja b jb ly jf lz ld ma lf mb lh mc jv lu lv lw lx bi translated">第2部分:无服务器应用的主干:Lambda函数和DynamoDb表</li><li id="2e16" class="lp lq hi ja b jb ly jf lz ld ma lf mb lh mc jv lu lv lw lx bi translated"><a class="ae lo" rel="noopener" href="/codex/detecting-locked-bicycle-stations-an-aws-serverless-story-part-3-d532318dfca7">第3部分</a>:用Lambda函数和DynamoDb流实现实时检测算法</li><li id="b36a" class="lp lq hi ja b jb ly jf lz ld ma lf mb lh mc jv lu lv lw lx bi translated"><a class="ae lo" href="https://ouvreboite.medium.com/creating-a-serverless-api-and-hosting-a-frontend-with-s3-b50e61a8f707" rel="noopener">第4部分</a>:创建一个无服务器的API，用S3托管一个前端</li><li id="9fd0" class="lp lq hi ja b jb ly jf lz ld ma lf mb lh mc jv lu lv lw lx bi translated"><a class="ae lo" rel="noopener" href="/codex/performance-tuning-for-an-aws-lambda-based-api-b8b49b2d07db">第5部分</a>:基于Lambda的API的性能调优</li></ul></div></div>    
</body>
</html>