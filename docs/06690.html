<html>
<head>
<title>Generics in Kotlin (Part 2)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kotlin中的泛型(第2部分)</h1>
<blockquote>原文：<a href="https://medium.com/codex/generics-in-kotlin-part-2-6e87f9b2e8ac?source=collection_archive---------9-----------------------#2022-05-07">https://medium.com/codex/generics-in-kotlin-part-2-6e87f9b2e8ac?source=collection_archive---------9-----------------------#2022-05-07</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/e2d1b707b903ce60f5463e4e8da60b42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZK4a1vzyc7Jj1PC6Ii8B-Q.jpeg"/></div></div></figure><p id="1f3f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">欢迎阅读泛型系列的第2部分。</p><p id="c7ea" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果您是第一次学习泛型，这里是本系列的第1部分，包含Java示例:</p><p id="ce50" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><a class="ae jo" rel="noopener" href="/@nehalCodes/generics-in-java-part-1-e6a2d74745cd">https://medium . com/@ nehalCodes/generics-in-Java-part-1-e6a2d 74745 CD</a></p><p id="cf4a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这篇文章中，我想回顾一下Kotlin中的泛型，并强调一下它与Java的区别。如前所述，学习这些的最好方法是在您的首选IDE中尝试这些示例:)</p><p id="0b83" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Kotlin有多个像in-out这样的关键字&amp;像<em class="jp">use-site-variance&amp;declaration-site-variance</em>这样的概念。通过这些详细的分步主题，我想确保我们绝对清楚地理解了这两个主要概念。我个人认为，一旦你完全理解了Java中的泛型，在Kotlin中映射一切就容易多了。</p><h1 id="9533" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">进出</h1><p id="94f3" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">我知道这是一个奇怪的标题，大多数帖子更喜欢像<em class="jp">声明-网站-差异等</em>这样的标题。然而，我更喜欢以非常简单的方式解释这些概念，我们可以将这些概念映射到标准术语中！</p><h2 id="143c" class="kt jr hi bd js ku kv kw jw kx ky kz ka jb la lb ke jf lc ld ki jj le lf km lg bi translated">与Java的相似之处</h2><p id="c721" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">我们已经看到了Extends &amp; Super如何与通配符一起使用来增加API的灵活性。如果您不熟悉，请查看本系列的第1部分。</p><p id="6341" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Kotlin简化了这个签名，并引入了一些强大的选项来使它不那么冗长。</p><p id="d1c3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们用一个类似的例子来尝试一下:</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="87dc" class="kt jr hi lm b fi lq lr l ls lt"><strong class="lm hj">class </strong>CustomStackK&lt;E&gt; {<br/><br/>    <strong class="lm hj">var stack </strong>= Stack&lt;E&gt;()<br/><br/>    <strong class="lm hj">fun </strong>pushAll(source: MutableList&lt;<strong class="lm hj">out </strong>E&gt;) {<br/>        <strong class="lm hj">while </strong>(source.iterator().hasNext()) {<br/>            <strong class="lm hj">stack</strong>.push(source.iterator().next())<br/>        }<br/>    }<br/><br/>    <strong class="lm hj">fun </strong>pop(destination: MutableCollection&lt;<strong class="lm hj">in </strong>E&gt;) {<br/>        destination.add(<strong class="lm hj">stack</strong>.pop())<br/>    }<br/>}</span></pre><p id="a131" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如你所见，用非常简单的术语来说，in &amp; out对应于Java中的super &amp; extends。所以你可以写List &lt; <strong class="is hj"> out </strong> E &gt;而不是写List  <strong class="is hj"> extends </strong> E &gt;。正如你可以清楚地看到它更容易记住了:)</p><p id="f6eb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Producer-extends Consumer-Super可以很容易地用相关的词<strong class="is hj">Out(Producer)&amp;In(Consumer)</strong>映射。</p><p id="0642" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我快速指出一些你可以从Kotlin免费得到的东西。我鼓励您打出这个示例代码，然后将pushAll函数改为使用列表而不是可变列表。因为List在Kotlin中是不可变的类型，所以也不需要指定out关键字！</p><p id="19d1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">编译器知道你只能从这个集合中提取项目:)</strong></p><p id="d9fb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">用Kotlin的术语来说，这个代码类型指的是<strong class="is hj"><em class="jp">use-site variance</em></strong>，这仅仅意味着当我们声明CustomStackK &lt; E &gt;时，这些注释(in &amp; out)不被使用，只有当这个类型实际上与一些逻辑一起使用时才被使用。</p><p id="5d44" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Kotlin的官方博客也这样写道:</p><p id="031c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">这是我们对<em class="jp">使用地点差异</em>的处理方式，它对应于Java的</strong> <code class="du lu lv lw lm b"><strong class="is hj">Array&lt;? extends Object&gt;</strong></code> <strong class="is hj">，只是稍微简单一些。</strong></p><p id="1c91" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">注意:如果你从一个Java类中调用pushAll，你可以为source/destination传递空值，因为这是允许的。在Kotlin中，这是不允许的，除非你把它指定为一个可空的参数。</p><h2 id="8553" class="kt jr hi bd js ku kv kw jw kx ky kz ka jb la lb ke jf lc ld ki jj le lf km lg bi translated">Kotlin增加了支持(声明-站点差异)</h2><p id="c6e6" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">让我们来看另一个样例代码，来回顾一下Kotlin中新引入的概念。Java没有这样的支持，而且非常方便！</p><p id="bd05" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">看看这个界面及其用法:</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="2b34" class="kt jr hi lm b fi lq lr l ls lt"><strong class="lm hj">interface </strong>CustomSource&lt;E&gt; {<br/><br/>   <strong class="lm hj">fun </strong>nextT(): E<br/><br/>}</span></pre><p id="3d76" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">用法:</p><figure class="lh li lj lk fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lx"><img src="../Images/e472d23bd80f75198dba028cff5197f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VRnTWucfisKCLvoCDilEEw.png"/></div></div></figure><p id="c462" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">基于泛型是如何工作的，我们不能真的将一个定制源<double>或定制源<int>分配给定制源<number>，即使它是绝对安全的。第三行在所有情况下都无效，只是为了额外理解而添加的。</number></int></double></p><p id="2a31" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这种情况下，由于这个接口只有生产者方法，我们实际上可以从这个接口使用的任何方法都只能充当生产者(理解这一点非常重要)。</p><p id="f003" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们看看如何支持Kotlin:</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="d812" class="kt jr hi lm b fi lq lr l ls lt"><strong class="lm hj">interface </strong>CustomSource&lt;<strong class="lm hj">out </strong>E&gt; {<br/><br/>   <strong class="lm hj">fun </strong>nextE(): E<br/><br/>}</span></pre><p id="0ea3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">用法:</p><figure class="lh li lj lk fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ly"><img src="../Images/1b212757c4bdf922c584fd8f833db25a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xH1PWKqj8qo7fpWtBe_Y0w.png"/></div></div></figure><p id="5164" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">第二行现在有效。让我们了解如何:</p><p id="ff00" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">out关键字现在已经用在了我们声明接口/类的地方<strong class="is hj">。这就是<strong class="is hj"> <em class="jp">申报-现场差异</em> </strong>的意思。我们被允许这样做(在声明中添加)，因为<strong class="is hj">我们在这个接口</strong>中只有生产者方法。如果您尝试这段代码并添加其他将类型E作为消费者的方法，编译器会立即阻止您。对于只有消费者方法的类/接口，</strong>中的<strong class="is hj">也有类似的选项。</strong></p><p id="195c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">此选项在Java中不可用。坦率地说，它非常方便。在Java中，我们唯一的选择是在一个方法中再次将类型声明为CustomSource  extends E&gt;接受这些类型来表示生产者/消费者，正如Java博客中所解释的那样，这很冗长，需要您创建额外的方法来处理这些检查。</p><p id="8201" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在下一篇文章中，我们将详细讨论星体投射，以及更多的概念和例子。</p><p id="31f3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">希望这些帖子能够澄清Java &amp; Kotlin中关于泛型的大部分概念。敬请期待！</p><p id="430d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">本系列第1部分:<a class="ae jo" rel="noopener" href="/codex/generics-in-java-part-1-e6a2d74745cd">https://medium . com/codex/generics-in-Java-part-1-e6a2d 74745 CD</a></p><p id="9f1a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">本系列第3部分:<a class="ae jo" rel="noopener" href="/codex/generics-in-kotlin-part-3-1efde0bf0167">https://medium . com/codex/generics-in-kotlin-part-3-1 efde 0 BF 0167</a></p></div></div>    
</body>
</html>