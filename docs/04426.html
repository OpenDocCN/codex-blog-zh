<html>
<head>
<title>Angular NgRx Data custom selectors</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">角度NgRx数据自定义选择器</h1>
<blockquote>原文：<a href="https://medium.com/codex/angular-ngrx-data-custom-selectors-664f04f1637d?source=collection_archive---------3-----------------------#2021-11-30">https://medium.com/codex/angular-ngrx-data-custom-selectors-664f04f1637d?source=collection_archive---------3-----------------------#2021-11-30</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/6b048864903c90cb62a1b7b145fea6c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9VDJHyHzE2v29cAE5uAaYw.png"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">角度NgRx数据</figcaption></figure><div class=""/><p id="7291" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如何扩展NgRx数据，只选择我们需要的数据。</p><blockquote class="js jt ju"><p id="4102" class="iu iv jv iw b ix iy iz ja jb jc jd je jw jg jh ji jx jk jl jm jy jo jp jq jr hb bi translated">本文假设您已经安装了一个带有NgRx和NgRx数据的Angular项目。</p></blockquote><p id="c579" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在之前的文章中，我展示了通过NgRx数据请求一个符合约定的标准CRUD后端是多么容易。</p><p id="682b" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这是一个伟大的工具，但有时我们有一个简单的需求，来自它提供的简单途径。</p><h1 id="ccb4" class="ka kb hx bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">显示过滤的数据</h1><p id="4674" class="pw-post-body-paragraph iu iv hx iw b ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn lc jp jq jr hb bi translated">假设我们有自己的Todo应用程序。我们在DTO中处理一个布尔型的“活动”字段。我想知道我的实体中有多少是“活动的”。有一个工具可以做到这一点:过滤器。这是<a class="ae jz" href="https://ngrx.io/guide/data/entity-metadata" rel="noopener ugc nofollow" target="_blank">实体元数据</a>的一个属性。你只需要指定如何过滤你的列表，然后从你的服务中消费可观察的:<strong class="iw hy"> filteredEntities$ </strong>。</p><figure class="le lf lg lh fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es ld"><img src="../Images/891661d437286e1633bb4ef802241581.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YhcCSqCMcFg-hN78eKENVg.png"/></div></div></figure><p id="f4e0" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">你如何设置这个过滤器？只需在EntityMetadata中声明过滤器Fn:</p><figure class="le lf lg lh fd hk"><div class="bz dy l di"><div class="li lj l"/></div></figure><p id="db4e" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在组件中，需要时就需要设置过滤器，否则filteredEntities$ Observable会发出一个空列表。你只要打电话。使用与您的函数签名相匹配的适当参数:</p><figure class="le lf lg lh fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es lk"><img src="../Images/b32eb0ea06c02eccb69e897f104b5b7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6NRjrc8kk3H9jaCixMmGUw.png"/></div></div></figure><h1 id="f0c5" class="ka kb hx bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">对实体进行高级筛选</h1><p id="4ddc" class="pw-post-body-paragraph iu iv hx iw b ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn lc jp jq jr hb bi translated">如果您需要一些更高级的过滤，您可以使用<a class="ae jz" href="https://ngrx.io/api/data/PropsFilterFnFactory" rel="noopener ugc nofollow" target="_blank">propsfilternfactory</a>来处理regexp。如果您想对两个不同的字段进行过滤，不区分大小写，则可能是这样的:</p><figure class="le lf lg lh fd hk"><div class="bz dy l di"><div class="li lj l"/></div></figure><p id="e3d4" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">一旦您配置了此过滤器，就可以将它与来自用户或类似来源的任何输入一起使用:</p><pre class="le lf lg lh fd ll lm ln lo aw lp bi"><span id="4e7c" class="lq kb hx lm b fi lr ls l lt lu">// well this is hardcoded filter <strong class="lm hy">obviously</strong> :)<br/>this.todosService.<strong class="lm hy">setFilter</strong>('angular');</span></pre><p id="d7e3" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这很好，但是你只有一个可观察的，如果你想同时显示多个信息呢？知道我们有多少活跃的和不活跃的元素呢？<strong class="iw hy">显然</strong>，你只能在你的实体元数据中声明一个filterFn。</p><figure class="le lf lg lh fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es lv"><img src="../Images/20c716aef75954a1a37fcc3611d8a286.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6HcHkxRpMXkLCwqsHY0Kow.jpeg"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">很明显… :D</figcaption></figure><h1 id="cad9" class="ka kb hx bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">NgRx数据中的自定义选择器</h1><p id="451f" class="pw-post-body-paragraph iu iv hx iw b ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn lc jp jq jr hb bi translated">NgRx数据有<a class="ae jz" href="https://ngrx.io/guide/data/extension-points" rel="noopener ugc nofollow" target="_blank">一些扩展点</a>，其中一个有用的扩展点是<a class="ae jz" href="https://ngrx.io/guide/data/extension-points#custom-selectors" rel="noopener ugc nofollow" target="_blank">自定义选择器</a>。官方文档有正确的代码，但是它与另一个实体选择器混合在一起，可能会令人困惑。这里有一个简单的方法:</p><p id="1ba2" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们想同时显示“潜水者”类别和“有角者”类别中的Todos数量。</p><p id="13e0" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们只需创建一个新的选择器，原理图没做什么:</p><pre class="le lf lg lh fd ll lm ln lo aw lp bi"><span id="5e6c" class="lq kb hx lm b fi lr ls l lt lu">ng g selector selectors/Todo --skip-tests</span></pre><p id="dca9" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">它用无用的导入创建了一个空文件，因为选择器是真正的纯函数，被插入到现有的存储中。创建后，我们只需填充选择器，以检索按类别过滤的所需待办事项:</p><figure class="le lf lg lh fd hk"><div class="bz dy l di"><div class="li lj l"/></div></figure><p id="a20a" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在，在任何组件中，我们简单地基于这个选择器创建Observables，它接受一个字符串作为参数(它可以接受任何其他内容) :</p><pre class="le lf lg lh fd ll lm ln lo aw lp bi"><span id="2996" class="lq kb hx lm b fi lr ls l lt lu">this.store.pipe(select(<strong class="lm hy">selectTodoByCategory</strong>('angular')))</span></pre><figure class="le lf lg lh fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es lw"><img src="../Images/b092f9293d3e45cd7227de1b922108fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k5z06-soyqNxlgm0OmMLLQ.png"/></div></div></figure><p id="3981" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在，我们有了多个可观察对象，可以在模板中使用它们来获得关于数据实体的特定信息。请记住，这些Observables只查询商店中的数据，在订阅它们时不会发出任何XHR查询。</p><pre class="le lf lg lh fd ll lm ln lo aw lp bi"><span id="f204" class="lq kb hx lm b fi lr ls l lt lu">&lt;p&gt;todos "divers" : &lt;span&gt;{{(todos1$ | async)?.length}}&lt;/span&gt;&lt;/p&gt;</span><span id="c9fd" class="lq kb hx lm b fi lx ls l lt lu">&lt;p&gt;todos "angular" : &lt;span&gt;{{(todos2$ | async)?.length}}&lt;/span&gt;&lt;/p&gt;</span></pre><p id="1e03" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">用一点点bootsrap，你会得到这个:</p><figure class="le lf lg lh fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es ly"><img src="../Images/3aecaa579bc88747287e7987d402e79a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BbhBYeZy28uBEYv0RUG8iA.png"/></div></div></figure><p id="7898" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">NgRx数据有许多扩展点，只等我们使用它们，如果默认的URL不适合您的服务，您可以更改URL的处理方式。当然，您可以使用EntityMetadata的sortComparer对集合进行排序，这非常有用，比如:</p><figure class="le lf lg lh fd hk"><div class="bz dy l di"><div class="li lj l"/></div></figure><p id="6e85" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">很明显，就是它了，但是我会继续玩这个伟大的工具，我喜欢NgRx和它的组件，以及为它工作的团队，我希望这可以帮助任何开始定制他的配置的人。</p><p id="cf28" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在这里查看运行中的代码(在我写这几行的时候没有任何CSS，但是我可以很快改变主意…):</p><div class="hh hi ez fb hj lz"><a href="https://github.com/aboudard/ngrx-data-todo" rel="noopener  ugc nofollow" target="_blank"><div class="ma ab dw"><div class="mb ab mc cl cj md"><h2 class="bd hy fi z dy me ea eb mf ed ef hw bi translated">GitHub - aboudard/ngrx-data-todo:角度ngrx数据</h2><div class="mg l"><h3 class="bd b fi z dy me ea eb mf ed ef dx translated">一个使用Angular NgRx数据和json-server后端的简单项目。本文中描述的…</h3></div><div class="mh l"><p class="bd b fp z dy me ea eb mf ed ef dx translated">github.com</p></div></div><div class="mi l"><div class="mj l mk ml mm mi mn hp lz"/></div></div></a></div></div></div>    
</body>
</html>