<html>
<head>
<title>Breaking Instagram — Automating Page Growth: Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">打破insta gram——自动化页面增长:第1部分</h1>
<blockquote>原文：<a href="https://medium.com/codex/breaking-instagram-automating-page-growth-part-1-a487c471db69?source=collection_archive---------5-----------------------#2021-04-17">https://medium.com/codex/breaking-instagram-automating-page-growth-part-1-a487c471db69?source=collection_archive---------5-----------------------#2021-04-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/8f4e9b5d1f7e58be388b9632164ef5e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*MgUfyRRCL1TTIJte"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">亚历山大·沙托夫在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="c7bd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这个故事开始于大约两年前。我在YouTube上偶然发现了一个视频，它推广了follow-for-follow技术，以获得Instagram上的粉丝。这种技术通常应用于增长主题页面的上下文中。通常，网页的所有者会策划适合某个特定领域的内容，可以是任何内容，从滑雪、宠物、婚礼到迷因。在Instagram上运行这些页面的任何人的目标通常只是尽可能获得更多的关注者，然后要么出售账户以盈利，要么通过在帖子中向任何以这种方式购买付费广告的人显示付费广告来赚钱。</p><p id="e2db" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这就是跟进跟进的由来。简单地发布内容通常不足以快速增长，除非你已经很有名或者在其他地方有追随者。因此，人们使用像跟随这样的技术来从零开始获得追随者。根据过去在Instagram页面上增长的人的说法，一旦你的粉丝达到2000到5000人，你的帖子很有可能会像病毒一样传播，页面也会爆炸，到那时，就不再需要一个接一个的关注了。这是跑腿工作，是需要得到一个网页离开地面，并在它的方式张贴病毒内容。</p><p id="cd19" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所以，最紧迫的问题是，你是如何做到的？这真的很简单，作为页面所有者，你将在你的领域搜索其他更大的页面，寻找好的<strong class="ix hj">参与</strong>。参与度是一个非常重要的衡量标准，基于以下几个原因:</p><ul class=""><li id="a443" class="jt ju hi ix b iy iz jc jd jg jv jk jw jo jx js jy jz ka kb bi translated">找到高参与度的内容意味着你可以将它重新发布到你的页面上(当然，要给原作者荣誉)，你的观众可能会更多地参与到这些内容中。</li><li id="42fd" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">你可以培养喜欢和/或评论特定内容的用户，只需关注他们，并希望他们也关注你。</li><li id="4f9a" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">Instagram真正关心的是让人们尽可能多地观看它，如果你能提供引人入胜的内容，Instagram更有可能通过探索页面和其他推荐渠道向更多用户推广你的内容，因此，你更有可能快速增长。</li><li id="5b91" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">引人入胜的内容通常会让人们与他们的朋友分享你的内容，给你的页面带来自然的追随者。</li></ul><p id="a0f2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">后续跟进的最后一部分是清理。一旦你关注了很多人，有些人又关注了你，你需要等待一段时间，然后取消那些没有关注你的账户。</p><p id="6a00" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这就是事情的全部。这很简单，如果你知道自己在做什么，完全有可能自动化一些，如果不是全部的话，让你的生活更轻松。</p><p id="8fa6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">免责声明:</strong>不要在家里尝试，Instagram的政策规定，使用软件来帮助你获得粉丝是违反服务条款的。虽然本文中概述的技术是可行的，但是它们不应该在任何情况下使用。Instagram也采取措施确保这很难执行，但我们稍后会谈到这一点。</p></div><div class="ab cl kh ki gp kj" role="separator"><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km"/></div><div class="hb hc hd he hf"><p id="164f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这个过程中，我发现手动操作最重复、最无聊的部分是向下滚动喜欢某个帖子的用户列表，并逐个关注他们。Instagram对这种基于垃圾邮件的活动设置了非常严格的限制，所以在行动被阻止之前，你在任何给定的时间内只能关注大约50个人。</p><figure class="kp kq kr ks fd ij er es paragraph-image"><div class="er es ko"><img src="../Images/f0f025376cadb281cdeec276f42ff8a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1188/format:webp/1*l12S5ARUCCh0QYQBWdvmPw.jpeg"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">Instagram“动作被阻止”消息</figcaption></figure><p id="d671" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这通常会让你在几个小时内无法在应用上做任何事情，根据Instagram判断你的垃圾邮件的严重程度，这可能会增加到24小时，甚至长达一周，最终导致永久禁令(我还没有测试过这一限制，但在我的自动化测试早期，我的一个测试账户上的垃圾邮件被禁止了一周)。</p><p id="465b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">凭借我对基本过程的了解，我开始尝试寻找一种方法来自动化这个过程。我想我最好的选择是Instagram的网络应用。如果我能写一些JS来点击follow按钮并自动向下滚动列表，我就能轻松地关注大量用户。</p><p id="a35b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们来讨论一下该解决方案的实现。我尝试的第一件事是构建一个可以在Instagram页面上运行的Chrome浏览器扩展。我过去已经构建过一些这样的程序，所以我认为这是直接在页面中运行代码而不被CORS拒绝的最简单的方法。我是对的。</p><p id="dd08" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">代码本身非常简单，我从在页面上放置一个按钮开始，这样我可以让页面进入正确的状态。我只是需要一个有喜欢这个帖子的人的列表的模型。在那里，我设置了一个计时器，所以当按钮被点击时，它会使用CSS选择器在模态上找到Follow按钮。然后，计时器会每分钟单击一次这些跟随按钮，一旦它到达列表的底部，它会滚动模式以加载下一组追随者，并单击下一个跟随按钮。下面是该脚本的快速GIF图片:</p><figure class="kp kq kr ks fd ij er es paragraph-image"><div class="er es kt"><img src="../Images/4dd86ca6b8559264bfa9828aad942e9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:648/1*oW3AjxnNxygGxa4oPp_MAQ.gif"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">自动跟随脚本</figcaption></figure><p id="1de7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">虽然这种快速和肮脏的MVP解决方案工作正常，但它只是刚刚好。它仍然需要经常维护，有时它无法滚动足够远来加载更多的人来关注，或者它只是滚动经过一群人，错过了列表中的一些人。对我来说，它不够自动化，也不够一致。这种方法带来的另一个问题是，我必须找到一种方法，在跟随一段时间后，取消跟随所有没有跟随我的人。没有真正的方法来跟踪我何时关注了某人，所以如果我使用这里类似的方法编写一个脚本来自动取消关注，我将冒着关注某人然后立即取消关注的风险。这将导致较低的整体跟进率。</p></div><div class="ab cl kh ki gp kj" role="separator"><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km"/></div><div class="hb hc hd he hf"><p id="9a3c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最终，我需要一种不同的方法。浏览器扩展是在页面上执行JavaScript的一种非常好的方式，所以我决定坚持使用它，但是除了给脚本添加我所寻求的可靠性之外，我还需要一些东西。我决定放弃我最后的方法，去做一些更有条理的事情。</p><p id="d3be" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我首先检查当我点击follow或unfollow按钮时会发生什么，起初我试图调试混乱的JS，看看我是否能找到一个简单的函数来挂钩，但这变得非常繁琐，进展缓慢，所以我决定自己编写。我认为，当用户点击关注来更新用户关注的人的列表时，Instagram必须发送某种网络请求。我查看了网络选项卡，这是我的发现:</p><figure class="kp kq kr ks fd ij er es paragraph-image"><div class="er es ku"><img src="../Images/22ff0d8609c12d76274039c479d5ff63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1034/format:webp/1*eHcwUXV-EgEb7mhalaliIA.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">Instagram跟随请求</figcaption></figure><p id="c7d7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是当你跟随某人时得到的请求，这是一个非常基本的格式。</p><p id="910b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">有了这些知识，我们现在可以把用户ID列表放在一起，然后通过点击这个端点并把ID替换到URL中来跟踪每个用户ID。在这一点上，我唯一缺少的是一种获取用户id列表的可靠方法。</p><p id="85b4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">思考了一段时间后，我发现我最适合像以前一样找到最近有良好参与度的帖子，并想出如何收集所有关注该帖子的用户的id。</p><p id="9e6c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">事实证明，这比解码跟踪某人的方法要稍微困难一些。当您调出一个喜欢某个帖子的所有人的列表时，请求看起来是这样的:</p><figure class="kp kq kr ks fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kz"><img src="../Images/a6e97aea98ce0e7a8715166d634131cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OqM2_QYGTDBPewaNyYWFew.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">Instagram帖子喜欢GraphQL请求</figcaption></figure><p id="43b8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是一个GraphQL请求，考虑到Instagram归脸书所有，这并不奇怪。对此进行分析，有两个参数:</p><ul class=""><li id="4cba" class="jt ju hi ix b iy iz jc jd jg jv jk jw jo jx js jy jz ka kb bi translated"><code class="du kv kw kx ky b">query_hash</code></li><li id="e9e9" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated"><code class="du kv kw kx ky b">variables</code></li></ul><figure class="kp kq kr ks fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es la"><img src="../Images/d4b6ffbb7ab8e79e9e4d3865af9d0104.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f5fEY7xO46iF-HWQSuvneQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">Instagram帖子喜欢GraphQL请求参数</figcaption></figure><p id="ff7f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这一点上，我不知道<code class="du kv kw kx ky b">query_hash</code>的意义是什么，但是<code class="du kv kw kx ky b">variables</code>更容易解码。我不得不假设，<code class="du kv kw kx ky b">shortcode</code>是文章ID，这一点通过快速浏览URL栏得到了确认，那里有确切的<code class="du kv kw kx ky b">shortcode</code>值，很容易找到。</p><p id="5c92" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">你还会注意到，<code class="du kv kw kx ky b">variables</code>、<code class="du kv kw kx ky b">include_reel</code>中的另外两个键/值对，据我所知，对我们要实现的目标没有任何实际意义，我们可以忽略那个。根据我过去使用GraphQL的经验，<code class="du kv kw kx ky b">first</code>只是我们请求的最大结果数，检查从这个查询返回的数据证实了:</p><figure class="kp kq kr ks fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lb"><img src="../Images/549d6066defbc3ee164e5785722535ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Kqy5baH2kDSWKyOgMm3u_Q.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">Instagram帖子喜欢回复</figcaption></figure><p id="d3e9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">正如您所看到的，我们得到了一个24个用户的列表，其中有许多有用的详细信息，更好的是，用户对象中的第一个键是<code class="du kv kw kx ky b">id</code>，这正是我们正在寻找的。</p><p id="593b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们现在面临的问题是，我们如何获得其余的用户。Instagram有一个“无限滚动”功能，当你到达下一页数值的某个触发滚动点时，它会发送一个请求。为了触发此操作，我只需向下滚动关注者列表，此时会发送以下请求:</p><figure class="kp kq kr ks fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lc"><img src="../Images/a80377c4a8246b5442b23e030d4f1729.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*quEIracBLLAhuw6fw2Q8sw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">Instagram帖子喜欢分页请求</figcaption></figure><p id="e87a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">参数的可读性更强，如下所示:</p><figure class="kp kq kr ks fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kz"><img src="../Images/c1d59ccdbb2196e106f203112c0cd955.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EdEpDAAKgLPc-1mPWddEYA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">Instagram Post喜欢分页请求参数</figcaption></figure><p id="556b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du kv kw kx ky b">shortcode</code>是相同的，这进一步证实了我们的理论，即这是用来识别帖子的。<code class="du kv kw kx ky b">include_reel</code>对我们来说显然是微不足道的。<code class="du kv kw kx ky b">first</code>现在已经更改为<code class="du kv kw kx ky b">12</code>，这对于避免垃圾邮件检测可能很重要，因此我们将在以后记住这一点。最后，<code class="du kv kw kx ky b">after</code>是一个新参数，这就是分页的工作方式。通过传递<code class="du kv kw kx ky b">first: 12</code>和<code class="du kv kw kx ky b">after: &lt;page_cursor_hash&gt;</code>,我们请求得到页面指针散列后的前12个结果。</p><p id="fb96" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">你可以在这里阅读更多关于这是如何运作的:<a class="ae iu" href="https://graphql.org/learn/pagination/" rel="noopener ugc nofollow" target="_blank">https://graphql.org/learn/pagination/</a></p><p id="3c8f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这个难题的另一个关键在于我们在查询这个端点时收到的以前的响应，它们都包括这个属性:</p><figure class="kp kq kr ks fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ld"><img src="../Images/d79c8584ea936fe9583c4eee9251bab9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WRjuTfEtn-FsHl1oeH2ong.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">页面信息属性</figcaption></figure><p id="7111" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du kv kw kx ky b">end_cursor</code>告诉我们，如果我们想要下一页，我们可以使用这个值来发出相同的请求，但是只需更改<code class="du kv kw kx ky b">after</code>值。可以说，这就是我们如何“翻页”的方式。</p><p id="1063" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">剩下的唯一要弄清楚的事情是，如果我们到达最后，请求看起来像什么？</p><figure class="kp kq kr ks fd ij er es paragraph-image"><div class="er es le"><img src="../Images/4c6f29b65ce75d471ed1a87ec04340dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:694/format:webp/1*T1glT7YuDjJSxSeoHeKtwQ.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">没有下一页信息属性</figcaption></figure><p id="4755" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，我们只需要编写一个脚本来一次抓取一个页面，挑选出用户id并将其存储在某个地方。然后，我们可以编写一个脚本，接受其中的每一个，并发送一个请求来跟随它们。简单对吗？不对！稍后我们将讨论原因，但是现在，让我们集中于实现这些脚本:</p><figure class="kp kq kr ks fd ij"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="29b2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们来看看这是如何工作的:</p><p id="fdbc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du kv kw kx ky b">getPage</code>和<code class="du kv kw kx ky b">getPageRequest</code>互相调用，这是我们用来获取每个页面的机制</p><p id="32ec" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du kv kw kx ky b">write</code>和<code class="du kv kw kx ky b">getGraphqlUrl</code>都是我们在<code class="du kv kw kx ky b">getPageRequest</code>中使用的辅助函数</p><p id="292d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当我们第一次调用<code class="du kv kw kx ky b">getPage</code>时，它为从现在起2秒内调用<code class="du kv kw kx ky b">getPageRequest</code>设置了一个超时，它需要一个<code class="du kv kw kx ky b">queryHash</code>、一个<code class="du kv kw kx ky b">shortcode</code>和一个<code class="du kv kw kx ky b">end_cursor</code>。<code class="du kv kw kx ky b">shortcode</code>是文章id，但是<code class="du kv kw kx ky b">queryHash</code>稍微复杂一点。看起来Instagram在这些问题上也有一些混淆，使其更难解决。</p><p id="cf9d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在我们继续讨论我如何找到一种自动获取查询散列的方法之前，让我们再谈一谈这些函数实际上是如何一起工作的。<code class="du kv kw kx ky b">getPage</code>最终负责发送请求，然后将响应传递给<code class="du kv kw kx ky b">getPageRequest</code>。一旦我们完成了响应，我们检查在<code class="du kv kw kx ky b">getPageRequest</code>中是否有另一个页面，如果有，我们跳回到<code class="du kv kw kx ky b">getPage</code>，如果没有，我们就结束递归。这样，我们可以遍历每一页并为自己存储所有的结果。</p></div><div class="ab cl kh ki gp kj" role="separator"><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km"/></div><div class="hb hc hd he hf"><p id="b761" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我认为尝试找到这些查询散列来自哪里不会有什么坏处，起初我认为这可能是页面加载上的某种形式的XHR请求，但是我似乎找不到任何与<code class="du kv kw kx ky b">queryHash</code>匹配的内容。</p><p id="6f8a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后，我决定尝试搜索源代码，我从我的一个帖子请求中复制了一个<code class="du kv kw kx ky b">queryHash</code>，然后切换到Chrome开发者工具中的<code class="du kv kw kx ky b">Sources</code>选项卡，并按CTRL+SHIFT+F进行搜索。然后我简单地粘贴了我的<code class="du kv kw kx ky b">queryHash</code>,并点击回车键，这就是我看到的:</p><figure class="kp kq kr ks fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lh"><img src="../Images/25107db79177cfcc6c71ee44db7b04b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bjmWIjIQ1sU8YKEiyws49g.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">查询哈希搜索</figcaption></figure><p id="777b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在我们到了某个地方，我的<code class="du kv kw kx ky b">queryHash</code>就在那里，接下来我必须弄清楚如何自动提取它，这样我就不必发送一个请求，然后每当我想开始这个过程时就把它取出来，尤其是在我测试它的时候。</p><p id="c42c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我还注意到，在浏览网站时，每当从不同地方查询内容时，就会发送一堆网络请求，这些请求也有查询哈希，但它们是不同的。然而，它似乎对每个终点都是一致的。事实证明，这对于理解我需要哪个查询散列来发出我想要的请求非常重要。</p><p id="7b67" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最终，我可以实现自动化。查看这里提供给我们的信息，我们可以看到该值来自的脚本:</p><p id="c046" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du kv kw kx ky b">www.instagram.com/static/bundles/es6/Consumer.js/6482aa4be930.js</code></p><p id="bd5e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我认为<code class="du kv kw kx ky b">Consumer.js</code>看起来是一个不错的开始，所以我在我的开发工具中又做了一次CTRL+SHIFT+F，搜索<code class="du kv kw kx ky b">Consumer.js</code>，这产生了3个结果:</p><figure class="kp kq kr ks fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es li"><img src="../Images/8910d947da19a6df599f258cc93946b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ILA0iswTcRec7EqU3olD8w.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">Consumer.js的搜索结果</figcaption></figure><p id="e02d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对我帮助最大的是中间的结果，点击之后，它为我突出显示了这行代码:</p><figure class="kp kq kr ks fd ij er es paragraph-image"><div class="er es lj"><img src="../Images/54f4fa8a9f0b462c1e4092c598c1243c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1080/format:webp/1*pYOugIyqEwMeMAuISMTMDQ.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">有用的搜索结果</figcaption></figure><p id="38e7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这很棒，看起来在<code class="du kv kw kx ky b">window</code>对象上只有一个全局对象，包含每个脚本的所有URL的索引:</p><figure class="kp kq kr ks fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lk"><img src="../Images/7d1ef074abcb3977dceec7e6ad492b40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Vohf_FMbDSbYxyLxOMYd1Q.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">脚本URL索引</figcaption></figure><p id="c957" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这就是我们所能要求的，现在我们有办法在这个对象中寻找我们的<code class="du kv kw kx ky b">Consumer.js</code> url，用它来请求那个文件，然后我们可以解析我们的<code class="du kv kw kx ky b">queryHash</code>的响应。我写了这一小段代码来首先找到<code class="du kv kw kx ky b">Consumer.js</code>的路径:</p><figure class="kp kq kr ks fd ij er es paragraph-image"><div class="er es ll"><img src="../Images/e701e79a6ca2f6cc5a18a28726da7780.png" data-original-src="https://miro.medium.com/v2/resize:fit:866/format:webp/1*MvGz12fOZ-OXT9gj0QcIog.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">获取Consumer.js文件路径</figcaption></figure><p id="b0d5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后我写了这个来获取数据:</p><figure class="kp kq kr ks fd ij er es paragraph-image"><div class="er es lm"><img src="../Images/2d4a810b7450b10424e011a4657d8c8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:988/format:webp/1*lZ048SstWvuyOQPIqzMq8Q.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">Consumer.js哈希</figcaption></figure><p id="b571" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在我们已经得到了所有散列的列表，我注意到获得赞的散列在这个数组的第5个索引处。我愿意打赌每次都是相同的索引，所以函数最终看起来像这样:</p><figure class="kp kq kr ks fd ij"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="9881" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这将可靠地获取用于获取帖子上的赞的<code class="du kv kw kx ky b">queryHash</code>,然后我们可以使用它来调用我们编写的函数，以实际获取之前的用户。</p></div><div class="ab cl kh ki gp kj" role="separator"><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km"/></div><div class="hb hc hd he hf"><p id="798c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在我们已经有了<code class="du kv kw kx ky b">queryHash</code>，我们可以自动收集用户ID号，并编写一个函数将它们通过管道传输进来，这样我们就可以自动跟踪用户。</p><p id="76f5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">实际跟踪用户的功能要简单得多:</p><figure class="kp kq kr ks fd ij"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="eed6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们只是向之前在分析请求时发现的URL发送一个XHR。这有点复杂，因为我们需要在这个请求上设置一些特定的头，但是从Chrome扩展在同一个域上发送请求来看，这是完全可能的。</p><p id="f461" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">可以在任何以前的follow请求的详细信息中的Network选项卡中找到隐藏的请求头，这使得处理起来非常容易。</p><p id="9e56" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du kv kw kx ky b">x-ig-app-id</code>、<code class="du kv kw kx ky b">x-ig-www-claim</code>和<code class="du kv kw kx ky b">x-instagram-ajax</code>在会话之间都保持一致，但<code class="du kv kw kx ky b">x-csrftoken</code>没有。我不得不写一个小函数来为我们自动抓取:</p><figure class="kp kq kr ks fd ij"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="1fa8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我在这里有了一个坚实的开端，我可以从一个帖子中抓取所有的关注者，并将该数组输入一个函数，然后该函数会以随机的间隔关注他们:</p><figure class="kp kq kr ks fd ij"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="99c3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">就这么简单，所有繁重的工作都在别处完成。我们现在可以自动关注大量的人，只需要从一个帖子中抓取他们，然后把这些值插入这里。这也是我之前提到做到这一点并不容易的原因。这可能看起来像是一个完整的解决方案，但它还有更多内容，包括:</p><ul class=""><li id="e6f1" class="jt ju hi ix b iy iz jc jd jg jv jk jw jo jx js jy jz ka kb bi translated">取消关注用户</li><li id="c14b" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">避免垃圾邮件检测措施(即使这样也骗不了Instagram)</li><li id="6f83" class="jt ju hi ix b iy kc jc kd jg ke jk kf jo kg js jy jz ka kb bi translated">跟踪你关注的人和时间，这样你就可以在不影响你的回头率的情况下记录取消关注的时间</li></ul><p id="8a34" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">除此之外，你还应该发布内容。我还开始编写一些脚本，通过抓取reddit来自动生成内容，然后给你一个漂亮的UI来过滤你想发布的内容和标题，这样你就可以为你的页面设置每个内容的格式，然后点击一个按钮就可以发布了。我还希望能够安排它应该发布的时间，这样你就可以在一个小时内完成一堆内容，并有几天的内容排队并准备好，让你可以在页面运行时轻松休息。我相信这将在未来证明这些脚本的价值，因为我认为它可以让你在不做太多工作的情况下将一个页面扩展到成千上万的追随者。</p><p id="39ed" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在我的测试中，我设法将一个页面扩展到1500名粉丝，我知道这不是一个很大的数字，但这个页面以每天10%左右的惊人速度增长，Instagram上的一些垃圾邮件检测措施抓住了我，让我的速度慢了不少。</p><p id="718e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我确实也有解决这些问题的计划，但是我将把它们留到第2部分的文章中，这将暂时结束我们的讨论。除了对我自己来说是一次很好的学习经历之外，这是一次非常有趣的逆向工程。我很清楚这个网站是如何在比我所希望的更深的层次上整合在一起的，我肯定会继续努力，看看我能走多远。希望您也喜欢这篇文章，并关注即将发布的第2部分</p></div></div>    
</body>
</html>