<html>
<head>
<title>The AWS API Gateway Impossibility (the story of an API migration)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">AWS API网关的不可能性(API迁移的故事)</h1>
<blockquote>原文：<a href="https://medium.com/codex/migrating-aws-api-gateway-story-of-an-api-migration-93ce3c28b3d0?source=collection_archive---------9-----------------------#2022-03-24">https://medium.com/codex/migrating-aws-api-gateway-story-of-an-api-migration-93ce3c28b3d0?source=collection_archive---------9-----------------------#2022-03-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="ca92" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在工作中，我们必须将API网关从一个AWS帐户迁移到另一个帐户。迁移必须没有停机时间，并且是渐进的(慢慢地将流量从旧的API转移到新的API)。由于我们不控制客户，我们不能要求他们逐步将呼叫转移到新的端点。<br/>我们认为这很容易，但我们错了。</p><p id="8d15" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个想法是将我们现有的域名(在下面的例子中是app.domain.name.com)指向两个不同的API网关，旧的和新的。我们非常确定这可以通过一些简单的DNS更改来实现。这就是我们认为的解决方法:</p><ul class=""><li id="46fc" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">在新帐户中复制API网关</li><li id="1f59" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">向指向旧API网关的现有DNS A记录(在Route53托管区域中)添加权重</li><li id="f030" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">在解析到新API网关的Route53托管区域中插入一个具有权重的新A记录</li></ul><p id="affa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">换句话说，我们想从这个:</p><pre class="jr js jt ju fd jv jw jx jy aw jz bi"><span id="0cdc" class="ka kb hi jw b fi kc kd l ke kf">+---------+---------+----------------------+--------------------+<br/>| Record  | Weight  | Source               | Destination        |<br/>+=========+=========+======================+====================+<br/>| A       | -       | app.domain.name.com  | API-GW-domain-old  |<br/>+---------+---------+----------------------+--------------------+ </span></pre><p id="2207" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对此:</p><pre class="jr js jt ju fd jv jw jx jy aw jz bi"><span id="dbcc" class="ka kb hi jw b fi kc kd l ke kf">+---------+---------+----------------------+--------------------+<br/>| Record  | Weight  | Source               | Destination        |<br/>+=========+=========+======================+====================+<br/>| A       | 255     | app.domain.name.com  | API-GW-domain-old  |<br/>+---------+---------+----------------------+--------------------+<br/>| A       | 255     | app.domain.name.com  | API-GW-domain-new  |<br/>+---------+---------+----------------------+--------------------+</span></pre><p id="02b6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">添加相同的权重(本例中为255)，使得Route53在两个记录之间以相等的概率进行选择。我们希望这就是我们如何慢慢地将流量从旧的api转移到新的API。以下是尝试实现上述内容的结果、失败的尝试以及API网关和Route53集成中的误解。</p><p id="a2ce" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们首先在一个新的AWS帐户中创建了新的API，只是偶然发现了一个CloudFormation故障。API网关自定义域资源失败，因为另一个帐户中已经存在具有该域的自定义域。原来分配给区域端点<strong class="ih hj">的域必须</strong>是唯一的。因此上面的云形成失败了。旧API已经有一个包含该域的API网关自定义域资源(app.domain.name.com)。</p><p id="015e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">很好，所以这是行不通的。我们尝试了另一种方法。创建新的API网关，并为其分配一个不同的自定义域，该域仅在最左侧的子域有所不同。即:</p><pre class="jr js jt ju fd jv jw jx jy aw jz bi"><span id="40b4" class="ka kb hi jw b fi kc kd l ke kf">+-------+-------+------------------------+------------------------+<br/>| Record| Weight| Source                 | Destination            |<br/>+=======+=======+========================+========================+<br/>| A     | 255   | app.domain.name.com    | api-old.domain.name.com|<br/>+-------+-------+------------------------+------------------------+<br/>| A     | 255   | app.domain.name.com    | api-new.domain.name.com|<br/>+-------+-------+------------------------+------------------------+<br/>| A     | -     | api-old.domain.name.com| API-GW-domain-old      |<br/>+-------+-------+------------------------+------------------------+<br/>| A     | -     | api-new.domain.name.com| API-GW-domain-new      |<br/>+-------+-------+------------------------+------------------------+</span></pre><p id="781a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">api域仅在子域上有所不同，这使得创建涵盖它们两者的证书(*.domain.name.com)变得简单。</p><p id="f1c9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，我们更新了证书，在新帐户中部署了新的API(这次成功了)，创建了上表中描述的DNS记录。是时候验证它是否有效了。正是在这里，我们意识到通过“api-old.domain.name.com”访问旧api是可行的，通过“api-new.domain.name.com”访问新api是可行的……但通过“app.domain.name.com”访问应用程序却不可行。我们所期待的是新旧域之间的循环赛，我们得到的却是总是雄辩的API GW错误消息:<code class="du kg kh ki jw b">{"message":"Forbidden"}</code>。<br/>为什么呢？看来<em class="kj">API网关服务检查请求中的主机头，并期望它是API网关自定义域之一。换句话说，以下内容不起作用:</em></p><pre class="jr js jt ju fd jv jw jx jy aw jz bi"><span id="cc64" class="ka kb hi jw b fi kc kd l ke kf">&gt; curl https://app.domain.name.com/demo {"message":"Forbidden"}</span></pre><p id="2b00" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但这确实:</p><pre class="jr js jt ju fd jv jw jx jy aw jz bi"><span id="98fa" class="ka kb hi jw b fi kc kd l ke kf">&gt; curl -H "Host: api-old.domain.name.com" https://app.domain.name.com/demo {"message":"Hello, World!"}</span></pre><p id="1d48" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，我们考虑使用一个<a class="ae kk" href="https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-custom-domains.html#wildcard-custom-domain-names" rel="noopener ugc nofollow" target="_blank">通配符自定义域</a>。这也不起作用，因为正如医生所说:</p><blockquote class="kl km kn"><p id="133e" class="if ig kj ih b ii ij ik il im in io ip ko ir is it kp iv iw ix kq iz ja jb jc hb bi translated"><em class="hi">如果不同的AWS帐户创建了与通配符自定义域名冲突的自定义域名，则不能创建通配符自定义域名。</em></p></blockquote><p id="63c5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">文件还说有可能为此申请一个例外。吸取的教训是，将一个域名指向两个API网关是不可能的。那么如何迁移呢？一些选项包括:</p><ul class=""><li id="86e0" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">让新的API发布301重定向到旧的API</li><li id="2a55" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">新API的旧API代理</li><li id="41c8" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">部署一个代理，在旧API和新API之间转移流量</li><li id="54ee" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">请求在两个不同的AWS帐户中使用通配符域的例外</li></ul></div><div class="ab cl kr ks gp kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="hb hc hd he hf"><p id="2570" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="kj">原载于2022年3月24日</em><a class="ae kk" href="https://dev.to/napicella/the-api-gateway-impossibility-1pho" rel="noopener ugc nofollow" target="_blank"><em class="kj">https://dev . to</em></a><em class="kj">。</em></p></div></div>    
</body>
</html>