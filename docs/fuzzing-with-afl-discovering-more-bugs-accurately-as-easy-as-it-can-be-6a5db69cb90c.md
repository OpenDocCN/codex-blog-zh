# 用 AFL 模糊化:尽可能容易地准确发现更多的 bug

> 原文：<https://medium.com/codex/fuzzing-with-afl-discovering-more-bugs-accurately-as-easy-as-it-can-be-6a5db69cb90c?source=collection_archive---------20----------------------->

![](img/7b37b8f65a379238237e43d5079be482.png)

技术和创新的巨大进步为攻击软件漏洞的网络威胁创造了机会，导致严重的损害和中断商业活动。一些网络攻击和威胁，包括分布式拒绝服务(DDoS)攻击，用太多数据淹没服务器导致系统崩溃的情况，以及 2017 年发生的 WannaCry 勒索软件攻击，WannaCry 利用了服务器消息块(SMB)协议中的漏洞，据报道，一天内感染了 150 多个国家的 23 万多台计算机。为了提高信息安全性和防止网络攻击，开发了几种对抗网络威胁的尝试。技术包括静态分析、动态分析、符号执行和模糊化(刘。et.al. 2012)被提出来检测漏洞和错误。

许多网络技术被用来克服数据泛滥，其中之一就是模糊化。许多公司使用模糊化作为他们的网络安全技术来寻找他们软件中的漏洞。据 brightsec.com 称，一些国际企业已经使用 fuzzing 来提高他们的网络安全。谷歌使用 fuzzing 检查和保护 chrome 中的数百万行代码，2019 年，谷歌通过内部模糊测试在 chrome 中发现了超过 2 万个漏洞。微软使用 fuzzing 作为其软件开发生命周期中的一个阶段，以找到漏洞并提高产品的稳定性。美国国防部(DoD)发布了 DevSecOps 参考设计和应用程序安全指南，这两个指南都要求将模糊测试作为软件开发过程的标准部分。

**模糊化:历史和基本原理**

Fuzzing 是一种自动的错误和漏洞发现技术，它持续生成输入并报告那些使程序崩溃的输入(Bohme M .，Cadar C .，Roychoudhury A. 2021)。fuzzing 的目的是立即发现程序中的错误。模糊化可以为传统的软件技术(手工代码审查、调试)增加另一个视角，因为它是非人类的方法。模糊化以自动化的方式使用畸形/半畸形数据注入来发现实现缺陷。Fuzzing 是由巴顿·米勒教授和他的学生于 1989 年在威斯康星大学麦迪逊分校开发的。模糊化的第一个项目主要关注命令行和 UI 模糊化，并表明现代操作系统甚至容易受到简单模糊化的攻击。早期的技术是随机输入，不使用任何程序行为、应用程序类型或系统描述的模型，通常被称为黑盒测试。可靠性标准很简单，如果应用程序崩溃或挂起，就认为测试失败，否则就通过测试。这个标准允许使用简单的测试预言。请记住，应用程序不需要以合理的方式响应输入，它甚至可以安静地退出。

**fuzzing 的第一个项目分四步进行:**
a .构造一个生成随机字符的程序，加上一个帮助测试交互实用程序的程序
b .用这些程序在随机输入的字符串上测试大量的实用程序，看它们是否崩溃
c .识别使这些程序崩溃的字符串(或字符串的类型)；确定程序崩溃的原因，并对导致这些崩溃的常见错误进行分类

测试结果是，在七个版本的 UNIX(多用户操作系统)上的近 90 个不同的实用程序中，超过 24%的程序会崩溃。该项目为崩溃的程序生成了一个 bug(和修复)列表，并为系统社区提供了一套工具。模糊化是自动发现 bug 的艺术，它的作用是发现软件实现的错误，如果可能的话识别它们。与其他技术相比，fuzzing 易于部署，具有良好的可扩展性和适用性，并且可以在有或没有源代码的情况下执行。艾尔。2018).

模糊化有三种方法，白盒、灰盒和黑盒。白盒模糊化假设可以访问源代码，因此可以通过分析源代码以及测试用例如何影响程序运行状态来收集更多信息。灰盒模糊化也是在没有源代码的情况下工作，通过程序分析获得目标程序的内部信息。黑盒模糊化在没有任何目标程序内部知识的情况下进行模糊化测试。

**介绍 AFL:美国模糊 Lop**

美国 Fuzzy Lop (AFL)是一个用 C 和汇编语言编写的开源 fuzzers。AFL 是由 Michal Zalewski 首先提出的。一名波兰安全研究员。Zalewski 首先通过创建一个只包含“hello”的文本文件，并要求 fuzzer 继续将它提供给一个需要 JPEG 图像的程序，来实验 AFL 从稀薄的空气中提取 JPEG 的有效性。在开发 AFL 的过程中，测试人员和开发人员使用 gcov 块覆盖进行了几次有说服力的实验，以从大量数据中选择最佳测试用例，然后将它们用作传统模糊化工作流的起点。AFL 尽最大努力不专注于任何单一的操作原理，也不成为任何特定理论的概念验证。

**您可以通过以下步骤开始使用 AFL 进行模糊化:**

a.下载、编译并安装 AFL
b .下载、检测并安装目标
c .获取将用于馈送 AFL 的数据
d .创建 Ramdisk 并存储 AFL 模糊化会话输入和输出目录
e .开始模糊化

**为什么要使用 AFL 进行模糊处理？**

**a .速度**

AFL 可以让你大致以目标的原生速度模糊大多数目标，以避免在发现 bug 时运行速度变慢。大多数模糊工具更有可能提高查找 bug 的准确性，但是，会影响它们的运行速度，从而导致工具在后台运行较慢。AFL 通过仔细修整语料库或跳过输入文件中不起作用但不可修整的区域来增加工具，以实际减少工作量。

**b .坚如磐石的可靠性**

AFL 之所以吸引人，是因为它实现了简单易用且可扩展的自动化测试。大多数模糊化工具基于符号执行、污点跟踪或复杂的语法感知工具，这些工具对于现实世界的目标来说并不可靠。另一方面，AFL 设计了一系列有趣的、经过充分研究的策略来帮助模糊者将精力集中在重要的任务上。

**c .简单性**

与大多数提供无数旋钮和模糊比率的模糊工具相比，AFL 只提供三个旋钮，即输出文件、内存限制和覆盖默认自动校准超时的能力。使用的旋钮越多，起毛过程就越复杂。这将导致测试作者和操作者之间的混淆，从而导致更多的漏洞和风险。通过简化旋钮，AFL 避免了这种风险并简化了模糊化过程。即使当事故发生时，AFL 已经提供了用户友好的错误信息，概述了新出现的原因，并立即解决问题。

**d .可链接性**

大多数通用模糊化器发现很难利用资源密集型或交互密集型工具，这需要他们开发专用的进程内模糊化器或投资大量 CPU 资源。该过程被认为是无效的，因为它主要导致与实际想要测试的代码不相关的任务。AFL 通过允许用户使用更轻量级的目标(例如，独立的图像解析库)来创建有趣的测试用例的小型语料库，这些测试用例可以放入手动测试过程或 UI 工具中，从而避免了这种情况。

处理未解决的代码无疑是一种负担，同时需要立即修复隐藏的错误和漏洞。此外，当使用的模糊化工具给出更复杂的过程而不是有用的功能时，测试人员更可能花更多的时间在工具中解决问题，而不是利用它来发现漏洞。AFL 通过提供高度可靠的可扩展自动测试减轻了负担。它允许 fuzzers 设计一个经过充分研究的策略和有趣的测试用例来发现更多的 bug。