# 编程语言的基本历史以及如何编写自己的语言

> 原文：<https://medium.com/codex/a-basic-history-of-programming-languages-and-how-to-write-your-own-c05b804dd932?source=collection_archive---------13----------------------->

![](img/787797d4213c8a6245bf56f7c6ab0d1e.png)

凯利·西克玛在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上的照片

创建自己的编程语言有很多原因。我怀疑如果你发现了这个，那么你心里可能已经有一个了。最坏的情况是，编写一门编程语言会让你对编程语言的工作原理有更丰富的理解。充其量，您可以创建一个有用的工具，让工作更有效地执行。**我的目标是解释创造你自己的语言所需的概念基础。**

创造一种语言是一个经过几十年不断完善的过程。在我们拥有图灵完整计算机之前，计算大多是直接硬编码到电路上的。这些都是难以置信的基础，并且不是图灵完成的，因为它们不可重复编程，因此不能解决所有问题。然后出现了图灵完整的可编程计算机。开发人员可以向计算机输入指令，计算机就会进行定制计算。第一种编程语言是二进制的，这种语言至今仍被用于各种计算中。处理器被设计成在给定特定指令(电信号)的情况下，它会执行某些操作，例如将值从存储器移入寄存器、算术计算等。通过硬编码到 CPU 中的一组基本指令，所有可能的问题都可以使用这些指令的组合(以及无限的计算能力和内存)来解决。

这些指令完全是二进制的。为了使编程更容易，汇编语言被创造出来。它们接受二进制指令，并给它们可读的别名，如 *mov* 或 *add* 。你可以用汇编语言编写代码，并使用一个叫做汇编程序的程序在别名和二进制机器码之间进行转换。随着格蕾丝·赫柏编译器的发明，语言变得越来越复杂，也变得越来越容易。重要的是后退一步，看看语言进化成这样的原因是为了解决抽象的问题。目标一直是使编程过程变得抽象；忽略我们在和电脑对话的事实，专注于用最接近我们自然语言的语言解决手头的问题。

更现代的语言如 C 语言明显比汇编语言更抽象；然而，C 仍然是一种极其简单的语言。它允许复杂的数学表达式与自然书写的几乎相同。c 还引入了类型概念，变量可以保存某些类型，函数接受或返回类型。**类型在理解代码在做什么方面提供了很大的效用，与 C 的汇编基础有着内在的联系**就像汇编代码被汇编成二进制一样，C 代码被编译成汇编，再被汇编成二进制。这并不那么简单，因为 C 允许一个程序被分割成多个文件，所以还有一个链接阶段和其他调试等中间步骤。然而，需要理解的基本事实是，在计算机中，C 并没有取代汇编；它用一层抽象掩盖了它。当今所有的计算机代码仍然以二进制形式运行，而且几乎肯定会在某个时候变成汇编代码。

如果我们继续往下跳，我们会得到像 Python 或 JavaScript 这样的语言。这些语言意义重大，因为它们是被解释的。**解释型语言不编译成汇编，汇编成二进制运行；它们被另一个程序遍历，并确定执行。**如果你熟悉树结构，我没有错用*遍历*这个词。关于编程语言，我可以了解很多历史，但我认为这足以开始讨论这个过程实际上是如何工作的。

![](img/7c89062d1892b61ab9a45bc057cc88d4.png)

照片由[沙哈达特·拉赫曼](https://unsplash.com/@hishahadat?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄

首先，汇编程序可以像文本替换程序一样简单。一旦你用二进制写了一个汇编程序，你就可以用你正在使用的汇编语言重写它，并使用先前生成的机器码来允许它运行。一些汇编器提供了比简单的文本替换更多的特性，但是这取决于汇编语言的特性集。我认为大多数现代汇编语言都比最初的汇编语言有更多的高级功能。必须为特定的 CPU 架构构建汇编程序，在一个 CPU 上汇编的代码可能无法在另一个 CPU 上运行，因为不同的架构使用不同的指令集，甚至可能使用不同的内存大小(考虑 32 位和 64 位)。

创建一门语言时，你需要回答的第一个问题是，你是希望你的语言被解释还是编译。我将详细介绍这三者的含义，以便您可以开始决定:

一个**编译的**语言会被转换成汇编代码。这意味着你可能需要了解或学习汇编。编译代码需要一些时间，但是一旦编译完成，就可以加载到内存中运行了。这使得编译语言速度最快。例如，C++以其性能和优化选项而闻名。问题是，如果您的程序打算在多种 CPU 体系结构(如 x86、x64 和 ARM)上运行，您将需要为您计划支持的每种体系结构修改汇编代码，并且需要为每种体系结构编译程序。

编译代码的另一种方法是**传输**。transpiler 是一种程序，它获取一种语言的代码并将其转换成另一种语言的代码。你会注意到每个编译器都是转换编译器，但不是每个转换编译器都是编译器。例如，transpiler 可以获取 C 代码并生成几乎等同的 Java 代码。如果你想避免手工使用汇编，但是想要一个编译语言，你可以从你的语言写一个 transpiler 到 C 之类的编译语言，然后，你可以使用现有的 C 编译器来编译和汇编你的代码。transpiler 唯一真正的缺点是编译速度会慢很多。你不仅要阅读和重写代码两次，而且你要把代码写成人类可读的格式，这种格式要简单得多，总体效率也低得多。然而，这在实践中可能没多大关系。

更现代的选择之一是创建一个**解释器**。这将是一个编译语言的程序，它将通读您的代码并确定正确的结果。你*可以*用一种解释语言创建一个解释器，但是在某些时候编译的代码将会运行。每个级别的初始阶段都会增加性能影响。这听起来可能比编译器更复杂，但实际上在很多方面都更简单。一旦我解释了构建的实际过程，这一点就变得更加清楚了。解释器的好处是它们实际上很容易编写，并且允许更统一的程序。不同架构上的编译可能会产生不同的计算结果，但是您的解释器可以统一这些结果。你可能需要为每个平台创建一个解释器，但总的来说，这是语言在各种计算机上工作的首选方法。Java 吹嘘有多少台计算机在使用它。这是因为 java 是被解释的(java 被编译成不同种类的 Java 代码，然后由 Java 虚拟机(JVM)解释)。然而，解释语言的主要缺点是它们通常很慢。可以进行优化，使它们在某些计算中的性能几乎与编译语言相同(如果采用正确的优化，可能会更快)，但通常计算速度非常慢且效率低下。这就是为什么绝大多数现代游戏仍然是用 C++这样的语言编写的。

现在，您应该能够更好地决定您的语言是要被解释、编译还是翻译。但是，不要太快决定。一种语言本身并不是解释的、编译的或翻译的；如果你愿意，你的语言可以是这三种语言，也可以是任意组合。让我们看看你在概念上需要做些什么来真正开始创造一门语言。

![](img/ae467f59b6a447f912653ca7df4df4ed.png)

照片由[阿玛多·洛雷罗](https://unsplash.com/@amadorloureiroblanco?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄

在你开始编码之前，你应该从设计你的语言的语法开始。(您还应该通读本文的其余部分，以便了解您将首先设计什么)。你想要像 C 一样的括号和分号吗，你想要像 Python 一样的缩进和换行符吗，或者你有什么新的想法吗？你想拥有什么样的运营商？您希望函数如何工作？类型是显式声明的还是推断的？会不会是面向对象的？这可能是创造一门语言最难的一步。你必须花时间决定你希望你的语言在使用时是什么感觉。因为你有太多的选择，这看起来会让人不知所措。如果你真的不能决定一些事情，看看你喜欢的语言，并从中获得灵感。然而，我建议把重点放在可读性和简单性上。我认为读起来像书面文字和数学的语言是理想的。关注可用性、调试和总体视觉吸引力。或者，如果你愿意，创造一堆可怕的符号；你的语言应该是你的。如果您希望或希望其他人实际使用这种语法，我建议您为它创建文档。它还能帮助你记住你做了什么决定以及为什么。

现在，您将有能力编写什么也不做的代码。为了让它有所作为，我们将有一个 3 步流程。我们将从创建一个**词法分析器**或分词器开始。这是一个程序，它读取你的源代码，并把它分解成令牌。每个符号和单词都是一个符号。根据您的语言，空格在这里可能会被忽略，或者本身就是一个标记。lexer 将按照标记在源文件中出现的顺序生成一个标记列表。让我用 C 写一个简单的例子:

int main(){ return 0；}

这将生成一个令牌列表，大致如下:

["int": type，" main": identifier，"(":symbol，")":symbol，" {": symbol，" return": keyword，" 0": int-literal，"；":符号，“}”:符号]

请注意，每个标记都有一个关联的类型。lexer 需要将一些符号作为组(例如标识符；它必须创造整个世界，或者像 Python 的指数运算符 **** 等符号一样是单数。不过，您可能需要的一些东西是标识符、符号、字符串文字、整数文字、浮点文字和关键字。标记它们的方式实际上取决于您，但是标记它们有助于分解代码并获得关于该令牌可能正在做什么的信息。

接下来，我们将讨论**解析器**。解析器将获取标记列表，并生成一个抽象语法树(AST)。抽象语法树是一种树，其中操作是节点，并且它们在树中出现的顺序定义了操作的顺序。您可以在树上执行深度优先搜索(DFS ),根据您想要的操作顺序以正确的顺序获得标记。深度优先搜索意味着从根节点开始，检查它，然后到左边的节点，再到右边的节点。如果您对递归或树遍历不熟悉，我建议您对此进行一些研究。

生成 AST 的这一步要求您已经想好了语言中的操作顺序(因此我建议在设计之前通读一遍)。这个顺序比算术更复杂；你需要包括函数调用，变量引用等等。不要太在意这些东西的名字，因为这是设计中最难的事情之一。算术和布尔表达式很容易识别，但是其他表达式应该叫什么呢？一旦你进入它，你就会明白我的意思。这基本上是创造你的语言语法的过程。我建议创建一个图表，显示每种类型的表达与其他类型的表达之间的关系。

一旦定义了语法，从标记列表生成 AST 就非常简单了。正如您将符号标识为特定类型并使用该信息创建标记一样，现在您将标记标识为特定类型的节点或表达式，并在树结构中创建节点。请注意，在每一步中，都会丢失一些信息。在 lexer 中，所有被忽略的空白都丢失了，但是很多空白可以通过列表中标记的顺序推断出来。类似地，书写的顺序现在也将丢失；然而，执行的顺序将直接传递到 AST 的结构中。这使得最后一步简单多了。

最后，您将创建一个**访问者**，这是我对编译器、传输器或解释器的通称。它将访问 AST 的每个节点(从根节点开始，执行 DFS)，因此得名。事实上，无论您选择使用哪种类型的访问者，之前的每一步都是相同的。这是为什么这种方法如此体面的主要原因。如果愿意，您可以创建一个、两个或全部三个访问者。这也是解释器如此简单的原因。如果您遇到一个像((+) lc(5) rc(6))这样的节点，也就是说一个加法节点，它的左子整数-文字数为 5，右子整数-文字数为 6，您只需确定该节点是加法节点，然后访问子节点并添加它们的结果。这非常简单。因为您总是检查子节点的值，所以整个树最终将被遍历。需要注意的是，并不是所有的运算都是二元运算。如果你愿意，有些可以是一元的、三元的或更多元的。每个语法规则都有自己的节点，可以按照你的意愿来设计。为了创建一个编译器或传输器，你将类似地从根开始遍历树，每种类型的节点都有自己的编译或传输函数。

**作为整个过程的总结，我们从一个词法分析器开始，它在源代码中逐个符号地生成不同类型的标记。然后，我们有一个解析器，它使用类型和顺序逐个生成抽象语法树中的节点，其中节点的顺序描述了操作的顺序，节点的类型描述了语法的类型。最后，我们有一个访问者，它对抽象语法树执行深度优先搜索，并根据节点类型和存储在其中的标记值生成代码或解释结果。**

![](img/8dace1656b60515c9fc5abe05fff2b5c.png)

照片由[克里斯汀·韦勒特](https://unsplash.com/@kristineweilert?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 拍摄

如果你已经走了这么远，深呼吸放松一下。仅凭这些信息，你可能还没有准备好创造你的语言。也许你已经开始设计你的语言，但还不能做出某些决定。不幸的是，我还没有找到很多创建编程语言的好教程，但我建议继续寻找。如果你真的想在设计你的语言之前理解这个过程是如何工作的，考虑为 C 或 Python 这样的语言创建一个访问者。你可以在网上找到这些语言定义良好的句法和语法，这将使你对词法分析器、语法分析器和访问者有一个实际的了解。你甚至可能最终为你自己的语言修改一些代码。

我希望这证明是有用的！我对创建编程语言感兴趣，因为我开始掌握 Python，发现我喜欢语法，但希望它有更低级的功能。这开始了我创建一个具有类似 Python 语法的 C 语言版本的探索，叫做 [Sea](https://github.com/DavidMacDonald11/Sea-Programming-Language) 。我已经有一段时间没有做这个了，因为我在设计语法之前就已经开始编程了，所以我的代码一塌糊涂。我计划写下很多我的设计过程，这样我就可以真正地思考它，然后我会重新开始编程。请随意查看代码以获得灵感或对该过程的实际理解。也许将来我会写一篇后续文章，从实践的角度而不是概念的角度来解释这个过程。祝你创造自己的语言好运！