<html>
<head>
<title>Seek and Destroy — The JavaScript Algorithm</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">寻找和破坏JavaScript算法</h1>
<blockquote>原文：<a href="https://medium.com/codex/seek-and-destroy-the-javascript-algorithm-8d028a2770dd?source=collection_archive---------1-----------------------#2021-12-04">https://medium.com/codex/seek-and-destroy-the-javascript-algorithm-8d028a2770dd?source=collection_archive---------1-----------------------#2021-12-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/289fd610ad6f290646d48ddf1ccea317.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*duQYt1qBK2AO2tWk.jpg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">图片来自Loudwire</figcaption></figure><p id="fe4f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在我们的算法练习过程中，有些练习很无聊，有些会很有趣，还有一些你会忍不住去写博客。我前几天碰到的这个好玩的算法就是这样。寻找和摧毁，让我听到詹姆斯·海特菲尔德唱出来的算法加载<em class="js">搜索，寻找和摧毁</em>与他的可识别的声音。是的，我说的是Metallica和一种算法，该算法将搜索初始数组中与该数组后面的参数相同的值，并销毁它们。</p><p id="3da1" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">比如<code class="du jt ju jv jw b">seekAndDestroy([1, 2, 3, 5, 1, 2, 3], 2, 3)</code>应该返回<code class="du jt ju jv jw b">[1, 5, 1]</code>。</p><p id="2dcf" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">因此，让我们用Seek和Destroy来引爆我们的耳机，并查看一些解决方案。</p><figure class="jx jy jz ka fd ij"><div class="bz dy l di"><div class="kb kc l"/></div></figure><h1 id="83c2" class="kd ke hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">嵌套循环</h1><figure class="jx jy jz ka fd ij"><div class="bz dy l di"><div class="lb kc l"/></div></figure><p id="8ec4" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">对于第一个解决方案，我们使用<code class="du jt ju jv jw b">Object.values(arguments).slice(1)</code>创建一个数组，并将其存储在变量<code class="du jt ju jv jw b">valuesToRemove</code>中，以便与arr进行比较。我们开始一个基本的for循环来遍历<code class="du jt ju jv jw b">arr</code>。然后，在第一个循环中嵌套另一个for循环，将整数变量<code class="du jt ju jv jw b">j</code>和<code class="du jt ju jv jw b">arr</code>改为<code class="du jt ju jv jw b">valuesToRemove</code>。第二个循环将遍历<code class="du jt ju jv jw b">valuesToRemove</code>。在第二个循环中创建一个if语句，严格检查arr[i]的当前值是否等于<code class="du jt ju jv jw b">valuesToRemove[j]</code>。如果当前索引<em class="js">处的值在两个数组中</em>相等，我们将把它从<code class="du jt ju jv jw b">arr</code>中删除。在嵌套循环之外:返回修改后的数组，过滤掉由<code class="du jt ju jv jw b">delete</code>操作符创建的任何空值。</p><p id="905b" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">您可能认为这段代码太复杂了，这是正确的。当我们通过输入添加嵌套迭代时，会增加复杂性。根据<a class="ae lc" href="https://dzone.com/articles/learning-big-o-notation-with-on-complexity" rel="noopener ugc nofollow" target="_blank">大O符号</a>，这是一个<em class="js"> O(n2) </em>函数，它代表一个复杂度与输入大小的平方成正比的函数。因此增加了复杂性。换句话说，反应会更慢，需要更多的内存，这比圣安格尔的小军鼓声音更糟糕。相当糟糕。</p><figure class="jx jy jz ka fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ld"><img src="../Images/a5b6e21b15255549480eabd65496bee8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*2vzqhRDG2AsXyZ3d.jpg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">拉尔斯看起来像是在吹嘘自己站起来打鼓的能力。声音较大的图片。</figcaption></figure><h1 id="7b8c" class="kd ke hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">阵列迭代方法</h1><figure class="jx jy jz ka fd ij"><div class="bz dy l di"><div class="lb kc l"/></div></figure><p id="07af" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们的第二个解决方案是最常见的JavaScript解决方案，本练习中的<em class="js">恩特尔·桑德曼</em>。它用<code class="du jt ju jv jw b">.filter</code>和<code class="du jt ju jv jw b">.includes</code>方法迭代新数组。正如我们所看到的，这是一个更干净的代码。<a class="ae lc" href="https://dev.to/lukocastillo/time-complexity-big-0-for-javascript-array-methods-and-examples-mlg" rel="noopener ugc nofollow" target="_blank">迭代方法</a>如<code class="du jt ju jv jw b">.filter</code>的时间复杂度为<em class="js"> O(n) </em>，与输入次数成正比线性增加。起初，迭代方法看起来令人困惑。一旦我们理解了如何使用它们，这些方法，在需要的时候实现它们，将会像在卡拉ok之夜跟着<em class="js">恩特尔·桑德曼</em>唱歌一样自然。</p><figure class="jx jy jz ka fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es le"><img src="../Images/4fd6858ab180b66f6e51222adf9e41ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*iPHWh6tLE_ynzR1g.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">Retsuko对恩特尔·桑德曼反应过度了。图片来自BBC。</figcaption></figure><h1 id="1b02" class="kd ke hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">休息参数</h1><figure class="jx jy jz ka fd ij"><div class="bz dy l di"><div class="lb kc l"/></div></figure><p id="edd1" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">第三个也是最后一个例子是我最喜欢的。这是克里夫伯顿(瑞普)玩低音独奏史诗级。在这个解决方案中，我们使用了<a class="ae lc" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters" rel="noopener ugc nofollow" target="_blank"> rest参数</a>语法。我们允许一个函数使用三个点<code class="du jt ju jv jw b">…</code>作为数组接受不确定数量的参数。然后，我们用<code class="du jt ju jv jw b">.includes</code>方法返回过滤后的数组。这个解决方案是一些漂亮的ES6代码。</p><figure class="jx jy jz ka fd ij"><div class="bz dy l di"><div class="kb kc l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">听听那个电贝司。他是有史以来最好的贝斯手之一。</figcaption></figure><p id="e932" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">所以我们有了它，一个有趣的算法，我们可以用金属乐队的一首歌来命名。我希望你能从这篇文章中学到一些新的东西，并像我喜欢写它一样喜欢它。所以，继续研究这些算法，找到一些你最喜欢的音乐或流行文化来参考它。</p><p id="42d2" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">编码快乐！</p><h1 id="2d35" class="kd ke hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">总结:</h1><ol class=""><li id="5155" class="lf lg hi iw b ix lh jb li jf lj jj lk jn ll jr lm ln lo lp bi translated">“查找并销毁”算法简介。</li><li id="7bc6" class="lf lg hi iw b ix lq jb lr jf ls jj lt jn lu jr lm ln lo lp bi translated">嵌套循环</li><li id="ec5b" class="lf lg hi iw b ix lq jb lr jf ls jj lt jn lu jr lm ln lo lp bi translated">阵列迭代方法</li><li id="919e" class="lf lg hi iw b ix lq jb lr jf ls jj lt jn lu jr lm ln lo lp bi translated">Rest参数语法</li></ol><h1 id="7b1a" class="kd ke hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">参考资料:</h1><ol class=""><li id="a5cc" class="lf lg hi iw b ix lh jb li jf lj jj lk jn ll jr lm ln lo lp bi translated"><a class="ae lc" href="https://dzone.com/articles/learning-big-o-notation-with-on-complexity" rel="noopener ugc nofollow" target="_blank">学习O(n)复杂度的大O记数法</a>牛顿，丹。</li><li id="5c74" class="lf lg hi iw b ix lq jb lr jf ls jj lt jn lu jr lm ln lo lp bi translated"><a class="ae lc" href="https://dev.to/lukocastillo/time-complexity-big-0-for-javascript-array-methods-and-examples-mlg" rel="noopener ugc nofollow" target="_blank">时间复杂度大0的Javascript数组方法和例子</a>作者Castillo，Luis。</li><li id="b4aa" class="lf lg hi iw b ix lq jb lr jf ls jj lt jn lu jr lm ln lo lp bi translated">MDN Web Docs，<a class="ae lc" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters" rel="noopener ugc nofollow" target="_blank">其余参数</a></li></ol></div></div>    
</body>
</html>