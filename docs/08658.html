<html>
<head>
<title>Unit Tests –What? Why? How?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">单元测试——什么？为什么？怎么会？</h1>
<blockquote>原文：<a href="https://medium.com/codex/unit-tests-what-why-how-89964e7041fe?source=collection_archive---------11-----------------------#2022-08-24">https://medium.com/codex/unit-tests-what-why-how-89964e7041fe?source=collection_archive---------11-----------------------#2022-08-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><blockquote class="if ig ih"><p id="c513" class="ii ij ik il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated">作为一名计算机专业的学生，我并没有真正理解编写单元测试的核心原因。当我第一次想推送我的代码，正在等待代码评审时，我得到了一条评论——“<em class="hi">你的单元测试在哪里？</em>”。</p></blockquote><h2 id="d988" class="jh ji hi bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke bi translated">当你说单元测试时，你指的是什么？</h2><p id="1f3c" class="pw-post-body-paragraph ii ij hi il b im kf io ip iq kg is it js kh iw ix jw ki ja jb ka kj je jf jg hb bi translated">顾名思义，这是一种测试单元的方法——逻辑上隔离的最小代码片段。在单元测试中，我们不能试图涉及组件之间的集成，我们不打算依赖外部资源(如数据库、web服务等)。).由于单元测试与外部资源隔离，我们应该能够在本地或任何其他机器上运行它们。</p><p id="0d7b" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it js iv iw ix jw iz ja jb ka jd je jf jg hb bi translated">单元测试也是TDD(测试驱动开发)的一部分，TDD是一种软件开发过程，它依赖于在软件完全开发之前将软件需求转换成测试用例。在这个过程中，在编写新代码之前，为每个功能创建测试用例。</p><p id="7088" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it js iv iw ix jw iz ja jb ka jd je jf jg hb bi translated">如今有许多工具可以运行、创建和编写单元测试，例如:<a class="ae kk" href="https://github.com/microsoft/vstest" rel="noopener ugc nofollow" target="_blank"> VSTest </a>、<a class="ae kk" href="https://karma-runner.github.io/latest/index.html" rel="noopener ugc nofollow" target="_blank"> Karma </a>、<a class="ae kk" href="https://github.com/microsoft/testfx" rel="noopener ugc nofollow" target="_blank"> MSTest </a>、<a class="ae kk" href="https://nunit.org/" rel="noopener ugc nofollow" target="_blank"> NUnit </a>、<a class="ae kk" href="https://xunit.net/" rel="noopener ugc nofollow" target="_blank"> XUnit </a>、<a class="ae kk" href="https://junit.org/junit5/" rel="noopener ugc nofollow" target="_blank"> Junit </a>。</p><h2 id="63f4" class="jh ji hi bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke bi translated">单元测试的核心原因是什么？</h2><p id="86f2" class="pw-post-body-paragraph ii ij hi il b im kf io ip iq kg is it js kh iw ix jw ki ja jb ka kj je jf jg hb bi translated">最常听到的原因是:</p><ul class=""><li id="db1f" class="kl km hi il b im in iq ir js kn jw ko ka kp jg kq kr ks kt bi translated">涵盖了我们无法使用手动或其他软件测试的情况，例如组件/系统/自动化测试，尤其是边缘情况。</li><li id="6da9" class="kl km hi il b im ku iq kv js kw jw kx ka ky jg kq kr ks kt bi translated">早期问题识别。</li><li id="2af4" class="kl km hi il b im ku iq kv js kw jw kx ka ky jg kq kr ks kt bi translated">快速执行运行时，这是在将代码更改应用到源代码控制之前的第一层测试。</li></ul><p id="0c36" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it js iv iw ix jw iz ja jb ka jd je jf jg hb bi translated">但是…</p><p id="a9db" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it js iv iw ix jw iz ja jb ka jd je jf jg hb bi translated">当我想到单元测试时，首先想到的是<strong class="il hj"> <em class="ik">依赖注入</em> </strong>。将创建对象的任务转移给其他人，并直接使用该对象，这被称为依赖注入。这有助于我们遵循<strong class="il hj"> SOLID的依赖倒置和单一责任原则。</strong></p><p id="006f" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it js iv iw ix jw iz ja jb ka jd je jf jg hb bi translated">使用依赖注入比让组件满足它们自己的依赖有几个好处。这些优势包括:</p><ul class=""><li id="223e" class="kl km hi il b im in iq ir js kn jw ko ka kp jg kq kr ks kt bi translated">可读性:更容易看出组件有哪些依赖关系</li><li id="0278" class="kl km hi il b im ku iq kv js kw jw kx ka ky jg kq kr ks kt bi translated">可扩展性:依靠抽象而不是实现，代码可以很容易地改变给定的实现</li><li id="1b12" class="kl km hi il b im ku iq kv js kw jw kx ka ky jg kq kr ks kt bi translated">可维护性:遵循可靠的原则</li><li id="42bc" class="kl km hi il b im ku iq kv js kw jw kx ka ky jg kq kr ks kt bi translated">易测性</li></ul><p id="2699" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it js iv iw ix jw iz ja jb ka jd je jf jg hb bi translated">当依赖关系可以被注入到一个组件中时，对那些依赖关系的模仿也可以。模拟对象用于测试，作为真实实现的替代。我们可以为模拟对象配置不同的行为，这样我们就可以测试组件来正确处理所有的行为。例如，我们可以测试组件是否能够处理mock何时返回正确的对象，何时返回null，以及何时抛出异常。此外，mock对象通常会记录对它们调用了什么方法以及调用了多少次，因此测试可以验证使用mock的组件是否按预期使用了它们。</p><p id="f4be" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it js iv iw ix jw iz ja jb ka jd je jf jg hb bi translated">很明显，如果我们试图为不遵循依赖注入模式的组件编写测试，我们很快就会发现许多场景甚至部分组件行为是不可测试的。</p><p id="ff0a" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it js iv iw ix jw iz ja jb ka jd je jf jg hb bi translated">例如，如果我们的组件使用一个网络层组件(比如<em class="ik"> HttpClient) </em>并且我们没有一个开发url，或者我们运行测试的机器被阻止访问互联网，如果我们不使用依赖注入，我们将不能测试所有使用<em class="ik"> HttpClient </em>功能的行为。</p><p id="c0e7" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it js iv iw ix jw iz ja jb ka jd je jf jg hb bi translated"><strong class="il hj">当我们编写单元测试时，它迫使我们遵循坚实的原则编写更可读、可扩展和可维护的软件</strong>。</p><h2 id="15cb" class="jh ji hi bd jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke bi translated">我们如何编写单元测试？</h2><p id="695a" class="pw-post-body-paragraph ii ij hi il b im kf io ip iq kg is it js kh iw ix jw ki ja jb ka kj je jf jg hb bi translated">单元测试应该像我们写文章一样来写。<br/>在一篇文章中，我们有一个<strong class="il hj">标题</strong>、<strong class="il hj">引言</strong>、文章<strong class="il hj">实质</strong>和一个<strong class="il hj">结论</strong>。<br/>在一个单元测试中，我们有一个<strong class="il hj">测试名称、准备、组件行为的执行</strong>，以及一个<strong class="il hj">决策</strong>:</p><ol class=""><li id="95b6" class="kl km hi il b im in iq ir js kn jw ko ka kp jg kz kr ks kt bi translated">测试名称:应该包括测试内容和预期结果</li><li id="503f" class="kl km hi il b im ku iq kv js kw jw kx ka ky jg kz kr ks kt bi translated"><strong class="il hj">准备</strong>:创建具有特定行为的模拟对象，并将其注入到被测组件中</li><li id="d96d" class="kl km hi il b im ku iq kv js kw jw kx ka ky jg kz kr ks kt bi translated"><strong class="il hj">执行组件的行为:</strong>运行我们想要测试的方法</li><li id="4c39" class="kl km hi il b im ku iq kv js kw jw kx ka ky jg kz kr ks kt bi translated"><strong class="il hj">决定:</strong>比较预期结果和实际结果，决定测试是否通过</li></ol><p id="7eae" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it js iv iw ix jw iz ja jb ka jd je jf jg hb bi translated">这里有一个例子:</p><figure class="lb lc ld le fd lf er es paragraph-image"><div class="er es la"><img src="../Images/ad26a22c1169c7e5e2f258c83d1a7bde.png" data-original-src="https://miro.medium.com/v2/resize:fit:1310/format:webp/1*xJ9e1YMkVSHegA8DeLoZUA.png"/></div></figure><p id="cad0" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it js iv iw ix jw iz ja jb ka jd je jf jg hb bi translated">我们有一个类<strong class="il hj"> CarProvider </strong>，它依赖IHttpClientWrapper的方法<strong class="il hj">GetCarPrice<em class="ik">(string model，int year) </em> </strong>，当给定型号和年份时，该方法将返回价格。</p><figure class="lb lc ld le fd lf er es paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="er es li"><img src="../Images/3ca41e566b223c282ec6b27a84e60b71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pnDEXv68fSvNn__m94Zwqw.png"/></div></div></figure><p id="8136" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it js iv iw ix jw iz ja jb ka jd je jf jg hb bi translated"><strong class="il hj">测试名</strong>描述了当一个异常被抛出时，我们期望从方法<em class="ik"> GetCarPrice </em>得到一个返回值0。</p><p id="a862" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it js iv iw ix jw iz ja jb ka jd je jf jg hb bi translated">在<strong class="il hj">准备</strong>部分，我们正在创建IHttpClientWrapper的模拟对象，我们将它注入到CarProvider组件中，并将其设置为抛出异常。然后，我们用模拟对象注入CarProvider组件。</p><p id="dc4d" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it js iv iw ix jw iz ja jb ka jd je jf jg hb bi translated">在<strong class="il hj">执行</strong>部分，我们调用我们测试的方法。</p><p id="fc51" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it js iv iw ix jw iz ja jb ka jd je jf jg hb bi translated">在<strong class="il hj">决策</strong>部分，我们将得到的结果与预期结果(0)进行比较，并决定测试是失败还是通过。</p><p id="2ff2" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it js iv iw ix jw iz ja jb ka jd je jf jg hb bi translated">所以不要等待代码评审，开始编写单元测试吧😉</p></div></div>    
</body>
</html>