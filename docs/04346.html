<html>
<head>
<title>You don’t really need to know HTML to render forms</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">您不需要真正了解HTML来呈现表单</h1>
<blockquote>原文：<a href="https://medium.com/codex/you-dont-really-need-to-know-html-to-render-forms-49ab5769aef0?source=collection_archive---------13-----------------------#2021-11-22">https://medium.com/codex/you-dont-really-need-to-know-html-to-render-forms-49ab5769aef0?source=collection_archive---------13-----------------------#2021-11-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="2e90" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">尽管有各种各样的HTML控件和各种各样的使用模式来产生一个现代的用户界面，但我认为最稳定的是如何使用，最可预测的是它应该如何表现，最保守的元素是一个<a class="ae jd" href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLFormElement" rel="noopener ugc nofollow" target="_blank"> FORM </a>元素。</p><p id="f63d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦看到HTML页面中的表单元素，您会期望:</p><ul class=""><li id="cb34" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc jj jk jl jm bi translated">有一个特定的数据上下文链接到此元素</li><li id="ec60" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">表单定义了该数据上下文的边界，并且表单本身是该数据上下文的根，因此所有子HTML控件都相对于根工作</li><li id="15cc" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">表单定义了对其拥有的数据的验证约束</li><li id="b803" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">表单在元素和数据模型之间引入了数据绑定功能，通常是双向数据绑定</li><li id="0195" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">如果表单不是只读的，则存在允许对更改的业务数据做出反应的操作，例如保存、取消、验证、发布到API等</li></ul><figure class="jt ju jv jw fd jx er es paragraph-image"><div role="button" tabindex="0" class="jy jz di ka bf kb"><div class="er es js"><img src="../Images/5329b0633c7b18a1ccfbbc8f994cca03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*uWSix4HmZuUjrda3"/></div></div><figcaption class="ke kf et er es kg kh bd b be z dx translated"><a class="ae jd" href="https://unsplash.com/@valerysysoev?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">瓦列里·塞索耶夫</a>在<a class="ae jd" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="7a9b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">大多数客户端应用程序使用表单来管理客户端数据，并且大多数应用程序都有数据管理页面。所以每次我们添加一个新的管理页面时，我们都要重新实现这个表单应该具有的一些特征:数据绑定、验证、用户操作等。</p><p id="0728" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">是的，我们可以引入一些可重用的模块、帮助器、包装器、复杂的自定义控件和其他抽象来简化数据管理的实现，但一般来说，从一个页面到另一个页面的过程是相同的:创建表单、添加HTML原语或复杂的自定义控件、应用数据绑定和添加动作控件或提供对表单动作的反应(如提交)。</p><p id="e088" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在现代世界中，大多数前端框架都简化了数据管理(例如Angular ngModel双向数据绑定指令)，但您需要为每个新页面从头开始:创建表单、添加HTML控件、实现/配置绑定、实现/配置验证等。</p><h1 id="5d3a" class="ki kj hi bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">改变视角</h1><p id="014f" class="pw-post-body-paragraph if ig hi ih b ii lg ik il im lh io ip iq li is it iu lj iw ix iy lk ja jb jc hb bi translated">如果我们可以改变我们的观点，不从HTML和呈现的角度，而是作为需要呈现给用户的领域上下文来检查表单构建过程，会怎么样呢？</p><p id="16ea" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们不要使用HTML规范语言，而是引入一些面向数据的DSL来描述数据应该如何呈现给最终用户。例如，假设我们想用下面的方案以只读模式(目前)表示一条单个用户信息:</p><pre class="jt ju jv jw fd ll lm ln lo aw lp bi"><span id="4ec5" class="lq kj hi lm b fi lr ls l lt lu">User {<br/>  id: string<br/>  firstName: string<br/>  lastName: string<br/>  age: Number</span><span id="7b0e" class="lq kj hi lm b fi lv ls l lt lu">  address: {<br/>    main: string<br/>  }</span><span id="15d7" class="lq kj hi lm b fi lv ls l lt lu">  permissions: {<br/>    read: boolean<br/>    write: boolean<br/>  }<br/>}</span></pre><h2 id="af3d" class="lq kj hi bd kk lw lx ly ko lz ma mb ks iq mc md kw iu me mf la iy mg mh le mi bi translated">数据元素</h2><p id="a864" class="pw-post-body-paragraph if ig hi ih b ii lg ik il im lh io ip iq li is it iu lj iw ix iy lk ja jb jc hb bi translated">为了描述我们的意图，我们需要尽可能少的属性:</p><ul class=""><li id="96b8" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc jj jk jl jm bi translated"><em class="mj">绑定</em>:从路由节点(用户)到我们要绑定的属性的路径(例如<em class="mj"> address.main </em>)</li><li id="b1ac" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated"><em class="mj"> type </em>:该字段的数据类型(通常是数据原语，如<em class="mj">字符串</em>、<em class="mj">数字</em></li><li id="17fb" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated"><em class="mj">渲染器</em>:我们希望如何表示这段数据(例如，使用<em class="mj">文本框</em>)</li></ul><p id="8df7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">示例:</p><pre class="jt ju jv jw fd ll lm ln lo aw lp bi"><span id="8467" class="lq kj hi lm b fi lr ls l lt lu">{<br/>  binding: address.main<br/>  renderer: label<br/>}</span></pre><p id="bc08" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">到目前为止一切顺利。我们知道我们的数据模型结构，我们可以只使用两个属性来描述我们的意图。</p><h2 id="6cf5" class="lq kj hi bd kk lw lx ly ko lz ma mb ks iq mc md kw iu me mf la iy mg mh le mi bi translated">形状要素</h2><p id="11d5" class="pw-post-body-paragraph if ig hi ih b ii lg ik il im lh io ip iq li is it iu lj iw ix iy lk ja jb jc hb bi translated">下一步是将原子元描述符组合成一个表单组件。因此，我们需要具有更高级数据API的元素，能够与数据源交互并控制内部数据处理。为此，我们来介绍一下表单描述属性:</p><ul class=""><li id="12b9" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc jj jk jl jm bi translated"><em class="mj">名称</em>:唯一的表单名称，用于区分同一页面上的每个表单</li><li id="593d" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated"><em class="mj">值</em>:直接来自我们可以指定的数据(如果我们使用一些本地数据)</li><li id="95ca" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated"><em class="mj"> valueSource </em>:链接到远程数据以加载到表单中</li><li id="e155" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated"><em class="mj">项</em>:原子数据元素表单列表包括</li></ul><p id="2430" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">示例:</p><pre class="jt ju jv jw fd ll lm ln lo aw lp bi"><span id="e064" class="lq kj hi lm b fi lr ls l lt lu">{<br/>  name: userForm<br/>  valueSource: https://some-external-source/resource/1</span><span id="44b9" class="lq kj hi lm b fi lv ls l lt lu">  items:<br/>  - binding: firstName<br/>    renderer: label</span><span id="f2bd" class="lq kj hi lm b fi lv ls l lt lu">  - binding: lastName<br/>    renderer: label</span><span id="4850" class="lq kj hi lm b fi lv ls l lt lu">  - binding: age<br/>    renderer: textbox<br/>    type: number</span><span id="f2be" class="lq kj hi lm b fi lv ls l lt lu">  - binding: address.main<br/>    renderer: textbox<br/>}</span></pre><p id="32ba" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个定义既易于阅读，又能根据我们的意图完全自我描述——我们希望从特定的URL加载数据，并将其绑定到一个包含4个数据元素的表单中，其中一些数据元素对于特定数据是只读的，一些数据元素允许更改输入数据。</p><p id="f00f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">仅此而已。如果我们没有一些复杂的依赖于表单的行为，只是想表示来自源的数据，并绑定它们以供进一步修改——我们已经充满了描述语言。</p><p id="359c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们可以使用HTML不可知的面向数据的语言来描述我们的大多数管理表单，而无需每次构建新表单时都重新发明轮子，会怎么样？话太多了，我们来复习例子。</p></div><div class="ab cl mk ml gp mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="hb hc hd he hf"><h2 id="2a4d" class="lq kj hi bd kk lw lx ly ko lz ma mb ks iq mc md kw iu me mf la iy mg mh le mi bi translated">示例1:表示用户个人信息</h2><p id="ebae" class="pw-post-body-paragraph if ig hi ih b ii lg ik il im lh io ip iq li is it iu lj iw ix iy lk ja jb jc hb bi translated">通过使用特定于用户界面的属性(label)来可视化前面的示例，使表单更加用户友好，并在输入控件之前呈现标签。此外，我们使用硬编码数据作为表单值(当数据来自内部源时的模拟示例)。</p><figure class="jt ju jv jw fd jx"><div class="bz dy l di"><div class="mr ms l"/></div><figcaption class="ke kf et er es kg kh bd b be z dx translated">简单静态形式</figcaption></figure><p id="4bad" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">结果，我们无需编写一行HTML代码就声明并呈现了用户表单页面——YAML被转换成了用户表单最常见的表示形式。</p><p id="9621" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">将“年龄”定义为数字—表单解析器使用特定类型的输入来正确表示它。</p><h2 id="7048" class="lq kj hi bd kk lw lx ly ko lz ma mb ks iq mc md kw iu me mf la iy mg mh le mi bi translated">示例2:使用远程数据</h2><p id="6bed" class="pw-post-body-paragraph if ig hi ih b ii lg ik il im lh io ip iq li is it iu lj iw ix iy lk ja jb jc hb bi translated">在这个解决方案中，从远程服务(HTTP REST)访问数据并以只读模式可视化该数据的一部分是一项微不足道的任务——我们所需要的就是通过利用属性中的“valueSource”来定义传入数据的来源</p><figure class="jt ju jv jw fd jx"><div class="bz dy l di"><div class="mr ms l"/></div><figcaption class="ke kf et er es kg kh bd b be z dx translated">远程数据</figcaption></figure><p id="48bb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因为我们知道传入数据的结构，所以我们准备了一组原语来向最终用户表示这些数据。因此，当表单实例化时，数据从远程加载并合并到表单控件中，然后呈现给用户。</p><h2 id="f212" class="lq kj hi bd kk lw lx ly ko lz ma mb ks iq mc md kw iu me mf la iy mg mh le mi bi translated">例3:集合呢？</h2><p id="bd92" class="pw-post-body-paragraph if ig hi ih b ii lg ik il im lh io ip iq li is it iu lj iw ix iy lk ja jb jc hb bi translated">集合只是一个更复杂的表示，但仍然是可以通过路径访问的数据对象。由于集合中的每个元素都可以是一个对象——我们需要对特定集合项中包含的对象进行更详细的(父子)描述</p><figure class="jt ju jv jw fd jx"><div class="bz dy l di"><div class="mr ms l"/></div><figcaption class="ke kf et er es kg kh bd b be z dx translated">带集合的表单</figcaption></figure><p id="f307" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因为我们只需要表示每个集合元素的一部分数据，所以我们使用类似的元素描述:绑定到与新的根(语言)和标签相关的数据模型。</p><p id="5833" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是仅仅表示数据并没有太大用处。在下一章中，我将介绍更有趣的使用模式:对用户的改变做出反应，验证输入，与远程资源交互，执行一个动作，等等。</p></div></div>    
</body>
</html>