<html>
<head>
<title>Structural Control Flow with Object-Oriented Programming (Part 2)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向对象编程的结构化控制流(第二部分)</h1>
<blockquote>原文：<a href="https://medium.com/codex/structural-control-flow-with-object-oriented-programming-part-2-7d18526146de?source=collection_archive---------1-----------------------#2022-04-06">https://medium.com/codex/structural-control-flow-with-object-oriented-programming-part-2-7d18526146de?source=collection_archive---------1-----------------------#2022-04-06</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="47d8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这两篇文章的前提是对我们如何考虑面向对象编程范例以及通过采用它们我们能获得什么好处进行一点重新想象。</p><p id="67df" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将从更加实际和实用的角度来看待OOP，而不是非常典型的学术<code class="du jd je jf jg b">Shape</code>、<code class="du jd je jf jg b">Circle</code>、<code class="du jd je jf jg b">Square</code>方法。</p><p id="9bcd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jh" href="https://chrlschn.medium.com/weve-been-teaching-object-oriented-programming-all-wrong-part-1-e171f57aa209" rel="noopener"> <strong class="ih hj">在上一篇文章</strong> </a>中，我们谈到了采用面向对象方法的一些简单原因，即使是在像JavaScript和TypeScript这样的面向函数的语言中。面向对象封装的一个简单且非常容易实现的好处是可发现性，并帮助我们避免当代码库遵循<a class="ae jh" href="https://martinfowler.com/eaaCatalog/transactionScript.html" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj"><em class="ji">事务脚本</em>模式</strong> </a>时变得常见的不同行为。</p><p id="dee7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是对我来说，面向对象思想的主要好处是它让你能够通过行为设计模式<a class="ae jh" href="https://refactoring.guru/design-patterns/behavioral-patterns" rel="noopener ugc nofollow" target="_blank"/>将<strong class="ih hj"><em class="ji"/></strong>改变为<strong class="ih hj"> <em class="ji">结构控制流</em> </strong> <em class="ji"> </em>，这使得复杂的代码更容易推理、扩展和维护。</p><p id="27f7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我特别选择在示例中使用TypeScript，因为它跨越了函数范式和对象范式之间的界限，开发人员经常忽略使用TypeScript的面向对象的可能性，但是这些技术和设计模式适用于任何支持面向对象原则的语言。</p></div><div class="ab cl jj jk gp jl" role="separator"><span class="jm bw bk jn jo jp"/><span class="jm bw bk jn jo jp"/><span class="jm bw bk jn jo"/></div><div class="hb hc hd he hf"><h1 id="2bf1" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">过程流与结构流</h1><p id="05d8" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">所有开发人员都熟悉过程控制流。当我们开始编写代码时，这些是我们所有人首先学到的核心结构:</p><ul class=""><li id="6e54" class="kt ku hi ih b ii ij im in iq kv iu kw iy kx jc ky kz la lb bi translated"><code class="du jd je jf jg b">if</code>报表</li><li id="22ca" class="kt ku hi ih b ii lc im ld iq le iu lf iy lg jc ky kz la lb bi translated"><code class="du jd je jf jg b">if-else-if</code>语句</li><li id="3664" class="kt ku hi ih b ii lc im ld iq le iu lf iy lg jc ky kz la lb bi translated"><code class="du jd je jf jg b">switch-case</code>报表</li></ul><p id="c77d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们举一个例子，我们有一个<code class="du jd je jf jg b">Order</code>，基于<code class="du jd je jf jg b">Order</code>的运输方式，我们想计算运输价格:</p><figure class="li lj lk ll fd lm er es paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="er es lh"><img src="../Images/4228eb9f0130650729fcf045e671a0ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1-aumRuic2crby_KTOouKA.png"/></div></div><figcaption class="lt lu et er es lv lw bd b be z dx translated">我们描述问题域的起始代码列表。第17–19行是我们要关注的地方。</figcaption></figure><p id="df9f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们感兴趣的是第17–19行的<code class="du jd je jf jg b">calculateShippingCost()</code>方法。我们的每种运输方式都有一套不同的规则，基于:</p><ul class=""><li id="75d9" class="kt ku hi ih b ii ij im in iq kv iu kw iy kx jc ky kz la lb bi translated">运输提供商</li><li id="3c0c" class="kt ku hi ih b ii lc im ld iq le iu lf iy lg jc ky kz la lb bi translated">每种运输方式特定层的产品重量</li><li id="7114" class="kt ku hi ih b ii lc im ld iq le iu lf iy lg jc ky kz la lb bi translated">并且如果包裹中有液体的话，可能需要额外费用</li></ul><p id="df2b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当然，实现这一点的简单方法是使用<code class="du jd je jf jg b">if-else</code>条件语句或<code class="du jd je jf jg b">switch-case</code>:</p><figure class="li lj lk ll fd lm er es paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="er es lx"><img src="../Images/d310c8fca0a02d0103414b2c2aea5527.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A4McQeHkjD_S-94E4EBMeA.png"/></div></div><figcaption class="lt lu et er es lv lw bd b be z dx translated">我对if-else条件进行了改动，使代码清单更加紧凑，但这是这种逻辑的典型代码。</figcaption></figure><p id="ecf0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我确信这段代码看起来很熟悉，因为每个代码库都有一些像这样的100-200行的条件块🤣(不知何故，有一个人<em class="ji">可以毫不犹豫地阅读它！).</em></p><p id="3491" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这种类型的代码存在许多问题。首先，代码很难阅读。我们只处理几个不同的变体，这已经相当复杂和有点草率了。其次，我们已经可以看到，这段代码的维护将是一个挑战。如果我们将来提供更多的交付选项，或者我们对现有的运输方式有了新的规则，我们就必须向这个条件语句添加更多的分支(例如，如果我们想添加国际运输费率)。</p><p id="cce7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这里，我们可以使用面向对象的设计原则将这个<em class="ji">程序逻辑</em>转换成<em class="ji">结构逻辑</em>。在这种情况下，我们将使用<a class="ae jh" href="https://en.wikipedia.org/wiki/Strategy_pattern" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">策略模式</strong> </a>结合<a class="ae jh" href="https://en.wikipedia.org/wiki/Factory_method_pattern" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">工厂模式</strong> </a>的变体来封装我们的规则。</p><p id="e32b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将创建一个<strong class="ih hj"> <em class="ji">抽象</em> </strong>基类，对所有运输策略的公共行为和属性进行建模；把它想象成一个模板，它定义了我们如何使用任何运输策略:</p><figure class="li lj lk ll fd lm er es paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="er es ly"><img src="../Images/d53055e129baa9dfb6dae06c6ccf970c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J1oNuEZNVHym5f4K2-cOiQ.png"/></div></div><figcaption class="lt lu et er es lv lw bd b be z dx translated">抽象基类不能被直接实例化，它定义了所有运输策略必须如何表现的契约和模板。</figcaption></figure><p id="abd4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们可以实现代表每个方法的<strong class="ih hj"> <em class="ji">具体的</em> </strong>类。在TypeScript中，这是使用<code class="du jd je jf jg b">extends</code>关键字完成的。注意当我们扩展<code class="du jd je jf jg b">ShippingStrategy</code>时会发生什么:</p><figure class="li lj lk ll fd lm er es paragraph-image"><div class="er es lz"><img src="../Images/c60c27bed78a8bbbed1d241af91a7ac6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1274/format:webp/1*UMTnCeJ7SlOsa1NlSv0zZQ.png"/></div><figcaption class="lt lu et er es lv lw bd b be z dx translated">我们的intellisense检测到我们的实现有错误，因为根据约定，我们的实现是不完整的。</figcaption></figure><p id="60bf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">抽象类<em class="ji">定义了一个契约——</em>任何<code class="du jd je jf jg b">abstract</code>成员<strong class="ih hj"> <em class="ji">都必须</em> </strong>被实现——因此，直到我们实现了<code class="du jd je jf jg b">calculate()</code>方法，我们的实现才是完整的。</p><p id="15de" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这比看起来更强大。通过定义契约，它向代码库中的其他人提供了如何在未来创建新的运输策略的提示，并且该契约包含来自订单逻辑其余部分的<code class="du jd je jf jg b">calculate()</code>的行为。</p><figure class="li lj lk ll fd lm er es paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="er es ma"><img src="../Images/abbddece6bf7e0d1b8aeb30a6d58e1d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*-uMtPZDh7oJOBw7lLChdCA.gif"/></div></div><figcaption class="lt lu et er es lv lw bd b be z dx translated">请注意基类是如何为我们提供契约的。</figcaption></figure><p id="4de2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们可以将我们的逻辑移到<code class="du jd je jf jg b">UspsShippingStrategy</code>中，并将其与我们的其他运输策略完全隔离开来！这有很多好处，包括易于测试策略，以及更好地将代码与回归测试隔离开来。</p><p id="b666" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因为USPS要求对运输液体收取额外费用，所以我们也可以通过<em class="ji">覆盖</em>基类行为将此逻辑移入策略中:</p><figure class="li lj lk ll fd lm er es paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="er es mb"><img src="../Images/86abd7342c2af9f0ac382ca62f685f59.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CH2bJLC0GdxUAW7pj87FvQ.png"/></div></div><figcaption class="lt lu et er es lv lw bd b be z dx translated">可以选择重写基类方法，以在具体的类中提供自定义逻辑。</figcaption></figure><p id="ec6a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">值得注意的一件有趣的事情是对<code class="du jd je jf jg b">this.weight</code>和<code class="du jd je jf jg b">this.hasLiquid</code>的引用。这些是由基类<code class="du jd je jf jg b">ShippingStrategy</code>自动提供给我们的代码的。</p><p id="1c75" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于每种运输方式，我们可以实施不同的策略:</p><figure class="li lj lk ll fd lm er es paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="er es mc"><img src="../Images/ca6284aaf8d161169bd01de06d5a12f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Tf4cRNtVXqUYYOzOn2rgZA.png"/></div></div><figcaption class="lt lu et er es lv lw bd b be z dx translated">UPS运输策略的逻辑(不要与USPS混淆)。</figcaption></figure><p id="c710" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请注意，我们没有覆盖<code class="du jd je jf jg b">surcharge</code>吸气剂，因为UPS不收取运输液体的附加费。在这种情况下，它将简单地从基类获取实现，基类返回乘数1x。</p><p id="e8f0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">既然我们已经有了自己的策略，我们需要一种将运输方法字符串映射到策略的机制。为此，我们通常会求助于所谓的<a class="ae jh" href="https://en.wikipedia.org/wiki/Factory_method_pattern" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">工厂模式</strong> </a>，但我们不需要太花哨。在这种情况下，我们可以创建一个简单的映射并创建一个伪工厂:</p><figure class="li lj lk ll fd lm er es paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="er es md"><img src="../Images/d76612f8b2689fc6bf488fe16d0afc7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HWdf6BOYMQEZY07vCbuEIw.png"/></div></div><figcaption class="lt lu et er es lv lw bd b be z dx translated">这看起来很复杂，但是我们只是将构造函数映射到我们的运输方法。</figcaption></figure><p id="092e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">工厂返回抽象类 <code class="du jd je jf jg b">ShippingStrategy</code>而不是具体类<em class="ji">。这是因为每一个具体的运输策略都实现了由抽象基类定义的契约，因此，我们的调用者不需要确切地知道它在与哪个策略一起工作，因为契约确保了我们与抽象类的交互对任何具体类都有效。</em></p><p id="af84" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">换句话说，我们有一个<strong class="ih hj"> <em class="ji">保证</em> </strong>任何运输策略都将为我们提供一个<code class="du jd je jf jg b">calculate()</code>方法和<code class="du jd je jf jg b">surcharge</code>属性。你可以把它想象成向你的朋友借他们的<code class="du jd je jf jg b">Phone</code>来做一个<code class="du jd je jf jg b">call()</code>。它可能是一辆<code class="du jd je jf jg b">iOSPhone</code>或<code class="du jd je jf jg b">AndoidPhone</code>；双方执行<code class="du jd je jf jg b">Phone.call()</code>的合同。</p><p id="762a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这让我们能够将<code class="du jd je jf jg b">calculateShippingCost()</code>中的高度程序化逻辑转化为结构化逻辑:</p><figure class="li lj lk ll fd lm er es paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="er es me"><img src="../Images/38ebbc219e4ea7d860fa23787dae6eff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bt6VLWjb9JnEzCDcxW391w.png"/></div></div><figcaption class="lt lu et er es lv lw bd b be z dx translated">我们将在第11行重温应用附加费的代码。</figcaption></figure><p id="ae2e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在有几个主要优势:</p><ul class=""><li id="e8a8" class="kt ku hi ih b ii ij im in iq kv iu kw iy kx jc ky kz la lb bi translated">由于我们已经将每个策略的逻辑隔离或封装在一个类中，因此<code class="du jd je jf jg b">calculateShippingCost()</code>方法的逻辑非常清晰且易于理解。</li><li id="13a3" class="kt ku hi ih b ii lc im ld iq le iu lf iy lg jc ky kz la lb bi translated">添加一个新的运输策略很容易，而且隔离得很好；如果我们在条件逻辑中犯了一个错误，我们不再需要担心破坏其他运输策略。</li><li id="54b3" class="kt ku hi ih b ii lc im ld iq le iu lf iy lg jc ky kz la lb bi translated">当添加一个新的运输策略时——比如说优步本地——我们不需要回归测试<code class="du jd je jf jg b">calculateShippingCost()</code>方法，因为我们根本不接触那个代码！</li><li id="cab2" class="kt ku hi ih b ii lc im ld iq le iu lf iy lg jc ky kz la lb bi translated">如果我们需要对所有的运输策略做一个共同的改变，我们可以在基类中做，也可以在T10中做。</li></ul><p id="f8e0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">即使在这个简单的例子中，好处也应该是显而易见的。这种将过程条件转移到结构化的、面向对象的逻辑的方法允许我们极大地简化核心业务逻辑的实现。</p></div><div class="ab cl jj jk gp jl" role="separator"><span class="jm bw bk jn jo jp"/><span class="jm bw bk jn jo jp"/><span class="jm bw bk jn jo"/></div><div class="hb hc hd he hf"><h1 id="743e" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">集中公共逻辑</h1><p id="aeb0" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">因为我们总是希望收取附加费(无论是1倍还是1.25倍)，所以我们很容易像这样改变我们的USPS策略:</p><figure class="li lj lk ll fd lm er es paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="er es mf"><img src="../Images/7a6e1551b14dae6b2677f1437882afa9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ait1bJ4axgnKvOMlGSuJYA.png"/></div></div><figcaption class="lt lu et er es lv lw bd b be z dx translated">我们计算价格时，只需在第15行加上附加费。</figcaption></figure><p id="a777" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是这样做意味着<em class="ji">任何实现该逻辑的人都必须记住应用乘数</em>。拥有抽象基类为我们提供了另一种机制，通过将调用包装到<code class="du jd je jf jg b">calculate</code>方法，使管理变得更容易:</p><figure class="li lj lk ll fd lm er es paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="er es mg"><img src="../Images/55ae21da6e0724b5b150e5d065d05385.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Jgij8lX3zScga0RCzwBZDA.png"/></div></div><figcaption class="lt lu et er es lv lw bd b be z dx translated">注意第16行的变化，在第18行应用了protected修饰符并添加了一个新方法</figcaption></figure><p id="d6be" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">同样，我们使用类的结构来帮助定义我们的逻辑。</p><p id="e4da" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在第16行，我们将<code class="du jd je jf jg b">calculate</code>方法更改为<code class="du jd je jf jg b">protected</code>，并添加了一个实际调用该方法的新方法<code class="du jd je jf jg b">getShippingPrice()</code>。这种方法的一个主要好处是，它允许我们像在第20行中所做的那样，为增加遥测和记录之类的事情集中逻辑。</p><p id="d0ba" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们查看下面的调用站点，我们可以看到<code class="du jd je jf jg b">calculate()</code>方法现在已经不可访问了:</p><figure class="li lj lk ll fd lm er es paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="er es mh"><img src="../Images/53b7cb496ae63e1408118b310dc5f0dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E2cJ2ESSuJONefyt_4LArA.png"/></div></div><figcaption class="lt lu et er es lv lw bd b be z dx translated">我们无法再访问此方法，因为我们将其标记为受保护。</figcaption></figure><p id="8ad5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是面向对象编程和正确使用访问修饰符如<code class="du jd je jf jg b">private</code>、<code class="du jd je jf jg b">protected</code>和<code class="du jd je jf jg b">public</code>的另一个好处。</p><p id="9a3f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">虽然这看起来微不足道，但这让我们能够通过将计算的内部逻辑指定为<code class="du jd je jf jg b">protected</code>并将我们的算法与外部API分离，来通知我们的调用者——你知道，我们的队友和合作者——在对象上允许什么操作。</p><p id="d4c3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是我们最后的<code class="du jd je jf jg b">Order</code>课:</p><figure class="li lj lk ll fd lm er es paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="er es mi"><img src="../Images/33d6481d26ee6d7c60c484f2923f9ebf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0SwMKYw2QH7sJ_JOWjLC7g.png"/></div></div><figcaption class="lt lu et er es lv lw bd b be z dx translated">注意第17行的变化。</figcaption></figure></div><div class="ab cl jj jk gp jl" role="separator"><span class="jm bw bk jn jo jp"/><span class="jm bw bk jn jo jp"/><span class="jm bw bk jn jo"/></div><div class="hb hc hd he hf"><h1 id="cd76" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">适应性</h1><p id="1db5" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">您可以看到这种模式在解决许多代码复杂的问题中的普遍适用性，这些问题通常使代码难以维护、重构和测试。</p><p id="d74f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">特别是，任何时候基于鉴别器存在离散的行为边界，策略和工厂模式都可以用来从结构上组织逻辑，而不是使用过程逻辑来清理代码。</p><p id="16f2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例子包括:</p><ul class=""><li id="bdc8" class="kt ku hi ih b ii ij im in iq kv iu kw iy kx jc ky kz la lb bi translated">支付处理— <code class="du jd je jf jg b">VisaProcessor</code>、<code class="du jd je jf jg b">MasterCardProcessor</code>、<code class="du jd je jf jg b">DiscoverProcessor</code>等等。</li><li id="c4ee" class="kt ku hi ih b ii lc im ld iq le iu lf iy lg jc ky kz la lb bi translated">员工薪酬— <code class="du jd je jf jg b">HourlyCompensationStrategy</code>、<code class="du jd je jf jg b">SalariedCompensationStrategy</code>、<code class="du jd je jf jg b">ContractorCompensationStrategy</code></li><li id="1a02" class="kt ku hi ih b ii lc im ld iq le iu lf iy lg jc ky kz la lb bi translated">供应商定价管理— <code class="du jd je jf jg b">AmazonPricingStrategy</code>、<code class="du jd je jf jg b">WalmartPricingStrategy</code>、<code class="du jd je jf jg b">TargetPricingStrategy</code>等等。</li></ul><p id="2dc9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">面向对象编程和相关的设计模式已经发展到可以帮助解决以逻辑的、可伸缩的和可维护的方式组织业务规则的挑战。</p></div><div class="ab cl jj jk gp jl" role="separator"><span class="jm bw bk jn jo jp"/><span class="jm bw bk jn jo jp"/><span class="jm bw bk jn jo"/></div><div class="hb hc hd he hf"><p id="300b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">虽然函数式编程目前似乎很流行，但事实是面向对象编程通常可以提供更清晰的结构化方式来组织复杂的行为和逻辑，使代码更容易理解、维护和扩展。</p><p id="ca2d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">面向对象的设计模式似乎已经失宠，因为应用它们需要学习曲线和经验(坦率地说，在大多数情况下，过于学术化的表述使它们难以接近)。许多年轻的开发人员可能仅仅通过查看试图解释这些概念的UML图而碰壁，因为随着团队采用“敏捷”并回避文档和设计，UML本身已经变得古板。但是这些设计模式经常在大型复杂的项目中经受考验，甚至可以帮助小团队对代码库进行重大改进。</p><p id="cc74" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你想更深入地探索，我强烈推荐两本关于这个主题的开创性书籍:</p><ol class=""><li id="4f19" class="kt ku hi ih b ii ij im in iq kv iu kw iy kx jc mj kz la lb bi translated"><a class="ae jh" href="https://www.amazon.com/Design-Patterns-Elements-Reusable-Object-Oriented/dp/0201633612" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">设计模式:可复用面向对象软件的要素</strong> </a></li><li id="c863" class="kt ku hi ih b ii lc im ld iq le iu lf iy lg jc mj kz la lb bi translated"><a class="ae jh" href="https://www.amazon.com/Patterns-Enterprise-Application-Architecture-Martin/dp/0321127420" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">企业应用架构模式</strong> </a></li></ol><p id="93f1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这些设计模式融合了几十年软件开发中积累的经验和知识，几乎可以应用于任何项目，因为很少有代码库是真正新颖的。</p><p id="5e81" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">希望在这个简短而实用的旅程之后，你会发现面向对象的原则是一个强大的工具——即使是在使用函数式语言的时候——并且发现这些概念不再那么抽象。</p></div><div class="ab cl jj jk gp jl" role="separator"><span class="jm bw bk jn jo jp"/><span class="jm bw bk jn jo jp"/><span class="jm bw bk jn jo"/></div><div class="hb hc hd he hf"><p id="d478" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">(完整的代码清单如下)</p><figure class="li lj lk ll fd lm"><div class="bz dy l di"><div class="mk ml l"/></div></figure></div></div>    
</body>
</html>