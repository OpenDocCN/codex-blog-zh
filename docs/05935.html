<html>
<head>
<title>Android: (Part 2) Real work of Coroutines.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Android:(第2部分)协程的实际工作。</h1>
<blockquote>原文：<a href="https://medium.com/codex/android-part-2-real-work-of-coroutines-881890f5acea?source=collection_archive---------11-----------------------#2022-04-03">https://medium.com/codex/android-part-2-real-work-of-coroutines-881890f5acea?source=collection_archive---------11-----------------------#2022-04-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/065387860b24fea7b8d638bd20212139.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xUP0WfHEAo0h0QqCUC5XUg.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">来源:谷歌图片</figcaption></figure><p id="d95a" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi js translated">本文是关于使用Android协程的系列文章的一部分。这里使用一次性请求来解决协程的实际困难。</p><p id="3ee4" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如果你是协程的新手，我推荐从系列的第一部分<em class="kb"/><a class="ae kc" rel="noopener" href="/@vinod.baste/android-part1-introduction-to-coroutines-eb36e06fb5d9"><em class="kb"/></a>开始。</p><p id="a3c9" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">本系列包括以下文章:</strong></p><div class="kd ke ez fb kf kg"><a rel="noopener follow" target="_blank" href="/@vinod.baste/android-part1-introduction-to-coroutines-eb36e06fb5d9"><div class="kh ab dw"><div class="ki ab kj cl cj kk"><h2 class="bd hj fi z dy kl ea eb km ed ef hh bi translated">Android:(第一部分)协程简介</h2><div class="kn l"><h3 class="bd b fi z dy kl ea eb km ed ef dx translated">Android有许多异步编程技术，但是选择最好的可能很棘手。有一个…</h3></div><div class="ko l"><p class="bd b fp z dy kl ea eb km ed ef dx translated">medium.com</p></div></div><div class="kp l"><div class="kq l kr ks kt kp ku io kg"/></div></div></a></div><p id="f2d3" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">让我们开始吧。</p><h1 id="2669" class="kv kw hi bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated"><strong class="ak">代码设置</strong></h1><p id="e064" class="pw-post-body-paragraph iu iv hi iw b ix lt iz ja jb lu jd je jf lv jh ji jj lw jl jm jn lx jp jq jr hb bi translated">在构造协程之前，必须首先将依赖项添加到Android项目中。首先编辑应用程序级别的build.gradle文件，并添加以下依赖项:</p><figure class="ly lz ma mb fd ij"><div class="bz dy l di"><div class="mc md l"/></div></figure><h1 id="c83f" class="kv kw hi bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">使用具有协程作用域的调度程序</h1><p id="d74b" class="pw-post-body-paragraph iu iv hi iw b ix lt iz ja jb lu jd je jf lv jh ji jj lw jl jm jn lx jp jq jr hb bi translated">一个<strong class="iw hj">协程作用域</strong>跟踪它用launch或async builder函数生成的任何协程。</p><p id="571e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">调度程序</strong>是一种定义执行协程的线程的方法。</p><figure class="ly lz ma mb fd ij"><div class="bz dy l di"><div class="mc md l"/></div></figure><p id="7048" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在上面的代码中，我们使用了3个不同的调度程序和3个不同的协程范围。</p><ul class=""><li id="ff19" class="me mf hi iw b ix iy jb jc jf mg jj mh jn mi jr mj mk ml mm bi translated"><strong class="iw hj"> <em class="kb">协查范围(Dispatchers。</em>i0):T19<em class="kb">协程范围(Dispatchers。I0)与输入/输出操作相关联，它在IO线程上运行。</em></strong></li></ul><figure class="ly lz ma mb fd ij"><div class="bz dy l di"><div class="mc md l"/></div></figure><ul class=""><li id="1d44" class="me mf hi iw b ix iy jb jc jf mg jj mh jn mi jr mj mk ml mm bi translated"><strong class="iw hj"> <em class="kb"> Globalscope。启动(调度员。</em>main):T25<em class="kb">global scope。启动(调度员。Main)与整个应用程序相关联。</em></strong></li></ul><figure class="ly lz ma mb fd ij"><div class="bz dy l di"><div class="mc md l"/></div></figure><ul class=""><li id="4c42" class="me mf hi iw b ix iy jb jc jf mg jj mh jn mi jr mj mk ml mm bi translated"><strong class="iw hj"> <em class="kb">主镜()。启动(调度员。</em>默认):</strong>主镜()。启动(调度员。Default)与实现它的活动相关联。</li></ul><figure class="ly lz ma mb fd ij"><div class="bz dy l di"><div class="mc md l"/></div></figure><p id="d01a" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">输出:</strong></p><p id="9202" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">关于被调度的线程。我们的输出为</p><figure class="ly lz ma mb fd ij"><div class="bz dy l di"><div class="mc md l"/></div></figure></div><div class="ab cl mn mo gp mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="hb hc hd he hf"><h1 id="4c86" class="kv kw hi bd kx ky mu la lb lc mv le lf lg mw li lj lk mx lm ln lo my lq lr ls bi translated">使用Suspend with函数</h1><p id="cc06" class="pw-post-body-paragraph iu iv hi iw b ix lt iz ja jb lu jd je jf lv jh ji jj lw jl jm jn lx jp jq jr hb bi translated">协程有助于实现可以挂起的功能&amp;稍后在指定点恢复，而不会阻塞线程。</p><figure class="ly lz ma mb fd ij"><div class="bz dy l di"><div class="mc md l"/></div></figure><p id="ee74" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在上面的代码片段中，我们定义了两个函数，它们是挂起函数。</p><p id="5217" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">任务1将执行并挂起1秒钟，然后任务2将执行并挂起2秒钟。</p><p id="6b9e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">为了启动这些暂停功能，我们使用了<em class="kb">协程示波器。</em></p><p id="86a3" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">输出:</strong></p><figure class="ly lz ma mb fd ij"><div class="bz dy l di"><div class="mc md l"/></div></figure><p id="30dd" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">您可以看到，第一个任务1被执行并挂起，然后协程启动另一个挂起函数任务2，它挂起以等待任何其他挂起函数完成指令。</p><blockquote class="mz na nb"><p id="f133" class="iu iv kb iw b ix iy iz ja jb jc jd je nc jg jh ji nd jk jl jm ne jo jp jq jr hb bi translated"><strong class="iw hj">注意:</strong> delay和yield是协程中使用的两个暂停点。</p></blockquote></div><div class="ab cl mn mo gp mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="hb hc hd he hf"><h1 id="2b2f" class="kv kw hi bd kx ky mu la lb lc mv le lf lg mw li lj lk mx lm ln lo my lq lr ls bi translated"><strong class="ak">职务使用</strong></h1><p id="fd0f" class="pw-post-body-paragraph iu iv hi iw b ix lt iz ja jb lu jd je jf lv jh ji jj lw jl jm jn lx jp jq jr hb bi translated"><em class="kb">作业是一个可以取消的东西，它有一个生命周期，最终会完成。</em></p><p id="d714" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">让我们看看作业是如何返回的，以及如何以编程方式使用它。</p><figure class="ly lz ma mb fd ij"><div class="bz dy l di"><div class="mc md l"/></div></figure><ul class=""><li id="c64c" class="me mf hi iw b ix iy jb jc jf mg jj mh jn mi jr mj mk ml mm bi translated"><strong class="iw hj"> job.jion(): </strong>在<strong class="iw hj">内</strong> runBlocking调用join方法被调用。这意味着一旦suspend方法执行完毕，就会调用日志。</li></ul><figure class="ly lz ma mb fd ij"><div class="bz dy l di"><div class="mc md l"/></div></figure><ul class=""><li id="05be" class="me mf hi iw b ix iy jb jc jf mg jj mh jn mi jr mj mk ml mm bi translated"><strong class="iw hj"> job.cancel(): </strong>用于停止协程，而不必等待它完成任务。</li></ul><figure class="ly lz ma mb fd ij"><div class="bz dy l di"><div class="mc md l"/></div></figure><p id="3d00" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在协程启动2秒钟后，作业被取消。</p><p id="42be" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">取消一个协程并不总是像上面例子中显示的那么简单。重要的是要记住，当使用cancel()方法时，协程应该知道cancel方法将被调用，因为有可能在协程仍在运行时调用cancel方法。换句话说，必须有足够的时间通知协程它已经被终止。</p><p id="7c2a" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">为了避免这种情况，我们必须手动检查协程是否被取消。这可以通过使用<strong class="iw hj"> isActive </strong>来检查协程是否有效来实现。</p><figure class="ly lz ma mb fd ij"><div class="bz dy l di"><div class="mc md l"/></div></figure><p id="5a7a" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">一旦任务取消。协程启动立即被取消。</p><ul class=""><li id="9559" class="me mf hi iw b ix iy jb jc jf mg jj mh jn mi jr mj mk ml mm bi translated"><strong class="iw hj"> withTimeOut(): </strong>经过指定的时间后，协程将自动取消。</li></ul><figure class="ly lz ma mb fd ij"><div class="bz dy l di"><div class="mc md l"/></div></figure><p id="9f98" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">协程启动3秒钟后，作业被取消。</p></div><div class="ab cl mn mo gp mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="hb hc hd he hf"><h1 id="a7a3" class="kv kw hi bd kx ky mu la lb lc mv le lf lg mw li lj lk mx lm ln lo my lq lr ls bi translated">参考</h1><ul class=""><li id="1ad4" class="me mf hi iw b ix lt jb lu jf nf jj ng jn nh jr mj mk ml mm bi translated"><a class="ae kc" href="https://developer.android.com/kotlin/coroutines?gclid=CjwKCAjwi6WSBhA-EiwA6Niok2lmU1xNMY8CxzZbHEY_wCNlsMHcjBUjzGamubkxndEXK33W61cZ9xoCTrIQAvD_BwE&amp;gclsrc=aw.ds" rel="noopener ugc nofollow" target="_blank"><strong class="iw hj">Android上的Kotlin协程</strong> </a></li><li id="3877" class="me mf hi iw b ix ni jb nj jf nk jj nl jn nm jr mj mk ml mm bi translated"><a class="ae kc" href="https://kotlinlang.org/docs/coroutines-basics.html" rel="noopener ugc nofollow" target="_blank"> <strong class="iw hj">协程基础知识</strong> </a></li><li id="e9cc" class="me mf hi iw b ix ni jb nj jf nk jj nl jn nm jr mj mk ml mm bi translated"><a class="ae kc" href="https://kotlinlang.org/docs/coroutines-overview.html" rel="noopener ugc nofollow" target="_blank"> <strong class="iw hj">协程</strong> </a></li></ul></div><div class="ab cl mn mo gp mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="hb hc hd he hf"><p id="90ce" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">感谢您花时间阅读这篇文章。如果你觉得这个帖子有用又有趣，请鼓掌推荐。</p><p id="e050" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如果我做错了什么，请在评论中提出来。我很想进步。</p></div></div>    
</body>
</html>