<html>
<head>
<title>LeetCode 1800. Maximum Ascending Subarray — Python Solution</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">LeetCode 1800。最大升序子数组Python解</h1>
<blockquote>原文：<a href="https://medium.com/codex/leetcode-1800-maximum-ascending-subarray-python-solution-a9680010e997?source=collection_archive---------18-----------------------#2022-06-22">https://medium.com/codex/leetcode-1800-maximum-ascending-subarray-python-solution-a9680010e997?source=collection_archive---------18-----------------------#2022-06-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="8180" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">盲75 —编程和技术面试问题—解释系列</h2></div><h2 id="eccf" class="ix iy hi bd iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju bi translated">问题是:</h2><p id="f44e" class="pw-post-body-paragraph jv jw hi jx b jy jz ij ka kb kc im kd ji ke kf kg jm kh ki kj jq kk kl km kn hb bi translated">给定一个正整数数组<strong class="jx hj"><em class="ko"/></strong>，返回<strong class="jx hj"> <em class="ko"> nums </em> </strong>中一个升序子数组的最大可能和。</p><p id="c726" class="pw-post-body-paragraph jv jw hi jx b jy kp ij ka kb kq im kd ji kr kf kg jm ks ki kj jq kt kl km kn hb bi translated">子数组被定义为数组中连续的数字序列。</p><p id="7d13" class="pw-post-body-paragraph jv jw hi jx b jy kp ij ka kb kq im kd ji kr kf kg jm ks ki kj jq kt kl km kn hb bi translated">一个子数组<strong class="jx hj"><em class="ko">【nums[l]，nums[l+1]，…，nums[r-1]，nums[r] </em> </strong>是升序如果对于所有<strong class="jx hj"> <em class="ko"> i </em> </strong>其中<strong class="jx hj"><em class="ko">l&lt;= I&lt;r</em></strong>，<strong class="jx hj"><em class="ko">nums[I]&lt;nums[I+1]</em></strong>。注意，大小为1的子数组是升序的。</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es ku"><img src="../Images/1312583c895cd1017253d470b4e09a7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*9sW_kMi7o-532KfN.png"/></div></div></figure><h2 id="5129" class="ix iy hi bd iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju bi translated">制约因素:</h2><ul class=""><li id="0509" class="lg lh hi jx b jy jz kb kc ji li jm lj jq lk kn ll lm ln lo bi translated">1&lt;= <strong class="jx hj"><em class="ko">nums . length</em></strong>&lt;= 100</li><li id="989a" class="lg lh hi jx b jy lp kb lq ji lr jm ls jq lt kn ll lm ln lo bi translated">1&lt;= <strong class="jx hj"><em class="ko">nums【I】</em></strong>&lt;= 100</li></ul><h2 id="89e8" class="ix iy hi bd iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju bi translated"><strong class="ak"> <em class="lu">解释:</em> </strong></h2><p id="f19b" class="pw-post-body-paragraph jv jw hi jx b jy jz ij ka kb kc im kd ji ke kf kg jm kh ki kj jq kk kl km kn hb bi translated">这个问题类似于<a class="ae lv" rel="noopener" href="/codex/leetcode-53-maximum-subarray-python-solution-dab6b038c2c7"> LeetCode 53。最大子数组</a>，但是更简单，因为我们知道子数组必须按升序排列。要获得这个问题的解决方案，首先需要使用动态编程技术创建一个数组来保存当前值，在本例中是子数组的总和。然后我们需要一个max sum变量来保存计算出的子数组中最大和的返回值。显然，我们必须循环遍历<strong class="jx hj"> <em class="ko"> nums </em> </strong>数组，并开始计算这些和。循环后，我们只返回我们的最大和。</p><h2 id="b074" class="ix iy hi bd iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju bi translated">动态规划解— O(n):</h2><p id="4db6" class="pw-post-body-paragraph jv jw hi jx b jy jz ij ka kb kc im kd ji ke kf kg jm kh ki kj jq kk kl km kn hb bi translated">首先我们把<strong class="jx hj"> <em class="ko"> nums </em> </strong>数组的长度保存成一个变量来节省一点时间。然后我们创建sums数组，用0填充，长度与数组<strong class="jx hj"> <em class="ko"> nums </em> </strong>相同。然后我们将这个数组的第一个元素设置为<strong class="jx hj"> <em class="ko"> nums </em> </strong>数组的第一个元素，因为它总是这个值。然后，我们将最大和的值设置为相同的值。现在是循环通过<strong class="jx hj"> <em class="ko"> nums </em> </strong>数组的时候了。我们将sums数组的当前元素设置为sums数组的前一个元素加上<strong class="jx hj"> <em class="ko"> nums </em> </strong>数组的当前值，也就是说，升序。如果不是升序，那么sums[i]就被设置为<strong class="jx hj"> <em class="ko"> nums[i] </em> </strong>。现在我们通过取其自身的最大值和这个新计算的和来计算最大和。然后一旦完成循环，返回这个最大和。</p><pre class="kv kw kx ky fd lw lx ly lz aw ma bi"><span id="c6cb" class="ix iy hi lx b fi mb mc l md me">class Solution:<br/> def maxAscendingSum(self, nums: List[int]) -&gt; int:<br/>  len_n = len(nums)<br/>  sums = [0] * len_n<br/>  sums[0] = nums[0]<br/>  max_sum = sums[0]<br/>    <br/>  for i in range(1, len_n):<br/>   sums[i] = sums[i-1] + nums[i] if nums[i] &gt; nums[i-1] else nums[i]<br/>  <br/>   max_sum = max(sums[i], max_sum)<br/>    <br/>    return max_sum</span></pre><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es mf"><img src="../Images/ee636c3b0aff4477093eb2bfb4c550b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*3UX5SNCejZnfZmHF.png"/></div></div></figure><h1 id="338c" class="mg iy hi bd iz mh mi mj jd mk ml mm jh io mn ip jl ir mo is jp iu mp iv jt mq bi translated">信息:</h1><p id="5ec6" class="pw-post-body-paragraph jv jw hi jx b jy jz ij ka kb kc im kd ji ke kf kg jm kh ki kj jq kk kl km kn hb bi translated">网址:<a class="ae lv" href="http://www.nkwade.dev/" rel="noopener ugc nofollow" target="_blank">nkwade . dev</a><br/>LinkedIn:<a class="ae lv" href="http://www.linkedin.com/in/nkwade/" rel="noopener ugc nofollow" target="_blank">linkedin.com/in/nkwade</a><br/>GitHub:<a class="ae lv" href="http://www.github.com/nkwade" rel="noopener ugc nofollow" target="_blank">github.com/nkwade</a><br/>邮箱:<a class="ae lv" href="mailto:nicholas@nkwade.dev" rel="noopener ugc nofollow" target="_blank"> nicholas@nkwade.dev </a></p></div></div>    
</body>
</html>