<html>
<head>
<title>Data Structures Primer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据结构入门</h1>
<blockquote>原文：<a href="https://medium.com/codex/data-structures-primer-b14c160cbd66?source=collection_archive---------6-----------------------#2022-01-18">https://medium.com/codex/data-structures-primer-b14c160cbd66?source=collection_archive---------6-----------------------#2022-01-18</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="fdab" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">根据您优化的目的，有许多不同的方法来保存或组织您的数据。</h2></div><p id="4ab3" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">顾名思义，数据结构是用于保存数据的结构。按照面试重要性的大致降序排列，常见的数据结构有:</p><h1 id="d156" class="jt ju hi bd jv jw jx jy jz ka kb kc kd io ke ip kf ir kg is kh iu ki iv kj kk bi translated"><strong class="ak">数组</strong></h1><p id="4d1f" class="pw-post-body-paragraph ix iy hi iz b ja kl ij jc jd km im jf jg kn ji jj jk ko jm jn jo kp jq jr js hb bi translated">数组是保存一组对象的最直接的方式。它在一个简单的对象列表中存储项目。如果你知道一个物体的索引(位置),查找速度会很快，否则会很慢。例如，检索列表中的第12个人很快，但查找所有名为“Alex”的人却很慢(因为您必须查看所有人)。</p><p id="cedd" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在大多数语言中，数组在创建后不能“增长”长度。您必须预先指定数组的长度，以后不能更改。</p><h2 id="5674" class="kq ju hi bd jv kr ks kt jz ku kv kw kd jg kx ky kf jk kz la kh jo lb lc kj ld bi translated"><strong class="ak">问题1 — </strong>给定一个正整数的排序数组，末尾有一个空格，<strong class="ak">按排序顺序插入一个元素</strong>。</h2><p id="3f11" class="pw-post-body-paragraph ix iy hi iz b ja kl ij jc jd km im jf jg kn ji jj jk ko jm jn jo kp jq jr js hb bi translated">我们可以想象我们的数组看起来像这样(末尾有一个空白点):</p><p id="b57c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi">1 4 7 8 9 _</p><p id="2ba1" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果我们需要插入一个像6这样的元素，就不能只在末尾插入。我们应该把它整理好。</p><p id="7817" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi">1 4 6 7 8 9</p><p id="cb39" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这需要向下“移动”所有元素，为6腾出空间，然后插入它。解决这个问题有两种方法:</p><p id="a241" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">方法1:从后面移动，然后插入</strong></p><p id="e0b1" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">第一种方法是移动所有元素，然后插入值x。我们必须小心不要在插入时覆盖值。我们可以从后面前进，而不是从前面转移。</p><p id="47cb" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi">1 4 7 8 9 _</p><p id="753a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们首先将9复制到空白处。然后8到9的位置。然后将7放入8所在的位置，以此类推。当我们为x找到合适的点时，我们停下来插入x。</p><figure class="lf lg lh li fd lj er es paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="er es le"><img src="../Images/5ab6b07487c1f07684bdfc59896ee516.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*cTV9IEZdVyKrG7vh"/></div></div></figure><p id="3c4e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果可以插入元素，则返回true，如果有错误，则返回false。</p><p id="db3d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">方法2:向前交换元素</strong></p><p id="e462" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">或者，我们可以通过数组向前迭代。我们对数组中的初始元素(小于x的元素)不做任何处理。那些不会被移动。然而，当我们找到x应该插入的位置时，我们交换x和数组中的当前元素。x的值现在将等于数组中的旧元素。当我们到达下一个元素时，我们想用x来交换那个值。我们对数组中的每个元素都继续这样做，直到最后。</p><p id="ab19" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">将6插入2，3，7，8，9中</p><p id="47f3" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">设定x = 6</p><p id="5b65" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">从A[0]开始I</p><p id="2bbf" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">将I移至A[1]</p><p id="6a77" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">将I移至A[2]</p><p id="0a70" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">交换A[2]和x。</p><p id="6a1f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">A = {2，3，6，8，9，_}</p><p id="1764" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">x = 7</p><p id="e349" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">交换A[3]和x。</p><p id="a42a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">A = {2，3，6，7，9，_}</p><p id="6d91" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">x = 8</p><p id="ad61" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">交换A[4]和x。</p><p id="b40e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">A = {2，3，6，7，8，_}</p><p id="8b42" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">x = 9</p><p id="e055" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">交换A[5]和x。</p><p id="b06e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">A = {2，3，6，7，8，9}</p><p id="18a7" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">x = _</p><p id="2be9" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">下面的代码实现了这个算法。</p><figure class="lf lg lh li fd lj er es paragraph-image"><div class="er es lq"><img src="../Images/4896abf3e8bfba6ea0c8c9dab9077f19.png" data-original-src="https://miro.medium.com/v2/resize:fit:918/0*nPZqnNsJOuI9x93x"/></div></figure><p id="428a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">注意，一旦第7行的if语句变为真，它将永远为真。</p><p id="02b7" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">两种算法都将花费<strong class="iz hj"> O(N)时间</strong>。</p><h2 id="c7b3" class="kq ju hi bd jv kr ks kt jz ku kv kw kd jg kx ky kf jk kz la kh jo lb lc kj ld bi translated"><strong class="ak">问题2 —反转数组中</strong>元素的顺序(不创建新数组)。</h2><p id="c5e9" class="pw-post-body-paragraph ix iy hi iz b ja kl ij jc jd km im jf jg kn ji jj jk ko jm jn jo kp jq jr js hb bi translated">乍一看，我们可能只想创建第二个数组，按顺序迭代元素，并以相反的顺序将它们插入到新数组中。不幸的是，问题说不要创建第二个数组。</p><p id="7363" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们来看一个例子:</p><p id="8ec0" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">原文:0，1，2，3，4，5，6</p><p id="73f6" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">反转:6，5，4，3，2，1，0</p><p id="37be" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">你可能会注意到，通过反转数组，我们将0放在6所在的位置，将6放在0所在的位置。同样，5和1被放在彼此的位置上。也就是说，我们在交换价值观！</p><p id="36d9" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们可以遍历数组，而不是创建第二个数组，将左边的值与右边相应的值交换。我们只需要遍历数组的左半部分，因为右半部分已经处理好了。</p><figure class="lf lg lh li fd lj er es paragraph-image"><div class="er es lr"><img src="../Images/f0873ebd439bd95521ead3637bec12e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:906/0*43PAZjPjowiLYZSw"/></div></figure><p id="1697" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">非常小心第2行和第5行的算术运算。</p><p id="b003" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">该算法将花费<strong class="iz hj"> O(N)时间</strong>。</p><h1 id="f8cd" class="jt ju hi bd jv jw jx jy jz ka kb kc kd io ke ip kf ir kg is kh iu ki iv kj kk bi translated"><strong class="ak">哈希表</strong></h1><p id="0830" class="pw-post-body-paragraph ix iy hi iz b ja kl ij jc jd km im jf jg kn ji jj jk ko jm jn jo kp jq jr js hb bi translated">哈希表(有时称为“字典”或“哈希表”)允许您将“键”映射到“值”。这个键通常是一个数字或字符串，值可以是任何类型的对象。您可以使用它将一个人的ID号映射到某个包含其他信息的对象。</p><figure class="lf lg lh li fd lj er es paragraph-image"><div class="er es ls"><img src="../Images/4bfe721007871ae51b9ef7b688914822.png" data-original-src="https://miro.medium.com/v2/resize:fit:466/0*vbLHiKyRyoMiXt9F"/></div></figure><p id="525e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是一个非常有用的数据结构，因为它允许非常快速的查找。我们一般假设一个哈希表是<strong class="iz hj"> O(1) </strong>(常数时间，不考虑数据量)对<strong class="iz hj">插入和查找元素</strong>。</p><h2 id="9aa8" class="kq ju hi bd jv kr ks kt jz ku kv kw kd jg kx ky kf jk kz la kh jo lb lc kj ld bi translated"><strong class="ak">问题3 — </strong>给定两个唯一字符串列表(A和B)，写一个程序来<strong class="ak">确定A是否是B的子集</strong>。检查A中的所有元素是否都包含在b中。</h2><p id="663b" class="pw-post-body-paragraph ix iy hi iz b ja kl ij jc jd km im jf jg kn ji jj jk ko jm jn jo kp jq jr js hb bi translated">我们被告知这两个列表包含唯一的字符串，所以我们只需要检查一个列表中的所有元素是否都包含在另一个列表中。</p><p id="24ab" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">方法1:暴力破解</strong></p><p id="ede9" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们可以通过“蛮力”来解决这个问题对于A中的每个元素，检查它是否在B中。一旦我们发现A中的元素不在B中，我们就可以返回false，因为我们知道A不是子集。我们知道，如果我们到达A的终点，还没有返回，我们可以找到每个元素。我们返回true。</p><figure class="lf lg lh li fd lj er es paragraph-image"><div class="er es lt"><img src="../Images/188286c055af5ac3950de34ecbd337ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1130/0*ARF-z6uE7FuXEsxx"/></div></figure><p id="7a7f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这个算法需要<strong class="iz hj"> O(a*b)时间</strong>，其中A是A的长度，B是B的长度。</p><p id="a0fd" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">方法2:哈希表</strong></p><p id="0732" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">早期的方法很慢，因为我们必须在B中搜索每个元素。如果一个元素在B中，只查找不是很好吗？这就是哈希表允许我们做的。我们可以建立一个B中所有元素的哈希表，然后，当我们想查找一个元素是否在B中时，我们只需要使用这个哈希表。</p><figure class="lf lg lh li fd lj er es paragraph-image"><div class="er es lu"><img src="../Images/5130d1e749be8078f7fd2b3627ebf554.png" data-original-src="https://miro.medium.com/v2/resize:fit:1372/0*TrpNggxyYv5xvT8J"/></div></figure><p id="c025" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这个算法花费<strong class="iz hj"> O(a+b)时间</strong>，其中A是A的长度，b是b的长度，保存哈希表需要O(b)额外的内存。</p><h2 id="633b" class="kq ju hi bd jv kr ks kt jz ku kv kw kd jg kx ky kf jk kz la kh jo lb lc kj ld bi translated"><strong class="ak">问题4 — </strong>给你一个销售数据的二维数组，其中第一列是产品ID，第二列是数量。编写一个函数来获取这个数据列表，并返回一个新的二维数组，其中包含每个产品ID 的<strong class="ak">总销售额。</strong></h2><p id="97ca" class="pw-post-body-paragraph ix iy hi iz b ja kl ij jc jd km im jf jg kn ji jj jk ko jm jn jo kp jq jr js hb bi translated">示例:</p><p id="d200" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">输入:</p><p id="bf47" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi">211,4</p><p id="6348" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi">262,3</p><p id="1f4b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi">211,5</p><p id="2afa" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi">216,6</p><p id="b5d3" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">输出:</p><p id="3f97" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi">211,9</p><p id="705e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi">262,3</p><p id="05a8" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi">216,6</p><p id="c497" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">该方法的输出需要是产品id及其总数的列表。</p><p id="60ef" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们可以通过使用哈希表直接做到这一点。我们遍历(productID，quantity)对的列表。对于每个值，我们在哈希表中增加它的条目，或者如果它不在哈希表中，就插入它。最后，我们将哈希表转换回数组。</p><figure class="lf lg lh li fd lj er es paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="er es lv"><img src="../Images/4c55df2811c18db4720538ffd028bf9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*B0QQp-QyST0wXBU-"/></div></div></figure><p id="4ced" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果您不知道keySet和containsKey的具体命令，也不用担心。你的面试官不应该关心这样的事情。重要的是你知道如何将一种方法转化成类似于可工作代码的东西。</p><p id="1650" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这个算法花费<strong class="iz hj"> O(N)时间</strong>，其中N是输入中的行数。</p><h1 id="c2c5" class="jt ju hi bd jv jw jx jy jz ka kb kc kd io ke ip kf ir kg is kh iu ki iv kj kk bi translated"><strong class="ak">图形和树</strong></h1><p id="9643" class="pw-post-body-paragraph ix iy hi iz b ja kl ij jc jd km im jf jg kn ji jj jk ko jm jn jo kp jq jr js hb bi translated">图<strong class="iz hj">是一组通过边连接的节点。并非所有的节点都需要连接起来——你可以有两个完全独立的子图——边可以是“有向的”或“无向的”有向边可以被认为是单行道，而无向边就像是双行道。如果图是有向的，则从v到w的边不是从w到v的边。因此，您可能能够从节点n“开车”到节点m，但不能反过来。</strong></p><figure class="lf lg lh li fd lj er es paragraph-image"><div class="er es lw"><img src="../Images/4698f253db57272cf49766dbbf2f59f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:500/0*3R8jQBd4OLqnehmK"/></div></figure><p id="f422" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">树</strong>是一种图形，其中任意两个节点通过一条且仅一条路径连接。树没有圈，因为任意两个节点之间只能有一条路径。</p><p id="7a5a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一棵树可以有多种形式，但目前最常见的是<strong class="iz hj">二叉树</strong>。二叉树是每个节点只有两个子节点的树。我们称这些节点为左节点和右节点。树上不能有任何“循环”(没有从一个节点回到自身的路径)。由于这些限制，二叉树可以用严格的分层方式表示，如下所示:</p><figure class="lf lg lh li fd lj er es paragraph-image"><div class="er es lx"><img src="../Images/0a18e18e5f005ec37979cf373d097500.png" data-original-src="https://miro.medium.com/v2/resize:fit:524/0*EWaqwmXEl34hNLBO"/></div></figure><p id="c0fa" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">通常，我们和二分搜索法树一起工作。二叉查找树是这样一棵树，其中左子树中的所有节点都小于该节点的值，而该节点的值又小于右子树中所有节点的值。上面的树是二叉查找树。</p><p id="5cd0" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果一个二叉查找树是平衡的(通常我们处理平衡的二分搜索法树)，插入一个元素，以及找到一个元素是<strong class="iz hj"> O(log n) </strong>，其中n是节点的数量。</p><h2 id="7a56" class="kq ju hi bd jv kr ks kt jz ku kv kw kd jg kx ky kf jk kz la kh jo lb lc kj ld bi translated"><strong class="ak">问题5 —将元素插入二叉查找树</strong>(按顺序)。你可以假设二叉查找树包含整数。</h2><p id="0fff" class="pw-post-body-paragraph ix iy hi iz b ja kl ij jc jd km im jf jg kn ji jj jk ko jm jn jo kp jq jr js hb bi translated">在二叉查找树中，较小的值放在节点的左侧，较大的值放在右侧。</p><p id="4831" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">实现这一点最简单的方法是递归。从根开始比较想要插入的值x，如果x小于根，调用<em class="ly"> root.left </em>上的insert。当x大于根时，调用右边的insert。如此反复，直到没有左孩子或右孩子。在那里插入x。</p><figure class="lf lg lh li fd lj er es paragraph-image"><div class="er es lz"><img src="../Images/7e89ae11707970fbfbd7badb288ba36d.png" data-original-src="https://miro.medium.com/v2/resize:fit:860/0*EfRYjJur_8yfWOYg"/></div></figure><p id="37f1" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">插入节点的<strong class="iz hj">时间将取决于树的高度。</strong>如果树是相对<strong class="iz hj">平衡的</strong>，它应该有<strong class="iz hj">高度O(log N)，</strong>其中N是树中节点的数量。然而，如果树<strong class="iz hj">非常不平衡</strong>(例如，基本上节点都在一条直线上)，那么<strong class="iz hj">的高度可能与n一样多</strong></p><h2 id="a7aa" class="kq ju hi bd jv kr ks kt jz ku kv kw kd jg kx ky kf jk kz la kh jo lb lc kj ld bi translated"><strong class="ak">问题6 — </strong>给定一个包含整数作为值的<strong class="ak">二叉查找树</strong>,<strong class="ak">计算所有数字的总和</strong> <strong class="ak">。</strong></h2><p id="35df" class="pw-post-body-paragraph ix iy hi iz b ja kl ij jc jd km im jf jg kn ji jj jk ko jm jn jo kp jq jr js hb bi translated">如果我们递归地处理这个问题，它会出奇地简单。在这种情况下,“正确的”视角意味着。</p><p id="5da9" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">假设我们想要计算树中节点的总和，如下所示:</p><figure class="lf lg lh li fd lj er es paragraph-image"><div class="er es lx"><img src="../Images/7467c3874461b282bbe01e3c5ac7e162.png" data-original-src="https://miro.medium.com/v2/resize:fit:524/0*ia0JWddm3Mqw3kOy"/></div></figure><p id="f2fe" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们可以遍历树，将它折叠成一个数组，然后计算这些值的总和。这比必要的要复杂得多。更简单的方法是考虑问题的子问题。整棵树的和将是左子树的<em class="ly">和+右子树的和+根的</em>和。</p><p id="5f29" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">sum(树_at_20) = sum(树_at_10) + sum(树_at_30) + value_at_node_20</p><p id="aa2b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在节点10得到的和可以用其子问题来定义。</p><p id="592d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">sum(树_at_10) = sum(树_at_5) + sum(树_at_15) + value_at_node_10</p><p id="9f76" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们几乎可以直接把它翻译成代码。</p><figure class="lf lg lh li fd lj er es paragraph-image"><div class="er es ma"><img src="../Images/99dd3884f7564790539e43592f4726c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/0*Icf6Hlon9Qpfyy3M"/></div></figure><p id="c53d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果我们到达路径的末端(一个空节点)，我们返回0。</p><p id="ec1c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">运行时将是<strong class="iz hj"> O(N) </strong>，其中N是树中的节点数。了解运行时的一种方法是认识到对于树中的每个节点，sum只被调用一次。</p><h1 id="5ffe" class="jt ju hi bd jv jw jx jy jz ka kb kc kd io ke ip kf ir kg is kh iu ki iv kj kk bi translated"><strong class="ak">链表</strong></h1><p id="9aaf" class="pw-post-body-paragraph ix iy hi iz b ja kl ij jc jd km im jf jg kn ji jj jk ko jm jn jo kp jq jr js hb bi translated">像二叉树一样，链表是由节点组成的数据结构，其中每个节点都有一个指向其他节点的指针。该节点在单链表中只有一个指向其下一个节点的指针。该节点在一个<strong class="iz hj">双向链表</strong>中指向它的上一个和下一个节点。如果一个链表有一个循环，这通常被认为是很有问题的，并且可能违反了链表的结构。</p><figure class="lf lg lh li fd lj er es paragraph-image"><div class="er es mb"><img src="../Images/f1be488ee1c53a6f82909bbbaf05fa8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:844/0*6OfKtNq_PhXQI1E9"/></div></figure><p id="62cf" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">在链表的<strong class="iz hj">前端</strong>插入</strong>节点可以在<strong class="iz hj"> O(1) </strong>时间内完成。但是，如果对<strong class="iz hj">列表进行了排序</strong>，并且您希望<strong class="iz hj">按照顺序</strong>插入节点，这将花费<strong class="iz hj"> O(N) </strong>时间，其中N是节点的数量，因为您必须首先找到正确的位置，这需要搜索整个列表。</p><p id="757f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">在链表中找到一个节点</strong>是<strong class="iz hj"> O(N) </strong>，不管链表是否排序。</p><h2 id="0c61" class="kq ju hi bd jv kr ks kt jz ku kv kw kd jg kx ky kf jk kz la kh jo lb lc kj ld bi translated"><strong class="ak">问题7 —将一个节点插入到一个排序链表中。</strong></h2><p id="28a1" class="pw-post-body-paragraph ix iy hi iz b ja kl ij jc jd km im jf jg kn ji jj jk ko jm jn jo kp jq jr js hb bi translated">要将一个数字按顺序插入到一个链表中，我们首先需要找到合适的位置来插入节点。然后，我们需要插入它。</p><p id="133e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">棘手的是如何处理在链表的前面插入一个节点。假设我们调用一个<em class="ly"> insertInOrder </em>方法，如下所示，它(对于这个特殊的例子)需要在链表的前面插入n:</p><p id="be59" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="ly">void insertin order(linked listnode nd，int value) </em></p><p id="f62a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">仅仅插入节点<em class="ly"> n </em>并让<em class="ly"> n.next </em>指向nd是不够的。使用链表的人不知道链表真正的<strong class="iz hj">头</strong>已经从<em class="ly">第</em>更新为<em class="ly"> n </em>。他们只有对<em class="ly">和</em>的引用。因此，在插入方法中，需要返回链表的新头。大多数时候，头部会和你调用insert之前一样。但是，有时它会改变，你需要通知打电话的人。</p><figure class="lf lg lh li fd lj er es paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="er es mc"><img src="../Images/7a28c21eb4a125b3cfd599f935d050f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*OPappYgo0j5AOxuv"/></div></div></figure><p id="b12f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这个算法花费<strong class="iz hj"> O(N)时间</strong>，其中N是节点数。</p><h2 id="5d21" class="kq ju hi bd jv kr ks kt jz ku kv kw kd jg kx ky kf jk kz la kh jo lb lc kj ld bi translated"><strong class="ak">问题8 —“排序”一个只包含0和1的链表。</strong>也就是说，修改列表，使全0出现在全1之前。</h2><p id="8602" class="pw-post-body-paragraph ix iy hi iz b ja kl ij jc jd km im jf jg kn ji jj jk ko jm jn jo kp jq jr js hb bi translated"><strong class="iz hj">方法1:构建两个链表</strong></p><p id="3dec" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最简单的方法之一是建立一个“0列表”和一个“1列表”,然后在最后将它们连接起来。</p><figure class="lf lg lh li fd lj er es paragraph-image"><div class="er es md"><img src="../Images/e44ce3930d0c6ce4b667366c800c8947.png" data-original-src="https://miro.medium.com/v2/resize:fit:784/0*ZX0CpEvD3vEttOZZ"/></div></figure><p id="a5e2" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">注意我们需要返回链表的新头，因为它可能已经改变了。</p><p id="4329" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">方法2:数零</strong></p><p id="6b30" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们不需要使用给我们的实物。如果我们移动值而不是节点，这将符合问题的要求。因此，我们可以只遍历链表一次，计算0的个数。然后，我们再次遍历它，将前k个值设置为0，其余的值设置为1。</p><figure class="lf lg lh li fd lj er es paragraph-image"><div class="er es me"><img src="../Images/41fa2fa83563e2e2c516c5e7678719ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:630/0*IkyBPJLXiVq5Q5Ry"/></div></figure><p id="4e4a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这种方法中，我们移动的是值，而不是节点。对头部的实际引用不会改变，所以我们不需要返回任何东西。</p><p id="7f61" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">方法3:交换数值</strong></p><p id="be4a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因为我们只需要移动值，所以我们也可以遍历链表，在找到0和1时交换它们。这种方法通过两个指针p和q工作，p指针寻找1，q指针寻找0。当他们找到自己的价值观时，他们就会交换。</p><p id="f3ae" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">1.从p开头。</p><p id="064d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi">0-&gt;0-&gt;0-&gt;1-&gt;1-&gt;0-&gt;1-&gt;0-&gt;1-&gt;0</p><p id="5c25" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">p</p><p id="c386" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">2.将p移到第一个1。</p><p id="dc05" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi">0-&gt;0-&gt;0-&gt;1-&gt;1-&gt;0-&gt;1-&gt;0-&gt;1-&gt;0</p><p id="8350" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">p</p><p id="fa17" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">3.从p开始p.next</p><p id="6634" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi">0-&gt;0-&gt;0-&gt;1-&gt;1-&gt;0-&gt;1-&gt;0-&gt;1-&gt;0</p><p id="0c43" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">p q</p><p id="bd4d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">4.将q移动到下一个0。</p><p id="2535" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi">0-&gt;0-&gt;0-&gt;1-&gt;1-&gt;0-&gt;1-&gt;0-&gt;1-&gt;0</p><p id="4a40" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">p q</p><p id="7ffb" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">5.交换p和q的值。</p><p id="7ed7" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi">0-&gt;0-&gt;0-&gt;0-&gt;1-&gt;1-&gt;1-&gt;0-&gt;1-&gt;0</p><p id="53c7" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">p q</p><p id="e132" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">6.重复第4步:</p><p id="24d5" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">//将p移动到下一个1</p><p id="c473" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi">0-&gt;0-&gt;0-&gt;0-&gt;1-&gt;1-&gt;1-&gt;0-&gt;1-&gt;0</p><p id="367a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">p q</p><p id="af27" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">//将q移动到下一个0</p><p id="27b4" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi">0-&gt;0-&gt;0-&gt;0-&gt;1-&gt;1-&gt;1-&gt;0-&gt;1-&gt;0</p><p id="7103" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">p q</p><p id="81ce" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">//交换</p><p id="d1d5" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi">0-&gt;0-&gt;0-&gt;0-&gt;0-&gt;1-&gt;1-&gt;1-&gt;1-&gt;0</p><p id="3bc9" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">p q</p><p id="b684" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">//将p移动到下一个1</p><p id="859c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi">0-&gt;0-&gt;0-&gt;0-&gt;0-&gt;1-&gt;1-&gt;1-&gt;1-&gt;0</p><p id="b955" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">p q</p><p id="47e4" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">//将q移动到下一个0</p><p id="cbb0" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi">0-&gt;0-&gt;0-&gt;0-&gt;0-&gt;1-&gt;1-&gt;1-&gt;1-&gt;0</p><p id="2153" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">p q</p><p id="cb0b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">//交换</p><p id="d5a9" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi">0-&gt;0-&gt;0-&gt;0-&gt;0-&gt;0-&gt;1-&gt;1-&gt;1-&gt;1</p><p id="98d3" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">p q</p><p id="847b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">换句话说，p总是指向第一个1，q指向第一个不在位置的0(也就是p后面的第一个0)。每当q找到一个0，我们就知道这个0是不合适的。我们将其值与p交换，并将p移动到下一个节点。</p><p id="c2da" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于某些人来说，这种方法可能是最不直观的，但是通过使用助手函数，它会产生相当短的代码——它会产生相当短的代码。</p><figure class="lf lg lh li fd lj er es paragraph-image"><div class="er es mf"><img src="../Images/e376d5f710ccabf946e6f012100ef571.png" data-original-src="https://miro.medium.com/v2/resize:fit:1076/0*d0RalP-EO1n5CzO7"/></div></figure><p id="e0ba" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这三种途径都是<strong class="iz hj"> O(N) </strong>。</p><h1 id="02ec" class="jt ju hi bd jv jw jx jy jz ka kb kc kd io ke ip kf ir kg is kh iu ki iv kj kk bi translated"><strong class="ak">栈</strong></h1><p id="6167" class="pw-post-body-paragraph ix iy hi iz b ja kl ij jc jd km im jf jg kn ji jj jk ko jm jn jo kp jq jr js hb bi translated">堆栈是一种数据结构，它定义了元素插入和移除的精确顺序。当添加或“推送”一个元素时，它被插入到堆栈的顶部。当一个元素被移除时，它被从栈顶“弹出”。</p><p id="07f9" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">栈被称为LIFO(后进先出)数据结构，因为最后(最近)添加的元素是第一个被删除的。</p><p id="3f86" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这样，它就像现实生活中的一叠盘子。当你把一个盘子放在一堆盘子上时，你把它放在最上面。当你拿走一个盘子时，你总是从上面拿走。</p><p id="f602" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">从堆栈中插入和移除</strong>是<strong class="iz hj"> O(1) </strong>。如果您需要查找具有特定值的元素，堆栈不是一个好的数据结构选择，因为它需要一个接一个地删除所有元素。</p><h2 id="4aa0" class="kq ju hi bd jv kr ks kt jz ku kv kw kd jg kx ky kf jk kz la kh jo lb lc kj ld bi translated"><strong class="ak">问题9 — </strong>编写一个函数，将一个堆栈作为输入，<strong class="ak">返回一个元素反转的新堆栈</strong>。</h2><p id="ce95" class="pw-post-body-paragraph ix iy hi iz b ja kl ij jc jd km im jf jg kn ji jj jk ko jm jn jo kp jq jr js hb bi translated">最直接的方法是创建一个新的堆栈，并将第一个堆栈中的元素弹出到第二个堆栈中。这将把原始堆栈的顶部元素放在新堆栈的底部。</p><figure class="lf lg lh li fd lj er es paragraph-image"><div class="er es mg"><img src="../Images/3d2583d856d528e37327d20745c40484.png" data-original-src="https://miro.medium.com/v2/resize:fit:1032/0*MJSlLzHleo6i3SDB"/></div></figure><p id="a80d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">唯一的问题是，我们的原始堆栈在这个过程中被完全清空了。</p><p id="0cb6" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果这是一个问题，您可以使用一个额外的堆栈来保存所有弹出的值。我们将弹出的值推送到临时堆栈和反转堆栈上。(这些堆栈将具有相同的元素。)一旦我们完成了从栈中弹出元素，我们就把它们从temp推回到原始栈中。</p><figure class="lf lg lh li fd lj er es paragraph-image"><div class="er es mh"><img src="../Images/6d02f3feaf30cd141617073ace5700a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1224/0*ibm5zFPsZtctnz19"/></div></figure><p id="3d11" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">两种方法都有运行时间。</p><p id="c2b3" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">第二个会经过两遍而不是一遍，但是常数不影响大O时间。请记住，大O不是一个表示某件事情需要多少秒的表达式。它表示随着输入大小变得越来越长，时间是如何缩放的(在本例中是线性的)。</p><h2 id="47ae" class="kq ju hi bd jv kr ks kt jz ku kv kw kd jg kx ky kf jk kz la kh jo lb lc kj ld bi translated"><strong class="ak">问题10 — </strong>写一个函数，让<strong class="ak">从一个栈</strong>中移除所有偶数。你应该返回原来的堆栈，而不是一个新的。</h2><p id="b5ac" class="pw-post-body-paragraph ix iy hi iz b ja kl ij jc jd km im jf jg kn ji jj jk ko jm jn jo kp jq jr js hb bi translated">对于这个问题，我们可以依赖与前一个问题的第二种方法相同的直觉:将某个东西反转两次，将元素恢复到它们原来的顺序。</p><p id="7749" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们可以一个元素一个元素地弹出堆栈。如果元素是奇数(也就是说，不是偶数)，就把它推到一个新的临时堆栈上。然后，一旦我们都完成了，把它们推回到原来的堆栈。</p><figure class="lf lg lh li fd lj er es paragraph-image"><div class="er es mi"><img src="../Images/d073928eb8b7c136a356e4880a151d23.png" data-original-src="https://miro.medium.com/v2/resize:fit:980/0*8RaROKrRhmUpluFy"/></div></figure><p id="aa0b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这个算法将花费<strong class="iz hj"> O(N)时间</strong>。既然每个元素都要过一遍，那就不能比这个更快的解决问题了。</p><h1 id="decf" class="jt ju hi bd jv jw jx jy jz ka kb kc kd io ke ip kf ir kg is kh iu ki iv kj kk bi translated"><strong class="ak">队列</strong></h1><p id="9dcb" class="pw-post-body-paragraph ix iy hi iz b ja kl ij jc jd km im jf jg kn ji jj jk ko jm jn jo kp jq jr js hb bi translated">队列本质上与堆栈相反。它不是按照后进先出的原则删除最新的项目，而是删除最早的项目。这被称为“先进先出”，因为你添加的第一个项目将是你删除的第一个项目。</p><p id="7909" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">它在现实生活中充当一个队列(或线)。当人们排队买电影票时，第一个排队的人是第一个被服务的人。当然，这就是数据结构得名的原因。</p><p id="c969" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">插入</strong>(或“入队”)和<strong class="iz hj">从队列中移除</strong>(或“出队”)是<strong class="iz hj"> O(1) </strong>。和在堆栈中一样，它不用于查找元素。</p><h2 id="bdc8" class="kq ju hi bd jv kr ks kt jz ku kv kw kd jg kx ky kf jk kz la kh jo lb lc kj ld bi translated"><strong class="ak">问题11 — </strong>写一个函数给<strong class="ak">检查两个队列是否相同</strong>(相同顺序的相同值)。修改/销毁两个队列没问题。</h2><p id="3c04" class="pw-post-body-paragraph ix iy hi iz b ja kl ij jc jd km im jf jg kn ji jj jk ko jm jn jo kp jq jr js hb bi translated">我们被允许修改这两个队列，这应该给我们一个线索，我们需要这样做。我们可以反复去掉每个链表的前面，比较值。如果值不相等，那么我们立即返回false。</p><p id="498b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当一个列表被清空时会发生什么？那得看情况。如果两个列表都是空的，我们知道链表是相同的(还没有失败)。然而，如果只有一个列表是空的，而另一个不是，我们知道这两个列表是不同的。毕竟，我们是以同样的顺序移除元素的。</p><figure class="lf lg lh li fd lj er es paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="er es mj"><img src="../Images/6fc74ebe1a5bf205a6af3a9c51ef24dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*VXoMmDyMruZczpp9"/></div></div></figure><p id="d57c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这个算法花费了<strong class="iz hj"> O(N)时间</strong>，其中N是较小列表的长度。为什么变小了？因为一旦列表为空，我们就退出。这将首先发生在较小的列表上。更大的列表有多大并不重要；不会影响运行时间。</p><h2 id="75b0" class="kq ju hi bd jv kr ks kt jz ku kv kw kd jg kx ky kf jk kz la kh jo lb lc kj ld bi translated"><strong class="ak">问题12 — </strong>写一个函数来<strong class="ak">从一个队列中移除第k个元素</strong>(保持所有其他元素在适当的位置并保持相同的顺序)。</h2><p id="4e80" class="pw-post-body-paragraph ix iy hi iz b ja kl ij jc jd km im jf jg kn ji jj jk ko jm jn jo kp jq jr js hb bi translated">请注意，如果我们不断地从前面删除元素，并将它们添加到后面，我们会得到相同的列表。因此，要删除第k个元素，我们可以只删除每个元素并重新添加它—跳过第k个元素。</p><figure class="lf lg lh li fd lj er es paragraph-image"><div class="er es mk"><img src="../Images/86702b1a1d0c2569b181195762f8fe4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:890/0*zO3x20VtwLL-6946"/></div></figure><p id="cbf0" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这个算法花费<strong class="iz hj"> O(N)时间</strong>，其中N是节点数。</p></div></div>    
</body>
</html>