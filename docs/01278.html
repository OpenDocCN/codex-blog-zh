<html>
<head>
<title>Creating reusable Linq filters (predicate builders for Where) that can be applied to different types</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">创建可应用于不同类型的可重用Linq过滤器(Where的谓词生成器)</h1>
<blockquote>原文：<a href="https://medium.com/codex/creating-reusable-linq-filters-predicate-builders-for-where-that-can-be-applied-to-different-f7b292c6c9a7?source=collection_archive---------3-----------------------#2021-04-16">https://medium.com/codex/creating-reusable-linq-filters-predicate-builders-for-where-that-can-be-applied-to-different-f7b292c6c9a7?source=collection_archive---------3-----------------------#2021-04-16</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="4c7f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一种创建可重用Linq筛选器(Where子句的谓词生成器)的方法，这些筛选器可应用于不同类型的对象。要筛选的对象字段是使用MemberExpression指定的。</p><p id="af41" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该方法适用于实体框架，包括异步操作。</p><h1 id="df79" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">主旨。什么是可重复使用的过滤器？</h1><p id="e6e6" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">例如，有订单:</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="a0c0" class="kp je hi kl b fi kq kr l ks kt">class Order {<br/>   public DateTime Start { get; set; }<br/>   public DateTime? End { get; set; }<br/>}</span></pre><p id="4c45" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您需要找到未来7天内有效的所有订单。</p><p id="4775" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用可重复使用的过滤器构建器(如果已实现)，您可以找到如下订单:</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="a44d" class="kp je hi kl b fi kq kr l ks kt">var ordersFiltred = orders<br/>   .WhereOverlap(<br/>      <em class="ku">// </em>using MemberExpressions<em class="ku"><br/></em>      <em class="ku">// </em>set up which fields to search for<em class="ku"><br/></em>      fromField: oo =&gt; oo.Start,<br/>      toField: oo =&gt; oo.End,</span><span id="59db" class="kp je hi kl b fi kv kr l ks kt"><em class="ku">      // </em>set up the search period<em class="ku"><br/></em>      from: DateTime.Now,<br/>      to: DateTime.Now.AddDays(7))<br/>   .ToList();</span></pre><p id="5354" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">相同的WhereOverlap可以重用并应用于另一个类型。例如，要搜索商务旅行:</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="22a1" class="kp je hi kl b fi kq kr l ks kt">class Trip {<br/>   public DateTime? From { get; set; }<br/>   public DateTime? To { get; set; }<br/>}</span><span id="3a44" class="kp je hi kl b fi kv kr l ks kt">var tripsFiltred = trips<br/>   .WhereOverlap(<br/>      <em class="ku">// </em>using MemberExpressions<em class="ku"><br/></em>      <em class="ku">// </em>set up which fields to search for<em class="ku"><br/></em>      fromField: oo =&gt; oo.From,<br/>      toField: oo =&gt; oo.To,</span><span id="ca50" class="kp je hi kl b fi kv kr l ks kt"><em class="ku">      // </em>set up the search period<br/>      from: DateTime.Now,<br/>      to: DateTime.Now.AddDays(7))<br/>   .ToList();</span></pre><p id="f7be" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">订单和商务旅行是不同类型的对象，它们没有通用的界面，并且搜索字段的名称也不同。然而，对于类型(订单和商务旅行)，有一个可重用的WhereOverlap过滤器。</p><p id="87cc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面描述了如何创建这样的可重用谓词生成器。</p><h1 id="a5d1" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">如何制作可重复使用的过滤器</h1><p id="7eac" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">上面描述了WhereOverlap的使用，显示其实现是合乎逻辑的。但是为了使WhereOverlap，您需要实现操作符“AND”、“OR”。所以让我们从一个更简单的例子开始。</p><p id="b021" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如，有支出和溢价:</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="d9cb" class="kp je hi kl b fi kq kr l ks kt">class Payout {<br/>   public decimal Total { get; set; }<br/>   public bool UnderControl { get; set; }<br/>}</span><span id="e797" class="kp je hi kl b fi kv kr l ks kt">class Premium {<br/>   public decimal Sum { get; set; }<br/>   public bool RequiresConfirmation { get; set; }<br/>}</span></pre><p id="ef42" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们制作一个可重复使用的过滤器来查找超过一定金额的付款:</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="6e3d" class="kp je hi kl b fi kq kr l ks kt">class UnderControlPayFilter {<br/>   readonly decimal Limit;<br/>   public UnderControlPayFilter(decimal limit) {<br/>      Limit = limit;<br/>   }</span><span id="d020" class="kp je hi kl b fi kv kr l ks kt">   public Expression&lt;Func&lt;TEnt, bool&gt;&gt; Create&lt;TEnt&gt;(<br/>      Expression&lt;Func&lt;TEnt, decimal&gt;&gt; sumField) {</span><span id="290d" class="kp je hi kl b fi kv kr l ks kt">      /<em class="ku">/ GreaterOrEqual - </em>need to be implemented<em class="ku"><br/></em>      <em class="ku">// GreaterOrEqual - is extension, </em>which takes arguments<em class="ku"><br/>   </em>   <em class="ku">//  - field </em>designation<em class="ku">(Expression sumField)<br/></em>      <em class="ku">//  - and </em>the value to be compared with <em class="ku">(Limit)<br/>   </em>   return sumField.GreaterOrEqual(Limit);<br/>   }<br/>}</span></pre><p id="4791" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用UnderControlPayFilter过滤器的示例:</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="f4c1" class="kp je hi kl b fi kq kr l ks kt"><em class="ku">// </em>search filter for payments requiring additional control<br/><em class="ku">//<br/>// </em>the specific limit (here 1000) can be taken out in the settings<em class="ku">,<br/>// </em>and the UnderControlPayFilter can be registered<br/>// in the IoC container<em class="ku">.<br/>// </em>Then you can centrally (through the application settings)<em class="ku"><br/>// </em>control the maximum limit<em class="ku"><br/></em>var underControlPayFilter = new UnderControlPayFilter(1000);</span><span id="08af" class="kp je hi kl b fi kv kr l ks kt">//<br/>// Applying a reusable filter for payouts</span><span id="cc4d" class="kp je hi kl b fi kv kr l ks kt">var payoutPredicate =<br/>   underControlPayFilter.Create&lt;Payout&gt;(pp =&gt; pp.Total);</span><span id="c0d5" class="kp je hi kl b fi kv kr l ks kt">// here, for simplicity, payouts is an array,<br/>// in a real application this can be an Entity Framework DbSet<br/>var payouts = new[] {<br/>   new Payout{ Total = 100 },<br/>   new Payout{ Total = 50, UnderControl = true },<br/>   new Payout{ Total = 25.5m },<br/>   new Payout{ Total = 1050.67m }<br/>}<br/>.AsQueryable()<br/>.Where(payoutPredicate)<br/>.ToList();<br/></span><span id="de06" class="kp je hi kl b fi kv kr l ks kt">//<br/>// Applying a reusable filter for premiums</span><span id="95fc" class="kp je hi kl b fi kv kr l ks kt">var premiumPredicate =<br/>   underControlPayFilter.Create&lt;Premium&gt;(pp =&gt; pp.Sum);</span><span id="541c" class="kp je hi kl b fi kv kr l ks kt">// here, for simplicity, payouts is an array,<br/>// in a real application this can be an Entity Framework DbSet<br/>var premiums = new[] {<br/>   new Premium{ Sum = 2000 },<br/>   new Premium{ Sum = 50.08m },<br/>   new Premium{ Sum = 25.5m, RequiresConfirmation = true },<br/>   new Premium{ Sum = 1070.07m } }<br/>.AsQueryable()<br/>.Where(premiumPredicate)<br/>.ToList();</span></pre><p id="0132" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">万事俱备，只欠实现更大的扩展:</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="89ef" class="kp je hi kl b fi kq kr l ks kt">public static class MemberExpressionExtensions {<br/>   public static Expression&lt;Func&lt;TEnt, bool&gt;&gt;<br/>   GreaterOrEqual&lt;TEnt, TProp&gt;(<br/>      this Expression&lt;Func&lt;TEnt, TProp&gt;&gt; field, TProp val)</span><span id="e3dc" class="kp je hi kl b fi kv kr l ks kt">      =&gt; Expression.Lambda&lt;Func&lt;TEnt, bool&gt;&gt;(<br/>            Expression.GreaterThanOrEqual(<br/>               field.Body, Expression.Constant(val, typeof(TProp))),<br/>            field.Parameters); }</span></pre><p id="5b8a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">同样，您可以实现LessOrEqual、Equal、HasNoVal等扩展。</p><h1 id="453d" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">使用AND和OR运算符的更复杂的可重用过滤器</h1><p id="2c1f" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">例如，您需要查找超过一定金额的付款以及那些特别标记为需要额外监控的付款。</p><p id="59fe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们修改下面的ControlPayFilter:</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="92fd" class="kp je hi kl b fi kq kr l ks kt">class UnderControlPayFilter {<br/>   readonly decimal Limit;<br/>   public UnderControlPayFilter(decimal limit) {<br/>      Limit = limit;  <br/>   }</span><span id="ebf2" class="kp je hi kl b fi kv kr l ks kt">   public Expression&lt;Func&lt;TEnt, bool&gt;&gt; Create&lt;TEnt&gt;(<br/>      Expression&lt;Func&lt;TEnt, decimal&gt;&gt; sumField,<br/>      Expression&lt;Func&lt;TEnt, bool&gt;&gt; controlMarkField) {</span><span id="1d8f" class="kp je hi kl b fi kv kr l ks kt"><em class="ku">         // PredicateBuilder </em>need to be implemented<em class="ku"><br/></em>         return PredicateBuilder.Or(<br/>            sumField.GreaterOrEqual(Limit),<br/>            controlMarkField.Equal(true));<br/>   }<br/>}</span></pre><p id="c81a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用示例:</p><pre class="kg kh ki kj fd kk kl km kn aw ko bi"><span id="26de" class="kp je hi kl b fi kq kr l ks kt"><em class="ku">// for payouts<br/></em>var payoutPredicate =<br/>   underControlPayFilter.Create&lt;Payout&gt;(<br/>      sumField: pp =&gt; pp.Total,<br/>      controlMarkField: pp =&gt; pp.UnderControl);</span><span id="8a38" class="kp je hi kl b fi kv kr l ks kt"><em class="ku">// for premiums<br/></em>var premiumPredicate =<br/>   underControlPayFilter.Create&lt;Premium&gt;(<br/>      sumField: pp =&gt; pp.Sum,<br/>      controlMarkField: pp =&gt; pp.RequiresConfirmation);</span></pre><p id="ae03" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">PredicateBuilder是由Pete Montgomery开发的一个通用的PredicateBuilder。</p><h1 id="cb98" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">结论</h1><p id="1d67" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">要制作自己的可重用过滤器，你只需要<a class="ae kw" href="https://petemontgomery.wordpress.com/2011/02/10/a-universal-predicatebuilder/" rel="noopener ugc nofollow" target="_blank"> PredicateBuilder </a>和<a class="ae kw" href="https://github.com/AlexeyBoiko/LinqExpr/blob/main/LinqExpr/MemberExpressionExtensions.cs" rel="noopener ugc nofollow" target="_blank">MemberExpressionExtensions</a>。只需将它们复制到您的项目中。可重用的过滤器可以被设计为扩展(如WhereOverlap)、静态帮助器或类(如UnderControlPayFilter)。</p><p id="883f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我做了几个可重复使用的过滤器——<a class="ae kw" href="https://www.nuget.org/packages/LinqExpr/" rel="noopener ugc nofollow" target="_blank">NuGet</a>，<a class="ae kw" href="https://github.com/AlexeyBoiko/LinqExpr" rel="noopener ugc nofollow" target="_blank"> GitHub </a>。</p></div></div>    
</body>
</html>