<html>
<head>
<title>Implement a chat service with Go + WebSocket</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Go + WebSocket实现聊天服务</h1>
<blockquote>原文：<a href="https://medium.com/codex/implement-a-chat-service-with-go-websocket-591cc9f9e33f?source=collection_archive---------3-----------------------#2021-10-01">https://medium.com/codex/implement-a-chat-service-with-go-websocket-591cc9f9e33f?source=collection_archive---------3-----------------------#2021-10-01</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="a8de" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">背景</h1><p id="9a7e" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">在<code class="du kb kc kd ke b">go-zero</code>开源后，很多用户询问<code class="du kb kc kd ke b">websocket</code>是否会被支持，何时会被支持，最终在<code class="du kb kc kd ke b">v1.1.6</code>我们得到了框架级支持的<code class="du kb kc kd ke b">websocket</code>，下面我们将以<code class="du kb kc kd ke b">chat</code>为例来解释如何使用<code class="du kb kc kd ke b">go-zero</code>实现一个带有<code class="du kb kc kd ke b">websocket</code>的<code class="du kb kc kd ke b">chat</code>服务。</p><h1 id="2bed" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">总设计</h1><p id="d978" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">下面我们以<code class="du kb kc kd ke b">zero-example</code>中的<code class="du kb kc kd ke b">chat</code>聊天室为例，一步步来讲解<code class="du kb kc kd ke b">websocket</code>的实现，分为以下几个部分。</p><ol class=""><li id="b43a" class="kf kg hi jf b jg kh jk ki jo kj js kk jw kl ka km kn ko kp bi translated">多客户端访问</li><li id="e04b" class="kf kg hi jf b jg kq jk kr jo ks js kt jw ku ka km kn ko kp bi translated">消息广播</li><li id="1ae8" class="kf kg hi jf b jg kq jk kr jo ks js kt jw ku ka km kn ko kp bi translated">及时的在线和离线客户端</li><li id="58f1" class="kf kg hi jf b jg kq jk kr jo ks js kt jw ku ka km kn ko kp bi translated">全双工通信【客户端本身就是发送方和接收方】。</li></ol><p id="e195" class="pw-post-body-paragraph jd je hi jf b jg kh ji jj jk ki jm jn jo kv jq jr js kw ju jv jw kx jy jz ka hb bi translated">首先，我们放一张一般数据传输的示意图。</p><figure class="kz la lb lc fd ld er es paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="er es ky"><img src="../Images/9f9d05d18be9fb8fd2535f9991b3cf7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1340/format:webp/1*OtNx0KEgQQ8EsKOnmb6F3A.png"/></div></div></figure><p id="9749" class="pw-post-body-paragraph jd je hi jf b jg kh ji jj jk ki jm jn jo kv jq jr js kw ju jv jw kx jy jz ka hb bi translated">中间有一个<code class="du kb kc kd ke b">select loop</code>是整个<code class="du kb kc kd ke b">chat</code>的<code class="du kb kc kd ke b">engine</code>。首先，支持双方沟通。</p><ul class=""><li id="2bdf" class="kf kg hi jf b jg kh jk ki jo kj js kk jw kl ka lk kn ko kp bi translated">必须有一个管道来交换数据。客户端仅从<em class="ll">管道</em>读取/传输数据。</li><li id="9875" class="kf kg hi jf b jg kq jk kr jo ks js kt jw ku ka lk kn ko kp bi translated">客户端在线。不能说你离线了还传输数据给你。</li></ul><h1 id="6cd5" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">数据流</h1><p id="b358" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">数据流是<code class="du kb kc kd ke b">engine</code>的主要功能，先不急着过代码，先想想<code class="du kb kc kd ke b">client</code>如何访问并被<code class="du kb kc kd ke b">engine</code>感知。</p><ol class=""><li id="c5fb" class="kf kg hi jf b jg kh jk ki jo kj js kk jw kl ka km kn ko kp bi translated">首先从前端发送一个<code class="du kb kc kd ke b">websocket</code>请求。</li><li id="2a31" class="kf kg hi jf b jg kq jk kr jo ks js kt jw ku ka km kn ko kp bi translated">建立联系；准备接收/发送通道。</li><li id="b782" class="kf kg hi jf b jg kq jk kr jo ks js kt jw ku ka km kn ko kp bi translated">注册到<code class="du kb kc kd ke b">engine</code>。</li></ol><figure class="kz la lb lc fd ld er es paragraph-image"><div class="er es lm"><img src="../Images/576ec89f265134d6934bedadae40a410.png" data-original-src="https://miro.medium.com/v2/resize:fit:992/format:webp/1*6t5dbwYi_vHUSz3oLkrLiQ.png"/></div></figure><p id="bd9f" class="pw-post-body-paragraph jd je hi jf b jg kh ji jj jk ki jm jn jo kv jq jr js kw ju jv jw kx jy jz ka hb bi translated">代码如下所示:</p><pre class="kz la lb lc fd ln ke lo lp aw lq bi"><span id="42d7" class="lr ig hi ke b fi ls lt l lu lv"> // HTML manipulation {js}<br/> if (window["WebSocket"]) {<br/>   conn = new WebSocket("ws://" + document.location.host + "/ws");<br/>   conn.onclose = function (evt) {<br/>     var item = document.createElement("div");<br/>     item.innerHTML = "&lt;b&gt;Connection closed.&lt;/b&gt;";<br/>     appendLog(item);<br/>   };<br/>   ...<br/> }<br/> ​<br/> // Routing<br/> engine.AddRoute(rest.Route{<br/>   Method: http.MethodGet,<br/>   Path: "/ws",<br/>   Handler: func(w http.ResponseWriter, r *http.Request) {<br/>     internal.ServeWs(hub, w, r)<br/>   },<br/> })<br/> ​<br/> // Access logic<br/> func ServeWs(hub *Hub, w http.ResponseWriter, r *http.Request) {<br/>   // escalate http requests to websockets<br/>   conn, err := upgrader.Upgrade(w, r, nil)<br/>   ...<br/>   // build client: hub{engine}, con{websocker conn}, send{channel buff}<br/>   client := &amp;Client{<br/>     hub: hub,<br/>     conn: conn,<br/>     send: make(chan []byte, bufSize),<br/>   }<br/>   client.hub.register &lt;- client<br/>   // Start client-side duplex communication, receiving and writing data<br/>   go client.writePump()<br/>   go client.readPump()<br/> }</span></pre><p id="035d" class="pw-post-body-paragraph jd je hi jf b jg kh ji jj jk ki jm jn jo kv jq jr js kw ju jv jw kx jy jz ka hb bi translated">这样，新访问的<code class="du kb kc kd ke b">client</code>被添加到<em class="ll">注册</em>通道。</p><h1 id="2393" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">轮毂发动机</h1><p id="9c69" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">当<code class="du kb kc kd ke b">engine</code>发出<em class="ll">寄存器</em>动作时，它做什么？</p><pre class="kz la lb lc fd ln ke lo lp aw lq bi"><span id="dfd2" class="lr ig hi ke b fi ls lt l lu lv"> type Hub struct {<br/>   clients map[*Client]bool // uplink clients<br/>   broadcast chan []byte // message sent by client -&gt; broadcast to other clients<br/>   register chan *Client // register chan, receive registration msg<br/>   unregister chan *Client // go offline chan<br/> }<br/> ​<br/> func (h *Hub) Run() {<br/>   for {<br/>     select {<br/>     // register chan: stored in the registry, and the data flow happens in these clients<br/>     case client := &lt;-h.register:<br/>       h.clients[client] = true<br/>     // Offline channels: remove from the registry<br/>     case client := &lt;-h.unregister:<br/>       if _, ok := h.clients[client]; ok {<br/>         delete(h.clients, client)<br/>         close(client.send)<br/>       }<br/>     // Broadcast message: sent to client in the registry, received by send and displayed to client<br/>     case message := &lt;-h.broadcast:<br/>       for client := range h.clients {<br/>         select {<br/>         case client.send &lt;- message:<br/>         default:<br/>           close(client.send)<br/>           delete(h.clients, client)<br/>         }<br/>       }<br/>     }<br/>   }<br/> }</span></pre><ol class=""><li id="fbd4" class="kf kg hi jf b jg kh jk ki jo kj js kk jw kl ka km kn ko kp bi translated">接收注册消息-&gt;添加到全局注册表</li><li id="c745" class="kf kg hi jf b jg kq jk kr jo ks js kt jw ku ka km kn ko kp bi translated">如果<code class="du kb kc kd ke b">engine.broadcast</code>收到它，它会将<em class="ll">注册表</em>中的<code class="du kb kc kd ke b">msg</code>传递给<code class="du kb kc kd ke b">client.sendChan</code>。</li></ol><p id="8199" class="pw-post-body-paragraph jd je hi jf b jg kh ji jj jk ki jm jn jo kv jq jr js kw ju jv jw kx jy jz ka hb bi translated">这样从<strong class="jf hj"> HTML - &gt;客户端- &gt; hub - &gt;其他客户端</strong>的整个数据流就一目了然了。</p><h1 id="efd6" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">广播数据</h1><p id="21ed" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">它说<code class="du kb kc kd ke b">engine.broadcast</code>接收数据，但是数据是如何发送到这里的，从页面开始？</p><pre class="kz la lb lc fd ln ke lo lp aw lq bi"><span id="71bf" class="lr ig hi ke b fi ls lt l lu lv"> func (c *Client) readPump() {<br/>   ...<br/>   for {<br/>     // 1<br/>     _, message, err := c.conn.ReadMessage()<br/>     if err ! = nil {<br/>       if websocket.IsUnexpectedCloseError(err, websocket.CloseGoingAway, websocket.CloseAbnormalClosure) {<br/>         log.Printf("error: %v", err)<br/>       }<br/>       break<br/>     }<br/>     message = bytes.TrimSpace(bytes.Replace(message, newline, space, -1))<br/>     // 2.<br/>     c.hub.broadcast &lt;- message<br/>   }<br/> }</span></pre><ol class=""><li id="cad9" class="kf kg hi jf b jg kh jk ki jo kj js kk jw kl ka km kn ko kp bi translated">从<code class="du kb kc kd ke b">conn</code>【点击页面后通过】继续阅读<code class="du kb kc kd ke b">msg</code></li><li id="ae96" class="kf kg hi jf b jg kq jk kr jo ks js kt jw ku ka km kn ko kp bi translated">将<code class="du kb kc kd ke b">msg</code>传入<code class="du kb kc kd ke b">engine.broadcast</code>向其他<code class="du kb kc kd ke b">clients</code>广播。3.</li><li id="4ace" class="kf kg hi jf b jg kq jk kr jo ks js kt jw ku ka km kn ko kp bi translated">当出现发送异常或超时时，将离线触发异常退出<code class="du kb kc kd ke b">client</code></li></ol><p id="0c7f" class="pw-post-body-paragraph jd je hi jf b jg kh ji jj jk ki jm jn jo kv jq jr js kw ju jv jw kx jy jz ka hb bi translated">同时，你应该知道不止一个<code class="du kb kc kd ke b">client</code>在发送消息，可能有很多。然后将它发送给其他客户，他们将从自己的<code class="du kb kc kd ke b">send channel</code>中读取，如下所示</p><pre class="kz la lb lc fd ln ke lo lp aw lq bi"><span id="023f" class="lr ig hi ke b fi ls lt l lu lv"> func (c *Client) writePump() {<br/>   // write timeout control<br/>   ticker := time.NewTicker(pingPeriod)<br/>   ...<br/>   for {<br/>     select {<br/>     case message, ok := &lt;-c.send:<br/>       // Extend the write timeout when receiving a message to write.<br/>       c.conn.SetWriteDeadline(time.Now().Add(writeWait))<br/>       ...<br/>       w, err := c.conn.NextWriter(websocket.TextMessage)<br/>       ...<br/>       w.Write(message)<br/> ​<br/>       // Read the messages in send in sequence and write<br/>       n := len(c.send)<br/>       for i := 0; i &lt; n; i++ {<br/>         w.Write(newline)<br/>         w.Write(&lt;-c.send)<br/>       }<br/>       ...<br/>     case &lt;-ticker:<br/>       c.conn.SetWriteDeadline(time.Now().Add(writeWait))<br/>       ...<br/>     }<br/>   }<br/> }</span></pre><p id="6816" class="pw-post-body-paragraph jd je hi jf b jg kh ji jj jk ki jm jn jo kv jq jr js kw ju jv jw kx jy jz ka hb bi translated">如上所述，<code class="du kb kc kd ke b">send</code>有来自各自客户端的msg:所以当<code class="du kb kc kd ke b">send</code>被检测到时，它继续接收消息并写入当前客户端；同时，当到达写入超时时，它检查websocket长连接是否还活着，如果是，则继续读取<code class="du kb kc kd ke b">send chan</code>，如果断开，则直接返回。</p><h1 id="57aa" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">完整的示例代码</h1><p id="1d30" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated"><a class="ae lw" href="https://github.com/zeromicro/zero-examples/tree/main/chat" rel="noopener ugc nofollow" target="_blank">https://github.com/zeromicro/zero-examples/tree/main/chat</a></p><h1 id="4ae0" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">摘要</h1><p id="7e7a" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">本文描述了如何在使用<code class="du kb kc kd ke b">go-zero</code>的情况下启动您的<code class="du kb kc kd ke b">websocket</code>项目，因此您可以根据自己的需要对其进行调整。</p><p id="37ac" class="pw-post-body-paragraph jd je hi jf b jg kh ji jj jk ki jm jn jo kv jq jr js kw ju jv jw kx jy jz ka hb bi translated">更多关于<code class="du kb kc kd ke b">go-zero</code>的设计和实现文章，请继续关注我们。</p><p id="3511" class="pw-post-body-paragraph jd je hi jf b jg kh ji jj jk ki jm jn jo kv jq jr js kw ju jv jw kx jy jz ka hb bi translated"><a class="ae lw" href="https://github.com/zeromicro/go-zero" rel="noopener ugc nofollow" target="_blank">https://github.com/zeromicro/go-zero</a></p><p id="58ff" class="pw-post-body-paragraph jd je hi jf b jg kh ji jj jk ki jm jn jo kv jq jr js kw ju jv jw kx jy jz ka hb bi translated">请随意使用<strong class="jf hj"> go-zero </strong>并给予<strong class="jf hj"> star </strong>支持我们！</p></div></div>    
</body>
</html>