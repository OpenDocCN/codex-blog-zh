<html>
<head>
<title>Stop! You’ve been using pull requests all wrong</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">停下来。你一直在错误地使用拉取请求</h1>
<blockquote>原文：<a href="https://medium.com/codex/stop-youve-been-using-pull-requests-all-wrong-79d5b5a5843c?source=collection_archive---------1-----------------------#2021-12-22">https://medium.com/codex/stop-youve-been-using-pull-requests-all-wrong-79d5b5a5843c?source=collection_archive---------1-----------------------#2021-12-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="10b0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让拉取请求1000%更有用的实用技巧</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jd"><img src="../Images/469723d5491083421da315c0d9447734.png" data-original-src="https://miro.medium.com/v2/resize:fit:472/format:webp/0*fMo3kjAkjVv_xrlq.jpg"/></div><figcaption class="jl jm et er es jn jo bd b be z dx translated"><a class="ae jp" href="https://i.pinimg.com/236x/1f/ff/f6/1ffff6d108ebf73c5d130ca7f4ead52c--meme.jpg" rel="noopener ugc nofollow" target="_blank"> src </a></figcaption></figure><p id="1c40" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">大多数成功的流程使用同行评审来确保质量。软件开发也不例外。通常，在将代码变更合并到主线分支之前，必须在拉请求中对其进行审查。</p><p id="c7a2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这些年来，我提交了一些拉取请求，并审查了大量请求。在这段时间里，我发现了一些工具和流程，对于提交请求和审阅请求的人来说，这些工具和流程使拉式请求更加有效。</p><h1 id="7c4a" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">停止争论偏好</h1><ul class=""><li id="db20" class="ko kp hi ih b ii kq im kr iq ks iu kt iy ku jc kv kw kx ky bi translated">将一个<a class="ae jp" href="https://www.perforce.com/blog/qac/what-lint-code-and-why-linting-important#:~:text=Linting%20is%20the%20automated%20checking,a%20basic%20static%20code%20analyzer.&amp;text=There%20are%20many%20code%20linters%20available%20for%20various%20programming%20languages%20today." rel="noopener ugc nofollow" target="_blank"> linter </a>添加到你的代码中，并将其挂钩到进程中(无论是在构建进程中还是在<a class="ae jp" href="https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks" rel="noopener ugc nofollow" target="_blank"> git挂钩</a>)</li></ul><p id="c529" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这确保了文件的格式是相同的，所以pull请求将只包含源代码更改(而不是显示大的更改集，因为我的ide将linux行尾更改为windows行尾)。这也将节省时间，因为审阅者不会争论无关紧要的变化，例如括号是否与if语句或next语句在同一行。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es kz"><img src="../Images/f3c4b7a53c52cf073e87de15f681087b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S8W_40eI0oUng0HjSkd_IA.png"/></div></div><figcaption class="jl jm et er es jn jo bd b be z dx translated">避免类似这样的拉取请求</figcaption></figure><h1 id="fb34" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">自动拒绝不符合标准的PRs</h1><ul class=""><li id="74f4" class="ko kp hi ih b ii kq im kr iq ks iu kt iy ku jc kv kw kx ky bi translated">向您的CI流程添加一个<a class="ae jp" href="https://www.sonarqube.org/" rel="noopener ugc nofollow" target="_blank">静态代码分析工具</a>。如果违反了规则，就让它在构建中失败</li></ul><p id="a626" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">静态代码分析提供了一种一致的、自动化的方法来确保代码符合某些标准(并且您可以在团队的基础上调整这些标准)。例如，这可以确保没有超过50行的方法，或者强制80%的单元测试覆盖率。如果拉请求不符合标准，则构建失败。这些检查甚至可以在请求其他人审阅之前进行。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es le"><img src="../Images/42a2d6b5514b1cb5f68957d0f292069a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iXzfeQi8xFwMg0IaIcjkug.png"/></div></div><figcaption class="jl jm et er es jn jo bd b be z dx translated">自动化静态代码分析，并将其添加到您的管道中</figcaption></figure><h1 id="40fb" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">在代码纠正之前关注可恢复性/缓解</h1><p id="1e9e" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq lf is it iu lg iw ix iy lh ja jb jc hb bi translated">审查代码是一个容易出错的过程。即使是最好的评论家也会犯错。考虑到错误的不可避免性(尤其是未知错误)，在审查pr时，我们应该将大部分注意力集中在用于最小化这些错误对客户影响的流程上。在实践中，这通常意味着执行以下操作</p><ul class=""><li id="9c65" class="ko kp hi ih b ii ij im in iq li iu lj iy lk jc kv kw kx ky bi translated">确保<a class="ae jp" href="https://aws.amazon.com/builders-library/ensuring-rollback-safety-during-deployments/" rel="noopener ugc nofollow" target="_blank">代码可以安全回滚</a></li><li id="3748" class="ko kp hi ih b ii ll im lm iq ln iu lo iy lp jc kv kw kx ky bi translated">确保使用<a class="ae jp" href="https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/automating-updates-to-serverless-apps.html" rel="noopener ugc nofollow" target="_blank">金丝雀或线性部署</a>(而不是一次全部使用)</li><li id="f623" class="ko kp hi ih b ii ll im lm iq ln iu lo iy lp jc kv kw kx ky bi translated">尽可能确保<a class="ae jp" rel="noopener" href="/@connorbutch/stop-making-synchronous-calls-f101af15cd46">处理是异步的</a></li><li id="6793" class="ko kp hi ih b ii ll im lm iq ln iu lo iy lp jc kv kw kx ky bi translated">确保失败事件保存在<a class="ae jp" href="https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-dead-letter-queues.html" rel="noopener ugc nofollow" target="_blank">死信队列</a>中</li><li id="19d9" class="ko kp hi ih b ii ll im lm iq ln iu lo iy lp jc kv kw kx ky bi translated">确保代码发出正确的<a class="ae jp" href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/publishingMetrics.html" rel="noopener ugc nofollow" target="_blank">自定义cloudwatch指标</a>(可能使用<a class="ae jp" href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/CloudWatch_Embedded_Metric_Format_Specification.html" rel="noopener ugc nofollow" target="_blank"> EMF </a>)</li><li id="4dfd" class="ko kp hi ih b ii ll im lm iq ln iu lo iy lp jc kv kw kx ky bi translated">确保<a class="ae jp" href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/AlarmThatSendsEmail.html" rel="noopener ugc nofollow" target="_blank"> cloudwatch对错误和延迟发出警报</a></li><li id="aa42" class="ko kp hi ih b ii ll im lm iq ln iu lo iy lp jc kv kw kx ky bi translated">确保<a class="ae jp" href="https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/automating-updates-to-serverless-apps.html" rel="noopener ugc nofollow" target="_blank">自动回滚</a>相关报警</li><li id="c673" class="ko kp hi ih b ii ll im lm iq ln iu lo iy lp jc kv kw kx ky bi translated">确保重新处理不合格项目的操作程序(<a class="ae jp" href="https://wa.aws.amazon.com/wellarchitected/2020-07-02T19-33-23/wat.concept.runbook.en.html" rel="noopener ugc nofollow" target="_blank">操作手册</a>)</li></ul><h1 id="5d4f" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">缩小PRs</h1><ul class=""><li id="7ad2" class="ko kp hi ih b ii kq im kr iq ks iu kt iy ku jc kv kw kx ky bi translated">变更集(pr)应该很小(可能只有20行)</li><li id="970b" class="ko kp hi ih b ii ll im lm iq ln iu lo iy lp jc kv kw kx ky bi translated">尝试每天至少两次重定基准/合并</li></ul><p id="a243" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通过<a class="ae jp" href="https://docs.aws.amazon.com/wellarchitected/latest/operational-excellence-pillar/design-principles.html" rel="noopener ugc nofollow" target="_blank">进行频繁的、小的、可逆的改变</a>，我们可以准确地确定什么改变导致错误/延迟增加。我们已经使用了上面定义的技术来确保最小的客户影响，所以现在我们需要担心的是将主线分支恢复到工作状态。这可以通过一个命令来完成</p><pre class="je jf jg jh fd lq lr ls lt aw lu bi"><span id="c51a" class="lv jr hi lr b fi lw lx l ly lz">git revert &lt;commitHashHere&gt;</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es ma"><img src="../Images/043ab6f9776256dd5fb66421668b1a25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W81ihqCWPux6z_dWtGDebw.png"/></div></div></figure><p id="53db" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">推动更小的变更集也使得审查拉请求变得更容易，开发人员将更有可能彻底审查它们。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es mb"><img src="../Images/23032f6401a471c9e04185c573661687.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QKsS_oAlBbZ0V_3Ze3Tp6w.png"/></div></div><figcaption class="jl jm et er es jn jo bd b be z dx translated">真的有人审核大拉请求吗？</figcaption></figure><p id="1e0c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">较小的拉取请求也最小化了引入错误的风险(<a class="ae jp" href="https://www.openrefactory.com/intelligent-code-repair-icr/" rel="noopener ugc nofollow" target="_blank">更多的代码=更多的错误</a></p><p id="79a8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这也避免了<a class="ae jp" href="https://dev.to/pencillr/merge-conflict-hell-46on" rel="noopener ugc nofollow" target="_blank">合并地狱</a>，因为一次改变的文件数量会少得多。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es mc"><img src="../Images/ecc14687391155344de065a8ca742a8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/0*UFH6NazEyPXIYM5M.jpg"/></div><figcaption class="jl jm et er es jn jo bd b be z dx translated"><a class="ae jp" href="https://media.makeameme.org/created/one-does-not-5bfeec.jpg" rel="noopener ugc nofollow" target="_blank"> src </a></figcaption></figure><h1 id="b69f" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">基于主干的开发有人吗？</h1><p id="9206" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq lf is it iu lg iw ix iy lh ja jb jc hb bi translated">随着我开始越来越频繁地创建更小的拉请求，到了拉请求本质上是一次提交的程度，我发现自己在问，“这些拉请求的目的是什么？”。我在几个团队中尝试过真正的基于主干的开发，并且发现适当的自动化是有效的。</p><h1 id="08ef" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">结论</h1><p id="6939" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq lf is it iu lg iw ix iy lh ja jb jc hb bi translated">这下你明白了。我对如何通过改进围绕拉动式请求的工具、流程和技术来产生更高质量的解决方案的建议。如果你有任何我没有在这里描述的技巧，请在评论中告诉我！</p></div></div>    
</body>
</html>