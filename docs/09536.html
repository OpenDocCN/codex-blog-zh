<html>
<head>
<title>Accelerate Your iOS Build Time Process Within Xcode</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Xcode中加速您的iOS构建时间过程</h1>
<blockquote>原文：<a href="https://medium.com/codex/accelerate-your-ios-build-time-process-within-xcode-f1c94f41db55?source=collection_archive---------9-----------------------#2022-10-26">https://medium.com/codex/accelerate-your-ios-build-time-process-within-xcode-f1c94f41db55?source=collection_archive---------9-----------------------#2022-10-26</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es im"><img src="../Images/84fd94f1248f3879797bdea56cbf93aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-rnqn_QjEgA8foyb"/></div></div><figcaption class="iy iz et er es ja jb bd b be z dx translated">照片由<a class="ae jc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae jc" href="https://unsplash.com/@ammarelamir?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">阿马尔·埃拉米尔</a>拍摄</figcaption></figure><p id="b9a2" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">当你在Xcode中构建你的iOS应用程序时，你是否一直想知道为什么你的iOS应用程序项目需要这么长时间？当你创建了一个小的改变，或者你只是想记录或打印你的一些代码，但当你再次构建它花了这么长时间？有没有什么解决方案可以加快我们的构建时间过程，从而提高我们的工作效率？</p><p id="a1e8" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">在这篇文章中，我将告诉你为什么你的iOS构建过程需要这么长时间，以及你如何加快你的构建时间过程。事不宜迟，我们进入正题。</p><p id="f010" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">通常，当您构建您的iOS应用程序项目时，Xcode会运行许多进程来将您的代码转换为iOS应用程序，但有一些进程会决定您的应用程序的构建时间进程，我们也可以加速这些进程，这些进程会被编译和链接。</p><p id="3324" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我写过一篇关于编译和链接过程的文章，这里就不多解释了，但是如果你想了解更多关于编译和链接过程的内容，可以参考这篇<a class="ae jc" href="https://danny-santoso.medium.com/how-xcode-work-when-we-build-the-ios-app-project-95fe95f0b17" rel="noopener"> <strong class="jf hj">链接</strong> </a>。</p><p id="b17f" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">不同于任何编程语言(像C++，Objective C，以及其他C语言)，swift没有任何头文件，这也就成为了我们在构建自己的程序时(尤其是编译过程时)swift编程语言耗时过长的原因之一。</p><p id="48ca" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">头文件通常包含类、子例程、变量和其他标识符的前向声明。通常，开发人员会在多个源文件中声明标准化的标识符，并可以将这些标识符放在一个头文件中。只要需要头内容，其他代码就可以包含它。这用于分离接口和实现。</p><p id="af59" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">swift等较新的编译编程语言不使用前向声明，标识符将在Swift源文件中被自动识别，并直接从动态库符号中读取。所以这就是Swift编程语言不需要不同于Objective C的头文件的原因。</p><p id="9409" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">在编译过程中，编译器会先读取头文件中的标识符，然后在链接过程中读取源文件中标识符的实现，所以当我们在头文件中声明了标识符，但在源文件中没有实现时，在链接过程中就会出错。例如，我在下面创建了两个c++文件，其中一个头文件声明了将在这两个文件中使用的所有标识符。</p><ul class=""><li id="d921" class="kb kc hi jf b jg jh jk jl jo kd js ke jw kf ka kg kh ki kj bi translated"><strong class="jf hj"> fileA.cpp </strong></li></ul><figure class="in io ip iq fd ir"><div class="bz dy l di"><div class="kk kl l"/></div></figure><ul class=""><li id="697a" class="kb kc hi jf b jg jh jk jl jo kd js ke jw kf ka kg kh ki kj bi translated"><strong class="jf hj"> fileB.cpp </strong></li></ul><figure class="in io ip iq fd ir"><div class="bz dy l di"><div class="kk kl l"/></div></figure><ul class=""><li id="c0ce" class="kb kc hi jf b jg jh jk jl jo kd js ke jw kf ka kg kh ki kj bi translated"><strong class="jf hj"> fileA.h </strong></li></ul><figure class="in io ip iq fd ir"><div class="bz dy l di"><div class="kk kl l"/></div></figure><p id="208a" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">如上例所示，我们可以运行这样的命令来编译和链接这些文件。</p><ul class=""><li id="07d6" class="kb kc hi jf b jg jh jk jl jo kd js ke jw kf ka kg kh ki kj bi translated"><strong class="jf hj">编译</strong></li></ul><pre class="in io ip iq fd km kn ko kp aw kq bi"><span id="8f14" class="kr ks hi kn b fi kt ku l kv kw">g++ -c fileA.cpp</span><span id="4694" class="kr ks hi kn b fi kx ku l kv kw">g++ -c fileB.cpp</span></pre><p id="3d3c" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">在我们运行这些命令之后，编译器将创建一个新的fileA.o和fileB.o，这些。o文件是二进制文件，我们可以用下面的命令把它们链接成一个可执行文件。</p><ul class=""><li id="82fb" class="kb kc hi jf b jg jh jk jl jo kd js ke jw kf ka kg kh ki kj bi translated"><strong class="jf hj">链接</strong></li></ul><pre class="in io ip iq fd km kn ko kp aw kq bi"><span id="071b" class="kr ks hi kn b fi kt ku l kv kw">g++ fileA.o fileB.o -o executable.out</span></pre><p id="f62a" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">这个命令将生成一个新的可执行文件(executable.out ),允许我们运行。你可以使用这个命令<code class="du ky kz la kn b">./executable.out</code>来运行这个可执行文件。</p><p id="ca30" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">现在，让我们尝试在fileB.cpp文件中命令haloB函数，并重新运行编译和链接过程。当你运行编译过程时，它将成功创建一个新的二进制文件，但是当你链接这些二进制文件时，将显示如下未定义的符号错误。</p><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es lb"><img src="../Images/4d2734ed04571d63029bd2674adb13ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*euO2Qz_3_iJyT9CkIVvT0Q.png"/></div></div></figure><p id="179e" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">这是因为当我们在头文件中声明所有的标识符时，编译器不会检查该标识符在源文件中的实现，编译器会忽略该标识符在源文件中的实现，而当涉及到链接过程时，链接器会检查该标识符在头文件中的实现是否与源文件中的实现一致。这就是为什么有头文件的编译编程语言比没有头文件的现代编程语言有更快的编译过程的原因，因为编译器会忽略标识符的实现，因为它是链接器任务。</p><p id="72c3" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">那么我们如何在iOS开发中增强我们的swift编译呢？解决方案是我们可以用框架创建一个模块化的应用程序。因为当你将你的源代码作为一个框架进行分组或模块化时，它将创建一个新的库文件，无论它是静态库还是动态库，以及任何其他的扩展文件，比如。swiftdoc，。swiftmodule、. swiftsourceinfo .和中的。swiftmodule文件它包含序列化的ASTs(可能还有SIL) —它基本上是一种二进制文件格式，相当于C框架或库的头文件。</p><p id="1060" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">所以，这就是为什么当你编译的时候，编译器会在。swiftmodule文件，并将移动到链接器来检查实现，这样编译过程不会花费太长时间。</p><p id="3962" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">不仅如此，因为我们创建了一个框架，编译器间接地要求我们将源代码分组为一个模块，这是我们构建iOS应用程序时的优势，因为编译器不会再次编译所有框架，但它会编译刚刚做出更改的框架或库，这就是为什么当您创建模块化应用程序时，它会缩短构建时间。</p><p id="2b80" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我们如何在应用程序中使用框架来创建模块化？在这里，我将一步一步地指导你使用Xcode中的一个框架创建一个模块化的app。</p><ul class=""><li id="e228" class="kb kc hi jf b jg jh jk jl jo kd js ke jw kf ka kg kh ki kj bi translated">首先，打开你的。xcodeproj，然后创建一个新的工作空间，如下图所示。</li></ul><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es lc"><img src="../Images/4994795e81175e1ea5edcd867c683d92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f3VsSEh1IR9EMhRGACCTNw.png"/></div></div></figure><ul class=""><li id="3726" class="kb kc hi jf b jg jh jk jl jo kd js ke jw kf ka kg kh ki kj bi translated">创建完新的工作空间后，它将显示一个空文件，如下图所示。</li></ul><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es ld"><img src="../Images/838277bfadef2390b9c917c172c8feac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c8jp75A8nthOig8EUrMFGA.png"/></div></div></figure><ul class=""><li id="ef29" class="kb kc hi jf b jg jh jk jl jo kd js ke jw kf ka kg kh ki kj bi translated">接下来，你需要做的就是添加你以前的。xcodeproj文件添加到您的工作区。</li></ul><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es le"><img src="../Images/334e67b915cf21043aef20fdac762eef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_P9zX6r7Devng1N9DKtCZQ.png"/></div></div></figure><ul class=""><li id="b657" class="kb kc hi jf b jg jh jk jl jo kd js ke jw kf ka kg kh ki kj bi translated">打开您的目录。xcodeproj定位，然后将其添加到您的工作区。</li></ul><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es lf"><img src="../Images/1295d91b580d80e7e09301ad373d620e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KVpJIcRnCCgvmUhX7TFPjg.png"/></div></div></figure><ul class=""><li id="36ba" class="kb kc hi jf b jg jh jk jl jo kd js ke jw kf ka kg kh ki kj bi translated">在您添加您的。xcodeproj到您的工作区，下一步是您需要创建一个新的框架，通过点击菜单栏中的文件菜单，然后选择一个新的项目。</li></ul><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es lg"><img src="../Images/6f2320b6206f54966c1b7b0a24eae26c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5nnU_UIijTsRs-FtH6jDrg.png"/></div></div></figure><ul class=""><li id="1f4b" class="kb kc hi jf b jg jh jk jl jo kd js ke jw kf ka kg kh ki kj bi translated">之后，您可以选择创建框架。</li></ul><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es lh"><img src="../Images/09c40a2e6172c45d9fd185a4aa8fbee9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nvxPeIzgK6ogMmZG9Gp4nw.png"/></div></div></figure><ul class=""><li id="43d0" class="kb kc hi jf b jg jh jk jl jo kd js ke jw kf ka kg kh ki kj bi translated">在工作区文件的根级别或与。工作区文件中的xcodeproj。</li></ul><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es li"><img src="../Images/3a5cf80eb336a9189df8531e5f630f3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y9Hd-MkxKUlvkJeoY2XD5w.png"/></div></div></figure><ul class=""><li id="bcae" class="kb kc hi jf b jg jh jk jl jo kd js ke jw kf ka kg kh ki kj bi translated">在你创建了你的新框架之后，它会如下图所示，然后你需要改变你的框架的库类型。在这里，你可以选择一个静态库作为你的mach-o类型的库。</li><li id="667a" class="kb kc hi jf b jg lj jk lk jo ll js lm jw ln ka kg kh ki kj bi translated">你们中的一些人可能想知道静态库和动态库之间的区别，在这里我将简单地解释一下它们。</li><li id="53a8" class="kb kc hi jf b jg lj jk lk jo ll js lm jw ln ka kg kh ki kj bi translated">在静态库中，它只链接所有的二进制文件，因为所有的二进制文件都已经被预编译，而在静态库中，所有已经被编译的二进制文件都将被复制粘贴到可执行的app中。但是在动态库中它会创建一个引用，在动态库中它会在运行时运行一个链接器。</li></ul><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es lo"><img src="../Images/5a67352e71e4ed86bf9465de18a59834.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IXQ3H9btFr8BgbeqwgDzEA.png"/></div></div></figure><ul class=""><li id="4730" class="kb kc hi jf b jg jh jk jl jo kd js ke jw kf ka kg kh ki kj bi translated">在您更改了库的Mach-O类型之后，您可以从主项目中复制您想要作为新模块分离的特性文件夹，并将其粘贴到您的框架模块中，并且不要忘记删除您想要在主项目中作为新模块分离的特性文件夹，因为我们已经将其复制到您的框架中。之后可以添加一个目标，选择如下图的iOS App模板。</li></ul><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es lp"><img src="../Images/0a03e76e5990414c04e9a712f3f59ef0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sFiiOm__AFnCmNN_5B-izQ.png"/></div></div></figure><ul class=""><li id="710e" class="kb kc hi jf b jg jh jk jl jo kd js ke jw kf ka kg kh ki kj bi translated">最后，你有你的模块目标应用程序，如果你想创建你的微应用程序，你可以利用它来运行你的模块页面。</li></ul><figure class="in io ip iq fd ir er es paragraph-image"><div class="er es lq"><img src="../Images/da1400d90c19d851d591f689972f86f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:636/format:webp/1*EaaTYwDpu22JvvFaXbIMhA.png"/></div></figure><ul class=""><li id="8de7" class="kb kc hi jf b jg jh jk jl jo kd js ke jw kf ka kg kh ki kj bi translated">在你的新模块应用目标中，不要忘记添加你当前的框架。你可以在下图中我标记的部分点击+按钮。</li></ul><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es lr"><img src="../Images/1fc5a97d2760a658fddb1ce891c0dbad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MnWzvLePtbPW_K-7CC_2MA.png"/></div></div></figure><ul class=""><li id="3eb6" class="kb kc hi jf b jg jh jk jl jo kd js ke jw kf ka kg kh ki kj bi translated">然后您可以选择您在上一步中创建的框架。</li></ul><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es ls"><img src="../Images/991a653c3bf09492abd2d20f6647dc21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_Jr1PRN7tO8lSQaggnDinA.png"/></div></div></figure><ul class=""><li id="6a6f" class="kb kc hi jf b jg jh jk jl jo kd js ke jw kf ka kg kh ki kj bi translated">现在，您将有您的框架链接到您的目标应用程序。</li></ul><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es lt"><img src="../Images/df59fc28c28436495be36f12b9a207e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Wuk8fiP8-VaVU0JJkSNl1g.png"/></div></div></figure><ul class=""><li id="7462" class="kb kc hi jf b jg jh jk jl jo kd js ke jw kf ka kg kh ki kj bi translated">这是你的模块应用程序的整体外观，你已经从你的主应用程序中分离出来。</li></ul><figure class="in io ip iq fd ir er es paragraph-image"><div class="er es lu"><img src="../Images/023594131424974b02e5cd020baf8e97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1064/format:webp/1*yfpluKOjuYW1Zb7ORrA7Sw.png"/></div></figure><ul class=""><li id="dbaa" class="kb kc hi jf b jg jh jk jl jo kd js ke jw kf ka kg kh ki kj bi translated">最后一件事，在你分离你的模块后，如果你复制粘贴你的特征到一个新的模块，如果你有一些XIB文件，不要忘记改变你的模块，如下图所示。</li></ul><figure class="in io ip iq fd ir er es paragraph-image"><div class="er es lv"><img src="../Images/c40b6d43430b45ca43035f996cdcec75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1036/format:webp/1*-cnTSS6v06yBbBRIvieoSw.png"/></div></figure><ul class=""><li id="15b1" class="kb kc hi jf b jg jh jk jl jo kd js ke jw kf ka kg kh ki kj bi translated">现在，您可以对所有想要分离为新模块的特性重复这些步骤。</li></ul><p id="8a9e" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">如果你想在你的iOS应用程序项目中加快你的构建时间过程，这就是步骤。通过从主应用程序中分离出一个不同的模块，如果其中一个模块有任何更改，编译器只会重新编译有更改的模块，而不会重新编译所有代码，并且通过创建一个框架，它会有。swiftmodule包含序列化的ASTs，相当于旧的编译编程语言中的头文件，用于加快编译和链接过程，这就是为什么它会加快您的构建时间过程。</p></div></div>    
</body>
</html>