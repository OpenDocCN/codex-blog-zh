<html>
<head>
<title>An Intro to Metaprogramming in Ruby</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Ruby元编程简介</h1>
<blockquote>原文：<a href="https://medium.com/codex/an-intro-to-metaprogramming-in-ruby-28f1bad3ed8e?source=collection_archive---------9-----------------------#2021-04-05">https://medium.com/codex/an-intro-to-metaprogramming-in-ruby-28f1bad3ed8e?source=collection_archive---------9-----------------------#2021-04-05</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/77788df22a2cd78b2e4b2841c2e5a816.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kLpq7ZLkw3by7leLMLT2pA.png"/></div></div></figure><h1 id="2a65" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">Ruby中的自动属性</h1><p id="cbd2" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">我经常在Ruby文档和问题栏中看到提到的一个词是“<em class="km">automagic</em>”。从表面上看，Ruby确实有自动变量和方法。然而，Ruby在幕后做了很多工作，元编程是这种自动关联背后的关键。</p></div><div class="ab cl kn ko gp kp" role="separator"><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks"/></div><div class="hb hc hd he hf"><h1 id="0dc7" class="iq ir hi bd is it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn bi translated">定义元编程</h1><p id="650d" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">互联网上流传着各种定义，试图解释什么是元编程。以下是一些例子:</p><blockquote class="kz la lb"><p id="9c9d" class="jo jp km jq b jr lc jt ju jv ld jx jy le lf kb kc lg lh kf kg li lj kj kk kl hb bi translated">"元编程是编写编写程序的程序."— <a class="ae lk" rel="noopener" href="/swlh/metaprogramming-in-ruby-1b69b1b54202">安德鲁·理查兹</a></p><p id="497f" class="jo jp km jq b jr lc jt ju jv ld jx jy le lf kb kc lg lh kf kg li lj kj kk kl hb bi translated">"元编程是为我们编写代码的实践."耶利米·塔布</p><p id="0587" class="jo jp km jq b jr lc jt ju jv ld jx jy le lf kb kc lg lh kf kg li lj kj kk kl hb bi translated">"元编程的定义是…操纵程序的程序."迪安·哈罗普</p></blockquote><p id="ef0d" class="pw-post-body-paragraph jo jp hi jq b jr lc jt ju jv ld jx jy jz lf kb kc kd lh kf kg kh lj kj kk kl hb bi translated">这些都是非常有效的定义，但对于这个概念的新手来说，它们解释不了什么。下面是Jordan Hugens的另一个定义，它给出了这个概念背后的更多细节:</p><blockquote class="ll"><p id="dcf1" class="lm ln hi bd lo lp lq lr ls lt lu kl dx translated">"元编程允许程序动态地创建方法，而不必在程序本身中定义它们."</p></blockquote><h1 id="6816" class="iq ir hi bd is it iu iv iw ix iy iz ja jb lv jd je jf lw jh ji jj lx jl jm jn bi translated">那么…这到底意味着什么呢？</h1><p id="ac96" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">为了真正解释什么是元编程，我们来看三个例子:</p><ol class=""><li id="9473" class="ly lz hi jq b jr lc jv ld jz ma kd mb kh mc kl md me mf mg bi translated">猴子补丁</li><li id="0680" class="ly lz hi jq b jr mh jv mi jz mj kd mk kh ml kl md me mf mg bi translated"><code class="du mm mn mo mp b">define_method</code></li><li id="c48f" class="ly lz hi jq b jr mh jv mi jz mj kd mk kh ml kl md me mf mg bi translated"><code class="du mm mn mo mp b">method.missing</code></li></ol></div><div class="ab cl kn ko gp kp" role="separator"><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks"/></div><div class="hb hc hd he hf"><h1 id="6a6b" class="iq ir hi bd is it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn bi translated">猴子补丁</h1><p id="bcf3" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">Ruby的一个非常强大但潜在危险的方面是能够打开任何类并改变其变量和方法。让我们观察一些工作中的元编程。</p><p id="640f" class="pw-post-body-paragraph jo jp hi jq b jr lc jt ju jv ld jx jy jz lf kb kc kd lh kf kg kh lj kj kk kl hb bi translated">在Ruby中，每个存在的类(例如:<code class="du mm mn mo mp b">String</code>、<code class="du mm mn mo mp b">Array</code>、<code class="du mm mn mo mp b">Time</code>)都是<code class="du mm mn mo mp b">Class</code>类的一个实例。当我们在<code class="du mm mn mo mp b">Class</code>类中定义一个新方法时，我们可以在任何其他类中调用它，如下所示。</p><figure class="mq mr ms mt fd ij"><div class="bz dy l di"><div class="mu mv l"/></div></figure><p id="90fe" class="pw-post-body-paragraph jo jp hi jq b jr lc jt ju jv ld jx jy jz lf kb kc kd lh kf kg kh lj kj kk kl hb bi translated">观察从同一个<code class="du mm mn mo mp b">hello_world</code>方法返回的两个不同输出。使用<code class="du mm mn mo mp b">self</code>关键字，我们的新方法能够动态地将新类的名称插入到自身中，并返回自定义字符串。</p><p id="8198" class="pw-post-body-paragraph jo jp hi jq b jr lc jt ju jv ld jx jy jz lf kb kc kd lh kf kg kh lj kj kk kl hb bi translated">这就是元编程:<strong class="jq hj">我们动态地创建了一个方法，我们的程序为我们编写代码。我们不需要进入每个类，手动将名字插入到我们的字符串中。</strong></p><h2 id="a575" class="mw ir hi bd is mx my mz iw na nb nc ja jz nd ne je kd nf ng ji kh nh ni jm nj bi translated">猴子打补丁的危险</h2><blockquote class="kz la lb"><p id="cf1c" class="jo jp km jq b jr lc jt ju jv ld jx jy le lf kb kc lg lh kf kg li lj kj kk kl hb bi translated">权力越大，责任越大…</p></blockquote><p id="f783" class="pw-post-body-paragraph jo jp hi jq b jr lc jt ju jv ld jx jy jz lf kb kc kd lh kf kg kh lj kj kk kl hb bi translated">这正是猴子打补丁的情况。看看下面我们的代码片段。</p><figure class="mq mr ms mt fd ij"><div class="bz dy l di"><div class="mu mv l"/></div></figure><p id="c24a" class="pw-post-body-paragraph jo jp hi jq b jr lc jt ju jv ld jx jy jz lf kb kc kd lh kf kg kh lj kj kk kl hb bi translated">正如你所看到的，我们能够打开Ruby中内置的<code class="du mm mn mo mp b">String</code>类并覆盖它的<code class="du mm mn mo mp b">upcase</code>方法来返回完全不同的东西。你可以想象这可能导致的潜在副作用(和头痛)</p></div><div class="ab cl kn ko gp kp" role="separator"><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks"/></div><div class="hb hc hd he hf"><h1 id="dd91" class="iq ir hi bd is it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn bi translated"><code class="du mm mn mo mp b">define_method</code></h1><p id="6a54" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">现在对元编程的工作原理有了更好的理解，我们可以深入到Ruby中一个稍微高级一点的叫做<code class="du mm mn mo mp b">define_method</code>的类方法。<code class="du mm mn mo mp b">define_method</code>的主要用途是在应用程序运行时创建方法。</p><p id="8421" class="pw-post-body-paragraph jo jp hi jq b jr lc jt ju jv ld jx jy jz lf kb kc kd lh kf kg kh lj kj kk kl hb bi translated">让我们用猴子补丁示例中的<code class="du mm mn mo mp b">DunderMifflin</code>类来演示一下。</p><figure class="mq mr ms mt fd ij"><div class="bz dy l di"><div class="mu mv l"/></div></figure><p id="b270" class="pw-post-body-paragraph jo jp hi jq b jr lc jt ju jv ld jx jy jz lf kb kc kd lh kf kg kh lj kj kk kl hb bi translated">使用<code class="du mm mn mo mp b">define_method</code>，我们能够定义一个<code class="du mm mn mo mp b">staff_intro</code>实例方法，并将其用于<code class="du mm mn mo mp b">DunderMifflin</code>的所有雇员。这是一个让我们的代码干涸的好方法！</p></div><div class="ab cl kn ko gp kp" role="separator"><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks"/></div><div class="hb hc hd he hf"><h1 id="b52d" class="iq ir hi bd is it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn bi translated">方法_缺失</h1><p id="2bb4" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">我们的最后一个例子将向我们展示Ruby最强大的方法之一。方法允许我们调用不存在的方法，并动态定义它们。</p><figure class="mq mr ms mt fd ij"><div class="bz dy l di"><div class="mu mv l"/></div></figure><p id="40cb" class="pw-post-body-paragraph jo jp hi jq b jr lc jt ju jv ld jx jy jz lf kb kc kd lh kf kg kh lj kj kk kl hb bi translated">在上面的例子中，每当我们试图调用一个不存在的方法<code class="du mm mn mo mp b">include?</code>单词<code class="du mm mn mo mp b">‘pawnee’</code>时，我们使用<code class="du mm mn mo mp b">method_missing</code>方法返回一个自定义字符串。程序不知道我们将调用什么方法名，但是我们已经把它编程为在某个条件下输出一个响应。</p><p id="b5e8" class="pw-post-body-paragraph jo jp hi jq b jr lc jt ju jv ld jx jy jz lf kb kc kd lh kf kg kh lj kj kk kl hb bi translated"><em class="km">自动的！</em></p><p id="aabb" class="pw-post-body-paragraph jo jp hi jq b jr lc jt ju jv ld jx jy jz lf kb kc kd lh kf kg kh lj kj kk kl hb bi translated">这种技术非常有用，尤其是在构建库或声明性DSL(特定领域语言)时，因为它允许程序在处理新情况时具有更大的灵活性。事实上，<code class="du mm mn mo mp b">method_missing</code>与<code class="du mm mn mo mp b">scoped_by_*</code>一起为Rails活动记录中的许多动态<a class="ae lk" href="https://apidock.com/rails/ActiveRecord/Base/method_missing/class" rel="noopener ugc nofollow" target="_blank">查找器方法提供动力！</a></p><p id="4833" class="pw-post-body-paragraph jo jp hi jq b jr lc jt ju jv ld jx jy jz lf kb kc kd lh kf kg kh lj kj kk kl hb bi translated">当使用<code class="du mm mn mo mp b">method_missing</code>时，为了让你的<a class="ae lk" href="https://makandracards.com/makandra/9821-when-overriding-method_missing-remember-to-override-respond_to_missing-as-well" rel="noopener ugc nofollow" target="_blank">动态方法与</a> <code class="du mm mn mo mp b"><a class="ae lk" href="https://makandracards.com/makandra/9821-when-overriding-method_missing-remember-to-override-respond_to_missing-as-well" rel="noopener ugc nofollow" target="_blank">#method</a></code>一起工作，同时实现<code class="du mm mn mo mp b">response_to_missing?</code>方法也很重要。然而，由于本文旨在介绍元编程，为了简洁起见，我们省略了这个细节。</p></div><div class="ab cl kn ko gp kp" role="separator"><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks"/></div><div class="hb hc hd he hf"><h1 id="c07e" class="iq ir hi bd is it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn bi translated">摘要</h1><p id="14ff" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">让我们回顾一下本文开头的定义:</p><blockquote class="kz la lb"><p id="758e" class="jo jp km jq b jr lc jt ju jv ld jx jy le lf kb kc lg lh kf kg li lj kj kk kl hb bi translated">"元编程是编写编写程序的程序."</p><p id="fa2b" class="jo jp km jq b jr lc jt ju jv ld jx jy le lf kb kc lg lh kf kg li lj kj kk kl hb bi translated">"元编程是为我们编写代码的实践."</p><p id="1e90" class="jo jp km jq b jr lc jt ju jv ld jx jy le lf kb kc lg lh kf kg li lj kj kk kl hb bi translated">"元编程的定义是…操纵程序的程序."</p><p id="80d9" class="jo jp km jq b jr lc jt ju jv ld jx jy le lf kb kc lg lh kf kg li lj kj kk kl hb bi translated">"元编程允许程序动态地创建方法，而不必在程序本身中定义它们."</p></blockquote><p id="ce86" class="pw-post-body-paragraph jo jp hi jq b jr lc jt ju jv ld jx jy jz lf kb kc kd lh kf kg kh lj kj kk kl hb bi translated">希望在阅读本文后，您能够更好地理解这些定义的含义。我们的基本猴子补丁、<code class="du mm mn mo mp b">define_method</code>和<code class="du mm mn mo mp b">method_missing</code>例子仅仅开始触及元编程的皮毛。它在许多其他语言中广泛使用，如Python、C++和TypeScript。</p><p id="1440" class="pw-post-body-paragraph jo jp hi jq b jr lc jt ju jv ld jx jy jz lf kb kc kd lh kf kg kh lj kj kk kl hb bi translated">虽然元编程很有用，但应该谨慎使用，因为它有潜在的副作用和代码维护问题。否则，元编程允许我们创建更灵活和适应性更强的程序，总体来说，学习元编程对于提高您的开发职业来说是一项很好的技能！</p><h1 id="2123" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">更多元编程</h1><figure class="mq mr ms mt fd ij"><div class="bz dy l di"><div class="nk mv l"/></div></figure><div class="nl nm ez fb nn no"><a rel="noopener follow" target="_blank" href="/swlh/metaprogramming-in-ruby-1b69b1b54202"><div class="np ab dw"><div class="nq ab nr cl cj ns"><h2 class="bd hj fi z dy nt ea eb nu ed ef hh bi translated">Ruby中的元编程</h2><div class="nv l"><h3 class="bd b fi z dy nt ea eb nu ed ef dx translated">什么是元编程？</h3></div><div class="nw l"><p class="bd b fp z dy nt ea eb nu ed ef dx translated">medium.com</p></div></div><div class="nx l"><div class="ny l nz oa ob nx oc io no"/></div></div></a></div><div class="nl nm ez fb nn no"><a href="https://www.leighhalliday.com/ruby-metaprogramming-method-missing" rel="noopener  ugc nofollow" target="_blank"><div class="np ab dw"><div class="nq ab nr cl cj ns"><h2 class="bd hj fi z dy nt ea eb nu ed ef hh bi translated">Ruby元编程-缺少方法</h2><div class="nv l"><h3 class="bd b fi z dy nt ea eb nu ed ef dx translated">method_missing是一个ruby提供的方法，当你调用一个…</h3></div><div class="nw l"><p class="bd b fp z dy nt ea eb nu ed ef dx translated">www.leighhalliday.com</p></div></div><div class="nx l"><div class="od l nz oa ob nx oc io no"/></div></div></a></div><div class="nl nm ez fb nn no"><a href="https://betterprogramming.pub/the-magic-of-metaprogramming-732f0300a5c7" rel="noopener  ugc nofollow" target="_blank"><div class="np ab dw"><div class="nq ab nr cl cj ns"><h2 class="bd hj fi z dy nt ea eb nu ed ef hh bi translated">元编程的魔力</h2><div class="nv l"><h3 class="bd b fi z dy nt ea eb nu ed ef dx translated">用抽象的魔法改造你的程序</h3></div><div class="nw l"><p class="bd b fp z dy nt ea eb nu ed ef dx translated">better编程. pub</p></div></div><div class="nx l"><div class="oe l nz oa ob nx oc io no"/></div></div></a></div></div><div class="ab cl kn ko gp kp" role="separator"><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks"/></div><div class="hb hc hd he hf"><h1 id="b802" class="iq ir hi bd is it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn bi translated">参考</h1><ul class=""><li id="d40c" class="ly lz hi jq b jr js jv jw jz of kd og kh oh kl oi me mf mg bi translated"><a class="ae lk" href="https://www.youtube.com/watch?v=lZfv4H-9ato&amp;feature=emb_title" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=lZfv4H-9ato&amp;feature = emb _ title</a></li><li id="6818" class="ly lz hi jq b jr mh jv mi jz mj kd mk kh ml kl oi me mf mg bi translated"><a class="ae lk" href="https://www.crondose.com/2016/08/examples-metaprogramming-guide-beginners/" rel="noopener ugc nofollow" target="_blank">https://www . cron dose . com/2016/08/examples-元编程-指南-初学者/ </a></li><li id="3a1f" class="ly lz hi jq b jr mh jv mi jz mj kd mk kh ml kl oi me mf mg bi translated"><a class="ae lk" rel="noopener" href="/swlh/metaprogramming-in-ruby-1b69b1b54202">https://medium . com/swlh/meta programming-in-ruby-1b 69 B1 b 54202</a></li><li id="249e" class="ly lz hi jq b jr mh jv mi jz mj kd mk kh ml kl oi me mf mg bi translated"><a class="ae lk" href="https://betterprogramming.pub/the-magic-of-metaprogramming-732f0300a5c7" rel="noopener ugc nofollow" target="_blank">https://better programming . pub/the-magic-of-meta programming-732 f 0300 a5c 7</a></li><li id="ca8d" class="ly lz hi jq b jr mh jv mi jz mj kd mk kh ml kl oi me mf mg bi translated"><a class="ae lk" href="https://www.quora.com/What-is-metaprogramming" rel="noopener ugc nofollow" target="_blank">https://www.quora.com/What-is-metaprogramming</a></li><li id="b353" class="ly lz hi jq b jr mh jv mi jz mj kd mk kh ml kl oi me mf mg bi translated"><a class="ae lk" href="https://culttt.com/2015/06/17/what-is-monkey-patching-in-ruby/" rel="noopener ugc nofollow" target="_blank">https://cult TT . com/2015/06/17/what-is-monkey-patching-in-ruby/</a></li><li id="6d78" class="ly lz hi jq b jr mh jv mi jz mj kd mk kh ml kl oi me mf mg bi translated"><a class="ae lk" href="https://www.leighhalliday.com/ruby-metaprogramming-method-missing" rel="noopener ugc nofollow" target="_blank">https://www . leighhalliday . com/ruby-元编程-方法-缺失</a></li><li id="22d8" class="ly lz hi jq b jr mh jv mi jz mj kd mk kh ml kl oi me mf mg bi translated"><a class="ae lk" href="https://apidock.com/rails/ActiveRecord/Base/method_missing/class" rel="noopener ugc nofollow" target="_blank">https://API dock . com/rails/active record/Base/method _ missing/class</a></li></ul></div></div>    
</body>
</html>