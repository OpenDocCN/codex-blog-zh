<html>
<head>
<title>3 Ways of Passing Arguments in C++</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C++中传递参数的3种方式</h1>
<blockquote>原文：<a href="https://medium.com/codex/3-ways-of-passing-arguments-in-c-f22b9853a5dc?source=collection_archive---------4-----------------------#2022-05-26">https://medium.com/codex/3-ways-of-passing-arguments-in-c-f22b9853a5dc?source=collection_archive---------4-----------------------#2022-05-26</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><h2 id="39f4" class="hg hh hi bd b fp hj hk hl hm hn ho dx hp translated" aria-label="kicker paragraph">C++基础</h2><div class=""/><div class=""><h2 id="7597" class="pw-subtitle-paragraph io hr hi bd b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf dx translated">了解你的论点</h2></div><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es jg"><img src="../Images/811a11673b314d24e864822174a486b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r52NdBeORG2dVyNgxJI9pQ.png"/></div></div><figcaption class="js jt et er es ju jv bd b be z dx translated">作者图片</figcaption></figure><p id="15e9" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">只有三种方法可以将参数传递给函数:</p><ul class=""><li id="f3f3" class="ks kt hi jy b jz ka kc kd kf ku kj kv kn kw kr kx ky kz la bi translated"><strong class="jy hs">按值传递</strong></li><li id="6db4" class="ks kt hi jy b jz lb kc lc kf ld kj le kn lf kr kx ky kz la bi translated"><strong class="jy hs">参考通过</strong></li><li id="d0bd" class="ks kt hi jy b jz lb kc lc kf ld kj le kn lf kr kx ky kz la bi translated"><strong class="jy hs">通过地址</strong></li></ul><p id="eb2b" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">本文将详细讨论这三种方法。</p><p id="3356" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">在继续之前，让我们看看<strong class="jy hs">实际参数</strong>和<strong class="jy hs">形式参数。</strong></p><ul class=""><li id="7764" class="ks kt hi jy b jz ka kc kd kf ku kj kv kn kw kr kx ky kz la bi translated"><strong class="jy hs">实际参数</strong>(也称为自变量)是传递给函数的值。</li><li id="c9c2" class="ks kt hi jy b jz lb kc lc kf ld kj le kn lf kr kx ky kz la bi translated"><strong class="jy hs">形参</strong>是在函数定义中定义的变量。</li></ul><figure class="jh ji jj jk fd jl er es paragraph-image"><div class="er es lg"><img src="../Images/0025bbb97123ff5e9cd50a8572453335.png" data-original-src="https://miro.medium.com/v2/resize:fit:1138/format:webp/1*dZ9vioLORght3YHtMa9Ybw.png"/></div><figcaption class="js jt et er es ju jv bd b be z dx translated">实际参数与形式参数</figcaption></figure></div><div class="ab cl lh li gp lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="hb hc hd he hf"><h1 id="d3b5" class="lo lp hi bd lq lr ls lt lu lv lw lx ly ix lz iy ma ja mb jb mc jd md je me mf bi translated">按值传送</h1><p id="19eb" class="pw-post-body-paragraph jw jx hi jy b jz mg is kb kc mh iv ke kf mi kh ki kj mj kl km kn mk kp kq kr hb bi translated">在<strong class="jy hs">按值传递中，</strong>实际参数的值被复制到形式参数中。对函数定义中的形参所做的更改不会反映在实参的变量中。在C++中，默认情况下参数是通过值传递的。</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es ml"><img src="../Images/c7a4db72f8fe4d3580da10bc1fd9617d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7UvFaUoTTq8dQIGPf_xGlQ.png"/></div></div><figcaption class="js jt et er es ju jv bd b be z dx translated">带代码的传值示例</figcaption></figure><p id="f241" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">此代码的输出是:</p><pre class="jh ji jj jk fd mm mn mo mp aw mq bi"><span id="177d" class="mr lp hi mn b fi ms mt l mu mv">Before the function call: 1 2 3 4 5<br/>After the function call: 1 2 3 4 5</span></pre><p id="6f0f" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">当控制权从主函数转移到multiply_array函数时，<strong class="jy hs">为<strong class="jy hs">形参</strong>创建新的内存位置</strong>，并将<strong class="jy hs">实参</strong>的值复制到其中。在<strong class="jy hs">主</strong>和<strong class="jy hs">乘数组</strong>函数中打印数组地址时，我们得到不同的值。这样就确认了实参变量的副本被传入了形参。</p><pre class="jh ji jj jk fd mm mn mo mp aw mq bi"><span id="6099" class="mr lp hi mn b fi ms mt l mu mv">void multiply_array(vector&lt;int&gt; arr, int mul_value) {<br/>    cout &lt;&lt; "array address in multiply_array function: " &lt;&lt; &amp;arr &lt;&lt;<br/>    endl;<br/>}<br/>int main() {<br/>    vector&lt;int&gt; arr = {1, 2, 3, 4, 5};<br/>    cout &lt;&lt; "array address in main function: " &lt;&lt; &amp;arr &lt;&lt; endl;<br/>    multiply_array(arr, 5);<br/>    return 0;<br/>}</span></pre><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es mw"><img src="../Images/77138d77d011eae2483cba30ca43d6c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ok-l5G6d7WmynVM7WlZjXQ.png"/></div></div><figcaption class="js jt et er es ju jv bd b be z dx translated">当数据按值传递时，函数中数组的地址</figcaption></figure><p id="1270" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">按值传递使用更多的内存，因为对于同一个变量，有两个内存位置。</p><h1 id="bcff" class="lo lp hi bd lq lr mx lt lu lv my lx ly ix mz iy ma ja na jb mc jd nb je me mf bi translated">通过引用传递</h1><p id="3d53" class="pw-post-body-paragraph jw jx hi jy b jz mg is kb kc mh iv ke kf mi kh ki kj mj kl km kn mk kp kq kr hb bi translated">在<strong class="jy hs">引用传递中，</strong>实际参数的<strong class="jy hs">引用</strong>被复制到形参中。所以在函数中引用被用来访问参数的实际值。因此，函数内部的任何变化都将反映在实际参数的变量中。通过引用传递变量<strong class="jy hs"> &amp; </strong>符号用于捕捉形式参数。看下面的例子有一个更清晰的画面。</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es nc"><img src="../Images/9bbf3021f606a46fe991ff078a879e87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k7By4kZ8QJYawx6OM9hnHw.png"/></div></div><figcaption class="js jt et er es ju jv bd b be z dx translated">用代码传递引用示例</figcaption></figure><p id="77b3" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">此代码的输出是:</p><pre class="jh ji jj jk fd mm mn mo mp aw mq bi"><span id="c6a0" class="mr lp hi mn b fi ms mt l mu mv">Before the function call: 1 2 3 4 5<br/>After the function call: 5 10 15 20 25</span></pre><p id="6d55" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">当控制权从主函数转移到multiply_array函数时，没有为形参创建新的存储单元<strong class="jy hs">。更确切地说，形式参数用于<strong class="jy hs">引用</strong>实际参数的存储位置。在两个函数中打印数组的地址时，我们得到了相同的结果，这证实了前面的陈述。</strong></p><pre class="jh ji jj jk fd mm mn mo mp aw mq bi"><span id="69c4" class="mr lp hi mn b fi ms mt l mu mv">void multiply_array(vector&lt;int&gt; &amp;arr, int mul_value) {<br/>    cout &lt;&lt; "array address in multiply_array function: " &lt;&lt; &amp;arr &lt;&lt;<br/>    endl;<br/>}<br/>int main() {<br/>    vector&lt;int&gt; arr = {1, 2, 3, 4, 5};<br/>    cout &lt;&lt; "array address in main function: " &lt;&lt; &amp;arr &lt;&lt; endl;<br/>    multiply_array(arr, 5);<br/>    return 0;<br/>}</span></pre><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es mw"><img src="../Images/a9c140393a6bc0dd48c0c87745045b60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uTWc5HcAvp22Bvglj53NiA.png"/></div></div><figcaption class="js jt et er es ju jv bd b be z dx translated">当数据通过引用传递时，两个函数中的数组地址</figcaption></figure><p id="2aa8" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">引用传递节省内存，因为变量的引用被复制。</p><h1 id="1096" class="lo lp hi bd lq lr mx lt lu lv my lx ly ix mz iy ma ja na jb mc jd nb je me mf bi translated">按地址传递</h1><p id="d77f" class="pw-post-body-paragraph jw jx hi jy b jz mg is kb kc mh iv ke kf mi kh ki kj mj kl km kn mk kp kq kr hb bi translated">在<strong class="jy hs">传递地址</strong>也称为<strong class="jy hs">传递指针中，</strong>复制形式参数中实际参数的<strong class="jy hs">地址</strong>。在函数中，地址用于访问实际参数。因为使用了变量的地址，所以对函数内部的形参所做的更改会影响到实际的形参。通过地址<strong class="jy hs"> &amp; </strong>传递变量，传递实参时使用符号<strong class="jy hs"> * </strong>捕捉形参时使用符号。</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es nd"><img src="../Images/c163d63bc986b476e50eec8f09f3aa0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dj7CQVYn7G5jFWHe4vdzTQ.png"/></div></div><figcaption class="js jt et er es ju jv bd b be z dx translated">带代码的传递地址示例</figcaption></figure><p id="31b3" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">此代码的输出是:</p><pre class="jh ji jj jk fd mm mn mo mp aw mq bi"><span id="65c1" class="mr lp hi mn b fi ms mt l mu mv">Before the function call: 1 2 3 4 5<br/>After the function call: 5 10 15 20 25</span></pre><p id="6925" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">当控制从主函数转移到multiply_array函数时，<strong class="jy hs">新的内存位置</strong>被创建，用于存储形式参数指针的值。在打印multiply_array函数中的指针地址和main函数中的数组地址时，我们得到了不同的值，从而证实了前面的陈述。</p><pre class="jh ji jj jk fd mm mn mo mp aw mq bi"><span id="7a64" class="mr lp hi mn b fi ms mt l mu mv">void multiply_array(vector&lt;int&gt; *arr, int mul_value) {<br/>    cout &lt;&lt; "array address in multiply_array function: " &lt;&lt; &amp;arr &lt;&lt;<br/>    endl;<br/>}<br/>int main() {<br/>    vector&lt;int&gt; arr = {1, 2, 3, 4, 5};<br/>    cout &lt;&lt; "array address in main function: " &lt;&lt; &amp;arr &lt;&lt; endl;<br/>    multiply_array(&amp;arr, 5);<br/>    return 0;<br/>}</span></pre><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es ne"><img src="../Images/4a510c7b6dc5488110154a24ec9a5ef2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*65IqzxudnhLlpGH19XePgQ.png"/></div></div><figcaption class="js jt et er es ju jv bd b be z dx translated">主函数和指针multiply_array函数中数组的地址</figcaption></figure></div><div class="ab cl lh li gp lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="hb hc hd he hf"><p id="6e23" class="pw-post-body-paragraph jw jx hi jy b jz ka is kb kc kd iv ke kf kg kh ki kj kk kl km kn ko kp kq kr hb bi translated">总之，可以说按引用传递和按地址传递比按值传递更有效。感谢您阅读这篇文章。希望这对你有帮助。在<a class="ae nf" href="https://www.linkedin.com/in/ashish-yoel-585a6116a/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上与我联系。</p><h2 id="3d1d" class="mr lp hi bd lq ng nh ni lu nj nk nl ly kf nm nn ma kj no np mc kn nq nr me ho bi translated">阅读更多</h2><div class="ns nt ez fb nu nv"><a href="https://blog.bytellect.com/software-development/cplusplus/which-is-faster-in-cplusplus-call-by-value-call-by-reference-or-call-by-pointer/" rel="noopener  ugc nofollow" target="_blank"><div class="nw ab dw"><div class="nx ab ny cl cj nz"><h2 class="bd hs fi z dy oa ea eb ob ed ef hr bi translated">C++中按值调用、按引用调用和按指针调用哪个更快？</h2><div class="oc l"><h3 class="bd b fi z dy oa ea eb ob ed ef dx translated">当引用或指针作为参数传递给函数时，指针大小的东西必须是…</h3></div><div class="od l"><p class="bd b fp z dy oa ea eb ob ed ef dx translated">blog.bytellect.com</p></div></div><div class="oe l"><div class="of l og oh oi oe oj jq nv"/></div></div></a></div><div class="ns nt ez fb nu nv"><a href="https://www.differencebetween.com/difference-between-actual-and-vs-formal-parameters/" rel="noopener  ugc nofollow" target="_blank"><div class="nw ab dw"><div class="nx ab ny cl cj nz"><h2 class="bd hs fi z dy oa ea eb ob ed ef hr bi translated">实际参数和形式参数之间的差异|比较相似术语之间的差异</h2><div class="oc l"><h3 class="bd b fi z dy oa ea eb ob ed ef dx translated">使用函数是编程中的一个重要概念。函数是一些语句，它们可以执行某种…</h3></div><div class="od l"><p class="bd b fp z dy oa ea eb ob ed ef dx translated">www.differencebetween.com</p></div></div><div class="oe l"><div class="ok l og oh oi oe oj jq nv"/></div></div></a></div><div class="ns nt ez fb nu nv"><a href="https://www.geeksforgeeks.org/pointers-c-examples/" rel="noopener  ugc nofollow" target="_blank"><div class="nw ab dw"><div class="nx ab ny cl cj nz"><h2 class="bd hs fi z dy oa ea eb ob ed ef hr bi translated">C/C++中的指针及示例- GeeksforGeeks</h2><div class="oc l"><h3 class="bd b fi z dy oa ea eb ob ed ef dx translated">指针是地址的符号表示。它们使程序能够模拟引用调用以及…</h3></div><div class="od l"><p class="bd b fp z dy oa ea eb ob ed ef dx translated">www.geeksforgeeks.org</p></div></div><div class="oe l"><div class="ol l og oh oi oe oj jq nv"/></div></div></a></div></div></div>    
</body>
</html>