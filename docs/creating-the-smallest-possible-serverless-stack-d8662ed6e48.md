# 创建尽可能最小的无服务器堆栈

> 原文：<https://medium.com/codex/creating-the-smallest-possible-serverless-stack-d8662ed6e48?source=collection_archive---------6----------------------->

![](img/6ebdf7706947b3dd560f6ed7aef4640e.png)

在工程团队中，我经常会遇到这样的问题:是扩展现有的堆栈，让它们增长还是限制它们，以避免潜在的问题，如部署缓慢、危险的回滚。在这篇文章中，我将强调小堆栈的优点，一些缺点，以及支持小堆栈的条件。

栈是资源的集合，其迁移在单个执行流/迁移中被管理。当使用 AWS 时，它通常由 CDK 创建的 Cloudformation 管理，然而，Terraform 工作区或无服务器框架也适用于本文。小型部署堆栈的优势

## **小型堆栈的迁移速度很快**

可能是最明显的一个。迁移规模越小，为 orchestrator 编制变更清单和执行变更所需的工作就越少。作为一名 CICD 爱好者，我总是试图将快速失效原则融入我的设计中。拥有更小的堆栈意味着更容易为部署、测试和生产做好准备。

## **出错更少，回滚更容易。**

每个经历过唯一出路就是摧毁基础设施的人都会有同感。基础设施最终仍可能处于崩溃状态。一些迁移可能是破坏性的，一些新产品缺乏成熟的回滚支持，或者总是存在人为因素。当筹码出现问题时，你很乐意用小筹码来减少风险。

## **小迁徙造就小评论。**

即使是一个简单的无服务器应用程序设置，其核心是部署一个 Lambda 来执行一些自定义代码，从队列中获取消息或通过 API 接收消息并存储一些数据，通常也会包含大约 25 个托管资源。我想说的是，当有人评估你的变化时，你可以合理地期望你的同事理解你的变化。特别是有了 CDK 的力量和更高级的[构造](https://docs.aws.amazon.com/cdk/v2/guide/constructs.html)，创建大堆栈变得很容易。同样的道理也适用于 [Terraform 模块](https://www.terraform.io/language/modules/develop)和[无服务器框架插件](https://www.serverless.com/plugins) **。**小书库便于复习。

## **认知负荷下降**

越来越多的人特别关注我们加在工程师身上的认知负荷。无服务器/云原生团队通常被设置为 DevOps 团队，甚至是 BizDevOps 团队。他们考虑到了很多复杂性。小堆栈限制了开发人员的精神负担，提高了生产率、创造力，或者创造了更积极的开发人员体验。

# 小书库的缺点

## **管理依赖资源**

导致更大堆栈的最大驱动力(通过选择)是相互依赖且没有解耦选项的资源。有些资源在生命周期中依赖于其他资源，这样迁移才有效。有些资源耦合性较弱，但仍然有很强的功能依赖性。

我们举个小例子。Lambda 的执行角色是其工作的基础。它管理对云资源的基本权限。理论上可以将它放在一个单独的堆栈中，但是这将需要一个协调层。

## **全平台管理**

有些需求要求您更新整个平台的资源。特别是对于模块和库，库中的一个小的变化就可能导致对大规模多栈扇出的需求。当你有大量的栈或者使用嵌套栈时，这就容易多了。想想你的账单标签的更新或者邻居账户资源的白名单。

## **摧毁堆栈**

帐户清理/擦除是我怀念单堆栈部署的便利之处之一。特别是如果你喜欢增加测试栈或者有很多你的开发栈的拷贝，管理一个更大的栈会容易得多。

## **缺乏运行配置的可见性**

这种方法的一个缺点是，在无服务器云平台的当前状态下，您的配置缺乏可见性。我还没有找到一个像样的工具，让我对我的无服务器环境有一个总体的了解。虽然这适用于大堆栈和小堆栈，但对于几十个小堆栈来说，这是一个更大的问题。一些人已经放弃了，并声称它现在太复杂了(就像一些 Kubernetes 部署的那样)。我认为这也是支持小筹码的有力论据。:)

# 支持小型堆栈

在现实生活中，一个云应用/服务/平台由几十到几千个需要协同工作来创造价值的资源组成。如何将这样的场景划分为域、帐户、服务和堆栈，以及创建它们的团队，这个问题并不简单。对于某些情况，DDD 已经展示了一个有价值的知识体来计算出最优的划分，然而，它是高度依赖于组织和它的环境的。它本身值得一篇文章。对于这篇博客的重点，让我们假设服务层的理想划分是正确确定的。

## 分离您的应用环境

为了支持小堆栈，最重要的概念是**去耦**。与我们在采用微服务的早期所经历的类似，最成功的平台是那些已经实现了分离的平台。获得正确的云原生架构模式至关重要。不仅仅是采用 Lambda 和 DynamoDB。在无服务器架构中，很容易通过创建相互关联的云资源网络来扼杀自己。请阅读我的博客[管理无服务器意大利面](/codex/managing-serverless-spaghetti-c2fb1a7db73e)了解更多内容。只有通过精心设计，才能减少资源的耦合。异步消息模式很有帮助，但是设计隔离的持久层和幂等弹性处理也很有帮助。请理解，脱钩是最难搞对的！我们大多数行业的更好实践帮助我们做到这一点。令人沮丧的消息是，你几乎需要把它们都考虑进去才能做好。

## **参数管理配置小堆栈**

所以一旦你把设计做好了，你需要一些实际的东西来做好。您需要一种策略来将配置外部化，以便能够进行部署。我喜欢[参数库](https://docs.aws.amazon.com/systems-manager/latest/userguide/parameter-store-working-with.html)，虽然它并不完美。比起 Cloudformation 导出，我更喜欢它，因为 cloud formation 导出会使你的栈纠缠在一起(我们正准备将它们解耦)。从您的 CICD 管道注入的上下文参数也可以做到这一点。

## **管理小型堆栈的部署协调**

即使有了完美的解耦，也必然会更新一个堆栈，并意识到有一个依赖的堆栈需要更新。我喜欢语义版本化来辐射突破性的变化，这意味着相关的栈也需要更新。像重试机制这样的弹性模式允许有一些余地来并行部署两个堆栈。例如当消息产生栈和消息消费栈是分开的栈时。如果您一直在自动化部署，您需要一种方法来触发多个堆栈部署。许多 CICD 工具允许配置“高级”管道，即触发其他管道的管道。

![](img/133162d20da703d624c2847c7dec32a9.png)

把它切碎

# 堆栈应该有多大或多小？

实际上，我从把非短暂的资源和让它们运转的东西放入它们的堆栈开始。因此，VPC 可以是一个堆栈(已经包含了许多资源)，一个带有一些参数的 DynamoDB 表，也许一些 IAM 策略也可以是一个合适的堆栈。这些非临时栈是你不经常迭代的栈。每当<insert some="" fancy="" service="" here="">错误地使您的迁移崩溃时，您希望防止它们被拆除。</insert>

创建非临时性资源(存储、存储桶、队列)后，继续将服务划分为小型临时性堆栈。堆栈是短暂的，因为它们从不产生应用程序状态。因此，包含对前面提到的存储进行处理的 blog-post 服务符合要求。也有可能是一个单独的服务可以被合理地分离成不同的堆栈。切割线有时很明显，可以是工作负载类型(前端、后端、分析、网络、存储)。

例如，它可以是前端团队和后端团队之间的分离，这两个团队可能在不同的存储库中，具有他们的管道。他们的解耦点是 API 层。我们还可以更进一步。在后端服务中，任何可以使用异步消息处理进行合理解耦的组件都可以被划分到它们的堆栈中。需要权衡的是这是否有意义。解耦在软件中是一个普遍的积极特征，然而正如前面提到的，这需要付出巨大的努力。因此，人们应该始终为这种投资做出有意义的权衡，并与一些业务目标保持一致。

# 包扎

我希望我激发了你思考为什么要创建更小或更大的堆栈的兴趣。小筹码已经成为我的个人偏好，但我不想争论哪个更好。AWS 中的嵌套栈也提供了一些分区的优势。但我更喜欢许多独立的堆栈，因为它迫使我考虑隔离和去耦。但就像我说的，你会为此付出代价的。所以享受对你的栈进行分区吧，我确信接下来的讨论将会非常有见地。