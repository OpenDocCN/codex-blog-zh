<html>
<head>
<title>Building a Sudoku Solver and Generator in Python (2/3)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Python构建数独解算器和生成器(2/3)</h1>
<blockquote>原文：<a href="https://medium.com/codex/building-a-sudoku-solver-and-generator-in-python-2-3-5eef3141702c?source=collection_archive---------6-----------------------#2021-04-02">https://medium.com/codex/building-a-sudoku-solver-and-generator-in-python-2-3-5eef3141702c?source=collection_archive---------6-----------------------#2021-04-02</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/083d426c32cd3c9bc7565073ff92e1a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UDnauIK4Zr3kIUQMX_BwqA.jpeg"/></div></div></figure><h1 id="b9ef" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">创建求解器</h1><p id="cb5b" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">欢迎回到这个3部分教程的第2部分，在这一部分我们将为数独引擎创建求解器，所以让我们直接进入代码。但是，首先我们需要创建两个方法来辅助主求解方法。</p><figure class="km kn ko kp fd ij"><div class="bz dy l di"><div class="kq kr l"/></div></figure><p id="bbe2" class="pw-post-body-paragraph jo jp hi jq b jr ks jt ju jv kt jx jy jz ku kb kc kd kv kf kg kh kw kj kk kl hb bi translated">这里我们遍历棋盘，返回我们遇到的第一个空方块的索引位置的行和列，如果没有方块，则返回False。</p><p id="87b4" class="pw-post-body-paragraph jo jp hi jq b jr ks jt ju jv kt jx jy jz ku kb kc kd kv kf kg kh kw kj kk kl hb bi translated">接下来，我们将创建一个方法，它可以检查并告诉我们某个数字是否可以输入到某个单元格中:</p><figure class="km kn ko kp fd ij"><div class="bz dy l di"><div class="kq kr l"/></div></figure><p id="c6ca" class="pw-post-body-paragraph jo jp hi jq b jr ks jt ju jv kt jx jy jz ku kb kc kd kv kf kg kh kw kj kk kl hb bi translated">这个方法有两个必需的参数，一个是试图输入到空间中的数字，第二个参数是包含行和列索引的元组。该方法将首先检查试图放入空格中的数字是否出现在同一行或列中，如果出现，则该数字不能放在那里，并返回False。接下来，检查内部框3x3框，如果该数字已经出现在框中，则返回False。如果到目前为止没有返回任何东西，那么我们试图放置数字的空间被认为是有效的，并且返回True。</p><p id="26dc" class="pw-post-body-paragraph jo jp hi jq b jr ks jt ju jv kt jx jy jz ku kb kc kd kv kf kg kh kw kj kk kl hb bi translated">最后，为了创建求解器，我们需要考虑如何求解数独棋盘，我创建了一些伪代码来表示求解算法:</p><figure class="km kn ko kp fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kx"><img src="../Images/517a50b3fbd0752067fe94c79a840c7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PummJkp4k7osx-p8yCnJLA.png"/></div></div><figcaption class="ky kz et er es la lb bd b be z dx translated">主求解算法的伪代码</figcaption></figure><p id="5afb" class="pw-post-body-paragraph jo jp hi jq b jr ks jt ju jv kt jx jy jz ku kb kc kd kv kf kg kh kw kj kk kl hb bi translated">将它转换成python后，我们得到:</p><figure class="km kn ko kp fd ij"><div class="bz dy l di"><div class="kq kr l"/></div></figure><p id="cb86" class="pw-post-body-paragraph jo jp hi jq b jr ks jt ju jv kt jx jy jz ku kb kc kd kv kf kg kh kw kj kk kl hb bi translated">在这个方法中，我们将创建求解算法，该算法将利用递归的能力来实现回溯解决方案，以完成数独谜题。首先，搜索任何空单元格，如果没有空单元格，则返回True，因为函数已经到达其基本情况，否则函数继续。</p><p id="43ed" class="pw-post-body-paragraph jo jp hi jq b jr ks jt ju jv kt jx jy jz ku kb kc kd kv kf kg kh kw kj kk kl hb bi translated">然后，for循环将变量n从1递增到9(包括1和9 ),在每次迭代过程中，都会检查n是否适合当前的空白空间，这是由findSpaces方法在前面找到的。如果可以，则用值n填充该空间，并且递归地调用求解函数，直到达到基本情况，这发生在棋盘上没有剩余的空间或者没有数字可以放入空白空间的时候。如果后者发生，则返回False，并且不返回板，而是将先前由值n填充的空间重置为0，并且for循环继续。</p><p id="2bb0" class="pw-post-body-paragraph jo jp hi jq b jr ks jt ju jv kt jx jy jz ku kb kc kd kv kf kg kh kw kj kk kl hb bi translated">我们还可以创建另一种方法，将求解的纸板转换成易于打印和存储的代码:</p><figure class="km kn ko kp fd ij"><div class="bz dy l di"><div class="kq kr l"/></div></figure></div><div class="ab cl lc ld gp le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="hb hc hd he hf"><h1 id="2373" class="iq ir hi bd is it lj iv iw ix lk iz ja jb ll jd je jf lm jh ji jj ln jl jm jn bi translated">世代入门</h1><p id="fb3a" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">要生成一个可以作为问题填写的数独板，我们首先需要创建一个由完全有效的数字填充的板(遵循数独规则)。为此，我们可以使用一个简单的小技巧和一些递归来生成一个完全填充的电路板。我们将使用的技巧会稍微加快我们的生成时间，但是有总比没有好，对吗？它是这样工作的:</p><figure class="km kn ko kp fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lo"><img src="../Images/ffdd3021222e99b730116f82796ea210.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*59bHQvTu7sIATuSTTGYZbA.png"/></div></div><figcaption class="ky kz et er es la lb bd b be z dx translated">显示如何独立安装3个内部盒子而不会相互干扰的图表</figcaption></figure><p id="ddf7" class="pw-post-body-paragraph jo jp hi jq b jr ks jt ju jv kt jx jy jz ku kb kc kd kv kf kg kh kw kj kk kl hb bi translated">在此图中，您可以在一条对角线上看到3个内部方框，粉红色方框中的内容不会干扰蓝色和绿色方框中的内容，反之亦然。从生成过程开始，我们可以创建一个生成完全填充电路板的方法:</p><figure class="km kn ko kp fd ij"><div class="bz dy l di"><div class="kq kr l"/></div></figure><p id="a98f" class="pw-post-body-paragraph jo jp hi jq b jr ks jt ju jv kt jx jy jz ku kb kc kd kv kf kg kh kw kj kk kl hb bi translated">在上面的方法中，我们检查了3个内部方框，并用数字1-9填充它，同时确保该数字不能通过从我们的临时数字列表中删除而被随机选取。最后，私有的<em class="lp"> generateCont </em>方法被调用，这样它可以填充棋盘上剩余的54个空单元格。这个函数看起来是这样的:</p><figure class="km kn ko kp fd ij"><div class="bz dy l di"><div class="kq kr l"/></div></figure><p id="5e12" class="pw-post-body-paragraph jo jp hi jq b jr ks jt ju jv kt jx jy jz ku kb kc kd kv kf kg kh kw kj kk kl hb bi translated">该方法也是递归的，因为它在生成填充电路板的过程中调用自身，并且遵循与solve方法非常相似的原理。它的工作方式是遍历棋盘并选择一个随机数，如果当前单元格是空的，那么它会尝试将该数字放在允许的位置，然后检查棋盘是否仍可解。如果它是可解的，那么它将移动到下一个单元格，否则它将重置该单元格的值。</p></div><div class="ab cl lc ld gp le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="hb hc hd he hf"><h1 id="9112" class="iq ir hi bd is it lj iv iw ix lk iz ja jb ll jd je jf lm jh ji jj ln jl jm jn bi translated">最后的想法</h1><p id="8533" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">这是3部分数独求解器和生成器教程的第2部分，在下一部分，我们将通过确保每个创建的数独只有一个解决方案来完成我们的生成器。请务必在下面评论您的任何疑问和想法。</p><p id="d98f" class="pw-post-body-paragraph jo jp hi jq b jr ks jt ju jv kt jx jy jz ku kb kc kd kv kf kg kh kw kj kk kl hb bi translated">点击<a class="ae lq" href="https://kushm.medium.com/building-a-sudoku-solver-and-generator-in-python-3-3-cac73d340973" rel="noopener">此处</a>查看第三部分。</p><p id="a6ad" class="pw-post-body-paragraph jo jp hi jq b jr ks jt ju jv kt jx jy jz ku kb kc kd kv kf kg kh kw kj kk kl hb bi translated">感谢您阅读第2部分！💖</p></div></div>    
</body>
</html>