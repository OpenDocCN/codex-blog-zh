<html>
<head>
<title>Solving Leetcode Problems with Golang</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Golang解决Leetcode问题</h1>
<blockquote>原文：<a href="https://medium.com/codex/solving-leetcode-problems-with-golang-43cba8727053?source=collection_archive---------3-----------------------#2022-01-28">https://medium.com/codex/solving-leetcode-problems-with-golang-43cba8727053?source=collection_archive---------3-----------------------#2022-01-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="7878" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">问题:盛水最多的容器</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/ff8032bccedc44e9a27a76355afb9f50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*cax_geEkxHY8s6yB.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">来源:<a class="ae jn" href="https://levelup.gitconnected.com/what-is-golang-and-how-to-install-it-2275236fe657" rel="noopener ugc nofollow" target="_blank">Golang是什么以及如何安装它|作者:萨扬·蒙达尔|升级编码(gitconnected.com)</a></figcaption></figure><h1 id="62ff" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">动机</h1><p id="d939" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">最近，我决定我要准备面试，编码比赛，并学习一门新的编程语言。为了一箭双雕，我决定每天用Golang练习Leetcode问题。用你不熟悉的语言解决算法问题，迫使你思考实际需要解决的问题，这有助于你成为更好的开发者。当然，在获得正确的语法时会遇到一些小问题，但是最重要的是不管使用什么工具都能解决问题。</p><p id="39f8" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">旅程开始后不久，我注意到Golang中对Leetcode问题的支持远不如C++、Python或Java。鉴于这些语言的历史，像Go这样的现代语言得不到同等水平的支持也就不足为奇了。然而，这篇文章将是我为Golang中的Leetcode问题提供解决方案的系列文章的第一篇。</p><p id="8a2e" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated"><strong class="ki hj"> <em class="lh">免责声明</em> </strong> <em class="lh">:如前所述，我还在学习围棋。如果有人有任何建议可以让我的代码更地道，请在评论中提供。</em></p><h1 id="7ff7" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">盛水最多的容器</h1><p id="a946" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">难度:中等</p><p id="0221" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">通过率:53%</p><p id="2eb5" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">给你一个长度为<code class="du li lj lk ll b">n</code>的整数数组<code class="du li lj lk ll b">height</code>。画有<code class="du li lj lk ll b">n</code>垂直线，使得<code class="du li lj lk ll b">ith</code>线的两个端点是<code class="du li lj lk ll b">(i, 0)</code>和<code class="du li lj lk ll b">(i, height[i])</code>。</p><p id="9b71" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">找出与x轴一起形成一个容器的两条线，这样容器中的水最多。</p><p id="8ad7" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">返回<em class="lh">一个容器可以储存的最大水量</em>。</p><p id="4df0" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated"><strong class="ki hj">注意</strong>不要倾斜容器。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es lm"><img src="../Images/ca07d15dd2075615897b887539582963.png" data-original-src="https://miro.medium.com/v2/resize:fit:1388/format:webp/1*0YIOqV2kwilTC-ahNnsvSw.png"/></div></figure><h2 id="0881" class="ln jp hi bd jq lo lp lq ju lr ls lt jy kp lu lv ka kt lw lx kc kx ly lz ke ma bi translated">问题分解</h2><p id="3ebd" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">简而言之，他们希望您将直线的坐标视为矩形的边，并找到返回所形成矩形的最大面积的边的组合。</p><p id="2713" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">问题是你不能倾斜容器。在图像中，你可以看到答案涉及到两个方面，其中一个是高度8，另一个是高度7。这一点很重要，因为我们必须确保矩形的边是平衡的，所以当处理两条不平坦的边时，我们将使用两条边中较小的一边来计算矩形的面积。</p><p id="1883" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">索引j和I之间的差将为我们提供矩形的长度。因此，我们对矩形面积的计算如下:</p><p id="fc35" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">面积=矩形长度*矩形高度</p><p id="4ab7" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">矩形长度= j-i</p><p id="7740" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">rectHeight= height[i]</p><h2 id="3260" class="ln jp hi bd jq lo lp lq ju lr ls lt jy kp lu lv ka kt lw lx kc kx ly lz ke ma bi translated">天真的方法</h2><p id="a2f1" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">简单/强力方法包括利用嵌套的for循环来遍历每个可能的。在分解和理解问题之后，实施天真的方法，然后使它更有效，这总是好的。这个想法是永远不要首先直接瞄准最有效的方法。你必须先了解问题，以及如何解决问题。效率是精通的奢侈品。</p><p id="1f24" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">这是Golang中的强力解决方案，由于使用了嵌套的for循环，它的运行时间不是很理想。</p><pre class="iy iz ja jb fd mb ll mc md aw me bi"><span id="1011" class="ln jp hi ll b fi mf mg l mh mi">func maxArea(height []int) int {<br/>    var maxArea int = 0<br/>    var size int = len(height)<br/>    <br/>    for i := 0; i &lt; size; i++ {<br/>        currentArea := 0<br/>        for j := 0; j &lt; size; j++ {<br/>            segmentLength := j-i<br/>            var segmentHeight int = height[i]<br/>            <br/>            if(segmentHeight &gt;= height[j]) {<br/>                segmentHeight = height[j]<br/>            }<br/>            <br/>            currentArea = segmentLength*segmentHeight<br/>            if(currentArea &gt; maxArea) {<br/>                maxArea = currentArea<br/>            }<br/>        }<br/>    }<br/>    <br/>    return maxArea<br/>}</span></pre><p id="0da1" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">该代码将提供正确的答案，但是由于超过了可接受的最小时间限制而导致测试用例失败。现在，我们优化。</p><h2 id="672d" class="ln jp hi bd jq lo lp lq ju lr ls lt jy kp lu lv ka kt lw lx kc kx ly lz ke ma bi translated">优化解决方案</h2><p id="eff6" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">优化这个解决方案需要注意问题的微妙之处。如果我们从数组开头的I开始，在末尾的j开始，我们可以向内移动指针，这样计算矩形的面积。为了向内移动指针，我们将增加I，减少j。</p><p id="93d5" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">这对我们有什么帮助？因为长度会不断变小，面积变大的唯一方式就是高度增加。</p><p id="6750" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">如果涉及两个指针，则强力算法是O(n ),并且问题涉及我们搜索满足给定标准的子元素的组合，那么我们有9/10的机会使用滑动窗口方法来优化解决方案。</p><p id="1873" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">滑动窗口方法为我们节省了许多小的计算步骤，但最重要的是允许我们将代码重构为O(n)解决方案。</p><p id="24cd" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">以下是优化的解决方案:</p><pre class="iy iz ja jb fd mb ll mc md aw me bi"><span id="714b" class="ln jp hi ll b fi mf mg l mh mi">func maxArea(height []int) int {<br/>    var maxArea int = 0<br/>    var i int = 0<br/>    var j int = len(height)-1<br/>    var result int = 0<br/>    <br/>    for i &lt; j {        <br/>        if(height[i] &lt;= height[j]) {<br/>            result = height[i] * (j-i)<br/>            i++<br/>        } else {<br/>            result = height[j] * (j-i)<br/>            j--<br/>        }<br/>                <br/>        if(result &gt; maxArea) {<br/>            maxArea = result<br/>        }<br/>    }<br/>    return maxArea<br/>}</span></pre><h1 id="4295" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">结束语</h1><p id="d254" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">以下是优化解决方案的性能指标:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mj"><img src="../Images/9a61121f9db064de176b70d7c688d374.png" data-original-src="https://miro.medium.com/v2/resize:fit:1358/format:webp/1*c1BdbEnSGGU6vsH3ucnfvw.png"/></div></figure><p id="5739" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">在我的问题解决方法和Golang代码中，非常感谢任何提示、建议或反馈</p><p id="d393" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">关注更多！</p></div></div>    
</body>
</html>