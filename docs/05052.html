<html>
<head>
<title>Django-plpy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">姜戈-皮比</h1>
<blockquote>原文：<a href="https://medium.com/codex/django-plpy-717a5f4644dc?source=collection_archive---------2-----------------------#2022-01-28">https://medium.com/codex/django-plpy-717a5f4644dc?source=collection_archive---------2-----------------------#2022-01-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/d83f492bcf48b852e887238dc83668b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zdQpLrL9g24Ntx57QO1C5g.png"/></div></div></figure><h2 id="22e0" class="hr hs ht bd b fp hu hv hw hx hy hz dx ia translated" aria-label="kicker paragraph">Python &amp; Django</h2><div class=""/><div class=""><h2 id="940c" class="pw-subtitle-paragraph iz ic ht bd b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq dx translated">用于PostgreSQL中Python存储过程的Django工具包</h2></div><p id="4677" class="pw-post-body-paragraph jr js ht jt b ju jv jd jw jx jy jg jz ka kb kc kd ke kf kg kh ki kj kk kl km hb bi translated">PostgreSQL是最先进的老式SQL数据库之一，涵盖了大量的任务，表现出了出色的性能。PL/Python插件允许用Python编写存储过程。</p><p id="26e5" class="pw-post-body-paragraph jr js ht jt b ju jv jd jw jx jy jg jz ka kb kc kd ke kf kg kh ki kj kk kl km hb bi translated">Django通过其惊人的contrib模块与PostgreSQL集成，并支持许多现代特性，但不支持PL/Python。我的最后一个图书馆Django-plpy填补了这个空白。</p><p id="8b28" class="pw-post-body-paragraph jr js ht jt b ju jv jd jw jx jy jg jz ka kb kc kd ke kf kg kh ki kj kk kl km hb bi translated">TL；博士:GITHUB </p><blockquote class="ko kp kq"><p id="11a9" class="jr js kr jt b ju jv jd jw jx jy jg jz ks kb kc kd kt kf kg kh ku kj kk kl km hb bi translated">寻找一些Python或JS自由职业者，工资高达50€/小时？请不要犹豫<a class="ae kn" href="https://twitter.com/SchifferThorin" rel="noopener ugc nofollow" target="_blank">在Twitter </a>或<a class="ae kn" href="https://www.linkedin.com/in/thorin-schiffer/" rel="noopener ugc nofollow" target="_blank"> Linkedin </a>上联系我，告诉我你的简历、空闲时间和时薪。(CET +/- 3小时)。</p></blockquote><h1 id="58b3" class="kv kw ht bd kx ky kz la lb lc ld le lf ji lg jj lh jl li jm lj jo lk jp ll lm bi translated">关于PL/Python及其特性</h1><p id="8f6e" class="pw-post-body-paragraph jr js ht jt b ju ln jd jw jx lo jg jz ka lp kc kd ke lq kg kh ki lr kk kl km hb bi translated">PL/Python允许您使用Python而不是PostgreSQL的本地存储过程语言PL/SQL来创建全功能的存储过程。使用的Python版本在PostgreSQL构建中设置。</p><p id="7e53" class="pw-post-body-paragraph jr js ht jt b ju jv jd jw jx jy jg jz ka kb kc kd ke kf kg kh ki kj kk kl km hb bi translated">下面是一个PL/Python函数的简单示例:</p><figure class="ls lt lu lv fd hk"><div class="bz dy l di"><div class="lw lx l"/></div></figure><p id="b770" class="pw-post-body-paragraph jr js ht jt b ju jv jd jw jx jy jg jz ka kb kc kd ke kf kg kh ki kj kk kl km hb bi translated">和一个触发器:</p><figure class="ls lt lu lv fd hk"><div class="bz dy l di"><div class="lw lx l"/></div></figure><p id="eab9" class="pw-post-body-paragraph jr js ht jt b ju jv jd jw jx jy jg jz ka kb kc kd ke kf kg kh ki kj kk kl km hb bi translated">用Django在原始SQL中维护PL/Python函数可能会变得相当烦人，因为尽管Django ORM与数据库深度集成，但Django从未真正喜欢过存储过程和触发器。可能的原因是数据库负责数据存储，web应用负责逻辑。Django-plpy使得在没有数据库的情况下测试存储过程成为可能，至少外表上的逻辑保留在数据库中。让我们开始吧。</p><h1 id="4e2f" class="kv kw ht bd kx ky kz la lb lc ld le lf ji lg jj lh jl li jm lj jo lk jp ll lm bi translated">使用django-plpy</h1><p id="95d8" class="pw-post-body-paragraph jr js ht jt b ju ln jd jw jx lo jg jz ka lp kc kd ke lq kg kh ki lr kk kl km hb bi translated">将python函数引入数据库的主要工作流程是用<code class="du ly lz ma mb b">@plpython</code>修饰它们，并调用manage.py命令<code class="du ly lz ma mb b">syncfunctions</code>来安装它们。映射到相应Postgres类型函数签名的正确参数需要完整的注释。然后，参数被自动映射到适当的数据库类型。</p><figure class="ls lt lu lv fd hk"><div class="bz dy l di"><div class="lw lx l"/></div></figure><p id="8674" class="pw-post-body-paragraph jr js ht jt b ju jv jd jw jx jy jg jz ka kb kc kd ke kf kg kh ki kj kk kl km hb bi translated">在执行了<code class="du ly lz ma mb b">manage.py syncfuntion</code>之后，Django-plpy将把这个函数封装在一个存储过程中，并安装到数据库中。该函数仍然是python函数，可以在不涉及数据库的情况下轻松进行单元测试。下面是该功能安装后的使用方法。</p><h2 id="9122" class="mc kw ht bd kx md me mf lb mg mh mi lf ka mj mk lh ke ml mm lj ki mn mo ll hz bi translated">SQL查询中的Python函数</h2><figure class="ls lt lu lv fd hk"><div class="bz dy l di"><div class="lw lx l"/></div></figure><h2 id="fb2b" class="mc kw ht bd kx md me mf lb mg mh mi lf ka mj mk lh ke ml mm lj ki mn mo ll hz bi translated">标注中的Python函数</h2><figure class="ls lt lu lv fd hk"><div class="bz dy l di"><div class="lw lx l"/></div></figure><h2 id="85ef" class="mc kw ht bd kx md me mf lb mg mh mi lf ka mj mk lh ke ml mm lj ki mn mo ll hz bi translated">使用python函数进行自定义ORM查找</h2><figure class="ls lt lu lv fd hk"><div class="bz dy l di"><div class="lw lx l"/></div></figure><h2 id="3850" class="mc kw ht bd kx md me mf lb mg mh mi lf ka mj mk lh ke ml mm lj ki mn mo ll hz bi translated">python触发器的安装</h2><p id="0e77" class="pw-post-body-paragraph jr js ht jt b ju ln jd jw jx lo jg jz ka lp kc kd ke lq kg kh ki lr kk kl km hb bi translated">触发器是一种非常强大的机制，django-plpy允许您轻松地将python函数标记为触发器，因此项目中的一些逻辑直接与数据库中的数据更改事件相关联。</p><p id="b037" class="pw-post-body-paragraph jr js ht jt b ju jv jd jw jx jy jg jz ka kb kc kd ke kf kg kh ki kj kk kl km hb bi translated">下面是一个使用<code class="du ly lz ma mb b">@pltrigger</code>装饰器的python触发器的例子。</p><figure class="ls lt lu lv fd hk"><div class="bz dy l di"><div class="lw lx l"/></div></figure><h2 id="077a" class="mc kw ht bd kx md me mf lb mg mh mi lf ka mj mk lh ke ml mm lj ki mn mo ll hz bi translated">在触发器中使用Django模型</h2><p id="ad88" class="pw-post-body-paragraph jr js ht jt b ju ln jd jw jx lo jg jz ka lp kc kd ke lq kg kh ki lr kk kl km hb bi translated"><code class="du ly lz ma mb b">@pltrigger</code> decorator的参数声明触发器参数，如触发器将绑定到的事件和表名。您可以将<code class="du ly lz ma mb b">table_name</code>替换为型号名称，表格名称将被自动查找:</p><figure class="ls lt lu lv fd hk"><div class="bz dy l di"><div class="lw lx l"/></div></figure><p id="ed29" class="pw-post-body-paragraph jr js ht jt b ju jv jd jw jx jy jg jz ka kb kc kd ke kf kg kh ki kj kk kl km hb bi translated">在Postgres官方文档中阅读更多关于plpy触发器的信息:<a class="ae kn" href="https://www.postgresql.org/docs/13/plpython-database.html" rel="noopener ugc nofollow" target="_blank">https://www.postgresql.org/docs/13/plpython-database.html</a>。</p><p id="7674" class="pw-post-body-paragraph jr js ht jt b ju jv jd jw jx jy jg jz ka kb kc kd ke kf kg kh ki kj kk kl km hb bi translated">不过，在触发器中使用Django ORM是有代价的，所以如果您想使用它们，请查看下面的实现细节。</p><h2 id="ed89" class="mc kw ht bd kx md me mf lb mg mh mi lf ka mj mk lh ke ml mm lj ki mn mo ll hz bi translated">批量操作和触发器，迁移</h2><p id="bb9e" class="pw-post-body-paragraph jr js ht jt b ju ln jd jw jx lo jg jz ka lp kc kd ke lq kg kh ki lr kk kl km hb bi translated">Python触发器是全功能的Postgres触发器，这意味着它们将为每一行创建，不像Django信号。因此，如果您用<code class="du ly lz ma mb b">event=”UPDATE”</code>定义了一个触发器，并在一个模型上调用批量更新，那么这个触发器将为所有受操作影响的对象调用:</p><figure class="ls lt lu lv fd hk"><div class="bz dy l di"><div class="lw lx l"/></div><figcaption class="mp mq et er es mr ms bd b be z dx translated">Updated为每一行调用触发器</figcaption></figure><p id="7a3c" class="pw-post-body-paragraph jr js ht jt b ju jv jd jw jx jy jg jz ka kb kc kd ke kf kg kh ki kj kk kl km hb bi translated">与Django模型或信号的代码不同，在迁移时也会调用触发器。</p><h2 id="d68c" class="mc kw ht bd kx md me mf lb mg mh mi lf ka mj mk lh ke ml mm lj ki mn mo ll hz bi translated">将Django信号转换为PL/Python触发器</h2><p id="2709" class="pw-post-body-paragraph jr js ht jt b ju ln jd jw jx lo jg jz ka lp kc kd ke lq kg kh ki lr kk kl km hb bi translated">尽管Django信号既不是异步的，也不能在另一个线程或进程中执行，但许多开发人员错误地认为它们会这样。这通常会导致回调地狱和复杂的执行流程，因为Django信号实现了一个dispatcher-receiver模式，并且只给人一种异步执行的印象。</p><p id="cf83" class="pw-post-body-paragraph jr js ht jt b ju jv jd jw jx jy jg jz ka kb kc kd ke kf kg kh ki kj kk kl km hb bi translated">使用django-plpy，您可以快速地将信号转换成触发器，并使它们真正异步。</p><figure class="ls lt lu lv fd hk"><div class="bz dy l di"><div class="lw lx l"/></div></figure><h1 id="96f8" class="kv kw ht bd kx ky kz la lb lc ld le lf ji lg jj lh jl li jm lj jo lk jp ll lm bi translated">在去那里的路上</h1><h2 id="3568" class="mc kw ht bd kx md me mf lb mg mh mi lf ka mj mk lh ke ml mm lj ki mn mo ll hz bi translated">代码的安装方式</h2><p id="c373" class="pw-post-body-paragraph jr js ht jt b ju ln jd jw jx lo jg jz ka lp kc kd ke lq kg kh ki lr kk kl km hb bi translated">Django-plpy复制函数代码，包装在PL/Python存储过程或触发器中，然后用<code class="du ly lz ma mb b">manage.py syncfunctions</code>安装。如果您使用Django模型，数据库需要访问您的项目文件和virtualenv(见下文)，或者如果您创建自己的数据库docker映像，则必须相应地提供它。这种情况看起来很奇怪，并且伴随着一定的风险。</p><h2 id="818d" class="mc kw ht bd kx md me mf lb mg mh mi lf ka mj mk lh ke ml mm lj ki mn mo ll hz bi translated">在PL函数和触发器中使用Django</h2><p id="ac94" class="pw-post-body-paragraph jr js ht jt b ju ln jd jw jx lo jg jz ka lp kc kd ke lq kg kh ki lr kk kl km hb bi translated">使用<code class="du ly lz ma mb b">syncfunctions</code>安装时，函数的源代码将被复制到相应的存储过程中，并安装在Postgres中。这使得您的本地上下文对函数不可用，这意味着没有模型或库可以在被转移的函数中使用。</p><p id="7a73" class="pw-post-body-paragraph jr js ht jt b ju jv jd jw jx jy jg jz ka kb kc kd ke kf kg kh ki kj kk kl km hb bi translated">为了解决这个问题，您需要在Postgres python解释器中设置python项目和环境。Django-plpy支持以下两种使用数据库的场景。</p><h1 id="3398" class="kv kw ht bd kx ky kz la lb lc ld le lf ji lg jj lh jl li jm lj jo lk jp ll lm bi translated">数据库设置和配置</h1><h2 id="76a0" class="mc kw ht bd kx md me mf lb mg mh mi lf ka mj mk lh ke ml mm lj ki mn mo ll hz bi translated">数据库和应用程序在同一台主机上</h2><p id="9d88" class="pw-post-body-paragraph jr js ht jt b ju ln jd jw jx lo jg jz ka lp kc kd ke lq kg kh ki lr kk kl km hb bi translated">现在很少使用，但仍然存在，这种场景对于环境共享来说是最简单的。Django-plpy创建存储过程并将必要的配置传输到数据库:</p><ul class=""><li id="9e1e" class="mt mu ht jt b ju jv jx jy ka mv ke mw ki mx km my mz na nb bi translated">机密和数据库访问凭据</li><li id="1986" class="mt mu ht jt b ju nc jx nd ka ne ke nf ki ng km my mz na nb bi translated">python env的路径(默认为<code class="du ly lz ma mb b">distutils.sysconfig.get_python_lib()</code>，更多配置见下文)</li><li id="7383" class="mt mu ht jt b ju nc jx nd ka ne ke nf ki ng km my mz na nb bi translated">按照manage.py的方式加载Django应用程序</li></ul><h2 id="242b" class="mc kw ht bd kx md me mf lb mg mh mi lf ka mj mk lh ke ml mm lj ki mn mo ll hz bi translated">数据库在一个单独的docker容器中</h2><p id="9514" class="pw-post-body-paragraph jr js ht jt b ju ln jd jw jx lo jg jz ka lp kc kd ke lq kg kh ki lr kk kl km hb bi translated">一个更常见的生产场景是数据库在一个单独的docker容器上。</p><p id="5589" class="pw-post-body-paragraph jr js ht jt b ju jv jd jw jx jy jg jz ka kb kc kd ke kf kg kh ki kj kk kl km hb bi translated">官方Postgres镜像不支持plpython插件，所以如果你想这样使用plpython，你需要创建你的镜像或者使用我创建的一个。</p><p id="0b40" class="pw-post-body-paragraph jr js ht jt b ju jv jd jw jx jy jg jz ka kb kc kd ke kf kg kh ki kj kk kl km hb bi translated">所有映像都提供python 3.7，因为Postgres使用映像所基于的操作系统中的默认python环境，而3.7是Debian Buster的标准。</p><h2 id="bf59" class="mc kw ht bd kx md me mf lb mg mh mi lf ka mj mk lh ke ml mm lj ki mn mo ll hz bi translated">使用django-plpy和dockerized Postgres</h2><p id="3637" class="pw-post-body-paragraph jr js ht jt b ju ln jd jw jx lo jg jz ka lp kc kd ke lq kg kh ki lr kk kl km hb bi translated">为了让Postgres python解释器可以使用代码，它必须以某种方式出现在docker容器中。如果您决定编写docker映像docker文件，您可以在构建时使用它来提供映像，也可以使用volumes来共享代码。</p><p id="5b52" class="pw-post-body-paragraph jr js ht jt b ju jv jd jw jx jy jg jz ka kb kc kd ke kf kg kh ki kj kk kl km hb bi translated">一旦代码和环境存在于Docker容器中的某个地方，django-plpy就可以被告知使用它们:因此，如果您的环境位于<code class="du ly lz ma mb b">/env</code>(将site-packages文件夹复制到该路径)下，而您的应用程序位于<code class="du ly lz ma mb b">/app</code>中，那么将以下设置添加到您的<code class="du ly lz ma mb b">settings.py</code>中</p><pre class="ls lt lu lv fd nh mb ni nj aw nk bi"><span id="b834" class="mc kw ht mb b fi nl nm l nn no">PLPY_ENV_PATHS = ["/env"]<br/>PLPY_PROJECT_PATH = "/app"</span></pre><h2 id="1ced" class="mc kw ht bd kx md me mf lb mg mh mi lf ka mj mk lh ke ml mm lj ki mn mo ll hz bi translated">AWS RDS和其他托管数据库</h2><p id="de63" class="pw-post-body-paragraph jr js ht jt b ju ln jd jw jx lo jg jz ka lp kc kd ke lq kg kh ki lr kk kl km hb bi translated">在SaaS时代，数据库很少在docker镜像中连接，但在AWS RDS之类的托管数据库中更为常见。在这种情况下，django-plpy只能安装简单的函数和触发器，因为在这种设置中无法访问数据库的文件系统。</p><p id="8f3a" class="pw-post-body-paragraph jr js ht jt b ju jv jd jw jx jy jg jz ka kb kc kd ke kf kg kh ki kj kk kl km hb bi translated">此外，一些托管数据库不会给你超级用户权限，这意味着在这种情况下安装扩展会很麻烦。</p><h2 id="0e8a" class="mc kw ht bd kx md me mf lb mg mh mi lf ka mj mk lh ke ml mm lj ki mn mo ll hz bi translated">隐藏递归</h2><p id="a7a7" class="pw-post-body-paragraph jr js ht jt b ju ln jd jw jx lo jg jz ka lp kc kd ke lq kg kh ki lr kk kl km hb bi translated">在触发函数中意外调用<code class="du ly lz ma mb b">Model.save</code>会造成非常糟糕的情况:触发函数会使用psycopg通过网络连接到本地数据库，导致一个新的事务被创建，无限重复所有的循环很多次。这种隐藏的递归会淹没数据库和应用服务器。</p><p id="92a0" class="pw-post-body-paragraph jr js ht jt b ju jv jd jw jx jy jg jz ka kb kc kd ke kf kg kh ki kj kk kl km hb bi translated">由触发器引起的任何写操作都可以触发相同的效果。因此，您应该避免在触发器中使用任何ORM方法。</p><h1 id="925f" class="kv kw ht bd kx ky kz la lb lc ld le lf ji lg jj lh jl li jm lj jo lk jp ll lm bi translated">安装和文档</h1><p id="059b" class="pw-post-body-paragraph jr js ht jt b ju ln jd jw jx lo jg jz ka lp kc kd ke lq kg kh ki lr kk kl km hb bi translated">完整的文档和安装说明可在<a class="ae kn" href="https://github.com/eviltnan/django-plpy#python-functions-in-annotations" rel="noopener ugc nofollow" target="_blank">这里</a>找到。为你的项目检查一下，欢迎你来投稿。</p><p id="cd73" class="pw-post-body-paragraph jr js ht jt b ju jv jd jw jx jy jg jz ka kb kc kd ke kf kg kh ki kj kk kl km hb bi">=====================================</p><p id="1ace" class="pw-post-body-paragraph jr js ht jt b ju jv jd jw jx jy jg jz ka kb kc kd ke kf kg kh ki kj kk kl km hb bi translated">如果你喜欢这个，看看我最近的文章:</p><p id="fc06" class="pw-post-body-paragraph jr js ht jt b ju jv jd jw jx jy jg jz ka kb kc kd ke kf kg kh ki kj kk kl km hb bi translated">🇩🇪 <a class="ae kn" rel="noopener" href="/swlh/part-1-10-things-about-employment-in-germany-eacdac94818b">赴德就业:</a>终极指南</p><p id="e8f3" class="pw-post-body-paragraph jr js ht jt b ju jv jd jw jx jy jg jz ka kb kc kd ke kf kg kh ki kj kk kl km hb bi translated">🕒<a class="ae kn" href="https://thorin-schiffer.medium.com/same-old-story-4d1ef4df0824" rel="noopener">为什么你的软件质量会随着时间退化</a>:短篇小说</p><p id="795d" class="pw-post-body-paragraph jr js ht jt b ju jv jd jw jx jy jg jz ka kb kc kd ke kf kg kh ki kj kk kl km hb bi translated">😃<a class="ae kn" rel="noopener" href="/analytics-vidhya/rapidapi-and-fastapi-d720789a5b7e"> RapidAPI:使用Python的第一步</a></p></div></div>    
</body>
</html>