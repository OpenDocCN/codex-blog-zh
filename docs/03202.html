<html>
<head>
<title>Set up a Multi-Stage Docker Build for Go Applications</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为Go应用程序建立多阶段Docker构建</h1>
<blockquote>原文：<a href="https://medium.com/codex/set-up-a-multi-stage-docker-build-for-go-applications-a37113791b4f?source=collection_archive---------15-----------------------#2021-08-22">https://medium.com/codex/set-up-a-multi-stage-docker-build-for-go-applications-a37113791b4f?source=collection_archive---------15-----------------------#2021-08-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="f678" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">好的开始是成功的一半</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/049acc57dbf968ff984784eb621ff5f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fLw3iitdA3T9dqPF"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated"><a class="ae jn" href="https://unsplash.com/@pankajpatel?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Pankaj Patel </a>在<a class="ae jn" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="b30d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们将为Go应用程序创建一个简单的多阶段Docker构建设置。一开始听起来可能令人畏惧，但实际上非常简单。</p><p id="12f7" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">多阶段Docker构建有几个用途。首先，最终的图像尺寸比传统图像更小，其次，它更安全。</p><p id="d6c4" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">使用dockers分层，我们可以将构建过程抽象为多个阶段。并且只复制我们下一阶段需要的输出。例如，我们正在运行<code class="du kk kl km kn b">go build -o main</code>创建的二进制文件。</p><p id="2edc" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这里的目标是最终得到一个docker映像，它只包含并运行最终的二进制文件。最后的二进制是什么，在这个上下文中并不重要。但是在本文中，我将使用一个简单的脚本向控制台输出文本。</p><h2 id="c10c" class="ko kp hi bd kq kr ks kt ku kv kw kx ky jx kz la lb kb lc ld le kf lf lg lh li bi translated">要求</h2><p id="1ba5" class="pw-post-body-paragraph jo jp hi jq b jr lj ij jt ju lk im jw jx ll jz ka kb lm kd ke kf ln kh ki kj hb bi translated">我们将需要以下工具，所以请确保您已经在机器上安装了这些工具。</p><ul class=""><li id="ce86" class="lo lp hi jq b jr js ju jv jx lq kb lr kf ls kj lt lu lv lw bi translated">Go 1.x或更高版本</li><li id="32c6" class="lo lp hi jq b jr lx ju ly jx lz kb ma kf mb kj lt lu lv lw bi translated">码头工人</li><li id="0f4e" class="lo lp hi jq b jr lx ju ly jx lz kb ma kf mb kj lt lu lv lw bi translated">VSCode或任何其他编辑器</li></ul><h2 id="231d" class="ko kp hi bd kq kr ks kt ku kv kw kx ky jx kz la lb kb lc ld le kf lf lg lh li bi translated">让我们写一些代码</h2><p id="14e5" class="pw-post-body-paragraph jo jp hi jq b jr lj ij jt ju lk im jw jx ll jz ka kb lm kd ke kf ln kh ki kj hb bi translated">让我们创建文件夹结构，以便我们有一个良好的基础来构建。在其中创建一个名为<code class="du kk kl km kn b">src</code>和<code class="du kk kl km kn b">cd</code>的目录。</p><p id="023f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在，让我们用下面的命令<code class="du kk kl km kn b">go mod init hello-world</code>初始化我们的go包。这将创建一个名为<code class="du kk kl km kn b">go.mod</code>的文件。</p><p id="53e0" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">完成这一部分后，让我们用Go编写一个简单的Hello World。在我们的<code class="du kk kl km kn b">src</code>目录中创建一个名为<code class="du kk kl km kn b">main.go</code>的文件，并添加以下代码。</p><pre class="iy iz ja jb fd mc kn md me aw mf bi"><span id="2603" class="ko kp hi kn b fi mg mh l mi mj">package main<br/><br/>import "fmt"<br/><br/>func main() {<br/>  fmt.Println("Hello World!")<br/>}</span></pre><p id="8473" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">如果您使用<code class="du kk kl km kn b">go run main.go</code>运行这个命令，输出将是<code class="du kk kl km kn b">Hello World!</code>。太好了，这一部分已经完成了，我们可以从深入Docker开始了！</p><h2 id="8627" class="ko kp hi bd kq kr ks kt ku kv kw kx ky jx kz la lb kb lc ld le kf lf lg lh li bi translated">戈朗基地形象</h2><p id="6c29" class="pw-post-body-paragraph jo jp hi jq b jr lj ij jt ju lk im jw jx ll jz ka kb lm kd ke kf ln kh ki kj hb bi translated">将目录(<code class="du kk kl km kn b">cd ..</code>)更改为项目根目录，在这里我们将创建一个<code class="du kk kl km kn b">dockerfile</code>。粘贴下面的代码，然后我会解释我们在做什么。</p><pre class="iy iz ja jb fd mc kn md me aw mf bi"><span id="736b" class="ko kp hi kn b fi mg mh l mi mj">FROM golang:1.16-alpine<br/><br/># Create a workspace for the app<br/>WORKDIR /app<br/><br/># Download necessary Go modules<br/>COPY src/go.mod .<br/>RUN go mod download<br/><br/># Copy over the source files<br/>COPY src/*.go ./<br/><br/># Build<br/>RUN go build -o /main<br/><br/>ENTRYPOINT ["/main"]</span></pre><p id="f695" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这里我们要做一些事情，在<code class="du kk kl km kn b">FROM</code>行我们要指定我们要使用哪个基础图像。设置一个<code class="du kk kl km kn b">WORKDIR</code>就像设置一个我们将要工作的特殊文件夹。然后我们复制我们的<code class="du kk kl km kn b">go.mod</code>，如果需要的话，下载我们的包。然后我们将复制我们的源代码。</p><p id="af50" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在这之后，我们准备构建我们的go应用程序，我们使用，<code class="du kk kl km kn b">RUN go build -o /main</code>。既然我们已经创建了一个单独的二进制文件，我们可以在运行docker映像时将它设置为入口点。</p><p id="4959" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">为了构建我们的图像，我们将使用<code class="du kk kl km kn b">docker build . -t hello-world-golang1.16</code>，这将构建图像。构建完成后。我们可以使用命令<code class="du kk kl km kn b">docker run hello-world-golang1.16</code>将我们的映像作为一个容器来运行，以测试这是否可行。您应该会得到类似于<code class="du kk kl km kn b">Hello World!</code>的输出。</p><p id="1a01" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">让我们也检查一下我们的图像的大小。使用<code class="du kk kl km kn b">docker images</code>命令，我们可以看到尺寸。</p><pre class="iy iz ja jb fd mc kn md me aw mf bi"><span id="bd54" class="ko kp hi kn b fi mg mh l mi mj">REPOSITORY               TAG       IMAGE ID       CREATED              SIZE<br/>hello-world-golang1.16   latest    68b776701cbe   About a minute ago   304MB</span></pre><p id="e51b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">哇，这是一个沉重的形象！以304 MB的速度进来。让我们试着去掉一些脂肪。</p><p id="39bd" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在我研究使用多阶段Docker构建的过程中。我看到Docker文档使用了Debian基本映像。正因为如此，我想把它也包括在这里。</p><p id="0471" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">让我们用下面的代码替换我们之前创建的<code class="du kk kl km kn b">dockerfile</code>。注意这里的两个注释，Builder和Runner。构建器部分用于构建go应用程序，仅此而已。对于Runner部分也是如此，因为它的唯一目的是运行我们的应用程序。</p><p id="9444" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">构建器将<code class="du kk kl km kn b">golang:1.6-alpine</code>作为基础映像，因为它需要在路径中包含<code class="du kk kl km kn b">Go</code>二进制文件。因为Go编译成一个二进制文件，所以运行它不需要Go的存在。因此，我们可以使用Debian的基本映像作为最终的映像来运行我们的应用程序。</p><pre class="iy iz ja jb fd mc kn md me aw mf bi"><span id="b094" class="ko kp hi kn b fi mg mh l mi mj">#<br/># Builder<br/>#<br/><br/>FROM golang:1.16-alpine AS builder<br/><br/># Create a workspace for the app<br/>WORKDIR /app<br/><br/># Download necessary Go modules<br/>COPY src/go.mod .<br/>RUN go mod download<br/><br/># Copy over the source files<br/>COPY src/*.go ./<br/><br/># Build<br/>RUN go build -o /main<br/><br/>#<br/># Runner<br/>#<br/><br/>FROM gcr.io/distroless/base-debian10 AS runner<br/><br/>WORKDIR /<br/><br/># Copy from builder the final binary<br/>COPY --from=builder /main /main<br/><br/>USER nonroot:nonroot<br/><br/>ENTRYPOINT ["/main"]</span></pre><p id="b4b2" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我正在更改build命令，这样我们就不会覆盖我们之前创建的映像。这样，我们可以看到我们的变化对最终的docker图像产生了什么影响。</p><p id="a6b2" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">使用<code class="du kk kl km kn b">docker build . -t hello-world-debian</code>建立我们的新形象。让我们看看这是否改变了容器<code class="du kk kl km kn b">docker run hello-world-debian</code>的行为。并且你应该得到和之前一样的输出:<code class="du kk kl km kn b">Hello World!</code>。</p><p id="1570" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">让我们用<code class="du kk kl km kn b">docker images</code>检查尺寸。</p><pre class="iy iz ja jb fd mc kn md me aw mf bi"><span id="a1e9" class="ko kp hi kn b fi mg mh l mi mj">REPOSITORY               TAG       IMAGE ID       CREATED              SIZE<br/>hello-world-debian       latest    7ad8a5965a06   About a minute ago   21.1MB<br/>hello-world-golang1.16   latest    68b776701cbe   About a minute ago   304MB</span></pre><p id="6bb5" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">看，21.1 MB，这是一个很大的缩减！</p><p id="36e9" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">太棒了，但是我们能不能再推一点？是的，我们可以！</p><p id="f262" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">使用最小的docker基本映像。也就是<code class="du kk kl km kn b">scratch</code>。这已经够光秃秃的了。在docker文件的runner部分，将<code class="du kk kl km kn b">FROM</code>语句改为<code class="du kk kl km kn b">scratch</code>，如下所示。</p><pre class="iy iz ja jb fd mc kn md me aw mf bi"><span id="1c2a" class="ko kp hi kn b fi mg mh l mi mj">#<br/># Runner<br/>#<br/><br/># FROM gcr.io/distroless/base-debian10 AS runner<br/>FROM scratch AS runner</span></pre><p id="cb68" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">使用<code class="du kk kl km kn b">docker build . -t hello-world-scratch</code>建立我们的新形象。让我们看看这是否改变了容器<code class="du kk kl km kn b">docker run hello-world-scratch</code>的行为。你应该得到和以前一样的输出:<code class="du kk kl km kn b">Hello World!</code>。</p><p id="594e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">让我们使用<code class="du kk kl km kn b">docker images</code>再次检查尺寸。</p><pre class="iy iz ja jb fd mc kn md me aw mf bi"><span id="bb3f" class="ko kp hi kn b fi mg mh l mi mj">REPOSITORY               TAG       IMAGE ID       CREATED              SIZE<br/>hello-world-scratch      latest    eb41c9777973   58 seconds ago       1.94MB<br/>hello-world-debian       latest    7ad8a5965a06   About a minute ago   21.1MB<br/>hello-world-golang1.16   latest    68b776701cbe   About a minute ago   304MB</span></pre><p id="793e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">你看看，1.94兆！太完美了。</p><h2 id="d116" class="ko kp hi bd kq kr ks kt ku kv kw kx ky jx kz la lb kb lc ld le kf lf lg lh li bi translated">包装它</h2><p id="ba59" class="pw-post-body-paragraph jo jp hi jq b jr lj ij jt ju lk im jw jx ll jz ka kb lm kd ke kf ln kh ki kj hb bi translated">我希望我已经启发你在下一个项目中使用多阶段Docker构建。这仍然是一个简单的两阶段Docker构建，如果你需要或者当你的项目需要时，你甚至可以使用更多的阶段。</p><p id="f459" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这里有一些有用的链接和源代码，所以你可以自己尝试一下。</p><ul class=""><li id="ca03" class="lo lp hi jq b jr js ju jv jx lq kb lr kf ls kj lt lu lv lw bi translated"><a class="ae jn" href="https://golang.org" rel="noopener ugc nofollow" target="_blank">戈朗</a></li><li id="4468" class="lo lp hi jq b jr lx ju ly jx lz kb ma kf mb kj lt lu lv lw bi translated"><a class="ae jn" href="https://docs.docker.com/language/golang/build-images/#multi-stage-builds" rel="noopener ugc nofollow" target="_blank">码头工人</a></li><li id="8542" class="lo lp hi jq b jr lx ju ly jx lz kb ma kf mb kj lt lu lv lw bi translated"><a class="ae jn" href="https://github.com/koenverburg/article-source-code/tree/main/multi-stage-docker-build-go" rel="noopener ugc nofollow" target="_blank">源代码</a></li></ul></div></div>    
</body>
</html>