<html>
<head>
<title>Building a tic tac toe game with LitElement</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用LitElement构建井字游戏</h1>
<blockquote>原文：<a href="https://medium.com/codex/building-a-tic-tac-toe-game-with-litelement-73e479f5a66d?source=collection_archive---------13-----------------------#2021-07-23">https://medium.com/codex/building-a-tic-tac-toe-game-with-litelement-73e479f5a66d?source=collection_archive---------13-----------------------#2021-07-23</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="251b" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">使用web组件构建交互式游戏</h2></div><p id="232b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在本文中，我们将使用基于web组件的库元素来构建经典的井字游戏。</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es jt"><img src="../Images/9e286dca66e026ab3601953f8488523f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BWXUexDv63IZH16HS9kDig.png"/></div></div></figure><h1 id="100e" class="kf kg hi bd kh ki kj kk kl km kn ko kp io kq ip kr ir ks is kt iu ku iv kv kw bi translated">项目初始化</h1><p id="e84f" class="pw-post-body-paragraph ix iy hi iz b ja kx ij jc jd ky im jf jg kz ji jj jk la jm jn jo lb jq jr js hb bi translated">首先，让我们做一些脚手架。为此，我推荐使用方便的dandy <a class="ae lc" href="https://open-wc.org" rel="noopener ugc nofollow" target="_blank"> open-wc </a>生成器工具，它为我们建立了一个lit-element组件。我们将在终端中键入以下命令:</p><pre class="ju jv jw jx fd ld le lf lg aw lh bi"><span id="45a7" class="li kg hi le b fi lj lk l ll lm">$ <!-- -->npm init @open-wc</span></pre><p id="5d53" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">该命令将初始化脚手架工具，以生成Lit元素组件或应用程序。我们将看到以下屏幕:</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div class="er es ln"><img src="../Images/1e2357d834381c8224fb736451d3fb3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1292/format:webp/1*6sVUAiYcHrMKZRIbAzRzaQ.png"/></div></figure><p id="219d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">要创建一个新项目，选择第一个选项:<em class="lo">搭建一个新项目</em>。之后，该工具会询问我们是否要创建一个组件或应用程序。为了制作一个可重用的组件，我们将选择<code class="du lp lq lr le b">Web Component</code>。</p><p id="a130" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后，我们会被问及是否要添加一些额外的功能，如林挺(代码样式)，测试和演示。这些都是完全可选的，但是您可以考虑至少包含测试模块来为组件运行自动化测试。</p><p id="ff5b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后这个工具会问我们是否要使用typescript，这个项目不会这样，所以我们点击<em class="lo"> No </em>。</p><p id="8e44" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们将继续命名我们的组件。随便你怎么命名，我就简单的给我的命名:井字游戏。记住Lit要求至少用两个连字符分隔的单词来命名它，如:my-component。不允许使用一个单词的名字。</p><p id="b7ae" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最后，它将向您展示将要写入磁盘的组件的文件结构。选择<em class="lo"> yes </em>后，工具会询问我们是否要安装依赖项。我们将选择第<em class="lo"> y </em> es，<em class="lo"> w </em> i <em class="lo">个npm </em>，这样我们就可以使用npm作为我们的依赖项管理器<em class="lo">。然后，它将最终为我们的新组件创建所有的文件夹和文件。</em></p><h2 id="fb0d" class="li kg hi bd kh ls lt lu kl lv lw lx kp jg ly lz kr jk ma mb kt jo mc md kv me bi translated">项目结构</h2><p id="1961" class="pw-post-body-paragraph ix iy hi iz b ja kx ij jc jd ky im jf jg kz ji jj jk la jm jn jo lb jq jr js hb bi translated">open-wc工具使用指定的组件名(在本例中是tic-tac-toe)在文件夹中生成以下项目结构。</p><pre class="ju jv jw jx fd ld le lf lg aw lh bi"><span id="af19" class="li kg hi le b fi lj lk l ll lm">./<br/>├── tic-tac-toe/<br/>│   ├── demo/<br/>│   │   └── index.html<br/>│   ├── src/<br/>│   │   └── TicTacToe.js<br/>│   ├── .editorconfig<br/>│   ├── .gitignore<br/>│   ├── custom-elements.json<br/>│   ├── index.js<br/>│   ├── LICENSE<br/>│   ├── package.json<br/>│   ├── README.md<br/>│   ├── tic-tac-toe.js<br/>│   └── web-dev-server.config.mjs</span></pre><p id="c4b3" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最重要的文件是:</p><ul class=""><li id="541d" class="mf mg hi iz b ja jb jd je jg mh jk mi jo mj js mk ml mm mn bi translated"><strong class="iz hj"> package.json </strong>包含npm项目的规范，以及它的依赖项和脚本。</li><li id="661d" class="mf mg hi iz b ja mo jd mp jg mq jk mr jo ms js mk ml mm mn bi translated">将我们的元素定义为本地web组件。</li><li id="d839" class="mf mg hi iz b ja mo jd mp jg mq jk mr jo ms js mk ml mm mn bi translated"><strong class="iz hj"> demo/index.htm </strong> l为我们的组件创建了一个展示页面，我们可以在这里看到它的实际显示。</li><li id="054f" class="mf mg hi iz b ja mo jd mp jg mq jk mr jo ms js mk ml mm mn bi translated"><strong class="iz hj"> src/TicTacToe.js </strong>组件本身。包含主组件的类的文件</li></ul><h1 id="4c9f" class="kf kg hi bd kh ki kj kk kl km kn ko kp io kq ip kr ir ks is kt iu ku iv kv kw bi translated">游戏组件</h1><p id="639a" class="pw-post-body-paragraph ix iy hi iz b ja kx ij jc jd ky im jf jg kz ji jj jk la jm jn jo lb jq jr js hb bi translated">现在我们有了一个组件，让我们开始把我们的小游戏组件分割成更小的部分，这样代码库更容易管理。主游戏实例将在我们的<code class="du lp lq lr le b">TicTacToe.js</code>文件中，它将运行游戏逻辑并包含棋盘。然后，我们将有一个<code class="du lp lq lr le b">TicTacToeCell.js</code>来代表我们的每个棋盘单元格，并包含一个十字或一个圆。因此，继续创建一个新文件，将第一个元素的内容复制到第二个元素中，或者复制第一个组件，只是不要忘记重命名它。项目结构现在应该看起来像这样:</p><pre class="ju jv jw jx fd ld le lf lg aw lh bi"><span id="1804" class="li kg hi le b fi lj lk l ll lm">./<br/>├── tic-tac-toe/<br/>│   ├── ...<br/>│   ├── src/<br/>│   │   ├── TicTacToe.js<br/>│   │   └── TicTacToeCell.js<br/>│   ├── ...</span></pre><p id="3e67" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，如果我们看一下文件<code class="du lp lq lr le b">TicTacToe.js</code>，它应该包含了很多我们不需要的支架代码。随意删除<code class="du lp lq lr le b">__increment</code>方法和所有方法的内容。现在，让我们开始编码。</p><h2 id="5025" class="li kg hi bd kh ls lt lu kl lv lw lx kp jg ly lz kr jk ma mb kt jo mc md kv me bi translated">属性和模板</h2><p id="25d8" class="pw-post-body-paragraph ix iy hi iz b ja kx ij jc jd ky im jf jg kz ji jj jk la jm jn jo lb jq jr js hb bi translated">让我们设置一些属性来管理棋盘状态和游戏条件。将<code class="du lp lq lr le b">properties</code>方法内容替换为以下内容:</p><figure class="ju jv jw jx fd jy"><div class="bz dy l di"><div class="mt mu l"/></div></figure><p id="67c0" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里我设置了一个<code class="du lp lq lr le b">board</code>属性，它将保存一个数组来表示每个玩家在棋盘上的移动。属性将依次保存玩家的号码，1或2。<code class="du lp lq lr le b">plays</code>是一个保存每个玩家移动次数的对象，以防我们以后想要实现某种统计。最后<code class="du lp lq lr le b">turn</code>保存了出于同样原因的播放次数。</p><p id="9624" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后，为了初始化所有这些变量，我们使用所有web组件固有的构造函数方法:</p><figure class="ju jv jw jx fd jy"><div class="bz dy l di"><div class="mt mu l"/></div></figure><p id="ff74" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">由于游戏初始化发生多次，该功能在<code class="du lp lq lr le b">initGame</code>函数中被重构，该函数在构造函数中被调用一次，然后在每次游戏需要重置时再次被调用。我们还设置了一些事件监听器，以便在游戏达到结束条件时显示确认消息，即玩家获胜或平局。我们稍后将设置这些事件的触发器。</p><p id="82b4" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后，让我们为主要组件设置模板:</p><figure class="ju jv jw jx fd jy"><div class="bz dy l di"><div class="mt mu l"/></div></figure><p id="abef" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这里，我们只设置了一个div作为我们的板。然而，这里有趣的事情是我们使用我们的<code class="du lp lq lr le b">tic-tac-toe-cell</code>来实际呈现单元格的内容，可能是一个十字或者一个圆。为了实现这一点，我们将单元格的属性<code class="du lp lq lr le b">.symbol</code>设置为一个空字符串，因为我们还不想让它显示任何符号。然后，为了让游戏逻辑工作，我们需要将我们的棋盘状态的数据表示(在这种情况下是我们的<code class="du lp lq lr le b">this.board</code>属性)与每个单元格的可视化表示(每个<code class="du lp lq lr le b">tic-tac-toe-cell</code>)结合起来，这就是为什么我们还在单元格中设置了一个<code class="du lp lq lr le b">.col</code>和一个<code class="du lp lq lr le b">.row</code>属性。最后，我们需要在单元格中有一个事件监听器，在用户单击它时监听它。方法<code class="du lp lq lr le b">this._handleClick</code>将用于该目的:</p><figure class="ju jv jw jx fd jy"><div class="bz dy l di"><div class="mt mu l"/></div></figure><p id="20b7" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du lp lq lr le b">handleClick</code>方法将根据当前玩家依次为点击的单元格设置相应的符号。它还会更新棋盘数组，以表示最新的棋步和游戏次数。最后，它会将回合传递给下一个调用<code class="du lp lq lr le b">changePlayer</code>方法的玩家。这里需要注意的是，如果所选单元格已经被选中，上面的任何操作都将被执行。</p><p id="9490" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在进行实际的<code class="du lp lq lr le b">tic-tac-toe-cell</code>:</p><figure class="ju jv jw jx fd jy"><div class="bz dy l di"><div class="mt mu l"/></div></figure><p id="a682" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">它由一个简单的组件组成，具有属性:<code class="du lp lq lr le b">row</code>、<code class="du lp lq lr le b">col</code>和<code class="du lp lq lr le b">symbol</code>。它有一个非常简单的模板，我们只需要它根据作为参数传递的<code class="du lp lq lr le b">symbol</code>显示一个带有类的div。也许这个组件中最值得注意的是它的样式，它们反映了符号属性。为了显示一个漂亮的图标一样的符号，我们使用普通的css。</p><h2 id="d409" class="li kg hi bd kh ls lt lu kl lv lw lx kp jg ly lz kr jk ma mb kt jo mc md kv me bi translated">样式和项目开始命令</h2><p id="3d30" class="pw-post-body-paragraph ix iy hi iz b ja kx ij jc jd ky im jf jg kz ji jj jk la jm jn jo lb jq jr js hb bi translated">谈到风格，让我们也为我们的董事会设定一个风格，好吗？将以下方法添加到我们的<code class="du lp lq lr le b">TicTacToe</code>类中:</p><figure class="ju jv jw jx fd jy"><div class="bz dy l di"><div class="mt mu l"/></div></figure><p id="d6e7" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们的井字游戏组件现在可以展示了。现在，在shell中键入以下命令来可视化您的项目，只需确保您在项目的文件夹中:</p><pre class="ju jv jw jx fd ld le lf lg aw lh bi"><span id="0cf8" class="li kg hi le b fi lj lk l ll lm">$ npm run start</span></pre><p id="c4ca" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这将服务于项目的文件。具体来说，我们将可视化<code class="du lp lq lr le b">demo/index.html</code>文件中的所有内容，这是我们组件的展示窗口，还记得吗？</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div class="er es mv"><img src="../Images/bf412eca5eaa8df1815be4e60d0d18da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*P1WfZVD6gjkWGTw5Ac5fRQ.gif"/></div><figcaption class="mw mx et er es my mz bd b be z dx translated">只需几行代码，我们的组件就活了过来！</figcaption></figure><p id="e66a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">很简单，不是吗？请注意，它甚至会根据当前玩家的身份来改变填充单元格的符号。然而，我们的小井字游戏无法确定谁赢了，或者比赛是否以平局结束，也不会在比赛结束后重置，让我们解决这个问题。</p><h1 id="4787" class="kf kg hi bd kh ki kj kk kl km kn ko kp io kq ip kr ir ks is kt iu ku iv kv kw bi translated">游戏逻辑</h1><p id="9861" class="pw-post-body-paragraph ix iy hi iz b ja kx ij jc jd ky im jf jg kz ji jj jk la jm jn jo lb jq jr js hb bi translated">首先，我们需要告诉我们的组件，一旦移动完成，就检查双方的胜利。为此，我们需要设置一些方法来检查什么是玩家的胜利。</p><h2 id="f655" class="li kg hi bd kh ls lt lu kl lv lw lx kp jg ly lz kr jk ma mb kt jo mc md kv me bi translated">检查胜利</h2><p id="a140" class="pw-post-body-paragraph ix iy hi iz b ja kx ij jc jd ky im jf jg kz ji jj jk la jm jn jo lb jq jr js hb bi translated">有三种方式玩家可以赢:如果一排只有一个玩家的符号(水平检查)；如果一列仅由该玩家的符号组成(垂直检查)；或者如果两个棋盘的对角线中的任何一个只包含玩家的符号(对角线检查)。</p><p id="7d84" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们创建进行这些检查的方法:</p><figure class="ju jv jw jx fd jy"><div class="bz dy l di"><div class="mt mu l"/></div></figure><p id="bdcb" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这不是最精彩的算法，但这是针对之前描述的三种情况的三种不同的方法。请随意用您自己的实现来替换它们，但这也很好。最后，有一个包装器<code class="du lp lq lr le b">checkVictory</code>函数可以在需要时轻松调用这三个方法。</p><p id="ae7a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在我们需要在玩家每次移动时调用这些。我们已经有了一个<code class="du lp lq lr le b">_handleClick</code>方法，每当玩家点击单元格时就会触发。让我们给这个方法添加胜利检查。</p><figure class="ju jv jw jx fd jy"><div class="bz dy l di"><div class="mt mu l"/></div></figure><p id="f98c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">还记得我们一开始在构造函数中设置的事件监听器吗？那些收听<em class="lo">玩家赢</em>和<em class="lo">平局</em>事件的人。这个新的实现触发了那些事件。超时功能防止事件在棋盘实际更新最后一步棋之前被调度，然后并且只有在那时游戏结束确认消息才可以显示。</p><h1 id="86a7" class="kf kg hi bd kh ki kj kk kl km kn ko kp io kq ip kr ir ks is kt iu ku iv kv kw bi translated">结论</h1><p id="e28f" class="pw-post-body-paragraph ix iy hi iz b ja kx ij jc jd ky im jf jg kz ji jj jk la jm jn jo lb jq jr js hb bi translated">我们用lit-element构建了一个简单而有趣的井字游戏组件。它可以打包并部署在任何web应用程序中，就像在<code class="du lp lq lr le b">demo/index.html</code>中一样。唯一困扰我的是确认消息真的很不美观，所以让我们在接下来的教程中构建一个漂亮的模态组件来显示游戏消息。</p></div></div>    
</body>
</html>