<html>
<head>
<title>How to calculate Pi</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">圆周率怎么算</h1>
<blockquote>原文：<a href="https://medium.com/codex/how-to-calculate-pi-fb2789c0aa62?source=collection_archive---------19-----------------------#2021-08-10">https://medium.com/codex/how-to-calculate-pi-fb2789c0aa62?source=collection_archive---------19-----------------------#2021-08-10</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="b6b1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这篇文章展示了我们如何使用一点数学和函数编程来近似圆周率。</p><p id="a8da" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它从引入<code class="du jd je jf jg b">Seq</code>开始，它允许在F#中操作无限序列。在第二部分，我们将看到如何使用F#序列来计算收敛序列的极限。然后我们将推导出圆周率的莱布尼茨公式，我们将用它来近似圆周率。</p><figure class="ji jj jk jl fd jm er es paragraph-image"><div role="button" tabindex="0" class="jn jo di jp bf jq"><div class="er es jh"><img src="../Images/ee8675fa75cb298d567e9f61ee26bbf2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*RIRnX8JYX-SjfXHU"/></div></div><figcaption class="jt ju et er es jv jw bd b be z dx translated"><a class="ae jx" href="https://unsplash.com/@hugoaitken?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">雨果·艾特肯</a>在<a class="ae jx" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="d8d3" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">操纵序列</h1><h2 id="1e7c" class="kw jz hi bd ka kx ky kz ke la lb lc ki iq ld le km iu lf lg kq iy lh li ku lj bi translated">基础</h2><p id="f433" class="pw-post-body-paragraph if ig hi ih b ii lk ik il im ll io ip iq lm is it iu ln iw ix iy lo ja jb jc hb bi translated">F#中的序列可以是有限的，也可以是无限的，但我们将重点讨论无限序列。</p><p id="245f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了创建一个无限序列，我们使用函数<code class="du jd je jf jg b">Seq.initInfinite</code>。它采用一个将索引映射到相应值的函数。它返回一个序列。</p><p id="c766" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如，我们可以创建将<em class="lp"> i </em>映射到第<em class="lp"> i </em>个正奇数的序列:</p><pre class="ji jj jk jl fd lq jg lr ls aw lt bi"><span id="7063" class="kw jz hi jg b fi lu lv l lw lx">let oddPositive = Seq.initInfinite (fun index -&gt; 1 + index * 2)</span></pre><p id="5772" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">序列是惰性的，这意味着除非我们请求，否则不会计算值。我们可以使用<code class="du jd je jf jg b">Seq.item</code>检索索引为<em class="lp"> n </em>的元素。例如:</p><pre class="ji jj jk jl fd lq jg lr ls aw lt bi"><span id="ca1a" class="kw jz hi jg b fi lu lv l lw lx">Seq.item 6 oddPositive<br/>// returns 13</span></pre><p id="5a60" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du jd je jf jg b">Seq.item</code>仅计算所需索引的值。</p><p id="b8cd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">另一个有用的函数是<code class="du jd je jf jg b">Seq.append s s'</code>，它将<em class="lp">s’</em>连接到<em class="lp"> s </em>。它以常数时间运行，可用于实现为序列预先赋值的函数:</p><pre class="ji jj jk jl fd lq jg lr ls aw lt bi"><span id="fd08" class="kw jz hi jg b fi lu lv l lw lx">let prep x sequence =<br/>    Seq.append (Seq.singleton x) sequence</span></pre><p id="825f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将在整篇文章中使用上面声明的函数<code class="du jd je jf jg b">prep</code>。</p><h2 id="fc64" class="kw jz hi bd ka kx ky kz ke la lb lc ki iq ld le km iu lf lg kq iy lh li ku lj bi translated">缓存序列</h2><p id="7fbd" class="pw-post-body-paragraph if ig hi ih b ii lk ik il im ll io ip iq lm is it iu ln iw ix iy lo ja jb jc hb bi translated">有时，我们可能希望计算并记住一个序列的所有先前值。这就是缓存序列的用途。我们可以创建一个，如下所示:</p><pre class="ji jj jk jl fd lq jg lr ls aw lt bi"><span id="0521" class="kw jz hi jg b fi lu lv l lw lx">let cachedSequence = Seq.cache mySequence</span></pre><p id="ebdc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du jd je jf jg b">Seq.item n cachedSequence</code>计算所有索引<em class="lp"> k </em> ≤ <em class="lp"> n </em>的<code class="du jd je jf jg b">Seq.item k mySequence</code>，因此<code class="du jd je jf jg b">Seq.item k mySequence</code>尚未计算。它返回<code class="du jd je jf jg b">Seq.item n mySequence</code>。如果我们请求一个已经计算过的项目，那么这个值会立即返回。</p><h2 id="5156" class="kw jz hi bd ka kx ky kz ke la lb lc ki iq ld le km iu lf lg kq iy lh li ku lj bi translated">归纳定义的延迟和序列</h2><p id="3f91" class="pw-post-body-paragraph if ig hi ih b ii lk ik il im ll io ip iq lm is it iu ln iw ix iy lo ja jb jc hb bi translated">函数<code class="du jd je jf jg b">Seq.delay</code>将函数<em class="lp"> f: unit → seq </em>作为参数，并从<em class="lp"> f </em>返回的序列中构造一个惰性序列。正如我们将看到的，这对于构建由递归关系定义的序列很有用。</p><p id="cd93" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如，我们可以构建如下几何序列:</p><figure class="ji jj jk jl fd jm"><div class="bz dy l di"><div class="ly lz l"/></div></figure><h1 id="506b" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">计算(某些)数列的极限</h1><p id="3110" class="pw-post-body-paragraph if ig hi ih b ii lk ik il im ll io ip iq lm is it iu ln iw ix iy lo ja jb jc hb bi translated">这一节给出了逼近某些收敛序列极限的一种方法，只要它们足够好。</p><p id="0e8c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们考虑一个收敛序列<em class="lp"> S </em>并固定一个正容限阈值𝜀.我们将遍历序列的所有值，直到找到两个距离小于𝜀.的连续值<em class="lp"> S </em> ( <em class="lp"> n </em>)和<em class="lp"> S </em> ( <em class="lp"> n + </em> 1)此时，<em class="lp"> S </em> ( <em class="lp"> n </em>)将足够接近极限。</p><p id="201c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">好吧，我承认这种说法在总体上是不正确的:<em class="lp"> S </em>可能有点迂回，值可能在一段时间内非常接近，然后彼此非常远离，在这种情况下<em class="lp"> S </em> ( <em class="lp"> n </em>)可能仍然远离极限。因此有了“行为良好假说”。</p><p id="5f75" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将使用以下函数:</p><figure class="ji jj jk jl fd jm"><div class="bz dy l di"><div class="ly lz l"/></div></figure><p id="5ce7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">枚举数提供了一种遍历序列的优雅方式。当is找不到值时，返回false(这种情况不应该发生，因为我们处理的是无限序列)。如果它返回true，我们可以使用<code class="du jd je jf jg b">enumerator.Current</code>找到序列的当前值。对<code class="du jd je jf jg b">MoveNext</code>的下一个调用将检索下一个<em class="lp">当前值</em> <em class="lp">值</em>。</p><p id="3535" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">每次递归调用都会记住前一个值，这样我们就可以比较每一对连续的值。初始<em class="lp">前一个值</em>(本例中为-1.0)的选择是任意的，但是我们需要确保它不会太接近序列的第一项。</p><h1 id="7641" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">𝜋系列</h1><p id="5863" class="pw-post-body-paragraph if ig hi ih b ii lk ik il im ll io ip iq lm is it iu ln iw ix iy lo ja jb jc hb bi translated">这一节展示了我们如何利用目前所学来近似𝜋.为此，我们需要找到一个收敛于𝜋.的级数我们将使用莱布尼茨公式，因为它很容易推导。</p><p id="b523" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一切从一个几何数列的求和公式开始(对于所有的<em class="lp"> a </em>，<em class="lp"> b </em>，(<em class="lp"> a </em>，<em class="lp"> b </em>)表示开区间{<em class="lp">x</em>|<em class="lp">a</em>&lt;<em class="lp">x</em>&lt;<em class="lp">b</em>}):</p><figure class="ji jj jk jl fd jm er es paragraph-image"><div role="button" tabindex="0" class="jn jo di jp bf jq"><div class="er es ma"><img src="../Images/3603716c371364d6ca0fac61473f7dee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_tpWoloYZHe_H4H7H43KaQ.png"/></div></div></figure><p id="e27c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此:</p><figure class="ji jj jk jl fd jm er es paragraph-image"><div role="button" tabindex="0" class="jn jo di jp bf jq"><div class="er es ma"><img src="../Images/466a9378a9ddc90e8c51cffd6584dba7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DCkh81pDP5IqziB-wsOERQ.png"/></div></div></figure><p id="6604" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于所有的<em class="lp"> x </em>，<em class="lp"> x </em>属于开区间(-1，1)当且仅当- <em class="lp"> x </em>属于开区间。因此我们可以替换为<em class="lp"> x </em> = - <em class="lp"> x </em>:</p><figure class="ji jj jk jl fd jm er es paragraph-image"><div role="button" tabindex="0" class="jn jo di jp bf jq"><div class="er es ma"><img src="../Images/bf3c2ed321a7996666b0c8f1700d019b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N1gMNGZrfLpQ1NMnlYqwmg.png"/></div></div></figure><p id="89bb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">两边取积分:</p><figure class="ji jj jk jl fd jm er es paragraph-image"><div role="button" tabindex="0" class="jn jo di jp bf jq"><div class="er es mb"><img src="../Images/74f288a0ece510989d15103f2b411e60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DbCle8CC5dXM2qQRxW3fVw.png"/></div></div></figure><p id="e9a4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">被积函数通过其在<em class="lp"> y </em>处的值递增并被上述值限制。因此:</p><figure class="ji jj jk jl fd jm er es paragraph-image"><div role="button" tabindex="0" class="jn jo di jp bf jq"><div class="er es mc"><img src="../Images/5c3a8fee507314076d5615f6c010e1e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HNLapgL_99ojcGB4voYkxg.png"/></div></div></figure><p id="7254" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面表达式的左手边趋于0随着<em class="lp"> N </em>趋于无穷大(因为| <em class="lp"> y </em> | &lt; 1)。通过挤压定理，积分趋于0。</p><p id="e676" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这给出了等式:</p><figure class="ji jj jk jl fd jm er es paragraph-image"><div role="button" tabindex="0" class="jn jo di jp bf jq"><div class="er es md"><img src="../Images/17efbfe1f0db52dc4109fe7873c22585.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KdbcaWG5bQ45eJHA14uiXQ.png"/></div></div></figure><p id="f913" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们现在得知<em class="lp">Arctan</em>1 =<em class="lp">Pi</em>/4。由于<em class="lp">反正切</em>连续为1，<em class="lp"> Pi </em> /4是<em class="lp">反正切</em> <em class="lp"> y </em>趋于1时的极限。</p><p id="c1bc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通过取极限并在两边乘以4，我们得到圆周率的以下表达式:</p><figure class="ji jj jk jl fd jm er es paragraph-image"><div role="button" tabindex="0" class="jn jo di jp bf jq"><div class="er es ma"><img src="../Images/7436c6641fc29dae14f7397158a44a34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dHkMWz6SPX907O9O-yZtKQ.png"/></div></div></figure><h1 id="0821" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">把所有东西放在一起</h1><p id="93e0" class="pw-post-body-paragraph if ig hi ih b ii lk ik il im ll io ip iq lm is it iu ln iw ix iy lo ja jb jc hb bi translated">我们使用<code class="du jd je jf jg b">Seq.delay</code>构建系列，如下所示:</p><figure class="ji jj jk jl fd jm"><div class="bz dy l di"><div class="ly lz l"/></div></figure><p id="2d3d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">级数收敛得相当慢。通过<em class="lp"> ε </em> = 10^{-9}到<code class="du jd je jf jg b">approximateLimit</code>，我们得到近似值<strong class="ih hj"> 3.1415926 </strong>。</p><p id="c7eb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这种方法可以扩展到使用幂级数计算一个数的指数、正弦或余弦，幂级数可以从泰勒定理导出。</p></div><div class="ab cl me mf gp mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="hb hc hd he hf"><h1 id="8cce" class="jy jz hi bd ka kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv bi translated">支持我！</h1><p id="3a91" class="pw-post-body-paragraph if ig hi ih b ii lk ik il im ll io ip iq lm is it iu ln iw ix iy lo ja jb jc hb bi translated">感谢阅读！如果您觉得这篇文章很有帮助，请考虑关注我，帮助我达到继续加入中型合作伙伴计划所需的100名关注者的门槛。这是免费的，真的很有帮助。</p><p id="81d0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">也可以使用我的推荐链接订阅Medium: <a class="ae jx" rel="noopener" href="/plans?subscribeToUserId=b705ec524bd3&amp;source=entity_driven_subscription-b705ec524bd3------------------------------------">成为会员</a>。你可以访问Medium上所有会员专用的文章，你的会员费将直接支持我。</p><p id="4c3b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi">🐙</p></div></div>    
</body>
</html>