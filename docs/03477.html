<html>
<head>
<title>Guide: Implementation of Design Patterns in Java</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">指南:设计模式在Java中的实现</h1>
<blockquote>原文：<a href="https://medium.com/codex/guide-implementation-of-design-patterns-in-java-821611f15f64?source=collection_archive---------0-----------------------#2021-09-05">https://medium.com/codex/guide-implementation-of-design-patterns-in-java-821611f15f64?source=collection_archive---------0-----------------------#2021-09-05</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/319208216768b52f1e5917be3a9e9efa.png" data-original-src="https://miro.medium.com/v2/resize:fit:746/0*RIH7hlXhnniPwb3N"/></div><figcaption class="im in et er es io ip bd b be z dx translated">指南:设计模式在Java中的实现</figcaption></figure><p id="2de9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">设计模式是Java开发人员中流行的一种开发方式。所以一个重要的问题是设计模式到底是什么？设计模式是解决特定任务或问题的明确定义的解决方案。设计模式本身是独立编程的，并定义了解决常见问题的行业标准策略。通过使用设计模式，您可以使您的代码更加灵活、可重用和易于维护。</p><p id="f167" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">要成为一名更好的软件开发人员，至少了解一些针对编码问题的流行设计模式是有帮助的。在本文中，我们将讨论不同类型的设计模式，以及它们的独特之处，因此在本文结束时，您可能能够选择最适合您的下一个项目的设计模式。</p><h1 id="a40e" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">设计模式</h1><p id="9e23" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">设计模式在Java中起着非常重要的作用。它们提高了代码的可读性，并为常见问题提供了合适的解决方案。它们在Java开发人员中非常流行，因为语言本身是基于设计模式的。这使得Java成为业界非常流行的语言。</p><p id="5a06" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在Java的核心中有3种主要的设计模式，可以进一步划分为子类。在本文中，我们将看看Java中使用的一些最流行的设计模式。</p><h1 id="fde0" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">创造性设计模式</h1><p id="3ca3" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">创造性设计模式提供了一种实例化单个对象来优化代码并增加其灵活性和可重用性的方法。</p><h2 id="242d" class="kr jp hi bd jq ks kt ku ju kv kw kx jy jb ky kz kc jf la lb kg jj lc ld kk le bi translated">1)单例模式:</h2><p id="e2c4" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">单例模式是Java开发人员使用的最流行的设计模式。在单例模式中，用户创建一个对象的单个全局实例，这样就可以对这个实例进行公共访问。</p><figure class="lg lh li lj fd ij er es paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="er es lf"><img src="../Images/d0ca816d3628b9ca15844bf8d786e193.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*DNE4Py8R9Vk65kpa"/></div></div></figure><p id="d6f3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">假设你拥有一家巧克力工厂，里面有电脑控制的锅炉。锅炉的工作是用巧克力和牛奶作为配料，将它们煮沸，然后传递到下一个阶段，制作巧克力棒。下面的代码显示了一个Chocolateboiler的单独实例。</p><pre class="lg lh li lj fd lo lp lq lr aw ls bi"><span id="80c0" class="kr jp hi lp b fi lt lu l lv lw">public class ChocolateBoiler {</span><span id="5b5d" class="kr jp hi lp b fi lx lu l lv lw">private boolean empty;</span><span id="b82f" class="kr jp hi lp b fi lx lu l lv lw">private boolean boiled;</span><span id="0d58" class="kr jp hi lp b fi lx lu l lv lw">private static ChocolateBoiler uniqueInstance;</span><span id="f638" class="kr jp hi lp b fi lx lu l lv lw">private ChocolateBoiler(){</span><span id="4395" class="kr jp hi lp b fi lx lu l lv lw">empty = true;</span><span id="d33f" class="kr jp hi lp b fi lx lu l lv lw">boiled = false;</span><span id="f184" class="kr jp hi lp b fi lx lu l lv lw">}</span><span id="c7bd" class="kr jp hi lp b fi lx lu l lv lw">public static ChocolateBoiler getInstance(){</span><span id="352e" class="kr jp hi lp b fi lx lu l lv lw"><em class="ly">if</em> (uniqueInstance == null){</span><span id="d49d" class="kr jp hi lp b fi lx lu l lv lw">uniqueInstance = <em class="ly">new</em> ChocolateBoiler();</span><span id="e8b5" class="kr jp hi lp b fi lx lu l lv lw">}</span><span id="ee51" class="kr jp hi lp b fi lx lu l lv lw"><em class="ly">return</em> uniqueInstance;</span><span id="05b6" class="kr jp hi lp b fi lx lu l lv lw">}</span><span id="e9da" class="kr jp hi lp b fi lx lu l lv lw">public void fill() {</span><span id="9ddd" class="kr jp hi lp b fi lx lu l lv lw"><em class="ly">if</em> (isEmpty()) {</span><span id="e12c" class="kr jp hi lp b fi lx lu l lv lw">empty = false;</span><span id="d481" class="kr jp hi lp b fi lx lu l lv lw">boiled = false;</span><span id="1019" class="kr jp hi lp b fi lx lu l lv lw"><em class="ly">// fill the boiler with a milk/chocolate mixture</em></span><span id="f999" class="kr jp hi lp b fi lx lu l lv lw">}</span><span id="b343" class="kr jp hi lp b fi lx lu l lv lw">}</span><span id="0726" class="kr jp hi lp b fi lx lu l lv lw">public void drain() {</span><span id="6fb5" class="kr jp hi lp b fi lx lu l lv lw"><em class="ly">if</em> (!isEmpty() &amp;&amp; isBoiled()) {</span><span id="b2be" class="kr jp hi lp b fi lx lu l lv lw"><em class="ly">// drain the boiled milk and chocolate</em></span><span id="71fc" class="kr jp hi lp b fi lx lu l lv lw">empty = true;</span><span id="31be" class="kr jp hi lp b fi lx lu l lv lw">}</span><span id="6389" class="kr jp hi lp b fi lx lu l lv lw">}</span><span id="21ea" class="kr jp hi lp b fi lx lu l lv lw">public void boil() {</span><span id="19fe" class="kr jp hi lp b fi lx lu l lv lw"><em class="ly">if</em> (!isEmpty() &amp;&amp; !isBoiled()) {</span><span id="29db" class="kr jp hi lp b fi lx lu l lv lw"><em class="ly">// bring the contents to a boil</em></span><span id="aac7" class="kr jp hi lp b fi lx lu l lv lw">boiled = true;</span><span id="59c9" class="kr jp hi lp b fi lx lu l lv lw">}</span><span id="9813" class="kr jp hi lp b fi lx lu l lv lw">}</span><span id="60da" class="kr jp hi lp b fi lx lu l lv lw">public boolean isEmpty() {</span><span id="3680" class="kr jp hi lp b fi lx lu l lv lw"><em class="ly">return</em> empty;</span><span id="f05a" class="kr jp hi lp b fi lx lu l lv lw">}</span><span id="9676" class="kr jp hi lp b fi lx lu l lv lw">public boolean isBoiled() {</span><span id="c5be" class="kr jp hi lp b fi lx lu l lv lw"><em class="ly">return</em> boiled;</span><span id="0ef0" class="kr jp hi lp b fi lx lu l lv lw">}</span><span id="5662" class="kr jp hi lp b fi lx lu l lv lw">}</span></pre><p id="bbe0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">该代码提出了一些标志，例如，如果混合物已经煮沸，则不允许它煮沸，排出500加仑未煮沸的混合物，或者当它已经满了时再装满锅炉。这有助于我们对单例模式及其使用有一个基本的了解。</p><h2 id="3aad" class="kr jp hi bd jq ks kt ku ju kv kw kx jy jb ky kz kc jf la lb kg jj lc ld kk le bi translated">2)工厂模式:</h2><p id="f12e" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">Java开发人员经常使用工厂设计模式。当一个超类有多个子类时使用它。在Java中，工厂设计模式提供了在超类中创建对象的接口，但允许在子类中创建对象类型。</p><p id="5824" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">想象一下有一家比萨饼店。您需要编写一些代码来确定比萨饼的类型，然后着手制作它。很快你就会意识到希腊风味卖得不多了，所以你决定把它们从菜单上拿掉，同时增加新的时尚披萨。</p><pre class="lg lh li lj fd lo lp lq lr aw ls bi"><span id="e1f4" class="kr jp hi lp b fi lt lu l lv lw">public class SimplePizzaFactory {</span><span id="1ec6" class="kr jp hi lp b fi lx lu l lv lw">public Pizza createPizza(String type) {</span><span id="2b7c" class="kr jp hi lp b fi lx lu l lv lw">Pizza pizza = null;</span><span id="7ab5" class="kr jp hi lp b fi lx lu l lv lw"><em class="ly">if</em> (type.equals(“cheese”)) {</span><span id="dea3" class="kr jp hi lp b fi lx lu l lv lw">pizza = <em class="ly">new</em> CheesePizza();</span><span id="1bdb" class="kr jp hi lp b fi lx lu l lv lw">} <em class="ly">else</em> <em class="ly">if</em> (type.equals(“pepperoni”)) {</span><span id="08b1" class="kr jp hi lp b fi lx lu l lv lw">pizza = <em class="ly">new</em> PepperoniPizza();</span><span id="2352" class="kr jp hi lp b fi lx lu l lv lw">} <em class="ly">else</em> <em class="ly">if</em> (type.equals(“clam”)) {</span><span id="00f3" class="kr jp hi lp b fi lx lu l lv lw">pizza = <em class="ly">new</em> ClamPizza();</span><span id="83bb" class="kr jp hi lp b fi lx lu l lv lw">} <em class="ly">else</em> <em class="ly">if</em> (type.equals(“veggie”)) {</span><span id="2db5" class="kr jp hi lp b fi lx lu l lv lw">pizza = <em class="ly">new</em> VeggiePizza();</span><span id="2a36" class="kr jp hi lp b fi lx lu l lv lw">}</span><span id="7ab6" class="kr jp hi lp b fi lx lu l lv lw"><em class="ly">return</em> pizza;</span><span id="d86a" class="kr jp hi lp b fi lx lu l lv lw">}</span><span id="4550" class="kr jp hi lp b fi lx lu l lv lw">}</span><span id="61f7" class="kr jp hi lp b fi lx lu l lv lw">public abstract class PizzaStore {</span><span id="4bfd" class="kr jp hi lp b fi lx lu l lv lw">public Pizza orderPizza(String type) {</span><span id="4541" class="kr jp hi lp b fi lx lu l lv lw">Pizza pizza;</span><span id="2ab7" class="kr jp hi lp b fi lx lu l lv lw">pizza = createPizza(type);</span><span id="2b13" class="kr jp hi lp b fi lx lu l lv lw">pizza.prepare();</span><span id="974f" class="kr jp hi lp b fi lx lu l lv lw">pizza.bake();</span><span id="4402" class="kr jp hi lp b fi lx lu l lv lw">pizza.cut();</span><span id="7674" class="kr jp hi lp b fi lx lu l lv lw">pizza.box();</span><span id="b9f5" class="kr jp hi lp b fi lx lu l lv lw"><em class="ly">return</em> pizza;</span><span id="471f" class="kr jp hi lp b fi lx lu l lv lw">}</span><span id="7220" class="kr jp hi lp b fi lx lu l lv lw">abstract Pizza createPizza(String type);</span><span id="f5d5" class="kr jp hi lp b fi lx lu l lv lw">}</span></pre><p id="2060" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">创建一个单独的比萨饼店类不会让我们特许经营我们的商店或帮助定义不同类型的比萨饼。所以我们实现了一个工厂模式来帮助我们定义我们的商店。</p><figure class="lg lh li lj fd ij er es paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="er es lz"><img src="../Images/242ae2b6ced80c9de48c433db83dd10d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*dqy31bjhutk-KmjT"/></div></div></figure><figure class="lg lh li lj fd ij er es paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="er es ma"><img src="../Images/041cdc3639cd508f00343449977a3933.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Jszck56hxGpkdK_f"/></div></div></figure><p id="7e80" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这允许我们将所有的比萨饼制作活动本地化到PizzaStore类，同时让特许经营者自由地拥有他们的区域风格，同时允许子类决定覆盖和扩展具体类的功能的方法。</p><h1 id="7251" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">结构设计模式</h1><p id="c255" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">结构模式提供了不同的方法来使用继承和组合将对象和类组装成更大的结构，同时保持它们的高效和灵活。</p><h2 id="bca3" class="kr jp hi bd jq ks kt ku ju kv kw kx jy jb ky kz kc jf la lb kg jj lc ld kk le bi translated">1)适配器模式:</h2><p id="f115" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">顾名思义，适配器模式提供了一个接口，使得接口不兼容的对象可以协作。连接这些接口的对象称为适配器。</p><p id="e3eb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们看一个例子，看看适配器模式是如何工作的。</p><p id="540b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">想象一下，定义一个Duck类，实现一只会飞会嘎嘎叫的鸭子。</p><pre class="lg lh li lj fd lo lp lq lr aw ls bi"><span id="61d7" class="kr jp hi lp b fi lt lu l lv lw">public interface Duck {</span><span id="356a" class="kr jp hi lp b fi lx lu l lv lw">public void quack();</span><span id="3a51" class="kr jp hi lp b fi lx lu l lv lw">public void fly();</span><span id="e022" class="kr jp hi lp b fi lx lu l lv lw">}</span></pre><p id="a74d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在可以创建一个名为绿头鸭的鸭子子类，它简单地打印出鸭子正在做的事情:</p><pre class="lg lh li lj fd lo lp lq lr aw ls bi"><span id="938a" class="kr jp hi lp b fi lt lu l lv lw">public class MallardDuck implements Duck {</span><span id="6db1" class="kr jp hi lp b fi lx lu l lv lw">public void quack() {</span><span id="9697" class="kr jp hi lp b fi lx lu l lv lw">System.out.println(“Quack”);</span><span id="c756" class="kr jp hi lp b fi lx lu l lv lw">}</span><span id="8c33" class="kr jp hi lp b fi lx lu l lv lw">public void fly() {</span><span id="ff11" class="kr jp hi lp b fi lx lu l lv lw">System.out.println(“I’m flying”);</span><span id="1a89" class="kr jp hi lp b fi lx lu l lv lw">}</span><span id="cf12" class="kr jp hi lp b fi lx lu l lv lw">}</span></pre><p id="8627" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">还可以实现一个简单的火鸡类，这样火鸡对象就可以像鸭子一样咯咯叫和飞翔。</p><pre class="lg lh li lj fd lo lp lq lr aw ls bi"><span id="2818" class="kr jp hi lp b fi lt lu l lv lw">public interface Turkey {</span><span id="0b29" class="kr jp hi lp b fi lx lu l lv lw">public void gobble();</span><span id="a078" class="kr jp hi lp b fi lx lu l lv lw">public void fly();</span><span id="8831" class="kr jp hi lp b fi lx lu l lv lw">}</span></pre><p id="dcf5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在想象一下鸭子对象用完了。因为火鸡对象的行为就像鸭子对象，所以你想把火鸡伪装成鸭子。我们不能简单地使用turkey类，我们必须首先使用一个适配器来改变它。</p><pre class="lg lh li lj fd lo lp lq lr aw ls bi"><span id="9e8b" class="kr jp hi lp b fi lt lu l lv lw">public class TurkeyAdapter implements Duck {</span><span id="0108" class="kr jp hi lp b fi lx lu l lv lw">Turkey turkey;</span><span id="6112" class="kr jp hi lp b fi lx lu l lv lw">public TurkeyAdapter(Turkey turkey) {</span><span id="9897" class="kr jp hi lp b fi lx lu l lv lw">this.turkey = turkey;</span><span id="aba5" class="kr jp hi lp b fi lx lu l lv lw">}</span><span id="690f" class="kr jp hi lp b fi lx lu l lv lw">public void quack() {</span><span id="e067" class="kr jp hi lp b fi lx lu l lv lw">turkey.gobble();</span><span id="8af3" class="kr jp hi lp b fi lx lu l lv lw">}</span><span id="0c96" class="kr jp hi lp b fi lx lu l lv lw">public void fly() {</span><span id="3bae" class="kr jp hi lp b fi lx lu l lv lw"><em class="ly">for</em>(int i=0; i &lt; 5; i++) {</span><span id="38e6" class="kr jp hi lp b fi lx lu l lv lw">turkey.fly();</span><span id="14e5" class="kr jp hi lp b fi lx lu l lv lw">}</span><span id="ff54" class="kr jp hi lp b fi lx lu l lv lw">}</span><span id="9325" class="kr jp hi lp b fi lx lu l lv lw">}</span></pre><p id="63cd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">适配器实现目标接口，并保存适配器的一个实例。TurkeyAdapter类更改turkey对象，使其行为和功能就像鸭子一样。</p><h2 id="412a" class="kr jp hi bd jq ks kt ku ju kv kw kx jy jb ky kz kc jf la lb kg jj lc ld kk le bi translated">2)装饰图案:</h2><p id="4eda" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">顾名思义，装饰模式通过将对象放在包含行为的特殊包装对象中来操纵对象的输出。这只会更改有问题的对象，而该对象的所有其他实例保持不变。</p><p id="6f2f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">想象一下经营一家咖啡店。最初，他们的商业模式是这样的:</p><figure class="lg lh li lj fd ij er es paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="er es mb"><img src="../Images/6ecc5e47ee92e70fb6a755852e7f8d84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*AEuh_jrRZCMfPnJF"/></div></div></figure><p id="2fe6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因为你发展如此之快，你想更新你的系统，以增加你的，是饮料产品。</p><p id="c720" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果出于某种原因，你采用了相同的设计模式，你将不得不管理多个子类。每一个子类都是不同混合物、它们的风味和它们的调味品的排列，它们可以很快变大。</p><p id="472a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们的目标是在不修改现有代码的情况下，允许类被容易地扩展以包含新的行为。这可以通过实现对变化有弹性并且足够灵活以采用新功能来满足不断变化的需求的设计来实现。相反，我们将从饮料开始，并在运行时用调味品“装饰”它。</p><figure class="lg lh li lj fd ij er es paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="er es mc"><img src="../Images/bcfb6580b8bfddb8ffda6f12c1ab141b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5ygYujmAA8e1hC1-"/></div></div></figure><p id="7ffe" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们将首先定义饮料类别:</p><pre class="lg lh li lj fd lo lp lq lr aw ls bi"><span id="cb5e" class="kr jp hi lp b fi lt lu l lv lw">public abstract class Beverage {</span><span id="376d" class="kr jp hi lp b fi lx lu l lv lw">String description = “Unknown Beverage”;</span><span id="646c" class="kr jp hi lp b fi lx lu l lv lw">public String getDescription() {</span><span id="1a68" class="kr jp hi lp b fi lx lu l lv lw"><em class="ly">return</em> description;</span><span id="2e1d" class="kr jp hi lp b fi lx lu l lv lw">}</span><span id="913b" class="kr jp hi lp b fi lx lu l lv lw">public abstract double cost();</span><span id="9708" class="kr jp hi lp b fi lx lu l lv lw">}</span></pre><p id="a7b6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">饮料类很简单。让我们也实现调味品(装饰)的抽象类:</p><pre class="lg lh li lj fd lo lp lq lr aw ls bi"><span id="b34a" class="kr jp hi lp b fi lt lu l lv lw">public abstract class CondimentDecorator extends Beverage {</span><span id="c865" class="kr jp hi lp b fi lx lu l lv lw">public abstract String getDescription();</span><span id="b779" class="kr jp hi lp b fi lx lu l lv lw">}</span></pre><p id="e678" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在我们已经解决了基类的问题，让我们实现一些饮料。我们将从浓咖啡开始。记住，我们需要为特定的饮料设置一个描述，还需要实现cost()方法。</p><pre class="lg lh li lj fd lo lp lq lr aw ls bi"><span id="9ced" class="kr jp hi lp b fi lt lu l lv lw">public class Espresso extends Beverage {</span><span id="cb34" class="kr jp hi lp b fi lx lu l lv lw">public Espresso() {</span><span id="e051" class="kr jp hi lp b fi lx lu l lv lw">description = “Espresso”;</span><span id="ebb3" class="kr jp hi lp b fi lx lu l lv lw">}</span><span id="aa4a" class="kr jp hi lp b fi lx lu l lv lw">public double cost() {</span><span id="b632" class="kr jp hi lp b fi lx lu l lv lw"><em class="ly">return</em> 1.99;</span><span id="f6a2" class="kr jp hi lp b fi lx lu l lv lw">}</span><span id="8b16" class="kr jp hi lp b fi lx lu l lv lw">}</span><span id="02f4" class="kr jp hi lp b fi lx lu l lv lw">public class HouseBlend extends Beverage {</span><span id="7cdc" class="kr jp hi lp b fi lx lu l lv lw">public HouseBlend() {</span><span id="f73c" class="kr jp hi lp b fi lx lu l lv lw">description = “House Blend Coffee”;</span><span id="e51a" class="kr jp hi lp b fi lx lu l lv lw">}</span><span id="1067" class="kr jp hi lp b fi lx lu l lv lw">public double cost() {</span><span id="c97f" class="kr jp hi lp b fi lx lu l lv lw"><em class="ly">return</em> .89;</span><span id="9082" class="kr jp hi lp b fi lx lu l lv lw">}</span><span id="1a98" class="kr jp hi lp b fi lx lu l lv lw">}</span><span id="3d83" class="kr jp hi lp b fi lx lu l lv lw">public class Mocha extends CondimentDecorator {</span><span id="4b83" class="kr jp hi lp b fi lx lu l lv lw">Beverage beverage;</span><span id="5d7e" class="kr jp hi lp b fi lx lu l lv lw">public Mocha(Beverage beverage) {</span><span id="04ce" class="kr jp hi lp b fi lx lu l lv lw">this.beverage = beverage;</span><span id="c4c6" class="kr jp hi lp b fi lx lu l lv lw">}</span><span id="14bc" class="kr jp hi lp b fi lx lu l lv lw">public String getDescription() {</span><span id="6801" class="kr jp hi lp b fi lx lu l lv lw"><em class="ly">return</em> beverage.getDescription() + “, Mocha”;</span><span id="0cf5" class="kr jp hi lp b fi lx lu l lv lw">}</span><span id="2201" class="kr jp hi lp b fi lx lu l lv lw">public double cost() {</span><span id="9c75" class="kr jp hi lp b fi lx lu l lv lw"><em class="ly">return</em> .20 + beverage.cost();</span><span id="0009" class="kr jp hi lp b fi lx lu l lv lw">}</span><span id="2540" class="kr jp hi lp b fi lx lu l lv lw">}</span></pre><p id="7c4f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们可以惊叹于设计的灵活性，它允许我们动态地计算成本，并且如果需要，可以毫不费力地扩展其功能。</p><h1 id="0d52" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">行为设计模式</h1><p id="4453" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">行为模式与算法有关，为对象之间更好的交互和它们之间的责任分配提供更好的解决方案。</p><h2 id="d394" class="kr jp hi bd jq ks kt ku ju kv kw kx jy jb ky kz kc jf la lb kg jj lc ld kk le bi translated">1)模板方法模式:</h2><p id="5c92" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">模板方法，也许是最重要的行为设计模式，在超类中定义了算法的框架，但让子类覆盖算法的特定步骤，而不改变整个结构。让我们看一个例子。</p><p id="0fbd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">许多人以一杯咖啡或茶开始他们的一天。它们都含有共同的成分咖啡因，能给人们一天所需的能量。现在，如果我们要编写制作咖啡或茶的代码，我们会有相同的方法。例如，咖啡分4步准备，烧开水，煮咖啡，倒入杯中，然后加入牛奶或糖。除了第二步我们用茶包之外，泡茶的方法也是一样的。</p><figure class="lg lh li lj fd ij er es paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="er es md"><img src="../Images/4570e08785f0ed40eada73f1b73ddc98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*CqCcrHZ93yxab5CO"/></div></div></figure><p id="a16d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们可以看到，这两种饮料有共同的步骤，会导致代码重复。这就是我们使用模板模式将算法分解成可以在子类中覆盖的步骤的地方。因此，我们可以定义一个抽象的父类CaffineBeverages，它可以在Tea和Coffee子类中扩展。这可以帮助我们减少重复，并使算法满足我们的特定需求。</p><pre class="lg lh li lj fd lo lp lq lr aw ls bi"><span id="d82f" class="kr jp hi lp b fi lt lu l lv lw">public abstract class CaffeineBeverage {</span><span id="926f" class="kr jp hi lp b fi lx lu l lv lw">final void prepareRecipe() {</span><span id="1bdd" class="kr jp hi lp b fi lx lu l lv lw">boilWater();</span><span id="a926" class="kr jp hi lp b fi lx lu l lv lw">brew();</span><span id="11db" class="kr jp hi lp b fi lx lu l lv lw">pourInCup();</span><span id="7a73" class="kr jp hi lp b fi lx lu l lv lw">addCondiments();</span><span id="5213" class="kr jp hi lp b fi lx lu l lv lw">}</span><span id="2154" class="kr jp hi lp b fi lx lu l lv lw">abstract void brew();</span><span id="262b" class="kr jp hi lp b fi lx lu l lv lw">abstract void addCondiments();</span><span id="878c" class="kr jp hi lp b fi lx lu l lv lw">void boilWater() {</span><span id="f1d0" class="kr jp hi lp b fi lx lu l lv lw">System.out.println(“Boiling water”);</span><span id="1d0f" class="kr jp hi lp b fi lx lu l lv lw">}</span><span id="2653" class="kr jp hi lp b fi lx lu l lv lw">void pourInCup() {</span><span id="13c8" class="kr jp hi lp b fi lx lu l lv lw">System.out.println(“Pouring into cup”);</span><span id="f6c0" class="kr jp hi lp b fi lx lu l lv lw">}</span><span id="fee8" class="kr jp hi lp b fi lx lu l lv lw">}</span><span id="f601" class="kr jp hi lp b fi lx lu l lv lw">public class Tea extends CaffeineBeverage {</span><span id="5f08" class="kr jp hi lp b fi lx lu l lv lw">public void brew() {</span><span id="f730" class="kr jp hi lp b fi lx lu l lv lw">System.out.println(“Steeping the tea”);</span><span id="2e07" class="kr jp hi lp b fi lx lu l lv lw">}</span><span id="2d76" class="kr jp hi lp b fi lx lu l lv lw">public void addCondiments() {</span><span id="4da9" class="kr jp hi lp b fi lx lu l lv lw">System.out.println(“Adding Lemon”);</span><span id="5212" class="kr jp hi lp b fi lx lu l lv lw">}</span><span id="509f" class="kr jp hi lp b fi lx lu l lv lw">}</span><span id="5482" class="kr jp hi lp b fi lx lu l lv lw">public class Coffee extends CaffeineBeverage {</span><span id="5630" class="kr jp hi lp b fi lx lu l lv lw">public void brew() {</span><span id="96a7" class="kr jp hi lp b fi lx lu l lv lw">System.out.println(“Dripping Coffee through filter”);</span><span id="5385" class="kr jp hi lp b fi lx lu l lv lw">}</span><span id="fb26" class="kr jp hi lp b fi lx lu l lv lw">public void addCondiments() {</span><span id="604f" class="kr jp hi lp b fi lx lu l lv lw">System.out.println(“Adding Sugar and Milk”);</span><span id="1199" class="kr jp hi lp b fi lx lu l lv lw">}</span><span id="322c" class="kr jp hi lp b fi lx lu l lv lw">}</span></pre><h1 id="1c81" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">最后的想法</h1><p id="b1ad" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">设计模式是一个成功的Java开发人员口袋里的强大武器库。它们提供了蓝图，可以帮助您定制解决代码中反复出现的问题。设计模式允许您实现适合自己特定需求的解决方案。它们增加了可读性，并帮助其他开发人员协作。</p><p id="bd2c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我希望这篇文章能帮助你掌握设计模式的基础，并帮助你为下一个编程项目选择一个配方。</p><h1 id="a9f9" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">参考</h1><ul class=""><li id="717c" class="me mf hi is b it km ix kn jb mg jf mh jj mi jn mj mk ml mm bi translated">弗里曼，埃里克，伊丽莎白罗布森，凯西塞拉和伯特贝茨。<em class="ly">头先设计图案</em>。塞瓦斯托波尔，加利福尼亚州:奥莱利，2004年。打印。</li></ul></div></div>    
</body>
</html>