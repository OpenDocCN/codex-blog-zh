<html>
<head>
<title>The Basics of Spring Framework Transactions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Spring框架事务的基础</h1>
<blockquote>原文：<a href="https://medium.com/codex/the-basics-of-spring-framework-transactions-6a99045dba8?source=collection_archive---------3-----------------------#2021-05-16">https://medium.com/codex/the-basics-of-spring-framework-transactions-6a99045dba8?source=collection_archive---------3-----------------------#2021-05-16</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="eb48" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">在这篇文章中，我将详细介绍Spring Framework如何在幕后处理事务</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/22974d1961313b8f290b9e9356190f88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8R5B_LRuli6JjogWugLV9Q.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">图片由spring.io提供</figcaption></figure><p id="932a" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">在我们讨论框架如何处理事务之前，我们需要理解一些基本概念，这些概念对于理解本文的内容至关重要。</p><h1 id="6e83" class="kj kk hi bd kl km kn ko kp kq kr ks kt io ku ip kv ir kw is kx iu ky iv kz la bi translated">第一个概念:酸的分离。</h1><p id="fd2d" class="pw-post-body-paragraph jn jo hi jp b jq lb ij js jt lc im jv jw ld jy jz ka le kc kd ke lf kg kh ki hb bi translated"><em class="lg">“如果你不知道</em><a class="ae lh" href="https://en.wikipedia.org/wiki/ACID" rel="noopener ugc nofollow" target="_blank"><em class="lg"/></a><em class="lg">(原子性、一致性、隔离性、持久性)是什么意思，我建议你去寻找相关资料，因为在这篇文章中，我不会深入讨论这些内容。”</em></p><p id="fee6" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">此时，我们将简要讨论一下ACID的隔离，更具体地说是关于<strong class="jp hj">读现象</strong>和<strong class="jp hj">隔离级别。</strong></p><p id="0a71" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">当在数据库中处理并发事务时，我们需要了解DBMS提供什么级别的隔离，以及每个级别解决什么类型的读取现象。</p><p id="ed57" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><strong class="jp hj">在这些现象中，我们有:</strong></p><p id="1417" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><strong class="jp hj">脏读:</strong>当数据在提交之前就可以在并发事务中被读取时，就会出现这种现象。</p><p id="ff37" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><strong class="jp hj">不可重复读取:</strong>当一条记录可以被读取两次而得到不同的结果时，会出现这种现象，因为该记录在两次读取之间的并发事务中被更改。</p><p id="8215" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><strong class="jp hj">幻像读取:</strong>这种现象与不可重复读取非常相似，但是在这种情况下，在其中一个事务中，执行查询的条件会返回多条记录，而在另一个事务中，我们会插入或删除影响并发事务的查询条件的记录，从而改变查询的结果。</p><p id="acc9" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><strong class="jp hj">在隔离级别中，我们有:</strong></p><p id="4bd8" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><strong class="jp hj"> Read Uncommitted: </strong>在这个级别，同时发生的事务之间可以看到未提交的数据，从而允许“脏读”现象发生。</p><p id="1008" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><strong class="jp hj">读取已提交:</strong>在此级别，在并发事务中只能查看已提交的数据。在这个级别，我们不再有“脏读”现象，但我们仍然可以有“不可重复读”和“幻影读”现象。</p><p id="4c59" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><strong class="jp hj"> Repeatable Read: </strong>在这个级别，我们可以保证在事务的查询中返回相同的记录，不管它是否在另一个并发事务中被更改和提交。在这个级别，我们不再有不可重复读取现象的发生，但是我们仍然可以有幻像读取现象。</p><p id="1f2c" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><strong class="jp hj"> Serializable: </strong>这是最高级别的隔离，在这种情况下，我们避免了上述所有现象的发生，但我们会对性能产生相当大的影响，因为数据库试图通过顺序执行调用来保证更高级别的数据完整性。</p><p id="d8d9" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">重要的是要弄清楚，上面所说的与隔离级别相关的一切都是基于ANSI标准中的描述，但是每个DBMS可以不同地实现隔离级别。因此，我们可能会有不同的行为，这取决于所使用的DBMS。</p><p id="0a30" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">另一个要点是，每个DBMS都有默认的隔离级别。例如，在Oracle、Postgres和SQL Server中，默认值是Read Committed。在Mysql中，默认是可重复读取。</p><p id="0a42" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">了解阅读每个DBMS的文档、理解它实现的隔离级别以及它如何处理每种现象总是很重要的。</p><h1 id="47a3" class="kj kk hi bd kl km kn ko kp kq kr ks kt io ku ip kv ir kw is kx iu ky iv kz la bi translated">第二个概念:Spring框架代理</h1><p id="ab7a" class="pw-post-body-paragraph jn jo hi jp b jq lb ij js jt lc im jv jw ld jy jz ka le kc kd ke lf kg kh ki hb bi translated">对于使用Spring框架的人来说，这是一个非常重要的概念。每当您通过Spring注释(如@Transactional)在类中放置指令时，Spring都需要将指令翻译成特定的代码块，这就是代理出现的时候。</p><p id="7918" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">特别提到@Transactional注释，当您用它来注释您的类的方法时，Spring会创建一个基于您的类的代理，并添加用于打开和关闭事务的代码块，在创建的代码块中间调用原始类的方法。</p><p id="f6c0" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">然而，要记住的非常重要的一点是，对于这些添加到代理中以便在代码执行期间调用的指令，对带注释的方法的调用需要来自外部类。当从类本身内部调用方法时，执行不通过代理，注释被忽略。</p><p id="f6df" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><strong class="jp hj">但是这个代理是什么时候创建的，执行是如何通过它的？</strong></p><p id="b52c" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">例如，当您注入一个通过@Autowired创建的类时，Spring会分析被注入的类是否有任何类型的注释需要解释，如果有，它会注入一个封装了原始类所有逻辑的代理，而不是注入您的类。</p><p id="2b9c" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">例如，您创建了一个名为MyService的@Service类型的类，它有一个用@Transactional注释的方法，该方法将数据写入数据库，名为saveData。</p><p id="dd2c" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">现在让我们假设您有一个类型为<a class="ae lh" href="http://twitter.com/Controller" rel="noopener ugc nofollow" target="_blank">@控制器</a>的类，它通过<a class="ae lh" href="http://twitter.com/Autowired" rel="noopener ugc nofollow" target="_blank">@自动连线</a>注释执行MyService类的注入。</p><p id="f31e" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">当Spring将要注入MyService类时，它将注入一个名为my service $ $ enhancerbyspringglib的类，而不是注入原来的类，例如，它也将有一个saveData方法。然而，这个方法不同于原始的类方法，它包括:</p><pre class="iy iz ja jb fd li lj lk ll aw lm bi"><span id="6063" class="ln kk hi lj b fi lo lp l lq lr">public void saveData (Object data) {</span><span id="df80" class="ln kk hi lj b fi ls lp l lq lr">    // begin of transaction here</span><span id="5cd9" class="ln kk hi lj b fi ls lp l lq lr">    originalClass.saveData(data);</span><span id="3631" class="ln kk hi lj b fi ls lp l lq lr">    // commit or rollback of transaction here</span><span id="2520" class="ln kk hi lj b fi ls lp l lq lr">}</span></pre><p id="088a" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><strong class="jp hj">注意:</strong>这只是一个说教的例子，它并不完全是框架生成的原始代码。</p><h1 id="2fd2" class="kj kk hi bd kl km kn ko kp kq kr ks kt io ku ip kv ir kw is kx iu ky iv kz la bi translated">但是，Spring如何处理事务呢？</h1><p id="6385" class="pw-post-body-paragraph jn jo hi jp b jq lb ij js jt lc im jv jw ld jy jz ka le kc kd ke lf kg kh ki hb bi translated">既然我们已经对这两个概念有了肤浅的了解，那么让我们来谈谈spring是如何处理事务的。</p><p id="b4ea" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">所有神奇的事情实际上都是通过@Transactional注释发生的。</p><p id="06fe" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">@Transactional注释既可以在类级别使用，也可以在方法级别使用，这取决于所需的事务范围。</p><p id="d28e" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">当我们在Spring中使用事务时，需要知道的重要一点与事务的回滚有关。只有当用@Transactional注释的代码块抛出未检查的异常时，才会发生回滚。如果您希望回滚也在检查异常的情况下发生，您需要使用@Transactional注释的“roll back on<strong class="jp hj">”</strong>属性来指定异常，例如:</p><pre class="iy iz ja jb fd li lj lk ll aw lm bi"><span id="7e00" class="ln kk hi lj b fi lo lp l lq lr">@Transactional(<strong class="lj hj">rollbackOn</strong> = YourCheckedException.<strong class="lj hj">class</strong>)</span></pre><p id="ae52" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">@Transactional注释有两个非常重要的属性，我们将在下面详述，这些属性是<strong class="jp hj">隔离</strong>和<strong class="jp hj">传播</strong>。</p><h2 id="aa36" class="ln kk hi bd kl lt lu lv kp lw lx ly kt jw lz ma kv ka mb mc kx ke md me kz mf bi translated">隔离</h2><p id="166f" class="pw-post-body-paragraph jn jo hi jp b jq lb ij js jt lc im jv jw ld jy jz ka le kc kd ke lf kg kh ki hb bi translated">隔离属性你应该已经想象出它是干什么用的了，基于我们在帖子开头看到的。</p><p id="fb1b" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">您可以在Spring事务中设置隔离级别，用下面的可能值填充隔离属性的值:</p><ul class=""><li id="7f80" class="mg mh hi jp b jq jr jt ju jw mi ka mj ke mk ki ml mm mn mo bi translated">@Transactional(isolation =隔离。已读_未提交)</li><li id="52d8" class="mg mh hi jp b jq mp jt mq jw mr ka ms ke mt ki ml mm mn mo bi translated">@Transactional(isolation =隔离。READ_COMMITTED)</li><li id="3354" class="mg mh hi jp b jq mp jt mq jw mr ka ms ke mt ki ml mm mn mo bi translated">@Transactional(isolation =隔离。可重复_读取)</li><li id="6fc2" class="mg mh hi jp b jq mp jt mq jw mr ka ms ke mt ki ml mm mn mo bi translated">@Transactional(isolation =隔离。可序列化)</li><li id="b552" class="mg mh hi jp b jq mp jt mq jw mr ka ms ke mt ki ml mm mn mo bi translated">@Transactional(isolation =隔离。默认)</li></ul><p id="4b99" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">上面提到的每一层都代表了DBMS中实现的相关层的行为。</p><p id="c0d8" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">如果没有填写该属性的值，其默认值将是Isolation。缺省值，因此会考虑DBMS的缺省隔离级别。</p><h2 id="3447" class="ln kk hi bd kl lt lu lv kp lw lx ly kt jw lz ma kv ka mb mc kx ke md me kz mf bi translated">传播</h2><p id="a656" class="pw-post-body-paragraph jn jo hi jp b jq lb ij js jt lc im jv jw ld jy jz ka le kc kd ke lf kg kh ki hb bi translated">另一方面，传播属性与事务在代码执行过程中必须传播的方式有关。</p><p id="cd2f" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">该属性的可能值为:</p><p id="cacc" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><strong class="jp hj"> @Transactional(传播=传播。必需)</strong></p><p id="609d" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">如果没有填充，这是传播属性的默认值。该值的行为是如果有当前事务，则使用当前事务，如果没有，则创建新事务。</p><p id="7f73" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><strong class="jp hj"> @Transactional(传播=传播。支持)</strong></p><p id="356d" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">对于SUPPORTS值，它使用当前的事务(如果有)，如果没有正在进行的事务，它不会创建新的事务。</p><p id="20a3" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><strong class="jp hj"> @Transactional(传播=传播。强制)</strong></p><p id="1c8f" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">在MANDATORY中，如果有正在进行的事务，就会使用它，否则Spring会抛出一个IllegalTransactionStateException类型的异常。</p><p id="c98e" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><strong class="jp hj"> @Transactional(传播=传播。从不)</strong></p><p id="e4e4" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">在NEVER值的情况下，将不允许使用事务，如果有正在进行的事务，将引发IllegalTransactionStateException类型的异常。</p><p id="7f44" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><strong class="jp hj"> @Transactional(传播=传播。不支持)</strong></p><p id="73eb" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">在NOT_SUPPORTED中，我们有一个非常类似于NEVER的场景，但是Spring不会抛出异常，而是会挂起当前的事务(如果它存在的话)。</p><p id="16b3" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><strong class="jp hj"> @Transactional(传播=传播。【需要_新)</strong></p><p id="e943" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">在REQUIRES_NEW的情况下，如果有一个正在进行的事务，Spring会暂停它并创建一个新的。一旦这个新事务结束，Spring将恢复暂停的事务。</p><p id="2aa4" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated"><strong class="jp hj"> @Transactional(传播=传播。嵌套)</strong></p><p id="a293" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">嵌套值在您想要使用保存点时使用，因此有可能部分回滚。当没有正在进行的事务时，它具有所需的相同行为，并创建一个新事务。</p><p id="3dc1" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">非常重要的一点是，为了使用嵌套值，我们依赖于外部因素，例如所使用的JDBC驱动程序的兼容性。</p><p id="067e" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">您可能已经注意到，当我们谈论传播属性的值时，我们谈论很多关于当前事务，但是什么是当前事务呢？</p><p id="0b27" class="pw-post-body-paragraph jn jo hi jp b jq jr ij js jt ju im jv jw jx jy jz ka kb kc kd ke kf kg kh ki hb bi translated">当前的事务只不过是来自外部的事务，具有更广泛的作用域，例如，假设您有一个使用@Transactional注释的@Controller类型的类，该控制器调用另一个使用@Transactional注释的@Service类型的类。当发生从控制器到服务的调用并且调用服务方法时，已经有一个来自控制器类的当前事务。</p><h1 id="21ad" class="kj kk hi bd kl km kn ko kp kq kr ks kt io ku ip kv ir kw is kx iu ky iv kz la bi translated">结论</h1><p id="82ff" class="pw-post-body-paragraph jn jo hi jp b jq lb ij js jt lc im jv jw ld jy jz ka le kc kd ke lf kg kh ki hb bi translated">我希望我能够澄清一点关于Spring中事务的使用以及它是如何处理它们的。当涉及到大量访问和并发的场景时，知道使用事务的正确方法会有很大的不同。如果使用不当，它还会损害应用程序的性能和业务规则。</p></div></div>    
</body>
</html>