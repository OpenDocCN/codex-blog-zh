<html>
<head>
<title>Binding in JS explained</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JS中的绑定解释</h1>
<blockquote>原文：<a href="https://medium.com/codex/binding-in-js-explained-4a2481a0b01a?source=collection_archive---------3-----------------------#2021-02-28">https://medium.com/codex/binding-in-js-explained-4a2481a0b01a?source=collection_archive---------3-----------------------#2021-02-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><h2 id="702a" class="hg hh hi bd b fp hj hk hl hm hn ho dx hp translated" aria-label="kicker paragraph"><a class="ae ge" href="http://medium.com/codex" rel="noopener">法典</a></h2><div class=""/><figure class="ev ex ip iq ir is er es paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="er es io"><img src="../Images/258df1fbdaab406a3d4182c87e3066d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UGl2H1Chsp7tyb1iUgJ4bA.jpeg"/></div></div></figure><p id="6b78" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">在我的上一篇关于原型链的文章中，我非常简要地提到了<code class="du jy jz ka kb b">this</code>关键词和绑定——现在是时候给予我们充分的关注了。</p><p id="891b" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">这是JavaScript中比较令人困惑的领域之一，所以请确保您的思考帽就在附近，坐下来让我们开始吧。</p></div><div class="ab cl kc kd gp ke" role="separator"><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh"/></div><div class="hb hc hd he hf"><p id="70cc" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">为了真正理解<code class="du jy jz ka kb b">this</code>的行为，我们需要注意4个<strong class="jb hs">绑定规则</strong>。</p><p id="6ef4" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">作为一个快速概述，以下是它们的升序排列(从低到高):</p><ul class=""><li id="e823" class="kj kk hi jb b jc jd jg jh jk kl jo km js kn jw ko kp kq kr bi translated">默认绑定</li><li id="1293" class="kj kk hi jb b jc ks jg kt jk ku jo kv js kw jw ko kp kq kr bi translated">隐式结合</li><li id="1405" class="kj kk hi jb b jc ks jg kt jk ku jo kv js kw jw ko kp kq kr bi translated">显式绑定</li><li id="dce5" class="kj kk hi jb b jc ks jg kt jk ku jo kv js kw jw ko kp kq kr bi translated">新绑定</li></ul><p id="d275" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">现在，对于主菜🥗…</p><h1 id="530c" class="kx ky hi bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">默认绑定</h1><p id="3782" class="pw-post-body-paragraph iz ja hi jb b jc lv je jf jg lw ji jj jk lx jm jn jo ly jq jr js lz ju jv jw hb bi translated">当其他绑定规则都不适用时，默认绑定基本上是包罗万象的——当我们查看其他规则时，这将更容易识别。</p><p id="5da2" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">使用默认绑定，<code class="du jy jz ka kb b">this</code>被绑定到全局对象。举以下例子:</p><figure class="ma mb mc md fd is"><div class="bz dy l di"><div class="me mf l"/></div></figure><p id="4fef" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">当我们调用<code class="du jy jz ka kb b">sayHello</code>时，你可能会惊讶地看到<code class="du jy jz ka kb b">'hello there'</code>被打印出来。</p><figure class="ma mb mc md fd is"><div class="bz dy l di"><div class="mg mf l"/></div><figcaption class="mh mi et er es mj mk bd b be z dx translated">我甚至不感到抱歉</figcaption></figure><p id="6b18" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">实际情况是这样的:</p><ol class=""><li id="1b7c" class="kj kk hi jb b jc jd jg jh jk kl jo km js kn jw ml kp kq kr bi translated">我们声明函数<code class="du jy jz ka kb b">sayHello</code>，它只是记录<code class="du jy jz ka kb b">this.hello</code></li><li id="51cb" class="kj kk hi jb b jc ks jg kt jk ku jo kv js kw jw ml kp kq kr bi translated">我们将字符串“hello there”赋给全局范围内的<code class="du jy jz ka kb b">hello</code>变量</li><li id="01f7" class="kj kk hi jb b jc ks jg kt jk ku jo kv js kw jw ml kp kq kr bi translated">当我们调用<code class="du jy jz ka kb b">sayHello()</code>时，<code class="du jy jz ka kb b">this</code>被绑定到全局对象，因为它是全局范围内的一个普通的旧函数调用，所以没有其他绑定规则适用。因为我们已经在全局对象上定义了<code class="du jy jz ka kb b">hello</code>变量，<code class="du jy jz ka kb b">this.hello</code>解析了它。</li></ol><p id="5abe" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">现在，你可能会想，如果我们删除<code class="du jy jz ka kb b">this</code>并简单地记录<code class="du jy jz ka kb b">hello</code>变量，由于你可能已经熟悉的词法范围的规则，你可能会期待‘hello there！’待印刷。</p><p id="a3cb" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">这让我想到了非常重要的一点:</p><p id="fc35" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated"><strong class="jb hs">词法范围和绑定上下文完全不相关！</strong></p><p id="276a" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">为了演示，让我们稍微修改一下第一个例子:</p><figure class="ma mb mc md fd is"><div class="bz dy l di"><div class="me mf l"/></div></figure><p id="fc9f" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">如果词法范围的规则适用于<code class="du jy jz ka kb b">this</code>，您可能会期望<code class="du jy jz ka kb b">this.response</code>等于<code class="du jy jz ka kb b">'general kenobi!’</code>。然而，因为它们是完全不同的概念<code class="du jy jz ka kb b">this.response</code>实际上是未定义的。</p><p id="239a" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">这是一个非常基本的例子，大多数IDE和文本编辑器都足够聪明，可以突出显示出<code class="du jy jz ka kb b">response</code>变量没有被使用，但是你已经明白了。</p><p id="3401" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">这也是确切的原因，在Node.js中复制这种行为略有不同！</p><p id="cd88" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">假设这段代码保存在<code class="du jy jz ka kb b">index.js</code>中，并且您使用<code class="du jy jz ka kb b">node index.js</code>运行它——由于node的内部原因，文件的顶层范围并不像您预期的那样是全局的。<code class="du jy jz ka kb b">index.js</code>被节点包装，节点将全局范围移动到更高的级别，在文件之外——所以<code class="du jy jz ka kb b">this</code>仍然绑定到全局对象，但是<code class="du jy jz ka kb b">hello</code>没有在全局对象上设置。这就是为什么我们需要在示例中的<code class="du jy jz ka kb b">global</code>对象上显式设置<code class="du jy jz ka kb b">hello</code>。</p><p id="3148" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">为简单起见，本文中的后续示例将假设它们正在浏览器中运行。</p><h2 id="da78" class="mm ky hi bd kz mn mo mp ld mq mr ms lh jk mt mu ll jo mv mw lp js mx my lt ho bi translated">“随它去吧</h2><p id="6f7a" class="pw-post-body-paragraph iz ja hi jb b jc lv je jf jg lw ji jj jk lx jm jn jo ly jq jr js lz ju jv jw hb bi translated">现在我已经把甲壳虫乐队印在了你的脑海里，这让我想到了一个旁注:</p><p id="eae6" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">如果我们在浏览器中尝试同样的例子，在ES6中用关键字<code class="du jy jz ka kb b">let</code>替换<code class="du jy jz ka kb b">var</code>，我们会得到<code class="du jy jz ka kb b">undefined</code>。摘自MDN的这篇文章解释了原因:</p><blockquote class="mz na nb"><p id="07ef" class="iz ja nc jb b jc jd je jf jg jh ji jj nd jl jm jn ne jp jq jr nf jt ju jv jw hb bi translated">就像<code class="du jy jz ka kb b"><a class="ae jx" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/const#description" rel="noopener ugc nofollow" target="_blank">const</a></code>一样，<code class="du jy jz ka kb b">let</code>在全局声明时<em class="hi">不会</em>创建<code class="du jy jz ka kb b"><a class="ae jx" href="https://developer.mozilla.org/en-US/docs/Web/API/Window" rel="noopener ugc nofollow" target="_blank">window</a></code>对象的属性(在最顶层的作用域中)。</p></blockquote><h2 id="fcba" class="mm ky hi bd kz mn mo mp ld mq mr ms lh jk mt mu ll jo mv mw lp js mx my lt ho bi translated">严格模式</h2><p id="f62a" class="pw-post-body-paragraph iz ja hi jb b jc lv je jf jg lw ji jj jk lx jm jn jo ly jq jr js lz ju jv jw hb bi translated">通过将<code class="du jy jz ka kb b">'use strict'</code>作为代码中的第一条语句，JavaScript代码可以在严格模式下运行。</p><p id="0258" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">让我们修改前面的示例，使用严格模式来演示不同之处:</p><figure class="ma mb mc md fd is"><div class="bz dy l di"><div class="me mf l"/></div></figure><p id="cec7" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">将它粘贴到浏览器的开发工具中，您会得到以下错误:</p><pre class="ma mb mc md fd ng kb nh ni aw nj bi"><span id="7368" class="mm ky hi kb b fi nk nl l nm nn">VM149:4 Uncaught TypeError: Cannot read property 'hello' of undefined<br/>    at demoDefaultScope (&lt;anonymous&gt;:4:22)<br/>    at &lt;anonymous&gt;:9:1</span></pre><p id="713c" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">在严格模式下，<code class="du jy jz ka kb b">this</code>不会被强制成为一个对象，因此当我们这次尝试记录<code class="du jy jz ka kb b">this.hello</code>时，<code class="du jy jz ka kb b">this</code>就是<code class="du jy jz ka kb b">undefined</code>导致了上面的错误。</p><h1 id="257c" class="kx ky hi bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">隐式结合</h1><p id="3577" class="pw-post-body-paragraph iz ja hi jb b jc lv je jf jg lw ji jj jk lx jm jn jo ly jq jr js lz ju jv jw hb bi translated">当从对象的上下文中调用函数时，<code class="du jy jz ka kb b">this</code>被设置为对象。</p><figure class="ma mb mc md fd is"><div class="bz dy l di"><div class="me mf l"/></div></figure><p id="3f45" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">在这个例子中，我们使用对象文字符号来声明<code class="du jy jz ka kb b">obj</code>，它具有属性<code class="du jy jz ka kb b">sayHello: sayHello()</code>和<code class="du jy jz ka kb b">hello: ‘hello there'</code>。</p><p id="1108" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">当我们调用<code class="du jy jz ka kb b">obj.sayHello()</code>时，<code class="du jy jz ka kb b">this</code>被绑定到<code class="du jy jz ka kb b">obj</code>，因此<code class="du jy jz ka kb b">sayHello()</code>能够解析到<code class="du jy jz ka kb b">obj</code>中定义的<code class="du jy jz ka kb b">hello</code>属性。</p><p id="b8c4" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">使用隐式绑定时要小心，因为如果绑定丢失，<code class="du jy jz ka kb b">this</code>将默认为默认绑定:</p><figure class="ma mb mc md fd is"><div class="bz dy l di"><div class="me mf l"/></div></figure><p id="1b5d" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">当我们将<code class="du jy jz ka kb b">obj.sayHello</code>赋给变量<code class="du jy jz ka kb b">yoink</code>时，<code class="du jy jz ka kb b">yoink</code>只是简单地引用了<code class="du jy jz ka kb b">sayHello</code>函数，<code class="du jy jz ka kb b">obj</code>根本不涉及。因此<code class="du jy jz ka kb b">this</code>将按照默认绑定规则默认为全局范围。</p><h1 id="1925" class="kx ky hi bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">显式绑定</h1><p id="f5b7" class="pw-post-body-paragraph iz ja hi jb b jc lv je jf jg lw ji jj jk lx jm jn jo ly jq jr js lz ju jv jw hb bi translated"><code class="du jy jz ka kb b">call</code>、<code class="du jy jz ka kb b">apply</code>和<code class="du jy jz ka kb b">bind</code>函数存在于函数原型中，这意味着默认情况下您声明的每个函数都可以访问这些函数。</p><p id="6d2f" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated"><code class="du jy jz ka kb b">Call</code>和<code class="du jy jz ka kb b">apply</code>非常相似，允许你调用带有<code class="du jy jz ka kb b">this</code>的函数。<code class="du jy jz ka kb b">call</code>和<code class="du jy jz ka kb b">apply</code>唯一的区别是<code class="du jy jz ka kb b">call</code>要求参数单独传递，而<code class="du jy jz ka kb b">apply</code>将它们作为一个数组。</p><figure class="ma mb mc md fd is"><div class="bz dy l di"><div class="me mf l"/></div></figure><p id="a8f4" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">在这个例子中，我们修改<code class="du jy jz ka kb b">sayHello</code>来打印传入的<code class="du jy jz ka kb b">firstName</code>和<code class="du jy jz ka kb b">lastName</code>以及<code class="du jy jz ka kb b">this.hello</code>的值。如果<code class="du jy jz ka kb b">console.log</code>中的字符串看起来有点陌生，那是因为它使用了ES6中引入的模板文字。</p><p id="635e" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">在<code class="du jy jz ka kb b">sayHello.call</code>和<code class="du jy jz ka kb b">sayHello.apply</code>中，我们在<code class="du jy jz ka kb b">this</code>设置为<code class="du jy jz ka kb b">obj</code>的情况下调用sayHello，我们可以从输出中看到<code class="du jy jz ka kb b">this.hello</code>成功解析为<code class="du jy jz ka kb b">obj.hello</code>。</p><h2 id="3f98" class="mm ky hi bd kz mn mo mp ld mq mr ms lh jk mt mu ll jo mv mw lp js mx my lt ho bi translated">绑定()</h2><p id="66cc" class="pw-post-body-paragraph iz ja hi jb b jc lv je jf jg lw ji jj jk lx jm jn jo ly jq jr js lz ju jv jw hb bi translated"><code class="du jy jz ka kb b">bind</code>函数用于返回一个新函数，其中<code class="du jy jz ka kb b">this</code>绑定到所提供的值。</p><p id="af87" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">这种行为被称为<strong class="jb hs">硬绑定</strong>，因为每次我们调用从<code class="du jy jz ka kb b">bind</code>返回的函数时，它总是被我们作为参数传递给<code class="du jy jz ka kb b">bind</code>的<code class="du jy jz ka kb b">this</code>调用。</p><figure class="ma mb mc md fd is"><div class="bz dy l di"><div class="me mf l"/></div></figure><p id="cc29" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">在这个例子中，<code class="du jy jz ka kb b">sayHello.bind(obj)</code>返回一个与<code class="du jy jz ka kb b">sayHello</code>实现相同的新函数，其中<code class="du jy jz ka kb b">this</code>被绑定到<code class="du jy jz ka kb b">obj</code>。所以当我们调用<code class="du jy jz ka kb b">boundFunction(firstName, lastName)</code>时，我们得到预期的输出，因为<code class="du jy jz ka kb b">this</code>被设置为<code class="du jy jz ka kb b">obj</code>。</p><h2 id="d562" class="mm ky hi bd kz mn mo mp ld mq mr ms lh jk mt mu ll jo mv mw lp js mx my lt ho bi translated">正在使用bind()</h2><p id="2d65" class="pw-post-body-paragraph iz ja hi jb b jc lv je jf jg lw ji jj jk lx jm jn jo ly jq jr js lz ju jv jw hb bi translated">关于<code class="du jy jz ka kb b">bind</code>另一个有趣的地方是它支持currying。</p><p id="e58c" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">Currying是函数<code class="du jy jz ka kb b">f(a, b)</code>到<code class="du jy jz ka kb b">f(a)(b)</code>的转换。当你想避免用相同的初始参数重复调用一个函数时，它特别有用。</p><p id="54df" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">让我们修改我们的示例，使用带有curry的<code class="du jy jz ka kb b">bind</code>:</p><figure class="ma mb mc md fd is"><div class="bz dy l di"><div class="me mf l"/></div></figure><p id="35a6" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">稍微重构了一下<code class="du jy jz ka kb b">sayHello()</code>函数，以便先传入<code class="du jy jz ka kb b">lastName</code>。</p><p id="4dac" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated"><code class="du jy jz ka kb b">sayHello.bind(obj, lastName)</code>返回一个带有绑定到对象的<code class="du jy jz ka kb b">this</code>的新函数<code class="du jy jz ka kb b">boundFunction</code>，它也部分应用带有值<code class="du jy jz ka kb b">'Skywalker'</code>的参数<code class="du jy jz ka kb b">lastName</code>。</p><p id="fe65" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">这很方便，因为我们现在可以继续调用绑定函数，而不必重复第一个参数<code class="du jy jz ka kb b">Skywalker</code>。</p><h1 id="da84" class="kx ky hi bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">新绑定</h1><p id="4117" class="pw-post-body-paragraph iz ja hi jb b jc lv je jf jg lw ji jj jk lx jm jn jo ly jq jr js lz ju jv jw hb bi translated">最后也是最重要的是新的绑定规则，它是绑定中优先级最高的<strong class="jb hs">。</strong></p><p id="e401" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">在JavaScript中，用<code class="du jy jz ka kb b">new</code>关键字调用的函数被称为构造函数，它仍然是一个普通的函数——但是它的行为被<code class="du jy jz ka kb b">new</code>关键字修改了。</p><p id="4aa9" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">当我们用关键字<code class="du jy jz ka kb b">new</code>调用一个函数并将其分配给一个新对象<code class="du jy jz ka kb b">obj</code>时，被调用的函数使用新对象<code class="du jy jz ka kb b">obj</code>作为<code class="du jy jz ka kb b">this</code>绑定。</p><p id="761d" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">例如:</p><figure class="ma mb mc md fd is"><div class="bz dy l di"><div class="me mf l"/></div></figure><p id="f41f" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">当我们调用<code class="du jy jz ka kb b">let jedi = new Jedi('purple', 'master')</code>时，新对象<code class="du jy jz ka kb b">jedi</code>首先被创建并被<code class="du jy jz ka kb b">Jedi</code>函数用作<code class="du jy jz ka kb b">this</code>绑定。所以<code class="du jy jz ka kb b">Jedi</code>函数中的<code class="du jy jz ka kb b">this.lightsaber</code>和<code class="du jy jz ka kb b">this.rank</code>指的是<code class="du jy jz ka kb b">jedi</code>对象。</p><p id="32d0" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">我们可以在记录<code class="du jy jz ka kb b">jedi</code>时看到这种情况:</p><figure class="ma mb mc md fd is er es paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="er es no"><img src="../Images/fd45767d060e86700ca85883f1a68ad0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kX0F_RbaAlAHtBJLjT6koQ.png"/></div></div></figure><p id="40ff" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">您可能已经注意到<code class="du jy jz ka kb b">Jedi</code>也出现在日志中。这是因为<code class="du jy jz ka kb b">jedi</code>原型上的构造函数属性指向构造它的函数，在本例中是<code class="du jy jz ka kb b">Jedi</code>函数。</p><h1 id="9a9f" class="kx ky hi bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">箭头函数不按规则运行</h1><p id="7cc4" class="pw-post-body-paragraph iz ja hi jb b jc lv je jf jg lw ji jj jk lx jm jn jo ly jq jr js lz ju jv jw hb bi translated">如果没有众所周知的扳手，软件工程会是什么样子呢🔧</p><p id="3111" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">从ES6开始，箭头函数成为了一件事情，当涉及到<code class="du jy jz ka kb b">this</code>的绑定时，箭头函数使用相同的<code class="du jy jz ka kb b">this</code>值作为它们的封闭范围。</p><p id="be39" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">为了演示这一点，我将隐式绑定一节中的示例修改为:</p><figure class="ma mb mc md fd is"><div class="bz dy l di"><div class="me mf l"/></div></figure><p id="9cf5" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">在<code class="du jy jz ka kb b">sayHello()</code>中，我们定义了一个分配给<code class="du jy jz ka kb b">sayHelloAgain</code>的箭头函数，令人惊讶的是，它记录了<code class="du jy jz ka kb b">this.hello</code>。我还声明了<code class="du jy jz ka kb b">hello</code>变量，只是为了表明它没有被使用。</p><p id="c637" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">调用<code class="du jy jz ka kb b">sayHelloAgain</code>时，输出与<code class="du jy jz ka kb b">this</code>完全相同，是包围作用域<code class="du jy jz ka kb b">sayHello</code>的箭头函数的值。</p></div><div class="ab cl kc kd gp ke" role="separator"><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh"/></div><div class="hb hc hd he hf"><p id="8089" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">如果您还在阅读，恭喜您坚持住了——这是JavaScript最令人困惑的方面之一！</p><p id="2a0b" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">希望这篇文章对你有帮助，我没有像迪士尼那样毁了你的星球大战😬</p><p id="d1e5" class="pw-post-body-paragraph iz ja hi jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">如果你有问题，或者如果我错过了你认为重要的东西，请留下你的评论——我很高兴收到你的来信。</p></div></div>    
</body>
</html>