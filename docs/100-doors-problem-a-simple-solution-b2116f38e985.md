# 100 扇门问题，一个简单的解决方案

> 原文：<https://medium.com/codex/100-doors-problem-a-simple-solution-b2116f38e985?source=collection_archive---------14----------------------->

![](img/b05d86df70a8b133daa7596ee4834976.png)

简单的计数序列(照片由来自 Pexels 的玛格达·埃勒斯拍摄:[https://www.pexels.com/photo/number-cutout-decors-1329302/](https://www.pexels.com/photo/number-cutout-decors-1329302/)

# 介绍

这个周末，我花时间磨练我的 Python 技能，并与罗宾·安德鲁斯在 LinkedIn Learning 上开设了一门名为[“Python 算法思维:基础”的课程。我过去上过算法课程，但从来没有在老师讲解任何内容之前给我一个挑战去解决。幸运的是，他从一个简单的问题开始，100 扇门的问题。](https://www.linkedin.com/learning-login/share?forceAccount=false&redirect=https%3A%2F%2Fwww.linkedin.com%2Flearning%2Falgorithmic-thinking-with-python-foundations%3Ftrk%3Dshare_ent_url%26shareId%3DZAopLAdcRTii1PFCKPcLSA%253D%253D)

我知道在我之前有无数人解决了这个问题，在我之后还会有无数人解决这个问题。我只是想分享我的经验，因为我在解决它和看到它揭示的模式后感到眩晕的喜悦，尽管它很简单。

# 100 门问题是什么？

我们从一个有 100 扇门的走廊开始，所有的门在开始时都是关闭的。我们总共会在走廊上走过 100 次。在第一遍中，我们将打开每扇门，将其状态从关闭切换到打开。在第二遍中，我们将只切换每隔一个门的状态(即 2、4、6……)。在第三遍中，我们将切换每第三个门的状态(即 3、6、9……)。这将持续到第 100 次通过，此时只有第 100 扇门被触发。

在所有这些之后，我们应该以一个非常具体的开门和关门的模式结束。

那么，哪些门将会打开呢？我向你挑战，在找到解决方案之前，尝试用任何你想要的方法来解决这个问题。如果你想出了一个不同的解决方案，或者对揭示的模式有所了解，请在评论中告诉我！

# 我是如何解决这个问题的

首先，让我们看看整个解决方案:

百门问题的众多解决方案之一

因为我正在探索用 Python 实现算法，所以我从编程的角度，而不是从基于数学的角度来处理这个问题。希望很快我将开始能够通过数学的应用解决算法问题，但是现在，我开始考虑如何用代码表示`doors`的状态。

```
# initial state of the doors
num_doors = 100
doors = [False] * num_doors
```

幸运的是，教练给了我们一个起点，尽管我也会这么做。我们将用一个列表来表示我们的`doors`走廊，一个可变的布尔值序列来表示`doors`是打开还是关闭的(分别是`True`或`False`)。在这一点上，我暂停了视频，因为剩下的只是提示，我想尝试自己解决它。为了便于测试，我创建了`num_doors`变量，因为我们将在几个地方使用它。

从那时起，我想知道第一次迭代会是什么样子。因为我知道我们将切换每一扇门，所以我使用了一个`for`循环来迭代这个序列。我很快意识到我需要用一个索引来跟踪我在哪扇门上，这就是我使用 Python 提供的`range()`函数的原因。我尝试使用 Python 的`enumerate()`函数，但是决定在这种情况下不需要将元素的索引和值分开。

```
# first pass over doors
for i in range(0, num_doors):
doors[i] = not doors[i]
```

这给我留下了一个`True`值的列表，我花了几分钟试图弄清楚第二次、第三次、第四次等等迭代会是什么样子。很明显，使用嵌套的`for`循环对于完成这个算法是必要的，因为我需要对所有的门迭代 100 次，同时跟踪我正在进行的迭代。

```
# the algorithm I used
for i in range(0, num_doors);
    for j in range(i, num_doors, i+1):
        doors[j] = not doors[j]
```

基本上，外部循环在门列表上迭代 100 次，范围从 0 到 100。提醒一下，Python `range()`函数排除了范围的上限，默认情况下所有列表都是零索引的。

这个外部循环和之前写的是一样的。

内部循环是算法有趣的部分。这里，被切换的元素是通过改变 for 循环将使用的范围来决定的。在每次迭代中，起始点等于外部循环的索引，以模拟“每第 n 个”门条件。

例如，在迭代 3 中，起始索引是 2，因为列表是零索引的。这类似于从第三扇门开始。

接下来，在这个算法中，循环的终点总是列表的末尾。

最后，使该算法工作的部分是内部循环的步骤，因为这完成了每次迭代的“每第 n 次”条件的实现。

如果我们在迭代 3 中，从第三个门开始，我们必须继续通过*每隔第三个门切换一次。*这通过将步骤设置为`i+1`来完成。我们必须使用`i+1`的原因是因为列表是零索引的，但是我们的基本步骤是 1。

可以这样想:如果我们的步长直接等于`i`，那么我们如何在迭代 0 上步进 0 次呢？我们至少需要步进 1 次才能使循环工作，因此我们给`i`加 1 来解决这个问题。

最后，我们简单地用`doors[j] = not doors[j]`为新范围中的每个元素切换每个门，以产生答案。这是 Python 翻转位的语法，不同的编程语言会有所不同。

# 解决方案

来自[https://compucademy.net/100Doors/](https://compucademy.net/100Doors/)的 100 门算法可视化

如果您已经自己解决了这个问题，或者运行了上面链接的要点中的代码，您可能已经有了解决方案。因为我想要一种简单的方法来查看发生了什么，所以我利用 Python 内置的字符串格式来查看`doors`列表的最终状态。

```
# quick printout of open doors
print("\nFinal State of doors:\n")
for index,door in enumerate(doors):
    if door: # evaluates door as a Boolean value
        print(f'{index+1}: Open; Square: {int(sqrt(index+1))}')
```

好吧，不仅仅是看看哪些门被打开了。为了给我的门编号，我很好地利用了 Python 内置的`enumerate()`函数。然后，我简单地检查每个门，看它是否打开(`True`)，并打印出门的编号(偏移 1，以便人们可以阅读)、状态和人们可以阅读的门编号的平方根。

在我深入解释为什么我包括了那个门号的平方根之前，让我说这就是解决方案。对于 100 个门，以下门将打开:

```
1: Open; Square: 1
4: Open; Square: 2
9: Open; Square: 3
16: Open; Square: 4
25: Open; Square: 5
36: Open; Square: 6
49: Open; Square: 7
64: Open; Square: 8
81: Open; Square: 9
100: Open; Square: 10
```

如果您手动解决这个问题(我不建议这样做)，您将在第 100 次通过后发现这个配置。

# 一种模式显露出来？

如果你像我一样，你可能会看着仍然开着的门的号码，看到一个模式:这是一个从 1 到 100 的完美方块的列表，包括 1 和 100。为了证实这一点，我找到了每个门牌号的平方根，它显示在我上面的快速打印输出中。

我在网上做了相当多的搜索，看看是否有人对为什么会出现这种情况进行了适当的数学分析。相反，我主要找到了“优化的”代码，它通过简单地打开{1…10}的完美正方形的门，一次性解决了这个问题。

我不能做一个真正的数学分析，因为我不知道怎么做(还不知道)，但我怀疑以下对任何数量的门都是正确的。

*   这个问题的解集将是`{1,4,9,...,n}`，其中`n`是门的数量。如果`n`不是一个完美的正方形，最高的门号将是集合中最高的完美正方形。
*   给定`n`扇门，`1`和`n`之间的完美正方形的数量等于`nth`迭代后打开的门的数量。
*   给定`n`个门，打开的门的数量将是集合`{1...floor(√n)}`的平方，其中`floor()`是一个函数，如果`n`不是一个完美的平方，则向下舍入到最接近的整数。

例如,“10 扇门”显示门 1、4 和 9 保持打开，因为它们是集合中唯一的完美正方形。

对于 100 个门，打开的门是 1、4、9、16、25、36、49、64、81 和 100。我们可以预测会有 10 扇门打开，因为`√100 = 10`。

那么，对于一万扇门，会打开多少扇门呢？嗯，`√10,000 = 100`。

这种模式成立，尽管像 42，501 门这样更复杂的数字可能会产生我作为一个人无法用脑子算出来的结果。我知道肯定有一个公式可以简洁地解决这个问题，但正如我所说的，我目前缺乏创建这个公式所必需的分析技能。

# 后续步骤

为了最大限度地利用这种解决方案，并考虑其实际应用，最明显的下一步是优化算法。虽然一个嵌套的 for 循环对于一小组数据来说没那么糟糕，但是它的时间复杂度是 O(n)，如果一个集合中有 1，000，000 个元素，这当然是可怕的。基本上，如果我们有 1，000，000 个门，我们最坏的情况会涉及*万亿*次迭代。对于翻转一万亿次来说，没那么糟糕，但是当你在内部循环中添加任何更复杂的操作时，速度就会变慢。

我可以想象，在这里，优化是从适当的数学分析开始的。我想，如果给我时间，我可能可以通过编程来优化它，但如果我不太理解底层公式的约束，这将是一个较慢的过程。

希望第二部分能够带来优化的运行时间和对这个解决方案的数学基础的透彻理解。

# 这有什么意义？

从中最重要的发现是，我在研究这个问题时获得了很多乐趣。总的来说，我在大约十分钟内解决了这个问题，然后花了两个小时试图找到一个好的数学分析模式，并写了这篇文章。

不得不承认，我其实还没想过这个算法的实际应用。这有望出现在第二部分！

我希望你和我一样觉得这个练习很有趣！如果你有不同的解决方法，或者知道如何对这个问题进行复杂的数学分析，请在评论中告诉我！