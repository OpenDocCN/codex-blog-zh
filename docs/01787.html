<html>
<head>
<title>Algorithmic Trading with the Know Sure Thing indicator in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Python中的确定性指标进行算法交易</h1>
<blockquote>原文：<a href="https://medium.com/codex/algorithmic-trading-with-the-know-sure-thing-indicator-in-python-68860a38a879?source=collection_archive---------3-----------------------#2021-05-31">https://medium.com/codex/algorithmic-trading-with-the-know-sure-thing-indicator-in-python-68860a38a879?source=collection_archive---------3-----------------------#2021-05-31</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="2152" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">关于在python中使用和实现KST指示器的完整指南</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/f79ca4b1839c3cccaea5bdf6820898e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*N2cFfqTP1IgiTEWG"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">法比奥·巴拉西纳在<a class="ae jn" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="dfcb" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">当我用最流行的动量振荡指标之一——移动平均线收敛/发散(MACD)对交易策略进行回溯测试时，结果非常惊人。今天，我发现了一个MACD指标的克隆，它的表现甚至更有效率。这正是众所周知的事情，简称为KST指标。</p><p id="d726" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在这篇文章中，我们将首先建立一些关于KST指标的基本直觉，以及计算该指标的方法。之后，我们将进入编程部分，使用Python从头构建指标，基于该指标构建简单的交易策略，在Tesla股票上回测该策略，并将其性能与SPY ETF(一种旨在跟踪标准普尔500市场指数走势的ETF)进行比较。话虽如此，我们还是深入文章吧！</p><p id="7ea7" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在继续之前，如果你想在没有任何代码的情况下回溯测试你的交易策略，有一个解决方案。这是<a class="ae jn" href="https://www.backtestzone.com/" rel="noopener ugc nofollow" target="_blank">的后验区</a>。这是一个平台，可以免费对不同类型的可交易资产的任意数量的交易策略进行回溯测试，无需编码。点击这里的链接，你可以马上使用这个工具:<a class="ae jn" href="https://www.backtestzone.com/" rel="noopener ugc nofollow" target="_blank">https://www.backtestzone.com/</a></p><h1 id="982a" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">变化率</h1><p id="3b43" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">在继续探讨KST指标之前，有必要知道变化率指标能提供什么，因为已知事物指标是基于ROC的。变化率指标是一个动量指标，交易者使用它作为一种工具来确定价格相对于当前收盘价和指定时间段之前的价格的百分比变化。与RSI和CCI等其他动量指标不同，变化率指标是一个无界的振荡器，其值不会在一定的范围内波动。</p><p id="9828" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">为了计算ROC的读数，我们必须首先确定“n”值，这个值就是当前收盘价与多少个周期之前的值进行比较。“n”的确定因交易者而异，但传统的设置是9(广泛用于短期交易)。将9作为“n”值，ROC指示器的读数计算如下:</p><p id="1d1e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">首先，从当前收盘价中减去9期之前的收盘价。这个差额然后除以9期前的收盘价，再乘以100。该计算可以用数学方法表示如下:</p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="c2c4" class="lm kl hi li b fi ln lo l lp lq"><strong class="li hj">ROC 9</strong> = [ ( <strong class="li hj">C.CLOSE </strong>- <strong class="li hj">PREV9.CLOSE</strong> ) / <strong class="li hj">PREV9.CLOSE</strong> ] * <strong class="li hj">100</strong></span><span id="6504" class="lm kl hi li b fi lr lo l lp lq">where,<br/>C.CLOSE = Current Closing Price<br/>PREV9.CLOSE = Closing Price of 9 Periods ago</span></pre><p id="de39" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">通常，ROC是在股票收盘价相对于零线的下方绘制的。如果观察到ROC指标的读数高于零线，则认为市场显示出强劲的上升势头，同样，如果数值低于零线，则认为市场显示出强劲的下降势头。这是使用ROC指标的一种方式，其他用途包括生成潜在的买入和卖出信号，识别市场状态(超买或超卖)，以及检测背离。</p><p id="8f61" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">ROC和它的计算就是这么回事。现在，我们准备开始探索这篇文章的主要思想，即“确信的事情”指标。</p><h1 id="d79b" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">知道肯定的事(KST)</h1><p id="da59" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">确信无疑指标是一个无界动量振荡器，被交易者广泛用于理解ROC指标的读数。KST指标基于平滑ROC的四个不同时间框架，并将收集的数据合并到一个振荡器中。已知事物指示器由两部分组成:</p><p id="0232" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> KST线:</strong>第一个组成部分是KST线本身。为了计算KST线的读数，我们必须首先确定四个roc，分别以10、15、20、30作为“n”值。然后分别以10、10、10、15作为回顾期，使用简单的移动平均来平滑每个ROC。这种平滑的ROC称为ROCSMA。在获得四个不同时间段的ROCSMA后，我们必须将第一个ROCSMA乘以1，第二个ROCSMA乘以2，第三个ROCSMA乘以3，第四个乘以4。最后，将这四个乘积相加。KST线的计算可以用数学方法表示如下:</p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="d477" class="lm kl hi li b fi ln lo l lp lq"><strong class="li hj">KL </strong>= (<strong class="li hj">ROCSMA1 </strong>* <strong class="li hj">1</strong>) + (<strong class="li hj">ROCSMA2 </strong>* <strong class="li hj">2</strong>) + (<strong class="li hj">ROCSMA3 </strong>* <strong class="li hj">3</strong>) + (<strong class="li hj">ROCSMA4 </strong>* <strong class="li hj">4</strong>)</span><span id="3da6" class="lm kl hi li b fi lr lo l lp lq">where,<br/>KL = KST Line<br/>ROCSMA1 = ROC 10 smoothed with SMA 10<br/>ROCSMA2 = ROC 15 smoothed with SMA 10<br/>ROCSMA3 = ROC 20 smoothed with SMA 10<br/>ROCSMA4 = ROC 30 smoothed with SMA 15</span></pre><p id="3762" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">信号线:</strong>现在，确知事物指示器的第二个组件是信号线组件。这个分量只不过是KST线的平滑版本。为了平滑KST线的值，以9作为回望周期的简单移动平均线被广泛使用。信号线的计算如下所示:</p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="3718" class="lm kl hi li b fi ln lo l lp lq"><strong class="li hj">SIGNAL LINE</strong> = <strong class="li hj">SMA9 </strong>( <strong class="li hj">KST LINE</strong> )</span></pre><p id="5b4e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">有许多类型的策略是用KST指标构建的，比如背离交易策略，零线交叉，等等。一些人认为它也可以作为一种工具来识别超买和超卖水平，但我个人认为它不会像RSI等其他指标那样有效，因为KST指标是一个无界的振荡器。在今天的文章中，我们将讨论并实施一个叫做交叉策略的基本策略。</p><p id="08b9" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">交叉策略揭示了一个买入信号，当KST线从信号线的下方交叉到上方时。当KST线从信号线的上方或下方穿过时，卖出信号就出现了。该策略可以表示如下:</p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="f485" class="lm kl hi li b fi ln lo l lp lq">IF <strong class="li hj">P.KST LINE</strong> &lt; <strong class="li hj">P.SIGNAL LINE</strong> AND <strong class="li hj">C.KST LINE</strong> &gt; <strong class="li hj">C.SIGNAL LINE</strong> =&gt; <strong class="li hj">BUY</strong><br/>IF <strong class="li hj">P.KST LINE</strong> &gt; <strong class="li hj">P.SIGNAL LINE</strong> AND <strong class="li hj">C.KST LINE</strong> &lt; <strong class="li hj">C.SIGNAL LINE</strong> =&gt; <strong class="li hj">SELL</strong></span></pre><p id="b70f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这就结束了我们对已知事物指示器的理论部分。现在，让我们进入编程部分，我们将使用python从头开始构建指标，构建交叉交易策略，对特斯拉股票进行回溯测试，将交叉策略回报与SPY ETF的回报进行比较。事不宜迟，我们直接跳到编程部分，做一些编码吧！在继续之前，关于免责声明的一个注意事项:本文的唯一目的是教育人们，必须被视为一个信息，而不是投资建议等。</p><h1 id="78b2" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">用Python实现</h1><p id="85cb" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">编码部分分为以下几个步骤:</p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="3a10" class="lm kl hi li b fi ln lo l lp lq"><strong class="li hj">1. Importing Packages<br/>2. Extracting Stock Data from Twelve Data<br/>3. ROC Calculation<br/>4. Know Sure Thing Calculation<br/>5. Know Sure Thing indicator Plot<br/>6. Creating the Trading Strategy<br/>7. Plotting the Trading Lists<br/>8. Creating our Position<br/>9. Backtesting<br/>10. SPY ETF Comparison</strong></span></pre><p id="0a93" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们将按照上面列表中提到的顺序，系好安全带，跟随每一个即将到来的编码部分。</p><h2 id="15f4" class="lm kl hi bd km ls lt lu kq lv lw lx ku jx ly lz kw kb ma mb ky kf mc md la me bi translated">步骤1:导入包</h2><p id="52e3" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">将所需的包导入python环境是一个不可跳过的步骤。主要的包是处理数据的Pandas，处理数组和复杂函数的NumPy，用于绘图的Matplotlib，以及进行API调用的请求。二级包是数学函数的Math和字体定制的Termcolor(可选)。</p><p id="9c45" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> Python实现:</strong></p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="2d44" class="lm kl hi li b fi ln lo l lp lq"><strong class="li hj"># IMPORTING PACKAGES<br/></strong><br/>import pandas as pd<br/>import numpy as np<br/>import requests<br/>import matplotlib.pyplot as plt<br/>from math import floor<br/>from termcolor import colored as cl<br/><br/>plt.style.use('fivethirtyeight')<br/>plt.rcParams['figure.figsize'] = (20,10)</span></pre><p id="bb38" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在我们已经将所有需要的包导入到python中。我们用十二数据的API端点来拉特斯拉的历史数据。</p><h2 id="f3f8" class="lm kl hi bd km ls lt lu kq lv lw lx ku jx ly lz kw kb ma mb ky kf mc md la me bi translated">步骤2:从12个数据中提取数据</h2><p id="e08e" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">在这一步中，我们将使用由twelvedata.com<a class="ae jn" href="https://twelvedata.com/" rel="noopener ugc nofollow" target="_blank">提供的API端点提取特斯拉的历史股票数据。在此之前，关于</a><a class="ae jn" href="https://twelvedata.com/" rel="noopener ugc nofollow" target="_blank">twelvedata.com</a>的一个说明:十二数据是领先的市场数据提供商之一，拥有大量针对所有类型市场数据的API端点。它非常容易与十二数据提供的API进行交互，并且拥有有史以来最好的文档。此外，确保您在<a class="ae jn" href="https://twelvedata.com/" rel="noopener ugc nofollow" target="_blank">twelvedata.com</a>上有一个帐户，只有这样，您才能访问您的API密钥(使用API提取数据的重要元素)。</p><p id="698b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> Python实现:</strong></p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="046c" class="lm kl hi li b fi ln lo l lp lq"><strong class="li hj"># EXTRACTING STOCK DATA<br/></strong><br/>def get_historical_data(symbol, start_date):<br/>    api_key = 'YOUR API KEY'<br/>    api_url = f'https://api.twelvedata.com/time_series?symbol={symbol}&amp;interval=1day&amp;outputsize=5000&amp;apikey={api_key}'<br/>    raw_df = requests.get(api_url).json()<br/>    df = pd.DataFrame(raw_df['values']).iloc[::-1].set_index('datetime').astype(float)<br/>    df = df[df.index &gt;= start_date]<br/>    df.index = pd.to_datetime(df.index)<br/>    return df<br/><br/>tsla = get_historical_data('TSLA', '2019-01-01')<br/>tsla</span></pre><p id="1f8f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">输出:</strong></p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mf"><img src="../Images/b94649753b34b94196912229c4f2cd67.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lKlBsrvvDIB0A0Ls_Af4gQ.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">作者图片</figcaption></figure><p id="98e1" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">代码解释:</strong>我们做的第一件事是定义一个名为‘get _ historical _ data’的函数，它以股票的符号(‘symbol’)和历史数据的起始日期(‘start _ date’)作为参数。在函数内部，我们定义了API键和URL，并将它们存储到各自的变量中。接下来，我们使用“get”函数提取JSON格式的历史数据，并将其存储到“raw_df”变量中。在对原始JSON数据进行清理和格式化之后，我们将以干净的Pandas数据帧的形式返回它。最后，我们正在调用创建的函数来提取特斯拉从2019年开始的历史数据，并将其存储到“tsla”变量中。</p><h2 id="2426" class="lm kl hi bd km ls lt lu kq lv lw lx ku jx ly lz kw kb ma mb ky kf mc md la me bi translated">步骤3: ROC计算</h2><p id="9845" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">在这一步中，我们将定义一个函数来计算给定系列的变化率指标的值。</p><p id="b28b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> Python实现:</strong></p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="5513" class="lm kl hi li b fi ln lo l lp lq"><strong class="li hj"># ROC CALCULATION</strong></span><span id="efa2" class="lm kl hi li b fi lr lo l lp lq">def get_roc(close, n):<br/>    difference = close.diff(n)<br/>    nprev_values = close.shift(n)<br/>    roc = (difference / nprev_values) * 100<br/>    return roc</span></pre><p id="8be1" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">代码解释:</strong>我们首先定义一个名为“get_roc”的函数，它将股票的收盘价(“close”)和“n”值(“n”)作为参数。在该函数中，我们首先使用Pandas包提供的“diff”函数来获取当前收盘价和指定时间段之前的收盘价之间的差值。在“shift”函数的帮助下，我们考虑了指定时间段之前的收盘价，并将其存储到“nprev_values”变量中。然后，我们将确定的值代入我们之前讨论的ROC指标公式，以计算值并最终返回数据。</p><h2 id="1c85" class="lm kl hi bd km ls lt lu kq lv lw lx ku jx ly lz kw kb ma mb ky kf mc md la me bi translated">第四步:了解有把握的事情计算</h2><p id="ee2b" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">在这一步，我们将按照我们之前讨论的方法和公式来计算已知事物指标的组成部分。</p><p id="9a41" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> Python实现:</strong></p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="2ab8" class="lm kl hi li b fi ln lo l lp lq"><strong class="li hj"># KST CALCULATION<br/></strong><br/>def get_kst(close, sma1, sma2, sma3, sma4, roc1, roc2, roc3, roc4, signal):<br/>    rcma1 = get_roc(close, roc1).rolling(sma1).mean()<br/>    rcma2 = get_roc(close, roc2).rolling(sma2).mean()<br/>    rcma3 = get_roc(close, roc3).rolling(sma3).mean()<br/>    rcma4 = get_roc(close, roc4).rolling(sma4).mean()<br/>    kst = (rcma1 * 1) + (rcma2 * 2) + (rcma3 * 3) + (rcma4 * 4)<br/>    signal = kst.rolling(signal).mean()<br/>    return kst, signal<br/><br/>tsla['kst'], tsla['signal_line'] = get_kst(tsla['close'], 10, 10, 10, 15, 10, 15, 20, 30, 9)<br/>tsla = tsla[tsla.index &gt;= '2020-01-01']<br/>tsla.tail()</span></pre><p id="5289" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">输出:</strong></p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mg"><img src="../Images/30b90214266f41767f142a113b31d148.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Dq8uYpFLlviN9nObHtFpeQ.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">作者图片</figcaption></figure><p id="dab0" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">代码解释:</strong>首先，我们定义一个名为“get_kst”的函数，该函数将股票的收盘价(“close”)、平滑ROC值的四个回顾期(“sma1”、“sma2”、“sma3”、“sma4”)、ROC的四个“n”值(“roc1”、“roc2”、“roc3”、“roc4”)以及信号线的回顾期(“signal”)作为参数。</p><p id="f365" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在函数内部，我们首先使用Pandas包提供的‘rolling’函数和我们之前创建的‘get _ roc’函数来计算四个ROCSMA值。然后，我们将计算出的ROCSMAs代入我们之前讨论过的公式，以确定KST线的读数。然后，我们用“滚动”函数平滑KST线的值，以获得信号线的值，并将它们存储到“信号”变量中。</p><p id="2f0f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">最后，我们将返回KST指标的计算分量，并调用创建的函数来存储特斯拉的KST线和信号线读数。</p><h2 id="6a8d" class="lm kl hi bd km ls lt lu kq lv lw lx ku jx ly lz kw kb ma mb ky kf mc md la me bi translated">第五步:了解确定的事情指标图</h2><p id="e618" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">在这一步中，我们将绘制特斯拉KST指标值的计算成分，以便更好地理解它们。这一部分的主要目的不是在编码部分，而是观察情节，以获得对已知事物技术指标的坚实理解。</p><p id="f005" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> Python实现:</strong></p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="14ea" class="lm kl hi li b fi ln lo l lp lq"><strong class="li hj"># KST INDICATOR PLOT<br/></strong><br/>ax1 = plt.subplot2grid((11,1), (0,0), rowspan = 5, colspan = 1)<br/>ax2 = plt.subplot2grid((11,1), (6,0), rowspan = 5, colspan = 1)<br/>ax1.plot(tsla['close'], linewidth = 2.5)<br/>ax1.set_title('TSLA CLOSING PRICES')<br/>ax2.plot(tsla['kst'], linewidth = 2, label = 'KST', color = 'orange')<br/>ax2.plot(tsla['signal_line'], linewidth = 2, label = 'SIGNAL', color = 'mediumorchid')<br/>ax2.legend()<br/>ax2.set_title('TSLA KST')<br/>plt.show()</span></pre><p id="23bf" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">输出:</strong></p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mh"><img src="../Images/81273b5a64dcb97dfa241a570909cc84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nDEYgXt6Q8QofP-kn35ISQ.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">作者图片</figcaption></figure><p id="a4ee" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">上面的图表分为两个面板:上面的面板是特斯拉的收盘价，下面的面板是确知事物指标的组成部分。可以注意到，两个组件的读数都是不确定的，并且不在某些界限之间有界，因为已知事物指示器是无界振荡器。这就是为什么在图表中没有超买和超卖水平的原因，这个图表在其他动量振荡指标中被广泛绘制。但是，有些人提出，这个指标可以用来确定超买和超卖水平，但不同的股票有所不同。这意味着，不像其他动量振荡指标有默认的超买和超卖水平，有必要分析KST成分的运动和读数来确定超买和超卖水平。在我们的例子中，最好是在100点发现超买水平，在-100点发现超卖水平。</p><p id="271b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">KST指标的一个特殊特征是，除了确定超买和超卖水平或发现背离外，它还可以用作检测区间市场(没有趋势或动力，但在特定的高低价格区间来回移动的市场)的工具。当两个成分来回交叉时，市场被认为是在波动。由于特斯拉的股票显示出巨大的价格波动，这种现象只能观察到很少几次(实际上是两次:一次是在前一年的6月和7月左右，另一次是在2021年初)。</p><h2 id="bd8b" class="lm kl hi bd km ls lt lu kq lv lw lx ku jx ly lz kw kb ma mb ky kf mc md la me bi translated">步骤6:创建交易策略</h2><p id="6a3b" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">在这一步中，我们将在python中实现我们讨论过的Know Sure Thing交叉交易策略。</p><p id="a085" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> Python实现:</strong></p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="b085" class="lm kl hi li b fi ln lo l lp lq"><strong class="li hj"># KST CROSSOVER TRADING STRATEGY<br/></strong><br/>def implement_kst_strategy(prices, kst_line, signal_line):<br/>    buy_price = []<br/>    sell_price = []<br/>    kst_signal = []<br/>    signal = 0<br/>    <br/>    for i in range(len(kst_line)):<br/>        <br/>        if kst_line[i-1] &lt; signal_line[i-1] and kst_line[i] &gt; signal_line[i]:<br/>            if signal != 1:<br/>                buy_price.append(prices[i])<br/>                sell_price.append(np.nan)<br/>                signal = 1<br/>                kst_signal.append(signal)<br/>            else:<br/>                buy_price.append(np.nan)<br/>                sell_price.append(np.nan)<br/>                kst_signal.append(0)<br/>                <br/>        elif kst_line[i-1] &gt; signal_line[i-1] and kst_line[i] &lt; signal_line[i]:<br/>            if signal != -1:<br/>                buy_price.append(np.nan)<br/>                sell_price.append(prices[i])<br/>                signal = -1<br/>                kst_signal.append(signal)<br/>            else:<br/>                buy_price.append(np.nan)<br/>                sell_price.append(np.nan)<br/>                kst_signal.append(0)<br/>                <br/>        else:<br/>            buy_price.append(np.nan)<br/>            sell_price.append(np.nan)<br/>            kst_signal.append(0)<br/>            <br/>    return buy_price, sell_price, kst_signal<br/><br/>buy_price, sell_price, kst_signal = implement_kst_strategy(tsla['close'], tsla['kst'], tsla['signal_line'])</span></pre><p id="58ce" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">代码解释:</strong>首先，我们定义一个名为‘implement _ kst _ strategy’的函数，它将股票价格(‘prices’)、kst线的读数(‘kst _ line’)和信号线的读数(‘Signal _ line’)作为参数。</p><p id="786c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在该函数中，我们创建了三个空列表(buy_price、sell_price和kst_signal ),在创建交易策略时，将在这些列表中追加值。</p><p id="3330" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">之后，我们通过for循环实施交易策略。在for循环内部，我们传递某些条件，如果条件得到满足，相应的值将被追加到空列表中。如果购买股票的条件得到满足，买入价将被追加到“buy_price”列表中，信号值将被追加为1，表示购买股票。类似地，如果卖出股票的条件得到满足，卖价将被追加到“sell_price”列表中，信号值将被追加为-1，表示卖出股票。</p><p id="6187" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">最后，我们返回附加了值的列表。然后，我们调用创建的函数并将值存储到各自的变量中。除非我们画出这些值，否则这个列表没有任何意义。所以，让我们画出创建的交易列表的值。</p><h2 id="cd64" class="lm kl hi bd km ls lt lu kq lv lw lx ku jx ly lz kw kb ma mb ky kf mc md la me bi translated">步骤7:绘制交易信号</h2><p id="6057" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">在这一步，我们将绘制已创建的交易列表，以使它们有意义。</p><p id="db61" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> Python实现:</strong></p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="5caa" class="lm kl hi li b fi ln lo l lp lq"><strong class="li hj"># TRADING SIGNALS PLOT<br/></strong><br/>ax1 = plt.subplot2grid((11,1), (0,0), rowspan = 5, colspan = 1)<br/>ax2 = plt.subplot2grid((11,1), (6,0), rowspan = 5, colspan = 1)<br/>ax1.plot(tsla['close'], linewidth = 2, label = 'TSLA')<br/>ax1.plot(tsla.index, buy_price, marker = '^', markersize = 12, linewidth = 0, color = 'green', label = 'BUY SIGNAL')<br/>ax1.plot(tsla.index, sell_price, marker = 'v', markersize = 12, linewidth = 0, color = 'r', label = 'SELL SIGNAL')<br/>ax1.legend()<br/>ax1.set_title('TSLA KST TRADING SIGNALS')<br/>ax2.plot(tsla['kst'], linewidth = 2, label = 'KST', color = 'orange')<br/>ax2.plot(tsla['signal_line'], linewidth = 2, label = 'SIGNAL', color = 'mediumorchid')<br/>ax2.legend()<br/>ax2.set_title('TSLA KST')<br/>plt.show()</span></pre><p id="bb2b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">输出:</strong></p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mh"><img src="../Images/4474802fe90842f25fbdf293b7db48f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qTwHy4vX-ONIvCXcOS_9HA.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">作者图片</figcaption></figure><p id="c3fd" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">代码解释:</strong>我们正在绘制KST指标成分的读数，以及交叉交易策略产生的买入和卖出信号。我们可以观察到，每当KST线从信号线的下方穿越到上方时，图表中就会出现绿色的买入信号。同样，每当KST线从信号线的上方穿越到下方时，图表中就会出现红色的卖出信号。</p><h2 id="4706" class="lm kl hi bd km ls lt lu kq lv lw lx ku jx ly lz kw kb ma mb ky kf mc md la me bi translated">第八步:确立我们的立场</h2><p id="b82a" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">在这一步中，我们将创建一个列表，如果我们持有股票，该列表将指示1；如果我们不拥有或持有股票，该列表将指示0。</p><p id="c5ee" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> Python实现:</strong></p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="3743" class="lm kl hi li b fi ln lo l lp lq"><strong class="li hj"># STOCK POSITION<br/></strong><br/>position = []<br/>for i in range(len(kst_signal)):<br/>    if kst_signal[i] &gt; 1:<br/>        position.append(0)<br/>    else:<br/>        position.append(1)<br/>        <br/>for i in range(len(tsla['close'])):<br/>    if kst_signal[i] == 1:<br/>        position[i] = 1<br/>    elif kst_signal[i] == -1:<br/>        position[i] = 0<br/>    else:<br/>        position[i] = position[i-1]<br/>        <br/>close_price = tsla['close']<br/>kst = tsla['kst']<br/>signal_line = tsla['signal_line']<br/>kst_signal = pd.DataFrame(kst_signal).rename(columns = {0:'kst_signal'}).set_index(tsla.index)<br/>position = pd.DataFrame(position).rename(columns = {0:'kst_position'}).set_index(tsla.index)<br/><br/>frames = [close_price, kst, signal_line, kst_signal, position]<br/>strategy = pd.concat(frames, join = 'inner', axis = 1)<br/><br/>strategy</span></pre><p id="23c7" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">输出:</strong></p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mi"><img src="../Images/469fe40ffe0247ff8580b8a12cff0e90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aymCA4ys8mcw32pgYoYr9w.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">作者图片</figcaption></figure><p id="59a1" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">代码解释:</strong>首先，我们创建一个名为‘position’的空列表。我们传递两个for循环，一个是为“位置”列表生成值，以匹配“信号”列表的长度。另一个for循环是我们用来生成实际位置值的循环。在第二个for循环中，我们对“signal”列表的值进行迭代，而“position”列表的值被附加到满足哪个条件上。如果我们持有股票，头寸的价值仍为1；如果我们卖出或不持有股票，头寸的价值仍为0。最后，我们正在进行一些数据操作，将所有创建的列表合并到一个数据帧中。</p><p id="ad23" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">从显示的输出中，我们可以看到，在第一行中，我们在股票中的位置仍然是1(因为KST信号没有任何变化)，但是当KST交易信号代表卖出信号(-1)时，我们的位置突然变成了-1。我们的头寸将保持为0，直到交易信号发生一些变化。现在是时候实现一些回溯测试过程了！</p><h2 id="a252" class="lm kl hi bd km ls lt lu kq lv lw lx ku jx ly lz kw kb ma mb ky kf mc md la me bi translated">步骤9:回溯测试</h2><p id="a8ab" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">在继续之前，有必要知道什么是回溯测试。回溯测试是查看我们的交易策略在给定股票数据上表现如何的过程。在我们的案例中，我们将对Tesla股票数据实施KST指标交叉交易策略的回溯测试流程。</p><p id="8a10" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> Python实现:</strong></p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="7975" class="lm kl hi li b fi ln lo l lp lq"><strong class="li hj"># BACKTESTING<br/></strong><br/>tsla_ret = pd.DataFrame(np.diff(tsla['close'])).rename(columns = {0:'returns'})<br/>kst_strategy_ret = []</span><span id="bfa4" class="lm kl hi li b fi lr lo l lp lq">for i in range(len(tsla_ret)):<br/>    returns = tsla_ret['returns'][i]*strategy['kst_position'][i]<br/>    kst_strategy_ret.append(returns)<br/>    <br/>kst_strategy_ret_df = pd.DataFrame(kst_strategy_ret).rename(columns = {0:'kst_returns'})<br/>investment_value = 100000<br/>number_of_stocks = floor(investment_value/tsla['close'][0])<br/>kst_investment_ret = []</span><span id="4d8e" class="lm kl hi li b fi lr lo l lp lq">for i in range(len(kst_strategy_ret_df['kst_returns'])):<br/>    returns = number_of_stocks*kst_strategy_ret_df['kst_returns'][i]<br/>    kst_investment_ret.append(returns)</span><span id="467f" class="lm kl hi li b fi lr lo l lp lq">kst_investment_ret_df = pd.DataFrame(kst_investment_ret).rename(columns = {0:'investment_returns'})<br/>total_investment_ret = round(sum(kst_investment_ret_df['investment_returns']), 2)<br/>profit_percentage = floor((total_investment_ret/investment_value)*100)<br/>print(cl('Profit gained from the KST strategy by investing $100k in TSLA : {}'.format(total_investment_ret), attrs = ['bold']))<br/>print(cl('Profit percentage of the KST strategy : {}%'.format(profit_percentage), attrs = ['bold']))</span></pre><p id="62e9" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">输出:</strong></p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="6bd9" class="lm kl hi li b fi ln lo l lp lq"><strong class="li hj">Profit gained from the KST strategy by investing $100k in TSLA : 295766.23</strong><br/><strong class="li hj">Profit percentage of the KST strategy : 295%</strong></span></pre><p id="daa8" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">代码解释:</strong>首先，我们使用NumPy包提供的‘diff’函数计算Tesla股票的回报，并将其作为数据帧存储到‘tsla _ ret’变量中。接下来，我们将传递一个for循环来迭代' tsla_ret '变量的值，以计算我们从我们确信无疑的指标交易策略中获得的回报，并将这些回报值追加到' kst_strategy_ret '列表中。接下来，我们将“kst_strategy_ret”列表转换为数据帧，并将其存储到“kst_strategy_ret_df”变量中。</p><p id="573e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">接下来是回溯测试过程。我们将通过投资10万美元到我们的交易策略中来回测我们的策略。首先，我们将投资金额存储到“投资值”变量中。之后，我们正在计算使用投资金额可以购买的特斯拉股票数量。你可以注意到，我使用了Math package提供的“floor”函数，因为当投资金额除以特斯拉股票的收盘价时，它会输出一个十进制数。股票数量应该是整数，而不是小数。使用“底数”函数，我们可以去掉小数。请记住,“floor”函数比“round”函数要复杂得多。然后，我们传递一个for循环来查找投资回报，后面是一些数据操作任务。</p><p id="7903" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">最后，我们打印出我们在交易策略中投入10万美元所获得的总回报，结果显示我们在一年中获得了大约22.9万美元的利润。太棒了。现在，让我们将我们的回报与SPY ETF(一种旨在跟踪标准普尔500股票市场指数的ETF)的回报进行比较。</p><h2 id="8999" class="lm kl hi bd km ls lt lu kq lv lw lx ku jx ly lz kw kb ma mb ky kf mc md la me bi translated">第十步:间谍ETF对比</h2><p id="11c3" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">这一步是可选的，但强烈推荐，因为我们可以了解我们的交易策略相对于基准(间谍ETF)的表现如何。在这一步，我们将使用我们创建的“get_historical_data”函数提取SPY ETF的数据，并将我们从SPY ETF获得的回报与我们在Tesla上的KST交叉交易策略回报进行比较。</p><p id="8991" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj"> Python实现:</strong></p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="df03" class="lm kl hi li b fi ln lo l lp lq"><strong class="li hj"># SPY ETF COMPARISON</strong><em class="mj"><br/></em><br/>def get_benchmark(start_date, investment_value):<br/>    spy = get_historical_data('SPY', start_date)['close']<br/>    benchmark = pd.DataFrame(np.diff(spy)).rename(columns = {0:'benchmark_returns'})<br/>    <br/>    investment_value = investment_value<br/>    number_of_stocks = floor(investment_value/spy[-1])<br/>    benchmark_investment_ret = []<br/>    <br/>    for i in range(len(benchmark['benchmark_returns'])):<br/>        returns = number_of_stocks*benchmark['benchmark_returns'][i]<br/>        benchmark_investment_ret.append(returns)<br/><br/>    benchmark_investment_ret_df = pd.DataFrame(benchmark_investment_ret).rename(columns = {0:'investment_returns'})<br/>    return benchmark_investment_ret_df<br/><br/>benchmark = get_benchmark('2020-01-01', 100000)<br/>investment_value = 100000<br/>total_benchmark_investment_ret = round(sum(benchmark['investment_returns']), 2)<br/>benchmark_profit_percentage = floor((total_benchmark_investment_ret/investment_value)*100)<br/>print(cl('Benchmark profit by investing $100k : {}'.format(total_benchmark_investment_ret), attrs = ['bold']))<br/>print(cl('Benchmark Profit percentage : {}%'.format(benchmark_profit_percentage), attrs = ['bold']))<br/>print(cl('KST Strategy profit is {}% higher than the Benchmark Profit'.format(profit_percentage - benchmark_profit_percentage), attrs = ['bold']))</span></pre><p id="cfb6" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">输出:</strong></p><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="d16f" class="lm kl hi li b fi ln lo l lp lq"><strong class="li hj">Benchmark profit by investing $100k : 22650.46</strong><br/><strong class="li hj">Benchmark Profit percentage : 22%</strong><br/><strong class="li hj">KST Strategy profit is 273% higher than the Benchmark Profit</strong></span></pre><p id="69bc" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">代码解释:</strong>此步骤中使用的代码几乎与前一回测步骤中使用的代码相似，但我们不是投资特斯拉，而是通过不实施任何交易策略来投资SPY ETF。从输出中，我们可以看到，我们确信无疑的交叉交易策略已经超过间谍ETF 273%。太好了！</p><h1 id="525b" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">最后的想法！</h1><p id="10ac" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">经过一个压倒性的过程，粉碎了理论和编码部分，我们已经成功地了解了什么是确知指标，它背后的数学，以及如何用python建立一个简单的KST交叉交易策略。</p><p id="2200" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">尽管我们通过KST策略获得了丰厚的利润，并超越了SPY ETF，但我们的策略回报仍低于Tesla股票的实际回报。这是因为KST指标的一个主要缺点。这没什么，但KST指标在市场波动期间容易揭示许多错误信号，这可以在我们的交叉交易信号图中观察到，我们的交易策略揭示了许多不必要的交易信号。</p><p id="7640" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">优化和解决这个问题的唯一方法是添加另一个技术指标，作为过滤交易策略给出的非真实或虚假信号的标尺。在我看来，波动指数与KST指标配合会非常好，因为它是一个专门跟踪市场是否波动的指标，也是最准确的跟踪指标之一。所以强烈建议用KST交易策略进行尽可能多的回溯测试，用另一个指标来区分假信号和真信号，这样会让你的结果更上一层楼。</p><p id="6dd8" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">话虽如此，你已经到了文章的结尾。如果您忘记了遵循任何编码部分，不要担心。我在文章底部提供了完整的源代码。希望你能从这篇文章中找到并学到一些有用的东西。快乐学习！</p><h2 id="69f2" class="lm kl hi bd km ls lt lu kq lv lw lx ku jx ly lz kw kb ma mb ky kf mc md la me bi translated">完整代码:</h2><pre class="iy iz ja jb fd lh li lj lk aw ll bi"><span id="9f8b" class="lm kl hi li b fi ln lo l lp lq"><strong class="li hj"># IMPORTING PACKAGES<br/></strong><br/>import pandas as pd<br/>import numpy as np<br/>import requests<br/>import matplotlib.pyplot as plt<br/>from math import floor<br/>from termcolor import colored as cl<br/><br/>plt.style.use('fivethirtyeight')<br/>plt.rcParams['figure.figsize'] = (20,10)<br/><br/><br/><strong class="li hj"># EXTRACTING STOCK DATA<br/></strong><br/>def get_historical_data(symbol, start_date):<br/>    api_key = 'YOUR API KEY'<br/>    api_url = f'https://api.twelvedata.com/time_series?symbol={symbol}&amp;interval=1day&amp;outputsize=5000&amp;apikey={api_key}'<br/>    raw_df = requests.get(api_url).json()<br/>    df = pd.DataFrame(raw_df['values']).iloc[::-1].set_index('datetime').astype(float)<br/>    df = df[df.index &gt;= start_date]<br/>    df.index = pd.to_datetime(df.index)<br/>    return df<br/><br/>tsla = get_historical_data('TSLA', '2019-01-01')<br/>print(tsla)<br/><br/><br/><strong class="li hj"># ROC CALCULATION<br/></strong><br/>def get_roc(close, n):<br/>    difference = close.diff(n)<br/>    nprev_values = close.shift(n)<br/>    roc = (difference / nprev_values) * 100<br/>    return roc<br/><br/><br/><strong class="li hj"># KST CALCULATION<br/></strong><br/>def get_kst(close, sma1, sma2, sma3, sma4, roc1, roc2, roc3, roc4, signal):<br/>    rcma1 = get_roc(close, roc1).rolling(sma1).mean()<br/>    rcma2 = get_roc(close, roc2).rolling(sma2).mean()<br/>    rcma3 = get_roc(close, roc3).rolling(sma3).mean()<br/>    rcma4 = get_roc(close, roc4).rolling(sma4).mean()<br/>    kst = (rcma1 * 1) + (rcma2 * 2) + (rcma3 * 3) + (rcma4 * 4)<br/>    signal = kst.rolling(signal).mean()<br/>    return kst, signal<br/><br/>tsla['kst'], tsla['signal_line'] = get_kst(tsla['close'], 10, 10, 10, 15, 10, 15, 20, 30, 9)<br/>tsla = tsla[tsla.index &gt;= '2020-01-01']<br/>print(tsla.tail())<br/><br/><br/><strong class="li hj"># KST INDICATOR PLOT<br/></strong><br/>ax1 = plt.subplot2grid((11,1), (0,0), rowspan = 5, colspan = 1)<br/>ax2 = plt.subplot2grid((11,1), (6,0), rowspan = 5, colspan = 1)<br/>ax1.plot(tsla['close'], linewidth = 2.5)<br/>ax1.set_title('TSLA CLOSING PRICES')<br/>ax2.plot(tsla['kst'], linewidth = 2, label = 'KST', color = 'orange')<br/>ax2.plot(tsla['signal_line'], linewidth = 2, label = 'SIGNAL', color = 'mediumorchid')<br/>ax2.legend()<br/>ax2.set_title('TSLA KST')<br/>plt.show()<br/><br/><br/><strong class="li hj"># KST CROSSOVER TRADING STRATEGY<br/></strong><br/>def implement_kst_strategy(prices, kst_line, signal_line):<br/>    buy_price = []<br/>    sell_price = []<br/>    kst_signal = []<br/>    signal = 0<br/>    <br/>    for i in range(len(kst_line)):<br/>        <br/>        if kst_line[i-1] &lt; signal_line[i-1] and kst_line[i] &gt; signal_line[i]:<br/>            if signal != 1:<br/>                buy_price.append(prices[i])<br/>                sell_price.append(np.nan)<br/>                signal = 1<br/>                kst_signal.append(signal)<br/>            else:<br/>                buy_price.append(np.nan)<br/>                sell_price.append(np.nan)<br/>                kst_signal.append(0)<br/>                <br/>        elif kst_line[i-1] &gt; signal_line[i-1] and kst_line[i] &lt; signal_line[i]:<br/>            if signal != -1:<br/>                buy_price.append(np.nan)<br/>                sell_price.append(prices[i])<br/>                signal = -1<br/>                kst_signal.append(signal)<br/>            else:<br/>                buy_price.append(np.nan)<br/>                sell_price.append(np.nan)<br/>                kst_signal.append(0)<br/>                <br/>        else:<br/>            buy_price.append(np.nan)<br/>            sell_price.append(np.nan)<br/>            kst_signal.append(0)<br/>            <br/>    return buy_price, sell_price, kst_signal<br/><br/>buy_price, sell_price, kst_signal = implement_kst_strategy(tsla['close'], tsla['kst'], tsla['signal_line'])<br/><br/><br/><strong class="li hj"># TRADING SIGNALS PLOT<br/></strong><br/>ax1 = plt.subplot2grid((11,1), (0,0), rowspan = 5, colspan = 1)<br/>ax2 = plt.subplot2grid((11,1), (6,0), rowspan = 5, colspan = 1)<br/>ax1.plot(tsla['close'], linewidth = 2, label = 'TSLA')<br/>ax1.plot(tsla.index, buy_price, marker = '^', markersize = 12, linewidth = 0, color = 'green', label = 'BUY SIGNAL')<br/>ax1.plot(tsla.index, sell_price, marker = 'v', markersize = 12, linewidth = 0, color = 'r', label = 'SELL SIGNAL')<br/>ax1.legend()<br/>ax1.set_title('TSLA KST TRADING SIGNALS')<br/>ax2.plot(tsla['kst'], linewidth = 2, label = 'KST', color = 'orange')<br/>ax2.plot(tsla['signal_line'], linewidth = 2, label = 'SIGNAL', color = 'mediumorchid')<br/>ax2.legend()<br/>ax2.set_title('TSLA KST')<br/>plt.show()<br/><br/><br/><strong class="li hj"># STOCK POSITION<br/></strong><br/>position = []<br/>for i in range(len(kst_signal)):<br/>    if kst_signal[i] &gt; 1:<br/>        position.append(0)<br/>    else:<br/>        position.append(1)<br/>        <br/>for i in range(len(tsla['close'])):<br/>    if kst_signal[i] == 1:<br/>        position[i] = 1<br/>    elif kst_signal[i] == -1:<br/>        position[i] = 0<br/>    else:<br/>        position[i] = position[i-1]<br/>        <br/>close_price = tsla['close']<br/>kst = tsla['kst']<br/>signal_line = tsla['signal_line']<br/>kst_signal = pd.DataFrame(kst_signal).rename(columns = {0:'kst_signal'}).set_index(tsla.index)<br/>position = pd.DataFrame(position).rename(columns = {0:'kst_position'}).set_index(tsla.index)<br/><br/>frames = [close_price, kst, signal_line, kst_signal, position]<br/>strategy = pd.concat(frames, join = 'inner', axis = 1)<br/><br/>print(strategy)<br/>print(strategy[35:40])<br/><br/><br/><strong class="li hj"># BACKTESTING<br/></strong><br/>tsla_ret = pd.DataFrame(np.diff(tsla['close'])).rename(columns = {0:'returns'})<br/>kst_strategy_ret = []<br/><br/>for i in range(len(tsla_ret)):<br/>    returns = tsla_ret['returns'][i]*strategy['kst_position'][i]<br/>    kst_strategy_ret.append(returns)<br/>    <br/>kst_strategy_ret_df = pd.DataFrame(kst_strategy_ret).rename(columns = {0:'kst_returns'})<br/>investment_value = 100000<br/>number_of_stocks = floor(investment_value/tsla['close'][0])<br/>kst_investment_ret = []<br/><br/>for i in range(len(kst_strategy_ret_df['kst_returns'])):<br/>    returns = number_of_stocks*kst_strategy_ret_df['kst_returns'][i]<br/>    kst_investment_ret.append(returns)<br/><br/>kst_investment_ret_df = pd.DataFrame(kst_investment_ret).rename(columns = {0:'investment_returns'})<br/>total_investment_ret = round(sum(kst_investment_ret_df['investment_returns']), 2)<br/>profit_percentage = floor((total_investment_ret/investment_value)*100)<br/>print(cl('Profit gained from the KST strategy by investing $100k in TSLA : {}'.format(total_investment_ret), attrs = ['bold']))<br/>print(cl('Profit percentage of the KST strategy : {}%'.format(profit_percentage), attrs = ['bold']))<br/><br/><br/><strong class="li hj"># SPY ETF COMPARISON<br/></strong><br/>def get_benchmark(start_date, investment_value):<br/>    spy = get_historical_data('SPY', start_date)['close']<br/>    benchmark = pd.DataFrame(np.diff(spy)).rename(columns = {0:'benchmark_returns'})<br/>    <br/>    investment_value = investment_value<br/>    number_of_stocks = floor(investment_value/spy[-1])<br/>    benchmark_investment_ret = []<br/>    <br/>    for i in range(len(benchmark['benchmark_returns'])):<br/>        returns = number_of_stocks*benchmark['benchmark_returns'][i]<br/>        benchmark_investment_ret.append(returns)<br/><br/>    benchmark_investment_ret_df = pd.DataFrame(benchmark_investment_ret).rename(columns = {0:'investment_returns'})<br/>    return benchmark_investment_ret_df<br/><br/>benchmark = get_benchmark('2020-01-01', 100000)<br/><br/>investment_value = 100000<br/>total_benchmark_investment_ret = round(sum(benchmark['investment_returns']), 2)<br/>benchmark_profit_percentage = floor((total_benchmark_investment_ret/investment_value)*100)<br/>print(cl('Benchmark profit by investing $100k : {}'.format(total_benchmark_investment_ret), attrs = ['bold']))<br/>print(cl('Benchmark Profit percentage : {}%'.format(benchmark_profit_percentage), attrs = ['bold']))<br/>print(cl('KST Strategy profit is {}% higher than the Benchmark Profit'.format(profit_percentage - benchmark_profit_percentage), attrs = ['bold']))</span></pre></div></div>    
</body>
</html>