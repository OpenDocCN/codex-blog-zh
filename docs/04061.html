<html>
<head>
<title>Swift + C: Callback Interoperability</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift + C:回调互操作性</h1>
<blockquote>原文：<a href="https://medium.com/codex/swift-c-callback-interoperability-6d57da6c8ee6?source=collection_archive---------6-----------------------#2021-10-22">https://medium.com/codex/swift-c-callback-interoperability-6d57da6c8ee6?source=collection_archive---------6-----------------------#2021-10-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/e28b07e28f184ce936bf335dbabfe26e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SlihR_sTH3TTj0SZgbsnhA.png"/></div></div></figure><h1 id="3955" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">背景</h1><p id="acc0" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">编程语言中一个非常常见的模式是使用回调函数。回调函数是对作为参数传递给其他代码的可执行代码的引用，允许它在以后执行。</p><p id="bdef" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">在swift中，我们经常遇到这种模式。一个特别常见的例子就是<code class="du kr ks kt ku b">URLSession.dataTask(with:completionHandler:)</code>。发出请求后，网络可能需要一些时间来响应。与其无所事事地等待，我们可以给出一个在收到响应时执行的完成处理程序，同时允许应用程序继续运行。</p><p id="34c2" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">我们在C语言中看到这种模式的一个地方是与Swift打包在一起的<code class="du kr ks kt ku b">SQLite3</code>框架。<code class="du kr ks kt ku b">SQLite3</code>促进了结构化查询语言数据库的访问和操作，并且是支持<code class="du kr ks kt ku b">CoreData</code>的底层技术。</p><p id="0136" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">由于数据库需要时间来搜索或修改，<code class="du kr ks kt ku b">SQLite3</code>提供了一个C风格的回调函数<code class="du kr ks kt ku b">sqlite3_exec</code>。当该函数被桥接到Swift时，将应用<code class="du kr ks kt ku b">@convention(c)</code>注释。该注释表示回调将在C上下文中使用，并且必须遵循一定的标准。其中一个标准是函数不能捕获任何数据。这就产生了一个问题，因为我们可能希望将回调参数传递给回调之外的其他对象——我们可能希望将数据库信息传递给视图层示例。</p><h1 id="f867" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">解决办法</h1><p id="c478" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">许多C APIs解决这个限制的一种方法是传递一个额外的上下文参数。除了稍后返回的参数之外，这还允许将对某个对象的引用传递给回调。然后我们可以将其他参数传递给对象，这样它们就可以被传递到回调范围之外。</p><p id="f2bb" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">假设以下设置:</p><figure class="kv kw kx ky fd ij"><div class="bz dy l di"><div class="kz la l"/></div><figcaption class="lb lc et er es ld le bd b be z dx translated">为了简洁起见，传递给<code class="du kr ks kt ku b">sqlite3_exec</code>的大多数变量都保留为零。</figcaption></figure><p id="360a" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">这里我们可以看到<code class="du kr ks kt ku b">Callback</code> typealias用前面提到的<code class="du kr ks kt ku b">@convention(c)</code>标注进行了标记。如果我们修改代码来捕获<code class="du kr ks kt ku b">callback</code>范围内的对象，我们会看到以下错误:</p><figure class="kv kw kx ky fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lf"><img src="../Images/1c3ce8982c2726e49094c372fd1fc6e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Mufv23dAgKjD2GpY_l2dTg.png"/></div></div><figcaption class="lb lc et er es ld le bd b be z dx translated">C函数指针不能由捕获上下文的闭包形成</figcaption></figure><p id="a3e1" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">解决这个问题的方法是将我们的对象作为上下文参数传递，如下所示:</p><figure class="kv kw kx ky fd ij"><div class="bz dy l di"><div class="kz la l"/></div></figure><p id="2a7b" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">这里我们创建了一个<code class="du kr ks kt ku b">Unmanaged</code>对象，我们希望手动管理它的生命周期。我们将它转换成一个<code class="du kr ks kt ku b">UnsafeMutableRawPointer</code>，这样它就可以作为上下文数据传入<code class="du kr ks kt ku b">sqlite3_exec</code>。然后，上下文数据被传递到我们的回调函数中，在回调函数中，数据可以被转换回我们的<code class="du kr ks kt ku b">Object</code>类型，以备使用。</p><p id="04e0" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><code class="du kr ks kt ku b">passRetained</code>创建一个引用，使对象无限期地保持活动，直到<code class="du kr ks kt ku b">takeRetainedValue</code>被调用。此时，保持器被消耗，对象可以被释放。如果保证对象在回调执行时仍然是活动的，那么可以使用<code class="du kr ks kt ku b">passUnretained</code>和<code class="du kr ks kt ku b">takeUnretainedValue</code>，但是要注意，如果对象超出了作用域，这将导致崩溃，非常类似于<code class="du kr ks kt ku b">unowned</code>变量的工作方式。</p><h1 id="1e9d" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">奖励材料</h1><p id="96a0" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">理想情况下，我们希望扩展这种模式，这样我们就不依赖任何一个对象来处理C API的响应。实现这一点的一种方法是传递一个快速闭包作为上下文参数。以下回购为感兴趣的人提供了一个这种模式的示例:</p><div class="lg lh ez fb li lj"><a href="https://github.com/oconnelltoby/Adder/blob/master/Sources/Adder/Adder.swift" rel="noopener  ugc nofollow" target="_blank"><div class="lk ab dw"><div class="ll ab lm cl cj ln"><h2 class="bd hj fi z dy lo ea eb lp ed ef hh bi translated">加法器/加法器.斯威夫特在主奥康纳托比/加法器</h2><div class="lq l"><h3 class="bd b fi z dy lo ea eb lp ed ef dx translated">一个通过C头文件将c++对象桥接到Swift的人为例子。-加法器/加法器.斯威夫特在主奥康纳托比/加法器</h3></div><div class="lr l"><p class="bd b fp z dy lo ea eb lp ed ef dx translated">github.com</p></div></div><div class="ls l"><div class="lt l lu lv lw ls lx io lj"/></div></div></a></div></div></div>    
</body>
</html>