<html>
<head>
<title>React Hack: Persisting Data w/ LocalStorage</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React Hack:使用本地存储保存数据</h1>
<blockquote>原文：<a href="https://medium.com/codex/react-hack-persisting-data-w-localstorage-237d02efc5e9?source=collection_archive---------10-----------------------#2021-08-23">https://medium.com/codex/react-hack-persisting-data-w-localstorage-237d02efc5e9?source=collection_archive---------10-----------------------#2021-08-23</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="0ed4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">今天我要告诉你一个超级简单的技巧，它将有助于改善你的应用程序用户体验，以及你的开发体验…</p><p id="5862" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">很可能大多数人都有过使用应用程序的经历，无论他们是意外刷新，还是因为连接中断而导致刷新，他们都会丢失刚刚查看或输入的数据。很可能大多数React开发人员都遇到过这样的情况(或大量情况),他们在用户测试某个应用程序状态时，由于热重新加载或浏览器刷新而损失了几分钟时间。</p><p id="4aea" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">仅使用两个简单的useEffect挂钩(或componentDidMount生命周期方法)，我们实际上可以将应用程序状态存储在LocalStorage中，并在刷新时将其重新加载到应用程序中。这个简单的任务将使您不必重复相同的用户输入100次来测试结果…并且还将使用户可以刷新他们的浏览器而不会丢失他们最近的输入。</p><p id="0bd3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最棒的是它真的很简单；它所需要的只是一个组件上的2个useEffect钩子；一个从LocalStorage获取数据并将其设置为state，另一个将状态推入LocalStorage。</p><p id="4898" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是它的工作原理——这两个useEffect挂钩的顺序很重要。</p><p id="cbe5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">假设我们正在构建一个抽认卡应用程序，用户可以在其中创建卡片组，并在这些卡片组中创建卡片。在应用程序本身中，卡片组通过一个useState钩子存储，其中数据存储为user deck，更新user deck的函数是setUserDecks。在这个例子中，应用程序用一个名为initialDecks的变量初始化。</p><ol class=""><li id="dac2" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">第一个useEffect钩子将从LocalStorage中检索userDecks数据:</li></ol><figure class="jn jo jp jq fd jr er es paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="er es jm"><img src="../Images/94445c1fa1c2acc951070422d7d2dc42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DYfOvCXnjPpq2_VP7HzGTg.png"/></div></div></figure><p id="023b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2.第二个useEffect钩子将把userDecks状态推入LocalStorage:</p><figure class="jn jo jp jq fd jr er es paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="er es jy"><img src="../Images/d8f7976afb06759344af52e68b0a9c00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o5M7pjn1KHhh9K1TwoyVQA.png"/></div></div></figure><p id="0540" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里要注意一些事情:当设置或从LocalStorage中检索时，我们使用一个字符串样式变量，在这个例子中“deck-list”是我们将状态推入LocalStorage的方式，因此我们也需要使用这个相同的变量从LocalStorage中拉出…并且我们还必须在将它推入LocalStorage时使用JSON.stringify(data ),因此我们必须在将它拉出LocalStorage时使用JSON.parse(data ),并将其设置为我们的应用程序状态。这个例子看起来很简单，但是功能齐全。应用程序现在存储用户面板状态，并自动存储用户所做的任何更改。如果您刷新页面，甚至关闭选项卡并重新打开它，状态会保持不变。这意味着用户现在可以创建卡片组，并在这些卡片组中创建卡片…然后离开应用程序，稍后再回来查看相同的数据！这真的是一个神奇的工具，而且实现起来非常简单。</p><p id="4668" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">解决一个主要问题:这不应该取代后端..显然，利用后端是最佳实践，这样用户可以在不同的设备上登录和退出您的应用程序，并查看与该用户相关的数据，而不仅仅是他们设备上的会话。但是，这确实为优化您的应用程序提供了可能性，并且通过将应用程序状态存储在LocalStorage中并向后端发送更多数据以便一次保存，减少了对后端的保存调用。</p><p id="46ed" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">干杯，我希望你喜欢这个反应黑客..我很快会回来的！</p></div></div>    
</body>
</html>