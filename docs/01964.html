<html>
<head>
<title>Introduction to Kotlin for Java developers — Part 1 : functions and operators</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向Java开发人员的Kotlin简介—第1部分:函数和运算符</h1>
<blockquote>原文：<a href="https://medium.com/codex/things-to-love-in-kotlin-coming-from-java-8-part-1-functions-and-operators-40aea17c8854?source=collection_archive---------13-----------------------#2021-06-18">https://medium.com/codex/things-to-love-in-kotlin-coming-from-java-8-part-1-functions-and-operators-40aea17c8854?source=collection_archive---------13-----------------------#2021-06-18</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es im"><img src="../Images/107a6ff9dc060566d1616bd0ef461647.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*DfLGrK1wFUWhgOvX.png"/></div></div></figure></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><p id="7553" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">在本系列的第一部分中，我将带您参观Kotlin中的函数和操作符。我将概述它们在哪些方面与Java不同。我希望你喜欢读这篇文章，就像我喜欢写它一样！如果你做到了，别忘了鼓掌:-)</p><p id="fba1" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">本系列的其他部分:</p><ul class=""><li id="0751" class="jw jx hi ja b jb jc jf jg jj jy jn jz jr ka jv kb kc kd ke bi translated">面向Java开发人员的Kotlin简介—第2部分:类和对象</li><li id="0a79" class="jw jx hi ja b jb kg jf kh jj ki jn kj jr kk jv kb kc kd ke bi translated"><a class="ae kf" rel="noopener" href="/codex/introduction-to-kotlin-for-java-developers-part-3-generics-21e1646ec2ae">面向Java开发人员的Kotlin介绍—第3部分:泛型</a></li></ul></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><p id="6df3" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">Java创建于26年前的1995年。第8版于2014年发布，至今仍是使用最广泛的版本。它主要介绍了lambda表达式、流API和一个新的日期/时间API。在我看来，从那时起，就没有推出真正的杀手级功能。迁移到新版本的痛苦大于好处，大多数人坚持了下来。</p><p id="9808" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">Kotlin是10年前由Jetbrains在2011年创建的。像Java一样，它编译成在JVM上运行的字节码(尽管它也可以转换成Javascript或编译成本机代码)。它被设计成100%与Java互操作，这意味着可以从Kotlin调用Java代码，反之亦然。自2017年以来，它被谷歌官方支持为Android语言，80%的顶级应用程序都在使用它。</p></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><h1 id="6ac6" class="kl km hi bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">1.功能</h1><p id="8988" class="pw-post-body-paragraph iy iz hi ja b jb lj jd je jf lk jh ji jj ll jl jm jn lm jp jq jr ln jt ju jv hb bi translated">Kotlin函数可以在文件的顶层声明，这意味着您不需要创建一个类来保存函数，而在Java中您需要这样做。</p><p id="edfe" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">用fun关键字声明的函数可以是命名的，也可以是匿名的。它们必须声明它们的返回类型(为了可读性，并且因为它们的主体可以包含复杂的控制流，使得编译器很难或者不可能推断出返回类型)。它们必须使用return关键字返回值(与lambda表达式相反——稍后将详细介绍)。</p><p id="64db" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">示例:</p><figure class="in io ip iq fd ir"><div class="bz dy l di"><div class="lo lp l"/></div></figure><p id="047a" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">与Java函数相比，Kotlin函数有许多与众不同的特性。请继续阅读，寻找答案。</p><p id="0089" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated"><a class="ae kf" href="https://kotlinlang.org/docs/functions.html" rel="noopener ugc nofollow" target="_blank">科特林文档</a></p><h2 id="40e4" class="lq km hi bd kn lr ls lt kr lu lv lw kv jj lx ly kz jn lz ma ld jr mb mc lh md bi translated">1.1默认参数</h2><p id="d960" class="pw-post-body-paragraph iy iz hi ja b jb lj jd je jf lk jh ji jj ll jl jm jn lm jp jq jr ln jt ju jv hb bi translated">函数参数可能有默认值，因此与Java相比减少了重载次数:</p><figure class="in io ip iq fd ir"><div class="bz dy l di"><div class="lo lp l"/></div></figure><p id="22b6" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated"><a class="ae kf" href="https://kotlinlang.org/docs/functions.html#default-arguments" rel="noopener ugc nofollow" target="_blank">科特林文档</a></p><h2 id="5900" class="lq km hi bd kn lr ls lt kr lu lv lw kv jj lx ly kz jn lz ma ld jr mb mc lh md bi translated">1.2命名参数</h2><p id="cf64" class="pw-post-body-paragraph iy iz hi ja b jb lj jd je jf lk jh ji jj ll jl jm jn lm jp jq jr ln jt ju jv hb bi translated">当调用一个函数时，可以命名它的一个或多个参数。当函数有大量参数时，这可能很有帮助。它也可以与构造函数一起使用，因此在许多情况下，定义繁琐的构造函数来维护构造函数变得没有必要。</p><figure class="in io ip iq fd ir"><div class="bz dy l di"><div class="lo lp l"/></div></figure><p id="8a50" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated"><a class="ae kf" href="https://kotlinlang.org/docs/functions.html#named-arguments" rel="noopener ugc nofollow" target="_blank">科特林文档</a></p><h2 id="3d10" class="lq km hi bd kn lr ls lt kr lu lv lw kv jj lx ly kz jn lz ma ld jr mb mc lh md bi translated">1.3接收器的功能</h2><p id="d773" class="pw-post-body-paragraph iy iz hi ja b jb lj jd je jf lk jh ji jj ll jl jm jn lm jp jq jr ln jt ju jv hb bi translated">带有接收方的函数是可以在类型A的对象上调用的函数，就像类型A的常规成员函数一样，尽管它不是类型A的一部分。</p><p id="99d6" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated"><strong class="ja hj"> 1.3.1扩展功能</strong></p><p id="655d" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">Kotlin中的扩展函数是带有接收器的函数，它提供了在现有类上移植新功能的能力，而不用以任何方式修改它。</p><p id="267f" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">扩展函数类似于常规函数，只是被扩展的类型(称为接收器类型)必须作为前缀添加到函数名中，后面跟一个点。在扩展函数的主体中，调用该函数的对象是可用的<code class="du me mf mg mh b">this</code>。</p><p id="961c" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">下面是一个向类型<code class="du me mf mg mh b">MutableList&lt;Int&gt;</code>添加交换成员函数的例子:</p><figure class="in io ip iq fd ir"><div class="bz dy l di"><div class="lo lp l"/></div></figure><p id="8aa1" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">扩展函数对于向第三方库的类中添加新成员很有用。这实际上是Kotlin本身如何将自己的附加特性添加到常规JDK集合类型中的。下面是Kotlin在ArrayList上定义的扩展函数的<a class="ae kf" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-array-list/#extension-functions" rel="noopener ugc nofollow" target="_blank">列表。</a></p><p id="fa46" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated"><a class="ae kf" href="https://kotlinlang.org/docs/extensions.html" rel="noopener ugc nofollow" target="_blank">科特林文档</a></p><p id="fb34" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated"><strong class="ja hj"> 1.3.2带接收方的函数字面量</strong></p><p id="6f3b" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">Lambdas和匿名函数也可以用来定义带有接收方的函数。稍后会详细介绍。</p><p id="6081" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated"><a class="ae kf" href="https://kotlinlang.org/docs/lambdas.html#function-literals-with-receiver" rel="noopener ugc nofollow" target="_blank">科特林文档</a></p><h2 id="bf3f" class="lq km hi bd kn lr ls lt kr lu lv lw kv jj lx ly kz jn lz ma ld jr mb mc lh md bi translated">1.4中缀函数</h2><p id="4ff9" class="pw-post-body-paragraph iy iz hi ja b jb lj jd je jf lk jh ji jj ll jl jm jn lm jp jq jr ln jt ju jv hb bi translated">带有单个参数的扩展函数或成员函数可以用关键字<code class="du me mf mg mh b">infix</code>标记，这样就可以在函数调用中去掉点号和括号。</p><p id="ad3a" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">下面是一个例子:从两个值创建一对的<a class="ae kf" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/to.html" rel="noopener ugc nofollow" target="_blank">到</a>扩展函数。</p><figure class="in io ip iq fd ir"><div class="bz dy l di"><div class="lo lp l"/></div></figure><p id="508b" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">例如，它可用于初始化地图，如下所示:</p><figure class="in io ip iq fd ir"><div class="bz dy l di"><div class="lo lp l"/></div></figure><p id="1b70" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated"><a class="ae kf" href="https://kotlinlang.org/docs/functions.html#infix-notation" rel="noopener ugc nofollow" target="_blank">科特林文档</a></p><h1 id="9fb5" class="kl km hi bd kn ko mi kq kr ks mj ku kv kw mk ky kz la ml lc ld le mm lg lh li bi translated">2.λ表达式</h1><p id="8594" class="pw-post-body-paragraph iy iz hi ja b jb lj jd je jf lk jh ji jj ll jl jm jn lm jp jq jr ln jt ju jv hb bi translated">Lambda表达式是只用花括号声明的函数(没有有趣的关键字)。它们不能使用return关键字，它们只是对最后一个表达式求值，因此编译器总是可以推断出返回类型(假设参数类型是声明的或者可以从上下文中推断出来)。事实上，没有声明返回类型的语法。</p><p id="3923" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">示例:</p><figure class="in io ip iq fd ir"><div class="bz dy l di"><div class="lo lp l"/></div></figure><p id="6ea7" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated"><a class="ae kf" href="https://kotlinlang.org/docs/lambdas.html" rel="noopener ugc nofollow" target="_blank">科特林文档</a></p><h2 id="fc68" class="lq km hi bd kn lr ls lt kr lu lv lw kv jj lx ly kz jn lz ma ld jr mb mc lh md bi translated">2.1单参数λ</h2><p id="84e3" class="pw-post-body-paragraph iy iz hi ja b jb lj jd je jf lk jh ji jj ll jl jm jn lm jp jq jr ln jt ju jv hb bi translated">如果一个lambda只有一个参数，允许不声明它并省略<code class="du me mf mg mh b">-&gt;</code>。该参数将以名称<code class="du me mf mg mh b">it</code>隐式声明。</p><figure class="in io ip iq fd ir"><div class="bz dy l di"><div class="lo lp l"/></div></figure><p id="9779" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated"><a class="ae kf" href="https://kotlinlang.org/docs/lambdas.html#it-implicit-name-of-a-single-parameter" rel="noopener ugc nofollow" target="_blank">科特林文档</a></p><h2 id="3c87" class="lq km hi bd kn lr ls lt kr lu lv lw kv jj lx ly kz jn lz ma ld jr mb mc lh md bi translated">2.2拖尾lambdas</h2><p id="d55a" class="pw-post-body-paragraph iy iz hi ja b jb lj jd je jf lk jh ji jj ll jl jm jn lm jp jq jr ln jt ju jv hb bi translated">在Kotlin中，如果函数的最后一个参数是函数，那么作为相应参数传递的lambda表达式可以放在括号外。此外，如果lambda是唯一的参数，括号可以完全省略。</p><p id="11bb" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">下面是一个使用<a class="ae kf" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/let.html" rel="noopener ugc nofollow" target="_blank"> let </a>扩展函数的例子，它可以用来调用一个或多个函数来处理调用链的结果，避免了声明变量的需要:</p><figure class="in io ip iq fd ir"><div class="bz dy l di"><div class="lo lp l"/></div></figure><p id="55de" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">这种写作风格有以下优点:</p><ul class=""><li id="3f70" class="jw jx hi ja b jb jc jf jg jj jy jn jz jr ka jv kb kc kd ke bi translated">它避免了在离调用点很远的地方用括号结束函数调用</li><li id="8252" class="jw jx hi ja b jb kg jf kh jj ki jn kj jr kk jv kb kc kd ke bi translated">嵌套的lambdas可以像嵌套的代码块一样格式化</li><li id="ca70" class="jw jx hi ja b jb kg jf kh jj ki jn kj jr kk jv kb kc kd ke bi translated">库可以像Java的try一样用资源定义语言结构作为常规函数</li></ul><p id="4b17" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">这一点，再加上操作符重载和带有接收器的函数，使得Kotlin在创建类型安全DSL时非常优雅，就像这个<a class="ae kf" href="https://kotlinlang.org/docs/typesafe-html-dsl.html" rel="noopener ugc nofollow" target="_blank"> HTML DSL </a>:</p><figure class="in io ip iq fd ir"><div class="bz dy l di"><div class="lo lp l"/></div></figure><p id="e0c1" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated"><a class="ae kf" href="https://kotlinlang.org/docs/lambdas.html#passing-trailing-lambdas" rel="noopener ugc nofollow" target="_blank">科特林文档</a></p><h2 id="6941" class="lq km hi bd kn lr ls lt kr lu lv lw kv jj lx ly kz jn lz ma ld jr mb mc lh md bi translated">2.3带接收器的Lambdas</h2><p id="13d5" class="pw-post-body-paragraph iy iz hi ja b jb lj jd je jf lk jh ji jj ll jl jm jn lm jp jq jr ln jt ju jv hb bi translated">匿名函数和lambda表达式可以用来定义带有接收方的函数，就像常规函数一样，类似地，在这些函数的主体中，调用函数的对象变成了隐式的<code class="du me mf mg mh b">this</code>。</p><p id="25bb" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">下面是一个带有功能的<a class="ae kf" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/with.html" rel="noopener ugc nofollow" target="_blank">的例子:</a></p><figure class="in io ip iq fd ir"><div class="bz dy l di"><div class="lo lp l"/></div></figure><p id="00d6" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">使用<code class="du me mf mg mh b">with</code>将<code class="du me mf mg mh b">myTurtle</code>设置为下一个代码块中的<code class="du me mf mg mh b">this</code>，从而允许在同一个对象上调用多个函数，而无需重复变量名。</p><p id="8eb3" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated"><a class="ae kf" href="https://kotlinlang.org/docs/lambdas.html#function-literals-with-receiver" rel="noopener ugc nofollow" target="_blank">科特林文档</a></p><h1 id="d731" class="kl km hi bd kn ko mi kq kr ks mj ku kv kw mk ky kz la ml lc ld le mm lg lh li bi translated">3.关闭</h1><p id="768f" class="pw-post-body-paragraph iy iz hi ja b jb lj jd je jf lk jh ji jj ll jl jm jn lm jp jq jr ln jt ju jv hb bi translated">闭包是一个函数、匿名函数或lambda，它引用在其主体外部定义的变量。</p><p id="9924" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">这样的事情是可能的，因为闭包保存了对创建它的堆栈框架的引用。并且该堆栈框架属于一个函数，该函数本身保存了对它被创建到的堆栈框架的引用，以此类推，创建了一个称为“作用域链”的堆栈框架链(只有当不再有闭包引用它时，堆栈框架才会被释放)。</p><p id="05f6" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">这允许有趣的模式，比如<a class="ae kf" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures#emulating_private_methods_with_closures" rel="noopener ugc nofollow" target="_blank">用私有成员和函数模拟没有内置该特性的语言中的类</a>。</p><p id="6fc5" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">Java 8有闭包……算是吧。Java的主要限制是在闭包中访问的外部作用域的变量必须是final或者实际上是final。在Kotlin中，这个限制被取消了，闭包可以通过作用域链改变任何可用的变量。</p><p id="21a8" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">这里有一个例子:</p><figure class="in io ip iq fd ir"><div class="bz dy l di"><div class="lo lp l"/></div></figure><p id="0b1a" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">还有一个:</p><figure class="in io ip iq fd ir"><div class="bz dy l di"><div class="lo lp l"/></div></figure><p id="5ed6" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated"><a class="ae kf" href="https://kotlinlang.org/docs/lambdas.html#closures" rel="noopener ugc nofollow" target="_blank">科特林文档</a></p><h1 id="7b56" class="kl km hi bd kn ko mi kq kr ks mj ku kv kw mk ky kz la ml lc ld le mm lg lh li bi translated">4.内嵌函数</h1><p id="6147" class="pw-post-body-paragraph iy iz hi ja b jb lj jd je jf lk jh ji jj ll jl jm jn lm jp jq jr ln jt ju jv hb bi translated">在Kotlin中，函数可以标记为inline。这类函数的行为类似于C宏，函数体是内联的，任何作为参数传递的lambda也是内联的。这消除了函数调用的成本和分配lambda对象及其相应闭包的成本。</p><p id="0da4" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">例如，<a class="ae kf" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/for-each.html" rel="noopener ugc nofollow" target="_blank"> forEach </a>是一个内联函数。</p><p id="5b58" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">当函数及其lambda参数被内联时，lambda表达式中允许return，并且return是非局部的。对return的调用涉及最近的封闭函数(即用fun定义的函数)。例如:</p><figure class="in io ip iq fd ir"><div class="bz dy l di"><div class="lo lp l"/></div></figure><p id="9671" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">暂时不支持“中断并继续”,但将来会支持。</p><p id="1105" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated"><a class="ae kf" href="https://kotlinlang.org/docs/inline-functions.html" rel="noopener ugc nofollow" target="_blank">科特林文档</a></p><h1 id="1bba" class="kl km hi bd kn ko mi kq kr ks mj ku kv kw mk ky kz la ml lc ld le mm lg lh li bi translated">5.运算符重载</h1><p id="3796" class="pw-post-body-paragraph iy iz hi ja b jb lj jd je jf lk jh ji jj ll jl jm jn lm jp jq jr ln jt ju jv hb bi translated">Kotlin允许您为t类型上的一组预定义操作符提供自定义实现。这些操作符中的每一个都对应于一个您必须实现的特殊函数名(作为成员函数或作为扩展函数),并在t类型上用<code class="du me mf mg mh b">operator</code>关键字进行标记。操作符可以是一元的，也可以是二元的。</p><p id="adb5" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated"><a class="ae kf" href="https://kotlinlang.org/docs/operator-overloading.html" rel="noopener ugc nofollow" target="_blank">科特林文档</a></p><h2 id="7e17" class="lq km hi bd kn lr ls lt kr lu lv lw kv jj lx ly kz jn lz ma ld jr mb mc lh md bi translated">5.1一元运算符</h2><p id="f098" class="pw-post-body-paragraph iy iz hi ja b jb lj jd je jf lk jh ji jj ll jl jm jn lm jp jq jr ln jt ju jv hb bi translated">一元运算符例子有<code class="du me mf mg mh b">-a</code>(函数名<code class="du me mf mg mh b">unaryMinus</code>)、<code class="du me mf mg mh b">a++</code>(函数名<code class="du me mf mg mh b">inc</code>)和<code class="du me mf mg mh b">a()</code>(函数名<code class="du me mf mg mh b">invoke</code>)。</p><p id="7aa6" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">示例:</p><figure class="in io ip iq fd ir"><div class="bz dy l di"><div class="lo lp l"/></div></figure><p id="d44e" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated"><a class="ae kf" href="https://kotlinlang.org/docs/operator-overloading.html#unary-operations" rel="noopener ugc nofollow" target="_blank">科特林文档</a></p><h2 id="cf29" class="lq km hi bd kn lr ls lt kr lu lv lw kv jj lx ly kz jn lz ma ld jr mb mc lh md bi translated">5.2二元运算符</h2><p id="a8fb" class="pw-post-body-paragraph iy iz hi ja b jb lj jd je jf lk jh ji jj ll jl jm jn lm jp jq jr ln jt ju jv hb bi translated">二元运算符的例子有<code class="du me mf mg mh b">a + b</code>(函数名<code class="du me mf mg mh b">plus</code>)、<code class="du me mf mg mh b">a in b</code>(函数名<code class="du me mf mg mh b">contains</code>)、<code class="du me mf mg mh b">a[i]</code>(函数名<code class="du me mf mg mh b">get</code>)。</p><p id="579e" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">示例:</p><figure class="in io ip iq fd ir"><div class="bz dy l di"><div class="lo lp l"/></div></figure><p id="84d3" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated"><a class="ae kf" href="https://kotlinlang.org/docs/operator-overloading.html#binary-operations" rel="noopener ugc nofollow" target="_blank">科特林文档</a></p><h1 id="ff76" class="kl km hi bd kn ko mi kq kr ks mj ku kv kw mk ky kz la ml lc ld le mm lg lh li bi translated">资源</h1><p id="c004" class="pw-post-body-paragraph iy iz hi ja b jb lj jd je jf lk jh ji jj ll jl jm jn lm jp jq jr ln jt ju jv hb bi translated"><a class="ae kf" href="https://kotlinlang.org/docs/home.html" rel="noopener ugc nofollow" target="_blank">科特林文档</a></p><p id="8ca1" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated"><a class="ae kf" href="https://play.kotlinlang.org/" rel="noopener ugc nofollow" target="_blank">科特林游乐场</a></p><p id="4f9d" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">科特林·考恩斯</p></div></div>    
</body>
</html>