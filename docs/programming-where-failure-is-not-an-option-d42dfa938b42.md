# 不允许失败的编程

> 原文：<https://medium.com/codex/programming-where-failure-is-not-an-option-d42dfa938b42?source=collection_archive---------15----------------------->

![](img/1dda86a13571512cfda24de5d3bb8514.png)

从[PublicDomainPictures.net](https://www.publicdomainpictures.net/en/view-image.php?image=212678&picture=space-shuttle-launch)。

当大多数程序员听到“失败不是选项”的系统时，他们会想到航天飞机或自动驾驶汽车。我对航天飞机一无所知，但我怀疑人们*真正*的意思是，航天飞机软件尽最大努力不导致死亡([和“非常最好”有非常强的“非常”](https://www.fastcompany.com/28121/they-write-right-stuff))。

我不是航天飞机程序员，我是一个低级的 Flash 开发人员，所以我只为充满安全漏洞的虚拟机软件编写 IL。虽然从统计上看，也许我在编程方面比航天飞机程序员“更好”,因为到目前为止我的代码死亡率为 0%。

在我的领域中，数学库最有可能被称为不会失败的系统。在游戏中，数学库不可能失败——当然，除了当它们失败的时候:比如当你要求它们成功地被零除或者在没有[万向锁](https://en.wikipedia.org/wiki/Gimbal_lock)的情况下 slerp 欧拉旋转。戴上我们的元分析帽子一会儿，我们意识到，只有当我们接受错误地使用它们是正确的用法时，这些东西才能被认为是“失败”。

这就是这辆“失败不是一个选项”的火车开始出轨的地方(它是一辆火车)，因为事实证明，错误地使用东西是一件非常人性的事情。给我一个系统，我保证我可以错误地使用它。编写一个系统，唯一可以确定的是别人会以不同于你预期的方式使用它。而且，公平地说，宇宙似乎也在这样做，这就是为什么我们发明了 [ECC RAM](https://en.wikipedia.org/wiki/ECC_memory) 以便那些该死的宇宙射线不会影响我们的 PUBG 鸡肉晚餐。因此，当我们写作时，我们必须长时间努力思考我们正在写作的系统的各种失败和我们正在消费的系统的失败。

“核心系统不能失败”——你知道，就像 I/O 一样。这是任何内核的核心要求。非常奇怪的是，S3 跨 AZs 复制数据，或者说，任何 I/O 接口的正确用法都是在捕捉弹出的错误时尝试写入数据。

这里的教训是，不要试图编写不会失败的软件，我们通常应该在明确定义失败的地方编写软件。我不确定这是“越差越好”的结果还是升华。一开始就说出来:不要让使用你的代码的开发人员拿着魔杖站在某个领域的中间，试图猜测失败案例在哪里或者失败是什么——出于对魔杖的热爱，不要否认失败的存在。

![](img/993887c5df59a6d7dd4aba3a9ead786c.png)

塞斯·梅耶斯，1942 年寻找水源| [美国地质调查局](https://www.usgs.gov/media/images/water-dowsing-1942)

许多人现在可能认为我在推荐编写垃圾代码。我们如何平衡编写“[好的简单系统](/codex/take-the-time-to-write-less-code-1bf0ab385a38)”与它们可能因为错误或误用或者可能(在其他选项中)[高能质子和原子核](https://en.wikipedia.org/wiki/Cosmic_ray)而失败的事实？

我最近在楼上的浴室里贴了一些壁纸。关于悬挂墙纸的事情是，墙纸的布局可能与你的墙壁不同。不幸的是，这是[等距图](https://en.wikipedia.org/wiki/Isometry)的一个数学事实(至少对于“无弹性”壁纸来说)。结果是你到处都有皱纹。那你怎么处理这些皱纹呢？首先，你不能忽视他们。然后你把它们组合在一起，形成更大的皱纹，然后你把它们移到一个皱纹不那么重要的地方——比如在梳妆台后面，或者在电灯开关下面。

这就是我们应该如何创作软件系统。

不要冲压出许多小的失败案例，在我们的墙纸上凿洞——试着围绕大的失败案例定位系统设计，把小的失败案例抖出来。然后，不是修复它们，而是记录它们。有时候(不要恨我)，文档*是*的补丁。

这是系统设计的壁纸方法。