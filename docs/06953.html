<html>
<head>
<title>Practice: Using K-Nearest Neighbors on Breast Cancer Data</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">实践:在乳腺癌数据中使用K-最近邻</h1>
<blockquote>原文：<a href="https://medium.com/codex/practice-using-k-nearest-neighbors-on-breast-cancer-data-2c8b9e0ed151?source=collection_archive---------12-----------------------#2022-05-21">https://medium.com/codex/practice-using-k-nearest-neighbors-on-breast-cancer-data-2c8b9e0ed151?source=collection_archive---------12-----------------------#2022-05-21</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="cb46" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">Sentdex教程笔记</h2></div><p id="fec5" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">下面是YouTube上的教程链接:</p><figure class="jt ju jv jw fd jx"><div class="bz dy l di"><div class="jy jz l"/></div></figure><p id="600e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">或者，如果您喜欢更多基于文本的教程，请访问以下网页:</p><div class="ka kb ez fb kc kd"><a href="https://pythonprogramming.net/k-nearest-neighbors-application-machine-learning-tutorial/" rel="noopener  ugc nofollow" target="_blank"><div class="ke ab dw"><div class="kf ab kg cl cj kh"><h2 class="bd hj fi z dy ki ea eb kj ed ef hh bi translated">Python编程教程</h2><div class="kk l"><h3 class="bd b fi z dy ki ea eb kj ed ef dx translated">欢迎来到Python机器学习教程系列的第14部分。在上一部分中，我们介绍了…</h3></div><div class="kl l"><p class="bd b fp z dy ki ea eb kj ed ef dx translated">pythonprogramming.net</p></div></div><div class="km l"><div class="kn l ko kp kq km kr ks kd"/></div></div></a></div><p id="9511" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果你有兴趣学习Python中机器学习的基础知识以及如何使用scikit-learn，我鼓励你浏览整个播放列表。我认为Sentdex用非常容易理解的术语解释了一切，这足以让我了解每个算法的要点。</p><p id="d28f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在2022年重新看这个教程时，我发现1:1复制代码是行不通的，可能是因为这些库在教程完成后已经更新了。下面我想分享一下我对这个小项目的最新记录。我发现写这个非常有帮助，万一我需要它作为将来的参考，以及提醒我(作为一个完全的Python初学者)为什么代码是这样写的。</p><p id="e59f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">第一步:下载并浏览数据</strong></p><p id="165f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您可以从UCI机器学习知识库中获取数据，具体来说就是从以下链接中获取数据:</p><p id="3ffb" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><a class="ae kt" href="https://archive.ics.uci.edu/ml/datasets/breast%2Bcancer%2Bwisconsin%2B(original)" rel="noopener ugc nofollow" target="_blank">https://archive . ics . UCI . edu/ml/datasets/breast % 2b cancer % 2b Wisconsin % 2B(原文)</a></p><p id="cb96" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">进入“数据文件夹”，您将看到以下内容:</p><figure class="jt ju jv jw fd jx er es paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="er es ku"><img src="../Images/2e7ed6c9bd6daf280d65609ae0ac92bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3835Gk2fv7kMVqIaJaxREA.png"/></div></div></figure><p id="f81e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们需要下载“乳腺癌-威斯康辛. data”和“乳腺癌-威斯康辛. names ”,以便按照教程进行操作。的”。data”文件包含我们想要分析的实际数据表，而。names”文件包含对数据的简要描述，这将对我们了解背景非常有用。在我的例子中，我只需将扩展名改为。人名”到。txt格式和"。数据”一到CSV格式，这将使事情变得更容易。</p><p id="c6c4" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">来自数据描述文件的一些重要观察结果:</p><ul class=""><li id="cf14" class="la lb hi iz b ja jb jd je jg lc jk ld jo le js lf lg lh li bi translated">表格包含699行数据</li><li id="769c" class="la lb hi iz b ja lj jd lk jg ll jk lm jo ln js lf lg lh li bi translated">表格包含样本号、用作确定细胞是良性还是恶性的变量的属性，以及目标值本身(名为“类”)</li><li id="ae19" class="la lb hi iz b ja lj jd lk jg ll jk lm jo ln js lf lg lh li bi translated">类别分为2种类型:2为良性，4为恶性</li><li id="d926" class="la lb hi iz b ja lj jd lk jg ll jk lm jo ln js lf lg lh li bi translated">有16行存在单个缺失的属性，用“？”表示。</li><li id="3438" class="la lb hi iz b ja lj jd lk jg ll jk lm jo ln js lf lg lh li bi translated">在数据中，65.5%是良性的，而34.5%是恶性的</li></ul><p id="7bd1" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们在这里的目标是使用K-最近邻来尝试和看看我们的模型是否可以尽可能接近预测，基于可用的数据，癌细胞是良性的还是恶性的。</p><p id="e831" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">打开CSV文件，我们发现我们有全套数据，但它们没有按列区分。所以第一步就是这么做。我们知道描述中给出的列名:</p><figure class="jt ju jv jw fd jx er es paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="er es lo"><img src="../Images/6cb8ae15e69f142053391fabab7c90eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Rgf36AnM9at2NAa6jHSmnA.png"/></div></div></figure><p id="45a6" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">与本教程中一样，我们可以通过在CSV文件的第一行之上插入新的一行，并直接添加列名来手动完成。您喜欢如何命名这些列并不重要，但最终它应该类似于下面的代码片段:</p><figure class="jt ju jv jw fd jx er es paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="er es lp"><img src="../Images/373f7cabbc73a6ee24c9f930e5098ac8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fgLl5izNODcqwe-AOnaN9w.png"/></div></div><figcaption class="lq lr et er es ls lt bd b be z dx translated">我用Jupyter实验室来做这个</figcaption></figure><p id="6d40" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，我认为我们已经准备好进入Python代码了</p><p id="c7aa" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">第二步:导入库</strong></p><p id="0257" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">以下是您需要在此项目中导入的库:</p><pre class="jt ju jv jw fd lu lv lw lx aw ly bi"><span id="cbf0" class="lz ma hi lv b fi mb mc l md me">import numpy as np <br/>from sklearn.model_selection import train_test_split<br/>from sklearn import neighbors<br/>from sklearn.metrics import accuracy_score<br/>import pandas as pd</span></pre><ul class=""><li id="af21" class="la lb hi iz b ja jb jd je jg lc jk ld jo le js lf lg lh li bi translated">numpy，因为我们需要将特征和标签转换成numpy数组，然后再将它们输入KNN算法</li><li id="0567" class="la lb hi iz b ja lj jd lk jg ll jk lm jo ln js lf lg lh li bi translated">train_test_split将数据集拆分为训练和测试数据集。</li><li id="2359" class="la lb hi iz b ja lj jd lk jg ll jk lm jo ln js lf lg lh li bi translated">邻居使用KNN的训练数据，这些数据最终将被用来做出预测</li><li id="7cd9" class="la lb hi iz b ja lj jd lk jg ll jk lm jo ln js lf lg lh li bi translated">accuracy_score将用于查看我们的预测与实际值的接近程度</li><li id="c34b" class="la lb hi iz b ja lj jd lk jg ll jk lm jo ln js lf lg lh li bi translated">熊猫，因为我们必须处理数据帧</li></ul><p id="e56b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">第三步:导入并清理数据</strong></p><p id="a3ff" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在我们使用pandas读取CSV文件(在这种情况下，CSV文件的位置与Python脚本的位置相同)，让我们快速了解一下DataFrame格式的数据:</p><pre class="jt ju jv jw fd lu lv lw lx aw ly bi"><span id="d804" class="lz ma hi lv b fi mb mc l md me">df = pd.read_csv("breast-cancer-wisconsin.csv")<br/>df.head()</span></pre><p id="9e3d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您应该看到类似这样的内容(获取前5行数据):</p><figure class="jt ju jv jw fd jx er es paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="er es mf"><img src="../Images/3e08ce0002e863094f66d5f22186ccfa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lYB7sJ61uM2UgjHn6mK4Jg.png"/></div></div></figure><p id="336b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">接下来，我们做一点清理工作。还记得在我们所做的观察中，有用“？”表示的缺失属性吗在数据中。我们需要删除这些，因为它可能会影响我们的算法。有两种方法可以做到这一点，要么我们可以完全删除所有16行，或者按照教程，我们可以用-99999替换它们。我们碰巧能够使用第二个，因为正如我们在属性描述中看到的，每一列(除了id和class)恰好是一个从1到10的值。这意味着我们放入的包含-99999值的行将被视为异常值，不会影响我们算法的预测。</p><pre class="jt ju jv jw fd lu lv lw lx aw ly bi"><span id="8466" class="lz ma hi lv b fi mb mc l md me">df.replace('?',-99999, inplace=True)</span></pre><p id="614a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最后，我们知道样本ID与我们算法的预测无关，因为它与我们的癌细胞是良性还是恶性没有关系。让我们也摆脱它。</p><pre class="jt ju jv jw fd lu lv lw lx aw ly bi"><span id="4760" class="lz ma hi lv b fi mb mc l md me">df.drop(columns=['id'],axis=1,inplace=True)</span></pre><p id="42b5" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">第四步:在将数据送入算法之前对其进行预处理</strong></p><p id="3b1f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，除了类(2或4)之外的任何东西都将是确定值的变量(“features”，用x表示)，而类本身将是预测的目标值(“labels”，用y表示)。我们将以numpy数组而不是DataFrame格式来分隔它们:</p><pre class="jt ju jv jw fd lu lv lw lx aw ly bi"><span id="bd78" class="lz ma hi lv b fi mb mc l md me">x = np.array(df.drop(columns=['class'], axis=1))</span><span id="ccdb" class="lz ma hi lv b fi mg mc l md me">y = np.array(df['class'])</span></pre><p id="7aa0" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在我们只需将整个数据分成两部分:一部分用于训练，另一部分用于测试。为此，我们使用之前导入的train_test_split:</p><pre class="jt ju jv jw fd lu lv lw lx aw ly bi"><span id="b143" class="lz ma hi lv b fi mb mc l md me">x_train, x_test, y_train, y_test = train_test_split(x,y,test_size = 0.2)</span></pre><p id="5c6e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">上面的代码只是意味着我们将把x和y分成训练数据和测试数据。80%的数据将用于训练KNN，20%将用于测试。总的目标是，在我们训练算法并做出预测后，我们将其与y_test进行比较，看看我们的预测与实际值有多接近，并给它打分。</p><p id="5951" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但是我想得太多了。</p><p id="6cba" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">第五步:用我们的训练数据集训练模型，进行预测并测试其准确性</strong></p><p id="20c5" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们只需要做以下事情来训练数据:</p><pre class="jt ju jv jw fd lu lv lw lx aw ly bi"><span id="2ca7" class="lz ma hi lv b fi mb mc l md me">clf = neighbors.KNeighborsClassifier()<br/>clf.fit(x_train, y_train)</span></pre><p id="c2ad" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">请记住，我们使用了x_train和y_train中存储的整个数据集的80%。</p><p id="90eb" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">既然模型已经训练好了，我们就可以尝试使用剩下的20%的数据(特别是x_test)进行预测，并将它们与我们的y_test进行比较，并给它一个接近程度的分数。完整代码如下:</p><pre class="jt ju jv jw fd lu lv lw lx aw ly bi"><span id="1cc9" class="lz ma hi lv b fi mb mc l md me">y_pred = clf.predict(x_test)</span><span id="ebdb" class="lz ma hi lv b fi mg mc l md me">accuracy = accuracy_score(y_test, y_pred)<br/>accuracy</span></pre><p id="233b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您可以看到如下结果:</p><figure class="jt ju jv jw fd jx er es paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="er es mf"><img src="../Images/eae36ea5b445886bec8b4da69dc012d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a6eBlHdeHlewgYaMX1T0GQ.png"/></div></div></figure><p id="6e7e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这仅仅意味着我们的模型与实际的y_test结果相比有95%的准确性。还不错，但肯定需要改进。但是就教程来说，这对于今天已经足够了。</p><p id="da46" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">使用该算法预测新样本</strong></p><p id="c122" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">假设我们有几个新样本，我们想用这个模型来预测它们是良性的还是恶性的。我们可以简单地将它们包含在一个numpy数组中，并将它们输入到模型中，这将为我们提供一个结果。</p><pre class="jt ju jv jw fd lu lv lw lx aw ly bi"><span id="1bf6" class="lz ma hi lv b fi mb mc l md me">example_data = np.array([[4,2,1,1,1,2,3,2,1], [8,9,9,9,10,4,9,8,1]])<br/>example_data.reshape(len(example_data), -1)</span><span id="f69f" class="lz ma hi lv b fi mg mc l md me">predictions = clf.predict(example_data)</span><span id="d375" class="lz ma hi lv b fi mg mc l md me">predictions</span></pre><p id="9536" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里每个数组有9个值，因为有11列，其中一列包含样本ID(我们不需要)，最后一列是类(我们试图找到它)。此外，numpy因为一些不赞成的警告而要求我们对数据进行整形，并告诉我们如果只有一个标签就整形为(1，-1)，如果只有一个特征就整形为(-1，1)。我们的例子肯定是前者，因为我们有2个数据集，我们将其整形为(2，-1)。</p><p id="6ffb" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们的结果如下，这意味着第一个样本是良性的，第二个样本是恶性的:</p><figure class="jt ju jv jw fd jx er es paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="er es mf"><img src="../Images/b84dad77d3728dd95807d4d866e58fb2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FSK7eIoVmCzCld3HnOePEA.png"/></div></div></figure><p id="105e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果你有兴趣浏览Sentdex的Python机器学习教程的完整播放列表，你可以点击下面的链接直接进入:</p><figure class="jt ju jv jw fd jx"><div class="bz dy l di"><div class="mh jz l"/></div></figure></div></div>    
</body>
</html>