<html>
<head>
<title>Test Driven Development : A Safety Net</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">测试驱动开发:安全网</h1>
<blockquote>原文：<a href="https://medium.com/codex/test-driven-development-27710d5edd78?source=collection_archive---------5-----------------------#2021-04-04">https://medium.com/codex/test-driven-development-27710d5edd78?source=collection_archive---------5-----------------------#2021-04-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/6af84abbb62aa3626c8cf6d8498c97d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*_VEYHIygEOHGQYcA.jpg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">图片来源:<a class="ae iu" href="http://prophage.blogspot.com/2015/07/coding-responsibly-part-iii-testing.html" rel="noopener ugc nofollow" target="_blank">prophage.blogspot.com</a></figcaption></figure><p id="5d48" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我第一次了解TDD的时候，我想，“哦，天哪。我们真的要这么做吗？为什么你要做一个注定要失败的测试？这怎么说得通？”我甚至惊讶于TDD被认为是编程中的最佳实践之一。坦白说，有相当一段时间，我确实在编写测试代码时遇到了一些麻烦。我很难理解为什么我们需要做这项额外的工作。但这些是我在意识到它塑造我写出更好的代码而不是给我增加负担之前的想法。怎么会？我们现在就开始吧！</p><blockquote class="jt ju jv"><p id="9802" class="iv iw jw ix b iy iz ja jb jc jd je jf jx jh ji jj jy jl jm jn jz jp jq jr js hb bi translated">"如果你的代码不可测试，那么它就不是一个好的设计."<em class="hi"> —迈克尔·费瑟斯</em></p></blockquote></div><div class="ab cl ka kb gp kc" role="separator"><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf"/></div><div class="hb hc hd he hf"><h1 id="fd03" class="kh ki hi bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">测试驱动开发及其规则</h1><p id="541d" class="pw-post-body-paragraph iv iw hi ix b iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo lj jq jr js hb bi translated"><strong class="ix hj">测试驱动开发</strong>是一个开发过程，它形成了一个测试代码和验证它做什么的循环。基本上，这是一个对功能进行测试的过程，测试它们，然后编写代码通过测试。简而言之，TDD的一个周期是这样的:</p><figure class="ll lm ln lo fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lk"><img src="../Images/061bbbf3b4ce0b860beb545e47d1e556.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*hb2o5MwxKxohyrCB.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">图片来源:<a class="ae iu" href="https://i.pinimg.com/originals/b9/be/51/b9be514dd54f4a058943099020284deb.png" rel="noopener ugc nofollow" target="_blank"> pinterest </a></figcaption></figure><ul class=""><li id="e603" class="lp lq hi ix b iy iz jc jd jg lr jk ls jo lt js lu lv lw lx bi translated"><strong class="ix hj">红色</strong></li></ul><p id="80d9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">首先，我们为程序中的每个小功能编写一个测试。<em class="jw">“但是我们什么都没写。有什么好考的？”我知道。这部分可能看起来有点混乱——编写一个肯定会失败的测试。但是编写这个测试可以防止您编写重复的代码或者更糟糕的不必要的代码。这是我为最后修改的组件编写代码之前的一个失败测试的例子。</em></p><figure class="ll lm ln lo fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ly"><img src="../Images/df74870c9a303684931d5acad2718ffe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1U9yeOQavzXxV5xQxD8TfA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">测试示例</figcaption></figure><figure class="ll lm ln lo fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lz"><img src="../Images/44ecf527d042bdbef39826abf227f896.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j0ZYgUDUsR1I7ROEnXhwXQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">在编写实现之前测试失败</figcaption></figure><ul class=""><li id="d0ff" class="lp lq hi ix b iy iz jc jd jg lr jk ls jo lt js lu lv lw lx bi translated"><strong class="ix hj">绿色</strong> <br/>测试失败后，我们编写一段代码，这段代码将帮助我们通过测试。在我的例子中，我需要编写一个代码来创建最后修改的组件。感谢之前的测试，我只写了几行必要的代码。</li></ul><figure class="ll lm ln lo fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ma"><img src="../Images/1a9205b118c3ced37ffc21c57cf49627.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1vdh5QJXIzN_IlbdB6dO8Q.png"/></div></div></figure><figure class="ll lm ln lo fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mb"><img src="../Images/fa6c71f2ebe3d6e0dff7d40883a3158f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xaEnlwL1dPGQXjIAJEo9LA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">编写实现后通过测试</figcaption></figure><ul class=""><li id="31e2" class="lp lq hi ix b iy iz jc jd jg lr jk ls jo lt js lu lv lw lx bi translated"><strong class="ix hj">重构<br/> </strong>通过测试后，我们可以改进我们的代码，使其更加简单有效——这一步叫做重构。应该注意的是，当你重构一个代码时，它不应该创建一个新的功能或者使修改后的代码不能通过测试。重构的唯一目的就是提高代码的质量。前一个例子中的代码足够简单，所以我不需要重构它。</li></ul><h1 id="c890" class="kh ki hi bd kj kk mc km kn ko md kq kr ks me ku kv kw mf ky kz la mg lc ld le bi translated">单元测试vs集成测试vs功能测试</h1><p id="134f" class="pw-post-body-paragraph iv iw hi ix b iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo lj jq jr js hb bi translated">有三种类型的测试，没有一种比其他的更重要。每一个都有一个重要的角色，可以帮助开发人员和测试人员创建更高级的测试。</p><figure class="ll lm ln lo fd ij er es paragraph-image"><div class="er es mh"><img src="../Images/d0c1b6c90498500141a9f27170f1fd37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1386/format:webp/0*jWyDP0y3wajj3B0S.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">图片来源:<a class="ae iu" href="https://www.softwaretestinghelp.com/the-difference-between-unit-integration-and-functional-testing/" rel="noopener ugc nofollow" target="_blank">softwaretestinghelp.com</a></figcaption></figure><ul class=""><li id="f071" class="lp lq hi ix b iy iz jc jd jg lr jk ls jo lt js lu lv lw lx bi translated"><strong class="ix hj">单元测试— </strong>从程序员的角度编写的测试，以测试一个单元或程序的最小部分。它是独立测试的，没有依赖性。单元测试占据了金字塔的最大部分，包含了程序的实体部分。它们很容易写，这就是成本低的原因。为了编写单元测试，我们可以使用一种叫做白盒测试的技术。为了做白盒测试，测试人员需要知道程序的内部结构。当我们执行功能测试时，从单元测试中获得的文档将是有用的。</li><li id="6ccf" class="lp lq hi ix b iy mi jc mj jg mk jk ml jo mm js lu lv lw lx bi translated"><strong class="ix hj">集成测试</strong> —测试不同的模块在与其他模块组合后是否还能正常工作。</li><li id="2d66" class="lp lq hi ix b iy mi jc mj jg mk jk ml jo mm js lu lv lw lx bi translated"><strong class="ix hj">功能测试</strong> —从用户角度编写的测试，目的是测试可能依赖于数据库等其他服务的系统功能。功能测试与集成测试相关，有时被认为是同一件事。但是功能测试检查整个应用程序的功能，而集成测试只检查系统的几个集成模块。为了编写功能测试，我们可以使用一种叫做黑盒测试的技术。与白盒不同，测试人员不需要知道应用程序的内部结构，因为它毕竟是从用户的角度编写的。</li></ul><p id="ef5b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">要知道你的测试覆盖了你的代码多少，有一个叫做<strong class="ix hj">代码覆盖率</strong>的测量方法。这是衡量测试套件质量的一个强有力的标准。覆盖率越高越好。覆盖率达到80%就足够了。但是对于这个项目，我们的目标是超过90%的覆盖率。</p><figure class="ll lm ln lo fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mn"><img src="../Images/6bc0c1d94ae03ca76159eba812122878.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N5YpUPgLzrSCajjkinFR8w.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">100%覆盖我的一个分支机构。从sonarqube看。</figcaption></figure><h1 id="6f04" class="kh ki hi bd kj kk mc km kn ko md kq kr ks me ku kv kw mf ky kz la mg lc ld le bi translated">TDD和干净代码</h1><p id="7464" class="pw-post-body-paragraph iv iw hi ix b iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo lj jq jr js hb bi translated">您可能没有想到，但是TDD与干净的代码有关系。编写糟糕的测试和不编写测试是一样的。随着应用程序的发展，测试可能需要一些修改。记得我们可以重构测试和代码吗？如果测试是肮脏的，那么我们将很难重构或改变它们。写代码有自己的指南，写测试也是如此。我们称之为<strong class="ix hj">第一</strong>原则:</p><ul class=""><li id="fde9" class="lp lq hi ix b iy iz jc jd jg lr jk ls jo lt js lu lv lw lx bi translated"><strong class="ix hj">快速</strong> —测试应该快速运行。测试运行的时间越长，我们就越懒，不想再测试一次。更不用说，会浪费时间。</li><li id="4f1a" class="lp lq hi ix b iy mi jc mj jg mk jk ml jo mm js lu lv lw lx bi translated"><strong class="ix hj">独立</strong> —测试不应该依赖于任何其他测试。这意味着，测试应该以任何顺序运行，并且不会影响其他测试。</li><li id="0aa5" class="lp lq hi ix b iy mi jc mj jg mk jk ml jo mm js lu lv lw lx bi translated"><strong class="ix hj">可重复</strong> —测试应能在不同的环境中重复进行。我们必须确保测试不仅在本地通过，而且在另一个开发人员的计算机上通过。</li><li id="c7ee" class="lp lq hi ix b iy mi jc mj jg mk jk ml jo mm js lu lv lw lx bi translated"><strong class="ix hj">自验证</strong> —测试应该只有两个值:通过或失败。查看日志看测试是否顺利很累。</li><li id="40ab" class="lp lq hi ix b iy mi jc mj jg mk jk ml jo mm js lu lv lw lx bi translated"><strong class="ix hj">适时</strong> —测试应在实际实施前编写。如果我们在编写代码之前编写了实现，那么编写测试可能需要一些时间。</li></ul><h1 id="0ede" class="kh ki hi bd kj kk mc km kn ko md kq kr ks me ku kv kw mf ky kz la mg lc ld le bi translated">TDD及其对团队的好处</h1><p id="44b8" class="pw-post-body-paragraph iv iw hi ix b iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo lj jq jr js hb bi translated">在我阅读的几乎每一篇关于TDD的文章中，都提到TDD有助于提高代码的质量。尽管不得不编写测试用例可能会耗费时间，但这将节省我们调试的精力，因为这将减少新错误的数量。</p><p id="5f00" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对我来说，它帮助我避免代码重复。此外，它节省了我写代码的时间，这些代码以后将是无用的。TDD帮助我们专注于需要做的事情。此外，如果团队中的任何一个成员发生了意外，而他们只编写了测试，那么其他成员可以简单地了解其他成员打算做什么以及需要完成什么。</p><p id="a1df" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这也增加了我们对改变的信心。如果出现冲突，并且我们不知道是什么导致了冲突，那么合并彼此的工作将会很麻烦。但是如果我们已经做了一些测试，并且看到我们的测试以高覆盖率通过了，那么我们点击合并按钮的恐惧就会变小。这是因为TDD给了我们一个保证，我们的代码已经按照我们计划的方式工作了，并且合并应该是安全的。</p><figure class="ll lm ln lo fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mo"><img src="../Images/6eee835877e2ecb29043e9144bcd2c52.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2XuHkX7WIhtZs5Vps3PCOw.png"/></div></div></figure></div><div class="ab cl ka kb gp kc" role="separator"><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf"/></div><div class="hb hc hd he hf"><p id="f5a6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">实践TDD可能需要一些时间，但这是值得的。毕竟，熟能生巧！</p><h2 id="af82" class="mp ki hi bd kj mq mr ms kn mt mu mv kr jg mw mx kv jk my mz kz jo na nb ld nc bi translated">参考资料:</h2><div class="nd ne ez fb nf ng"><a href="https://www.softwaretestinghelp.com/the-difference-between-unit-integration-and-functional-testing/" rel="noopener  ugc nofollow" target="_blank"><div class="nh ab dw"><div class="ni ab nj cl cj nk"><h2 class="bd hj fi z dy nl ea eb nm ed ef hh bi translated">单元测试、集成测试和功能测试的区别</h2><div class="nn l"><h3 class="bd b fi z dy nl ea eb nm ed ef dx translated">单元测试、集成测试和功能测试的区别。单元测试考虑检查单个组件…</h3></div><div class="no l"><p class="bd b fp z dy nl ea eb nm ed ef dx translated">www.softwaretestinghelp.com</p></div></div><div class="np l"><div class="nq l nr ns nt np nu io ng"/></div></div></a></div><div class="nd ne ez fb nf ng"><a href="https://www.guru99.com/test-driven-development.html" rel="noopener  ugc nofollow" target="_blank"><div class="nh ab dw"><div class="ni ab nj cl cj nk"><h2 class="bd hj fi z dy nl ea eb nm ed ef hh bi translated">什么是测试驱动开发(TDD)？带示例的教程</h2><div class="nn l"><h3 class="bd b fi z dy nl ea eb nm ed ef dx translated">测试驱动开发(TDD)是一种软件开发方法，在这种方法中，测试用例被开发出来，以指定和…</h3></div><div class="no l"><p class="bd b fp z dy nl ea eb nm ed ef dx translated">www.guru99.com</p></div></div><div class="np l"><div class="nv l nr ns nt np nu io ng"/></div></div></a></div><div class="nd ne ez fb nf ng"><a href="https://scrumology.com/the-benefits-of-tdd-are-neither-clear-nor-are-they-immediately-apparent/" rel="noopener  ugc nofollow" target="_blank"><div class="nh ab dw"><div class="ni ab nj cl cj nk"><h2 class="bd hj fi z dy nl ea eb nm ed ef hh bi translated">TDD的好处既不清楚，也不是立竿见影的</h2><div class="nn l"><h3 class="bd b fi z dy nl ea eb nm ed ef dx translated">让我从故事的结尾开始，然后回到开头。从个人经验测试驱动…</h3></div><div class="no l"><p class="bd b fp z dy nl ea eb nm ed ef dx translated">scrumology.com</p></div></div></div></a></div><div class="nd ne ez fb nf ng"><a rel="noopener follow" target="_blank" href="/@shley_ng/clean-code-unit-tests-c0c871219f75"><div class="nh ab dw"><div class="ni ab nj cl cj nk"><h2 class="bd hj fi z dy nl ea eb nm ed ef hh bi translated">干净的代码:单元测试</h2><div class="nn l"><h3 class="bd b fi z dy nl ea eb nm ed ef dx translated">TDD，或测试驱动开发，或红绿重构。</h3></div><div class="no l"><p class="bd b fp z dy nl ea eb nm ed ef dx translated">medium.com</p></div></div></div></a></div><div class="nd ne ez fb nf ng"><a href="https://www.atlassian.com/continuous-delivery/software-testing/code-coverage" rel="noopener  ugc nofollow" target="_blank"><div class="nh ab dw"><div class="ni ab nj cl cj nk"><h2 class="bd hj fi z dy nl ea eb nm ed ef hh bi translated">代码覆盖率介绍| Atlassian</h2><div class="nn l"><h3 class="bd b fi z dy nl ea eb nm ed ef dx translated">代码覆盖率是一个可以帮助你理解你的源代码有多少被测试的度量标准。这是一个非常有用的指标…</h3></div><div class="no l"><p class="bd b fp z dy nl ea eb nm ed ef dx translated">www.atlassian.com</p></div></div><div class="np l"><div class="nw l nr ns nt np nu io ng"/></div></div></a></div><p id="2eb3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">https://www . sim form . com/Unit-testing-vs-functional-testing/#:~:text = Unit % 20 testing % 20 is % 20 fast % 20 and，% 20to % 20the要求。</p></div></div>    
</body>
</html>