<html>
<head>
<title>3D Graphics With OpenGL in Android</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Android中使用OpenGL的3D图形</h1>
<blockquote>原文：<a href="https://medium.com/codex/3d-graphics-with-opengl-in-android-5e5d8a4f7d2b?source=collection_archive---------2-----------------------#2021-03-28">https://medium.com/codex/3d-graphics-with-opengl-in-android-5e5d8a4f7d2b?source=collection_archive---------2-----------------------#2021-03-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><h2 id="0e98" class="hg hh hi bd b fp hj hk hl hm hn ho dx hp translated" aria-label="kicker paragraph"><a class="ae ge" href="http://medium.com/codex" rel="noopener">抄本</a></h2><div class=""/><figure class="ev ex io ip iq ir"><div class="bz dy l di"><div class="is it l"/></div></figure><p id="645e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">计算机图形是我们生活的核心部分，在电影、游戏、计算机辅助设计、虚拟模拟器、可视化，甚至成像产品和相机中。当我们玩3D游戏、体验虚拟现实或与复杂的数据可视化交互时，组成这样一个场景的几何图形必须在设备上每秒钟重画几十次。除了由点、线和多边形组成的几何图形之外，我们通常还在3D场景中使用纹理、照明和虚拟相机来控制形状和对象的外观，并改变我们在场景中的视角。</p><p id="af08" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hs"> OpenGL </strong>是渲染2D和3D矢量图形的应用编程接口。API通常用于与<em class="js">图形处理单元</em>交互，以实现<em class="js">硬件加速渲染</em>。OpenGL的对象由图元组成(如三角形、四边形、多边形、点和线)。图元通过一个或多个顶点来定义。<strong class="iw hs"> Android通过其框架API和本地开发工具包(NDK)支持OpenGL </strong>。本文主要讨论Android框架的API接口。</p><p id="d459" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">Android框架中有两个基础类，可以让你用OpenGL ES API创建和操作图形:<code class="du jt ju jv jw b"><a class="ae jx" href="https://developer.android.com/reference/android/opengl/GLSurfaceView" rel="noopener ugc nofollow" target="_blank">GLSurfaceView</a></code>和<code class="du jt ju jv jw b"><a class="ae jx" href="https://developer.android.com/reference/android/opengl/GLSurfaceView.Renderer" rel="noopener ugc nofollow" target="_blank">GLSurfaceView.Renderer</a></code>。我们将使用OpenGL来创建3D形状和动画。在我们将对象绘制到屏幕上之前，我们需要通过OpenGL管道发送它，为此我们需要使用称为<strong class="iw hs"> <em class="js">着色器的小子程序。</em> </strong> <em class="js">着色器告诉图形处理单元(GPU)如何绘制我们的数据</em>。有两种类型的<strong class="iw hs">着色器顶点着色器和片段着色器，</strong>着色器是在GPU上为每个顶点(顶点着色器)或每个片段(片段着色器)并行执行的小程序</p><p id="4c6f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">1.<strong class="iw hs">一个<em class="js">顶点着色器:</em> </strong>它生成每个顶点的最终位置，并且每个顶点运行一次。一旦知道了最终的位置，OpenGL将获取可见的顶点集，并将它们组合成点、线和三角形。</p><p id="679c" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">2.<strong class="iw hs">一个<em class="js">片段着色器:</em> </strong>它生成点、线或三角形的每个<em class="js">片段</em>的最终颜色，并对每个片段运行一次。片段是一个单一颜色的小矩形区域，类似于计算机屏幕上的一个像素。</p><h1 id="23f7" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">OpenGL中的图形管道</h1><figure class="kx ky kz la fd ir er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es kw"><img src="../Images/29e0c0885c0e01214e498a75045ae528.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VUUOlBM4b5x7EV37AHlgvw.png"/></div></div><figcaption class="lh li et er es lj lk bd b be z dx translated">OpenGL中的图形管道</figcaption></figure><p id="db91" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">顶点处理器:就像瘸子在纸上画画一样，点和线连接在一起形成共同的几何图形。顶点只是表示几何对象的一个角的点，具有与该点相关联的各种属性。最重要的属性是位置，代表这个顶点在空间中的位置。</p><p id="de22" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">顶点处理包括将模型从模型空间转换到世界空间，并将视图转换到相机空间，然后将其投影到设备的屏幕上。在将对象渲染到归一化的设备坐标时，可以通过缩放、旋转和变换以及投影(正交投影或透视投影)的矩阵运算来应用各种变换</p><figure class="kx ky kz la fd ir er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es ll"><img src="../Images/ad38587285f9e4652924eea433706bf2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dQ2XAKzmktZB5-pmSGjb5g.png"/></div></div></figure><p id="1cc2" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hs">光栅化</strong></p><p id="bb39" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这确定了被图元(例如三角形)覆盖的像素，并为每个被覆盖的像素内插顶点着色器的输出变量(即变化的变量和深度)。</p><figure class="kx ky kz la fd ir er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es lm"><img src="../Images/50be443c2dd93deb8e7103287855e0e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:704/format:webp/1*d0FPw2akIKodDUS9xKFWaQ.png"/></div></div><figcaption class="lh li et er es lj lk bd b be z dx translated"><a class="ae jx" href="https://upload.wikimedia.org/wikipedia/commons/d/d6/Pixels_covered_by_a_triangle.png" rel="noopener ugc nofollow" target="_blank">图片来自维基百科</a></figcaption></figure><p id="ca35" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hs">片段处理</strong></p><p id="3f2e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hs">片段着色器</strong>是<strong class="iw hs">着色器</strong>阶段，它将光栅化生成的<strong class="iw hs">片段</strong>处理成一组颜色和单个深度值。<strong class="iw hs">片段着色器</strong>是图元光栅化后的<strong class="iw hs"> OpenGL </strong>流水线阶段。对于由图元覆盖的像素的每个样本，生成一个“<strong class="iw hs">片段</strong>”。光照、阴影、插值和纹理映射都在这里完成。</p><figure class="kx ky kz la fd ir er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es ln"><img src="../Images/9c696992c23fbe65e6faeace5ce417b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qAD9Wi1eA83dLA_YdOAIuw.png"/></div></div><figcaption class="lh li et er es lj lk bd b be z dx translated"><a class="ae jx" href="https://vispy.org/getting_started/modern-gl.html" rel="noopener ugc nofollow" target="_blank">图片来自vispy </a></figcaption></figure><p id="3ee0" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hs">输出合并</strong></p><p id="a86d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">一旦生成了最终的颜色，OpenGL会将它们写入一个被称为<em class="js">帧缓冲区</em>的内存块，然后Android会在屏幕上显示这个帧缓冲区。</p></div><div class="ab cl lo lp gp lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="hb hc hd he hf"><p id="1110" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hs">让我们跳转到某个编码</strong></p><figure class="kx ky kz la fd ir er es paragraph-image"><div class="er es lv"><img src="../Images/8a2293bd205a50b761c0981eb2fbc6e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/1*BufbCIqezKQzO2lIxIvW-A.gif"/></div></figure><p id="b589" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hs">设置环境</strong></p><p id="fdd0" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">为了向后兼容，我们将使用OpenGL ES 2.0支持，它与API 10兼容:Android 2.3.3(姜饼)和更高版本。</p><p id="b127" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">创建GLSurfaceView的实例</p><p id="20a5" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">GLSurfaceView负责OpenGL初始化的一些细节，例如在后台线程上配置显示和渲染，处理标准的Android活动生命周期，例如<em class="js"> onCreated </em>和<em class="js"> onDestroyed </em>。这种渲染是在显示器的一个特殊区域完成的，称为<em class="js">表面</em>；这有时也被称为<em class="js">视口</em>。</p><p id="9fd4" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在处理android的活动生命周期事件时，我们增加了暂停和恢复的方法，以符合Android的活动生命周期。这样我们的surface view就可以适当地暂停和恢复后台渲染线程以及释放和更新OpenGL上下文，如果我们不这样做，我们的应用程序可能会崩溃并被Android杀死</p><p id="3301" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hs">创建渲染器</strong></p><p id="d4d4" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">渲染器负责调用OpenGL来渲染帧。GLSurfaceView将在单独的线程上调用renderer方法。默认情况下，GLSurfaceView将连续呈现，通常以显示器的刷新率呈现，但我们也可以通过使用GLSurfaceView调用GLSurfaceView.setRenderMode()来配置表面视图，使其仅在请求时呈现。RENDERMODE_WHEN_DIRTY作为参数。由于Android的GLSurfaceView是在后台线程中做渲染的，所以一定要小心，只在渲染线程内调用OpenGL，Android UI只在Android的主线程内调用。我们可以在GLSurfaceView实例上调用queueEvent()，在后台渲染线程上发布一个Runnable。</p><p id="6f96" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hs">创建出对象</strong></p><p id="2899" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">OpenGL希望你在一个数组中发送所有的顶点。一个<strong class="iw hs">顶点数组</strong>对象(VAO)是一个<strong class="iw hs"> OpenGL </strong>对象，它存储了提供<strong class="iw hs">顶点</strong>数据所需的所有状态(下面有一个小的例外)。它存储了<strong class="iw hs">顶点</strong>数据的格式以及<strong class="iw hs">缓冲</strong>对象(见下文)提供的<strong class="iw hs">顶点</strong>数据<strong class="iw hs">数组</strong>。我们将创建一个<strong class="iw hs">场景</strong>，它有<strong class="iw hs">地板</strong>、<strong class="iw hs">球、墙、水花和水滴。我们将为场景中的物体定义顶点，如下所示。</strong></p><figure class="kx ky kz la fd ir"><div class="bz dy l di"><div class="lw it l"/></div></figure><blockquote class="lx ly lz"><p id="3b00" class="iu iv js iw b ix iy iz ja jb jc jd je ma jg jh ji mb jk jl jm mc jo jp jq jr hb bi translated">我们使用浮点数的顺序列表来定义顶点数据，这样我们就可以用小数点来存储位置。这个数组就是我们的<em class="hi">顶点属性数组</em>。Java中的Float有32位精度，而byte有8位精度。每个浮点数中有4个字节。FloatBuffer将用于在本机内存中存储数据。我们可以访问Java中的一组特殊的类，这些类将分配一块本地内存并将我们的数据复制到该内存中。本地环境可以访问这个本地内存，并且它不会被垃圾收集器管理。我们通过调用<code class="du jt ju jv jw b"><em class="hi">StoreVertexData(..)</em></code> <em class="hi">方法</em>中的glBufferData()和<code class="du jt ju jv jw b"><em class="hi">StroreVertexData</em></code> <em class="hi">中的<code class="du jt ju jv jw b">glBindBuffer</code>将数据上传到指定缓冲区ID </em>的buffer对象中</p></blockquote><figure class="kx ky kz la fd ir"><div class="bz dy l di"><div class="lw it l"/></div></figure><p id="cce5" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们实现渲染器接口定义的方法:</p><p id="9f75" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hs"><em class="js">onSurfaceCreated(GL11 glUnused，EGLConfig config)</em></strong>GLSurfaceView在创建表面时调用这个。这发生在我们的应用程序第一次运行时，也可能在设备唤醒或用户切换回我们的活动时被调用..</p><p id="6a19" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hs">onSurfaceChanged(GL11 Glu nu used，int width，int height </strong> ) GLSurfaceView在创建表面后以及尺寸改变时调用此函数。当从纵向切换到横向时会发生尺寸变化，反之亦然。</p><p id="9f1c" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hs">onDrawFrame(GL10 glUnused)</strong>GLSurfaceView在绘制框架的时候调用这个。我们<em class="js">必须</em>画点什么，哪怕只是为了清空屏幕。这个方法返回后，渲染缓冲区将被交换并显示在屏幕上，所以如果我们不画任何东西，我们可能会得到不好的闪烁效果。</p></div><div class="ab cl lo lp gp lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="hb hc hd he hf"><p id="52a0" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hs">结论</strong></p><p id="6df4" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这是github repo 的链接，你现在可以放心地根据需要将它应用到你的android项目中。</p><div class="md me ez fb mf mg"><a href="https://github.com/banjodayo39/3DAndroidGraphicWithOpenGL.git" rel="noopener  ugc nofollow" target="_blank"><div class="mh ab dw"><div class="mi ab mj cl cj mk"><h2 class="bd hs fi z dy ml ea eb mm ed ef hr bi translated">banjodayo 39/3 androidgraphicwith OpenGL</h2><div class="mn l"><h3 class="bd b fi z dy ml ea eb mm ed ef dx translated">这是一个用android和OpenGL制作的3D场景。OpenGL是一个应用程序，用于渲染2D和三维矢量…</h3></div><div class="mo l"><p class="bd b fp z dy ml ea eb mm ed ef dx translated">github.com</p></div></div><div class="mp l"><div class="mq l mr ms mt mp mu lf mg"/></div></div></a></div></div></div>    
</body>
</html>