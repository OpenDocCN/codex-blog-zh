<html>
<head>
<title>Writing custom linter in Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Go中编写自定义linter</h1>
<blockquote>原文：<a href="https://medium.com/codex/writing-custom-linter-in-go-54ef6f8080?source=collection_archive---------5-----------------------#2021-05-06">https://medium.com/codex/writing-custom-linter-in-go-54ef6f8080?source=collection_archive---------5-----------------------#2021-05-06</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/2ad7eea3c125270542deac281baf6761.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r9nOz_Vl0D2ZbSv01wq8hg.png"/></div></div></figure><p id="7b3e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">编写linters很简单。我很惊讶写一篇Go linter这么容易。今天，我们将编写一个linter来计算Go代码的圈复杂度。</p><p id="cfa1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">什么是圈复杂度？</strong></p><blockquote class="jo jp jq"><p id="5ffd" class="iq ir jr is b it iu iv iw ix iy iz ja js jc jd je jt jg jh ji ju jk jl jm jn hb bi translated"><em class="hi">圈复杂度是一种软件度量，用于表示程序的复杂度。</em> <a class="ae jv" href="https://en.wikipedia.org/wiki/Cyclomatic_complexity" rel="noopener ugc nofollow" target="_blank"> <em class="hi">参考</em> </a></p></blockquote><p id="72aa" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个想法很简单——每当我们发现任何控制流语句，我们就增加一个复杂度。我知道我把它简化了一点，但我不想用不必要的细节淹没你。</p><p id="c6f3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">有几个我们应该遵循的步骤来编写我们的自定义linter。首先，我们可以创建一个测试来检查我们的linter是否工作。让我们把他归档。</p><pre class="ka kb kc kd fd ke jz kf kg aw kh bi"><span id="7b1d" class="ki kj hi jz b fi kk kl l km kn">package analyzer<br/><br/>import (<br/>	"os"<br/>	"path/filepath"<br/>	"testing"<br/><br/>	"golang.org/x/tools/go/analysis/analysistest"<br/>)<br/><br/>func TestAll(t *testing.T) {<br/>	wd, err := os.Getwd()<br/>	if err != nil {<br/>		t.Fatalf("Failed to get wd: %s", err)<br/>	}<br/><br/>	testdata := filepath.Join(filepath.Dir(filepath.Dir(wd)), "testdata")<br/>	analysistest.Run(t, testdata, NewAnalyzer(), "complexity")<br/>}</span></pre><p id="4d68" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du jw jx jy jz b">analysistest.Run()</code>函数是简化测试linters的助手。它所做的是在<code class="du jw jx jy jz b">testate</code>文件夹中的<code class="du jw jx jy jz b">complexity</code>包上运行我们的linter。我们使用<code class="du jw jx jy jz b">NewAnalyzer()</code>函数来返回分析器的实例。再加上<code class="du jw jx jy jz b">pkg/analyzer/analyzer.go</code>吧。</p><pre class="ka kb kc kd fd ke jz kf kg aw kh bi"><span id="6a22" class="ki kj hi jz b fi kk kl l km kn">package analyzer<br/><br/>import "golang.org/x/tools/go/analysis"<br/><br/>//nolint:gochecknoglobals<br/>var flagSet flag.FlagSet<br/><br/>func NewAnalyzer() *analysis.Analyzer {<br/>	return &amp;analysis.Analyzer{<br/>		Name:  "cyclop",<br/>		Doc:   "calculates cyclomatic complexity",<br/>		Run:   run,<br/>		Flags: flagSet,<br/>	}<br/>}<br/><br/>func run(pass *analysis.Pass) (interface{}, error) {<br/>  return nil, nil<br/>}</span></pre><p id="1343" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们将使用标志集向linter输入参数。在<code class="du jw jx jy jz b">NewAnalyzer()</code>中，我们用名称<code class="du jw jx jy jz b">cyclop</code>、描述和已定义的<code class="du jw jx jy jz b">Run</code>功能来定义分析仪。它接受文档中<a class="ae jv" href="https://pkg.go.dev/golang.org/x/tools@v0.1.0/go/analysis#Pass" rel="noopener ugc nofollow" target="_blank">描述的<code class="du jw jx jy jz b">analysis.Pass</code>结构。我们现在只需要几样东西。</a></p><p id="2226" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了在被分析的文件中报告一个问题，我们可以使用<code class="du jw jx jy jz b">pass.Reportf()</code>方法。它接受诊断的位置和用户将看到的消息。<code class="du jw jx jy jz b">pass.Files</code>是<code class="du jw jx jy jz b">*ast.File</code>的一个片段，即包内文件的列表。</p><p id="8c20" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们将使用最后一个来迭代每个文件，并逐个检查它们。当我们发现问题时，我们会报告。为此，我们必须使用下面的循环迭代这些文件。</p><pre class="ka kb kc kd fd ke jz kf kg aw kh bi"><span id="2b15" class="ki kj hi jz b fi kk kl l km kn">for _, f := range pass.Files {<br/>		ast.Inspect(f, func(node ast.Node) bool {<br/>		  // your code goes here<br/>		}<br/>}</span></pre><p id="8723" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是我们棉绒的核心。<code class="du jw jx jy jz b">ast.Node</code>是一个只有两种方法的接口，在报告任何问题时都需要这两种方法。</p><pre class="ka kb kc kd fd ke jz kf kg aw kh bi"><span id="dbbc" class="ki kj hi jz b fi kk kl l km kn">type Node interface {<br/>    Pos() token.Pos // position of first character belonging to the node<br/>    End() token.Pos // position of first character immediately after the node<br/>}</span></pre><p id="e2aa" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们只对函数或方法感兴趣，所以我们必须将这种类型转换成<code class="du jw jx jy jz b">*ast.FuncDecl</code>。</p><pre class="ka kb kc kd fd ke jz kf kg aw kh bi"><span id="5335" class="ki kj hi jz b fi kk kl l km kn">type FuncDecl struct {<br/>    Doc  *CommentGroup // associated documentation; or nil<br/>    Recv *FieldList    // receiver (methods); or nil (functions)<br/>    Name *Ident        // function/method name<br/>    Type *FuncType     // function signature: parameters, results, and position of "func" keyword<br/>    Body *BlockStmt    // function body; or nil for external (non-Go) function<br/>}</span></pre><p id="ca61" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们的循环应该如下图所示。</p><pre class="ka kb kc kd fd ke jz kf kg aw kh bi"><span id="2c6e" class="ki kj hi jz b fi kk kl l km kn">for _, f := range pass.Files {<br/>		ast.Inspect(f, func(node ast.Node) bool {<br/>    f, ok := node.(*ast.FuncDecl)<br/>			if !ok {<br/>				return true<br/>			}<br/>	})<br/>}</span></pre><p id="c343" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">是时候计算圈复杂度了。新的<code class="du jw jx jy jz b">complexity</code>函数接受<code class="du jw jx jy jz b">*ast.File</code>。该算法在每次找到<code class="du jw jx jy jz b">if</code>、<code class="du jw jx jy jz b">for</code>、<code class="du jw jx jy jz b">select</code>或<code class="du jw jx jy jz b">case</code>语句以及<code class="du jw jx jy jz b">if</code>语句中的<code class="du jw jx jy jz b">||</code>或<code class="du jw jx jy jz b">&amp;&amp;</code>运算符时都会增加复杂度。</p><pre class="ka kb kc kd fd ke jz kf kg aw kh bi"><span id="fd97" class="ki kj hi jz b fi kk kl l km kn">func complexity(fn *ast.FuncDecl) int {<br/>	v := complexityVisitor{Complexity:1}<br/>	ast.Walk(&amp;v, fn)<br/>	return v.Complexity<br/>}<br/><br/>type complexityVisitor struct {<br/>	Complexity int<br/>}<br/><br/>func (v *complexityVisitor) Visit(n ast.Node) ast.Visitor {<br/>	switch n := n.(type) {<br/>	case *ast.FuncDecl, *ast.IfStmt, *ast.ForStmt, *ast.RangeStmt, *ast.CaseClause, *ast.CommClause:<br/>		v.Complexity++<br/>	case *ast.BinaryExpr:<br/>		if n.Op == token.LAND || n.Op == token.LOR {<br/>			v.Complexity++<br/>		}<br/>	}<br/>	return v<br/>}</span></pre><p id="3272" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">有一条<code class="du jw jx jy jz b">ast.Walk(&amp;v, fn)</code>线可能会令人困惑。这个函数接受在我们提供的父节点的每个子节点上调用的访问者。我们使用一个简单的<a class="ae jv" href="https://tour.golang.org/methods/15" rel="noopener ugc nofollow" target="_blank">类型断言</a>来确定特定节点的类型。</p><p id="986d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当我们有了代码，我们就可以编写测试用例。为此，让我们创建一个新的<code class="du jw jx jy jz b">complexity</code>包。在<code class="du jw jx jy jz b">complexity.go</code>文件中放入下面的代码。</p><pre class="ka kb kc kd fd ke jz kf kg aw kh bi"><span id="7749" class="ki kj hi jz b fi kk kl l km kn">package complexity<br/><br/>import "testing"<br/><br/>func highComplexity() { // want "calculated cyclomatic complexity for function"<br/>	i := 1<br/>	if i &gt; 2 {<br/>		if i &gt; 2 {<br/>		}<br/>		if i &gt; 2 {<br/>		}<br/>		if i &gt; 2 {<br/>		}<br/>		if i &gt; 2 {<br/>		}<br/>	} else {<br/>		if i &gt; 2 {<br/>		}<br/>		if i &gt; 2 {<br/>		}<br/>		if i &gt; 2 {<br/>		}<br/>		if i &gt; 2 {<br/>		}<br/>	}<br/><br/>	if i &gt; 2 {<br/>	}<br/>}<br/><br/>func noComplexity() {}</span></pre><p id="a0c7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们创建了两个函数。<code class="du jw jx jy jz b">noComplexity()</code>函数具有<code class="du jw jx jy jz b">1</code>的复杂性，因为它只有一条执行路径。linter不应该报告任何问题。<code class="du jw jx jy jz b">highComplexity</code>有一堆<code class="du jw jx jy jz b">if</code>语句增加了这个指标。It <strong class="is hj">应该</strong>报告一个问题。注意，我们有一个特殊的注释，让测试套件知道我们期望被报告的诊断。你可以把它想象成<a class="ae jv" href="https://martinfowler.com/bliki/GivenWhenThen.html" rel="noopener ugc nofollow" target="_blank">给定时间然后</a>方法中的<code class="du jw jx jy jz b">then</code>部分。引号内的所有内容都是正则表达式，必须与诊断消息相匹配。你可以在官方文件中读到更多相关信息。</p><p id="162a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当我们运行测试时，我们应该看到成功！下一步是使linter可执行。我们所要做的就是在<code class="du jw jx jy jz b">cmd/cyclop/cyclop.go</code>文件中创建一个文件，并将内容放在下面。</p><pre class="ka kb kc kd fd ke jz kf kg aw kh bi"><span id="9501" class="ki kj hi jz b fi kk kl l km kn">package main<br/><br/>import (<br/>	"github.com/bkielbasa/cyclop/pkg/analyzer"<br/>	"golang.org/x/tools/go/analysis/singlechecker"<br/>)<br/><br/>func main() {<br/>	singlechecker.Main(analyzer.NewAnalyzer())<br/>}</span></pre><p id="5468" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">上面的代码将我们的分析器作为一个独立的工具运行。就是这样！我们有一个功能齐全的去棉绒！Github 上有完整的(有点复杂的)代码<a class="ae jv" href="https://github.com/bkielbasa/cyclop" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="5d68" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你可以做一个可选的步骤——将你的棉绒加入到<a class="ae jv" href="https://github.com/golangci/golangci-lint" rel="noopener ugc nofollow" target="_blank"> golangci-lint </a>中。这是我们制作的T2棉绒的一个例子。</p><p id="3a6d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我希望Go社区将会得到许多棒极了的棉绒，这将会节省我们几个小时或几天的时间。</p><p id="9e10" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><a class="ae jv" href="https://www.buymeacoffee.com/bklimczak" rel="noopener ugc nofollow" target="_blank">给我买杯咖啡</a></p></div><div class="ab cl ko kp gp kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="hb hc hd he hf"><p id="9060" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jr">原载于</em><a class="ae jv" href="https://developer20.com/custom-go-linter/" rel="noopener ugc nofollow" target="_blank"><em class="jr">https://developer20.com</em></a><em class="jr">。</em></p></div></div>    
</body>
</html>