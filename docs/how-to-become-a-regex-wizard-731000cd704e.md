# 如何成为正则表达式向导

> 原文：<https://medium.com/codex/how-to-become-a-regex-wizard-731000cd704e?source=collection_archive---------15----------------------->

## 正则表达式基础及其实际应用

在用 Ruby 为一个博客应用程序编写一些验证时，我遇到了一个问题。我想写一个验证来确保一个新的博客文章的标题包括各种潜在的字符串之一。我最终能够提出一个涉及许多许多逻辑 OR 运算符的解决方案。非常重复，当然也不漂亮。

![](img/870bd9cddd13a9cf6efcbd3cd7e1af60.png)

不使用正则表达式编写验证

我知道一定有更好的方法。这种更好的方法很快以正则表达式的形式出现。我完全掉进了兔子洞，并发现 RegEx 使查找字符串变得容易多了。

那么什么是正则表达式呢？本质上，它们允许我们梳理字符串，寻找特定的模式或字符，并在其他地方使用这些信息，比如 Ruby 验证。

每个正则表达式都以正斜杠开始和结束，就像这样:

```
/bat/
```

这将选择字符串中第一个`“bat”`实例。

## 旗帜

您还可以在表达式的末尾添加一个或多个“标志”。一些有用的基本标志是

*   g(全球)，
*   I(不区分大小写)
*   x(扩展模式)

全局标志将选择表达式的每个实例，而不仅仅是第一个。不区分大小写标志忽略大小写差异。扩展模式标志会忽略正在梳理的字符串中的空白。

## 特殊字符

特殊字符和修饰符允许您进一步指定如何从字符串中进行选择。重要的是要知道:

*   +
*   ?
*   *
*   .
*   {}

+修饰符选择一个或多个前面的标记。例如，如果您在一串`“The bat and the cat fought over the food.”`上使用`/o+/g`，不仅`“cat”`和`“fought”`中的前两个 o 会被选中，而且`"food"`中的双 o 也会被选中。

那个？modifer 选择零个或一个前面的标记，本质上使选择是可选的。使用上面的相同字符串并使用表达式`/ou?/g`将会选择在“fighted”中找到的 ou，但是句子中其余的单个 o 也会被选择。后面的 u 字符只是可选的。

*修饰符选择零个或多个前面的标记，即？和+修饰语。再次使用相同的字符串，`/fo*/g`的正则表达式将选择`“fought”`中的 f，以及`“food”`中的 foo。

的。是一个特殊的字符，它可以匹配除了新行之外的任何内容。例如，`/.at/g`将同时选择`“bat”`和`“cat”`。在这种情况下，句点充当通配符，代表任何字符。注意:如果你想选择句点作为字符，你要做的就是在它前面加一个反斜杠，就像这样`/\./g`。该表达式对特殊字符进行转义，并选择字符串中的每个句点

大括号{}允许您提供最小和最大数字来选择字符数。`{3}`会选择一行中前面的任意三个标记。`{3,}`会在前面的一行记号中选择三个或更多的字符。`{3–4}` 将在前面的标记的一行中返回三到四个字符。当与范围和它们的快捷方式结合使用时，这个修饰符更有用。

## 范围

使用方括号可以匹配其中的任何字符，也可以用来定义范围。例如，`[12345]`和`[1–5]`都会选择 1 到 5 之间的任意数字。一些有用的范围是`[0–9]`、`[a-z]`和`[A-Z]`。某些范围也有快捷方式:

*   `[0–9]`可以表示为`\d`，也可以表示为否定`\D`。
*   `[0–9a-zA-Z]`可以表示为`\w`，也可以表示为否定`\W`。
*   空白可以选择为\s，或者负的 `\S`。

另一个有用的约定是通过()分组。

## 捕获组

括号内的任何东西都是捕获组，意味着它们只作用于自己。这意味着可以使用运算符，如逻辑 OR，而不会弄乱表达式的其余部分。例如，如果在字符串`“The bat and the cat fought over the food.”`上调用正则表达式`/(c|b)at/g` ，它将选择`“bat”`和`“cat”`。如果删除括号并调用`/c|bat/g`，则`“bat”`仍会被选中，但只有字母`“c”`会被选中，因为它是通过逻辑 OR 分隔的。这也可以用花括号配对。`/(o|f|u){2,3}/g`将选择两组三个:fou 在`“fought”`中，foo 在`“food”`中。

## 实际应用

通过上面的信息，您将能够完成 RegEx 通常用途的大约 90%。让我们来看一个实际的例子。假设您的应用程序需要通过信用卡支付。我们希望验证输入的信息是有效的信用卡号。完美的正则表达式！

您可以编写一个简单的表达式来检查 16 个连续的数字，如下所示:

```
/\d{16}/
```

但是如果用户决定将信用卡号分成四个一组怎么办:`5555–5555–5555–5555`。合理，但是上面的选择器不行。要解决这个问题，您可以在四组选择器之间添加连字符，查找四个数字，如下所示:

```
/\d{4}-\d{4}-\d{4}-\d{4}/
```

这是可行的，但是为了同时处理带连字符的数字和普通块，我们需要将连字符设为可选的。我们该怎么做？

```
/\d{4}-?\d{4}-?\d{4}-?\d{4}/
```

没错！那个？修饰符使选择器无论连字符是否存在都可以工作。最后，如果用户使用空格而不是破折号会怎样？向下滚动之前，试着想清楚。

请记住，我们希望该表达式与所有三个选项一起工作:一个块、连字符或空格。

![](img/d4623201881875789e8dc901bf6b124d.png)

为了让这三者都工作，我们希望将连字符和空格组合在一个字符组中，如下所示:

```
/\d{4}[ -]?\d{4}[ -]?\d{4}[ -]?\d{4}/
```

这就对了。这将允许正则表达式选择或匹配信用卡号，无论它是单个块，由连字符分隔，还是由空格分隔。作为额外的奖励，您可以在数字的每一部分加上括号，如下所示:

```
(\d{4})[ -]?(\d{4})[ -]?(\d{4})[ -]?(\d{4})
```

这将允许您单独访问每组四个数字。默认情况下，这些组被命名为 1、2、3 和 4，但也可以给定自定义名称:

```
(?<name1>\d{4})[ -]?(?<name2>\d{4})[ -]?(?<name3>\d{4})[ -]?(?<name4>\d{4})
```

你有它！你现在正在成为一名正则表达式大师。如果你想尝试这些例子或者做进一步的实验，[Regexr.com](https://regexr.com/)是可视化正则表达式如何工作的极好资源。