<html>
<head>
<title>Synchronous Communication — Queries &amp; Cache (Part 2/3)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">同步通信—查询和缓存(第2/3部分)</h1>
<blockquote>原文：<a href="https://medium.com/codex/synchronous-communication-queries-cache-c91124a0aad0?source=collection_archive---------7-----------------------#2022-11-06">https://medium.com/codex/synchronous-communication-queries-cache-c91124a0aad0?source=collection_archive---------7-----------------------#2022-11-06</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="ec69" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">这篇文章探讨了对缓存的需求、挑战以及保持缓存与数据源一致的策略。</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/938030eb6aa1dbd146b604637d902a6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-lLiCl0b76TmuwW8"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">由<a class="ae jn" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae jn" href="https://unsplash.com/@geojango_maps?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> GeoJango Maps </a>拍摄</figcaption></figure><h2 id="8cf9" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">为什么要缓存数据？</h2><p id="8555" class="pw-post-body-paragraph km kn hi ko b kp kq ij kr ks kt im ku jz kv kw kx kd ky kz la kh lb lc ld le hb bi translated">高速缓存的想法是将数据的<strong class="ko hj">副本</strong>存储在离所需位置更近的<strong class="ko hj">位置，或者<strong class="ko hj">将数据保存在更快的数据存储</strong>中，这可以比从数据库读取数据更快地提供查询，或者它甚至可以存储昂贵的计算操作的结果。</strong></p><p id="c6bf" class="pw-post-body-paragraph km kn hi ko b kp lf ij kr ks lg im ku jz lh kw kx kd li kz la kh lj lc ld le hb bi translated">除了<strong class="ko hj">性能</strong>之外，缓存还可以帮助提高<strong class="ko hj">可用性</strong>——如果源不可用(这意味着我们更喜欢可用性而不是一致性)，可伸缩性<strong class="ko hj">——因为它可以通过减少争用来减轻源的压力，&amp;也许<strong class="ko hj">降低总体成本</strong>，这取决于它在基础架构中的实施位置(下一部分将详细介绍)。</strong></p><h2 id="ee59" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">缓存数据的挑战</h2><p id="0a15" class="pw-post-body-paragraph km kn hi ko b kp kq ij kr ks kt im ku jz kv kw kx kd ky kz la kh lb lc ld le hb bi translated">缓存数据是原始数据的快照，随着时间的推移，随着对原始数据的更新，缓存可能会变得与原始数据不一致。因此，<strong class="ko hj">缓存对于经常读取而很少更新的数据是有效的&amp;直接了当的。</strong>然而，对于一个必然会更新的数据模型，我们有一些考虑。</p><p id="e012" class="pw-post-body-paragraph km kn hi ko b kp lf ij kr ks lg im ku jz lh kw kx kd li kz la kh lj lc ld le hb bi translated">该策略必须考虑新鲜或陈旧数据的可接受程度，从而决定缓存过期或失效策略。如果高速缓存中的数据过早过期，则每个读取请求都可能被发送到源，从而违背了高速缓存的目的。如果太高，缓存可能会提供过时的数据。这种考虑是特定于应用程序及其领域的。</p><blockquote class="lk ll lm"><p id="50ef" class="km kn ln ko b kp lf ij kr ks lg im ku lo lh kw kx lp li kz la lq lj lc ld le hb bi translated">源数据的变化率以及刷新数据的缓存策略将决定数据的不一致性。<a class="ae jn" href="https://aws.amazon.com/builders-library/caching-challenges-and-strategies/?did=ba_card&amp;trk=ba_card" rel="noopener ugc nofollow" target="_blank">https://AWS . Amazon . com/builders-library/caching-challenges-and-strategies/？did = ba _ card&amp;trk = ba _ card</a></p></blockquote><h2 id="11c3" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">保持缓存与源一致的策略(尽可能)</h2><ol class=""><li id="3f6d" class="lr ls hi ko b kp kq ks kt jz lt kd lu kh lv le lw lx ly lz bi translated"><strong class="ko hj">部分缓存</strong> —不是缓存所有内容，而是只缓存一些字段。这些字段可能相对稳定，很少更新。</li><li id="3ff2" class="lr ls hi ko b kp ma ks mb jz mc kd md kh me le lw lx ly lz bi translated"><strong class="ko hj">侧缓存(或侧缓存)</strong> —应用程序保持缓存最新。<strong class="ko hj">适用于缓存中的数据必须按需加载的情况</strong>。或者当不支持内联高速缓存(通读或直写)操作时。关于这个模式的更多信息<a class="ae jn" href="https://learn.microsoft.com/en-us/azure/architecture/patterns/cache-aside" rel="noopener ugc nofollow" target="_blank">https://learn . Microsoft . com/en-us/azure/architecture/patterns/cache-aside</a></li></ol><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mf"><img src="../Images/44f34a25fcd5207362ac70597cfcf251.png" data-original-src="https://miro.medium.com/v2/resize:fit:1196/format:webp/1*8fCxTKYOnWRjGJEjW3pYfQ.png"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">缓存备用模式—图片来源<a class="ae jn" href="https://learn.microsoft.com/en-us/azure/architecture/patterns/cache-aside" rel="noopener ugc nofollow" target="_blank">https://learn . Microsoft . com/en-us/azure/architecture/patterns/cache-Aside</a></figcaption></figure><p id="a88e" class="pw-post-body-paragraph km kn hi ko b kp lf ij kr ks lg im ku jz lh kw kx kd li kz la kh lj lc ld le hb bi translated"><strong class="ko hj"> 3。内联缓存</strong> —缓存构成了数据访问API的一部分，缓存对数据访问API的消费者是透明的。线内缓存可以进一步分为以下几类</p><p id="3312" class="pw-post-body-paragraph km kn hi ko b kp lf ij kr ks lg im ku jz lh kw kx kd li kz la kh lj lc ld le hb bi translated"><strong class="ko hj"> 3.1通读缓存</strong> —每个读请求首先在缓存中查找，如果它在缓存中不可用(或者已经无效)，缓存从数据源中读取它，并为将来的查找进行自我更新，然后返回结果。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mg"><img src="../Images/421def61efa6e7cd4e6e1587e7b4d6aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1ffoFW-5iEbTOvFliNi_yQ.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">通读缓存</figcaption></figure><p id="c48c" class="pw-post-body-paragraph km kn hi ko b kp lf ij kr ks lg im ku jz lh kw kx kd li kz la kh lj lc ld le hb bi translated"><strong class="ko hj"> 3.2提前刷新缓存</strong> —为了<strong class="ko hj">减少通读缓存的延迟，并保持缓存中的热对象新鲜</strong>，一些缓存可能支持提前加载数据。如果对象在到期后被访问，这是一个同步调用来读取和呈现结果(类似于通读)。但是，如果在过期前的某个配置时间访问了对象，则返回该值，但是来自源的异步读取会用最新值补充缓存。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mh"><img src="../Images/804c972db0d929dd7c60821e428fc062.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*skUq2V1YbzIjzwxRKTJsww.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated"><strong class="bd jq">提前刷新缓存</strong></figcaption></figure><p id="8ca5" class="pw-post-body-paragraph km kn hi ko b kp lf ij kr ks lg im ku jz lh kw kx kd li kz la kh lj lc ld le hb bi translated"><strong class="ko hj"> 3.3直写缓存</strong> —每次写入都会更新自身和源的缓存。直接用于服务器端缓存。它<strong class="ko hj">减慢写操作</strong>完成时数据被写入两者，高速缓存&amp;原点。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mi"><img src="../Images/d73ffa99981ff93a2aa4e1e11ba64204.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xGK5btKgBE4aBM_ZHrE9KQ.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated"><strong class="bd jq">直写高速缓存</strong></figcaption></figure><p id="8166" class="pw-post-body-paragraph km kn hi ko b kp lf ij kr ks lg im ku jz lh kw kx kd li kz la kh lj lc ld le hb bi translated"><strong class="ko hj"> 3.4后写缓存</strong> —它不同于直写缓存，因为它<strong class="ko hj">通过异步写入原点来加速写入</strong>。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mj"><img src="../Images/ceda26262f3f5be08b621974fe3ec582.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dkkNNvrakCBtp7n76uBmQw.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated"><strong class="bd jq">后写式高速缓存</strong></figcaption></figure><p id="61eb" class="pw-post-body-paragraph km kn hi ko b kp lf ij kr ks lg im ku jz lh kw kx kd li kz la kh lj lc ld le hb bi translated">可以通过查看高速缓存未命中(当在高速缓存中没有找到对象并且从源读取时)与高速缓存命中(当在高速缓存中找到对象时)矩阵来确定高速缓存策略是否有效。</p></div><div class="ab cl mk ml gp mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="hb hc hd he hf"><p id="cd5d" class="pw-post-body-paragraph km kn hi ko b kp lf ij kr ks lg im ku jz lh kw kx kd li kz la kh lj lc ld le hb bi translated">在下一部分中，我将写我们可以在哪里应用缓存，以及它会有什么好处或影响。</p><p id="ffe4" class="pw-post-body-paragraph km kn hi ko b kp lf ij kr ks lg im ku jz lh kw kx kd li kz la kh lj lc ld le hb bi translated">链接到<a class="ae jn" rel="noopener" href="/codex/synchronous-communication-queries-cache-644ffcecf1d9">上一部分</a>涵盖—查询，CQRS&amp;CQRS在不同上下文中的应用。</p><p id="01f5" class="pw-post-body-paragraph km kn hi ko b kp lf ij kr ks lg im ku jz lh kw kx kd li kz la kh lj lc ld le hb bi translated">学分—</p><ul class=""><li id="e4b8" class="lr ls hi ko b kp lf ks lg jz mr kd ms kh mt le mu lx ly lz bi translated"><a class="ae jn" href="https://docs.oracle.com/cd/E15357_01/coh.360/e15723/cache_rtwtwbra.htm#COHDG200" rel="noopener ugc nofollow" target="_blank">https://docs . Oracle . com/CD/e 15357 _ 01/coh . 360/e 15723/cache _ rtwtwbra . htm # cohdg 200</a></li><li id="ae86" class="lr ls hi ko b kp ma ks mb jz mc kd md kh me le mu lx ly lz bi translated"><a class="ae jn" href="https://aws.amazon.com/builders-library/caching-challenges-and-strategies/?did=ba_card&amp;trk=ba_card" rel="noopener ugc nofollow" target="_blank">https://AWS . Amazon . com/builders-library/caching-challenges-and-strategies/？did=ba_card &amp; trk=ba_card </a></li></ul></div></div>    
</body>
</html>