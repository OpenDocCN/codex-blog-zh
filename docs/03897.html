<html>
<head>
<title>How to Partition MySQL Tables</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何划分MySQL表</h1>
<blockquote>原文：<a href="https://medium.com/codex/how-to-partition-mysql-tables-fc2c2fcb6108?source=collection_archive---------8-----------------------#2021-10-05">https://medium.com/codex/how-to-partition-mysql-tables-fc2c2fcb6108?source=collection_archive---------8-----------------------#2021-10-05</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/54dc5fcf03f99985e97a54e2a33fc9f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*m5fFyIFFftYcqFQ-.png"/></div></div></figure><h1 id="d07a" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">水平和垂直分区</h1><p id="41bf" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">有两种类型的数据库分区—垂直的和水平的。</p><h2 id="5324" class="km ir hi bd is kn ko kp iw kq kr ks ja jz kt ku je kd kv kw ji kh kx ky jm kz bi translated">垂直分割</h2><p id="a3bd" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">垂直分区依赖于最初创建较少列的表，然后使用额外的表来存储剩余的列。因为行是根据它们的列来拆分的，所以垂直分区也称为行拆分(与水平分区相反)。到目前为止，MySQL的数据库不支持垂直分区，T2不支持。</p><h2 id="3d8e" class="km ir hi bd is kn ko kp iw kq kr ks ja jz kt ku je kd kv kw ji kh kx ky jm kz bi translated">水平分割</h2><p id="b235" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">分区逻辑将行分成多个表。在整个分区中，列数保持不变，而行数可以变化。我的SQL目前支持水平分区。在这篇文章中，我们将看看MySQL中三种不同的水平分区。</p><h1 id="3973" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">范围划分</h1><p id="31ce" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">实现范围分区时，如果列值在特定分区的指定范围内，则该行将被添加到该分区。</p><h2 id="3853" class="km ir hi bd is kn ko kp iw kq kr ks ja jz kt ku je kd kv kw ji kh kx ky jm kz bi translated">实现范围分区</h2><ol class=""><li id="c693" class="la lb hi jq b jr js jv jw jz lc kd ld kh le kl lf lg lh li bi translated">创建样本表:</li></ol><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="f937" class="km ir hi lo b fi ls lt l lu lv">CREATE TABLE arctype.range_crypto(<br/>  timestamp INT,<br/>  open DOUBLE,<br/>  close INT,<br/>  high DOUBLE,<br/>  low DOUBLE,<br/>  volume DOUBLE,<br/>  );</span></pre><p id="9c9c" class="pw-post-body-paragraph jo jp hi jq b jr lw jt ju jv lx jx jy jz ly kb kc kd lz kf kg kh ma kj kk kl hb bi translated">2.<em class="mb">(可选)</em>用样本数据填充表格。在这种情况下，<a class="ae mc" href="https://gist.github.com/Bamimore-Tomi/54b34a36a2a4f4e895cdd1081f4f4798#file-forex-csv" rel="noopener ugc nofollow" target="_blank">下载这个数据集</a>。然后，将CSV数据导入表中。<br/> <br/> 3。使用<code class="du md me mf lo b">ALTER TABLE</code>表达式创建范围分区:</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="83c7" class="km ir hi lo b fi ls lt l lu lv">ALTER TABLE arctype.range_crypto<br/>  PARTITION BY RANGE (close) (<br/>      partition p0 VALUES LESS THAN (10000),<br/>      partition p1 VALUES LESS THAN (20000),<br/>      partition p2 VALUES LESS THAN (30000),<br/>      partition p3 VALUES LESS THAN (40000),<br/>      partition p4 VALUES LESS THAN (50000),<br/>      partition p5 VALUES LESS THAN (60000),<br/>      partition p6 VALUES LESS THAN  MAXVALUE<br/>  )</span></pre><p id="52a5" class="pw-post-body-paragraph jo jp hi jq b jr lw jt ju jv lx jx jy jz ly kb kc kd lz kf kg kh ma kj kk kl hb bi translated">4.现在，您可以从您创建的任何分区中查询数据:</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="2975" class="km ir hi lo b fi ls lt l lu lv">SELECT * <br/>  FROM arctype.range_crypto PARTITION (p3) <br/>  WHERE close BETWEEN 35000 and 38000;</span></pre><p id="717e" class="pw-post-body-paragraph jo jp hi jq b jr lw jt ju jv lx jx jy jz ly kb kc kd lz kf kg kh ma kj kk kl hb bi translated">相反，如果您运行以下查询:</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="df54" class="km ir hi lo b fi ls lt l lu lv">SELECT * <br/>  FROM arctype.range_crypto PARTITION (p0) <br/>  WHERE close BETWEEN 35000 and 38000;</span></pre><p id="f04f" class="pw-post-body-paragraph jo jp hi jq b jr lw jt ju jv lx jx jy jz ly kb kc kd lz kf kg kh ma kj kk kl hb bi translated">那么结果将是空的。指定分区显示MySQL在哪里查找，使您的查询运行得更快(如果您有数百万行)。</p><p id="2d4b" class="pw-post-body-paragraph jo jp hi jq b jr lw jt ju jv lx jx jy jz ly kb kc kd lz kf kg kh ma kj kk kl hb bi translated">范围分区的另一个变体是<code class="du md me mf lo b">RANGE COLUMNS.</code>,它允许您指定多个分区列。让我们创建一个区间分区，在一段时间内保持一个区间的收盘价。</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="9603" class="km ir hi lo b fi ls lt l lu lv">ALTER TABLE arctype.range_crypto <br/>  PARTITION BY RANGE COLUMNS (timestamp, close) (<br/>    PARTITION from_2018_10k VALUES LESS THAN (1533127192, 10000),<br/>    PARTITION from_2019_20k VALUES LESS THAN (1564663192, 20000),<br/>    PARTITION from_2020_30k VALUES LESS THAN (1596285592,30000),<br/>    PARTITION from_2021_40k VALUES LESS THAN (1627821592,40000 ),<br/>    PARTITION from_latest_highest VALUES LESS THAN (MAXVALUE, MAXVALUE)<br/>  );</span></pre><p id="b318" class="pw-post-body-paragraph jo jp hi jq b jr lw jt ju jv lx jx jy jz ly kb kc kd lz kf kg kh ma kj kk kl hb bi translated">如果您想要查询时间戳在2018年和2019年之间的所有行，其中价格收盘在13500和11600之间，您可以运行如下查询:</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="1f3d" class="km ir hi lo b fi ls lt l lu lv">SELECT * <br/>  FROM arctype.range_crypto PARTITION(from_2019_20k) <br/>  WHERE close BETWEEN 11600 AND 13500</span></pre><h2 id="d270" class="km ir hi bd is kn ko kp iw kq kr ks ja jz kt ku je kd kv kw ji kh kx ky jm kz bi translated">列表分区</h2><p id="2397" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">在列表分区中，对行进行分组的前提是它们在用于分区的列中的值与定义的列表(离散值集)中的值相似。为了客观地看待问题，当您创建分区列表时，MySQL会检查“这一行中的某一列是否有与列表中的值相似的值？”。如果值相同，MySQL会将该行添加到列表中该值的分区中。</p><h2 id="37d6" class="km ir hi bd is kn ko kp iw kq kr ks ja jz kt ku je kd kv kw ji kh kx ky jm kz bi translated">实现列表分区</h2><ol class=""><li id="d2c8" class="la lb hi jq b jr js jv jw jz lc kd ld kh le kl lf lg lh li bi translated">使用以下内容创建示例表:</li></ol><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="890f" class="km ir hi lo b fi ls lt l lu lv">CREATE TABLE arctype.football(<br/>  home_team TEXT,<br/>  away_team TEXT,<br/>  home_goals INT,<br/>  away_goals INT, <br/>  result TEXT,<br/>  season TEXT<br/>  );</span></pre><p id="65ab" class="pw-post-body-paragraph jo jp hi jq b jr lw jt ju jv lx jx jy jz ly kb kc kd lz kf kg kh ma kj kk kl hb bi translated">2.可选-用示例数据填充表格。在这种情况下，<a class="ae mc" href="https://gist.github.com/Bamimore-Tomi/54b34a36a2a4f4e895cdd1081f4f4798#file-football-csv" rel="noopener ugc nofollow" target="_blank">下载这个数据集</a>。</p><ol class=""><li id="68c8" class="la lb hi jq b jr lw jv lx jz mg kd mh kh mi kl lf lg lh li bi translated">现在可以使用<code class="du md me mf lo b">ALTER TABLE</code>表达式创建列表分区。</li></ol><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="85fe" class="km ir hi lo b fi ls lt l lu lv">ALTER TABLE arctype.football<br/>  PARTITION BY LIST (home_goals) (<br/>  PARTITION odd VALUES IN (1,3,5,7,9),<br/>  PARTITION even VALUES IN (0,2,4,6,8)<br/>  );</span></pre><p id="65ed" class="pw-post-body-paragraph jo jp hi jq b jr lw jt ju jv lx jx jy jz ly kb kc kd lz kf kg kh ma kj kk kl hb bi translated">我们现在可以使用刚刚创建的分区编写查询:</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="e111" class="km ir hi lo b fi ls lt l lu lv">SELECT * FROM arctype.football PARTITION(odd) WHERE (home_goals=3);</span></pre><h2 id="e1e2" class="km ir hi bd is kn ko kp iw kq kr ks ja jz kt ku je kd kv kw ji kh kx ky jm kz bi translated">哈希分区</h2><p id="3650" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">在定义前面的分区时，您必须说明哪个列值、范围或列值属于特定的分区。使用哈希分区，您必须为列(或表达式)指定所需的分区数量。MySQL使用<code class="du md me mf lo b">MOD(expression, number of partitions)</code>来确定任何一行属于哪个分区。要理解这是如何工作的，请看这个例子；</p><figure class="lj lk ll lm fd ij er es paragraph-image"><div class="ab fe cl mj"><img src="../Images/73da5aabadf5d3b03f70de516e403030.png" data-original-src="https://miro.medium.com/v2/0*1o8jDeTgCLN-Iq1N"/></div></figure><p id="b256" class="pw-post-body-paragraph jo jp hi jq b jr lw jt ju jv lx jx jy jz ly kb kc kd lz kf kg kh ma kj kk kl hb bi translated">对于第一行，使用<code class="du md me mf lo b">MOD(1,2)=1</code>确定基于<code class="du md me mf lo b">home_goals</code>列它所属的分区。将使用<code class="du md me mf lo b">MOD(2,2)=0</code>选择第三行的分区。如果你和<code class="du md me mf lo b">9 home_goals</code>、<code class="du md me mf lo b">MOD(9,2)=1</code>有虚排。</p><h2 id="cf4d" class="km ir hi bd is kn ko kp iw kq kr ks ja jz kt ku je kd kv kw ji kh kx ky jm kz bi translated">实现范围分区</h2><p id="b44d" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">您可以使用相同的<code class="du md me mf lo b">ALTER TABLE</code>语句在MySQL中实现范围分区。</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="a761" class="km ir hi lo b fi ls lt l lu lv">ALTER TABLE arctype.football<br/>PARTITION BY HASH (home_goals)<br/>PARTITIONS 2;</span></pre><h1 id="61b4" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">结论</h1><p id="5aec" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">一般来说，分区可以加快你的搜索速度。虽然这是正确的，但分区的效果在较小的表中并不明显。因此，如果您的查询执行缓慢，并且您的数据库表不包含数百万行，那么您应该在拆分表之前考虑其他优化方法。</p><h2 id="eb1a" class="km ir hi bd is kn ko kp iw kq kr ks ja jz kt ku je kd kv kw ji kh kx ky jm kz bi translated">进一步阅读</h2><ol class=""><li id="3396" class="la lb hi jq b jr js jv jw jz lc kd ld kh le kl lf lg lh li bi translated"><a class="ae mc" href="https://en.wikipedia.org/wiki/Partition_(database)" rel="noopener ugc nofollow" target="_blank">https://en . Wikipedia . org/wiki/Partition _(database)</a></li><li id="da4d" class="la lb hi jq b jr mk jv ml jz mm kd mn kh mo kl lf lg lh li bi translated"><a class="ae mc" href="https://dev.mysql.com/doc/refman/8.0/en/partitioning.html" rel="noopener ugc nofollow" target="_blank">https://dev.mysql.com/doc/refman/8.0/en/partitioning.html</a></li><li id="fb02" class="la lb hi jq b jr mk jv ml jz mm kd mn kh mo kl lf lg lh li bi translated"><a class="ae mc" href="https://www.w3resource.com/mysql/mysql-partition.php" rel="noopener ugc nofollow" target="_blank">https://www.w3resource.com/mysql/mysql-partition.php</a></li></ol></div></div>    
</body>
</html>