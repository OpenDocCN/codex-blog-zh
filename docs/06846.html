<html>
<head>
<title>Object-oriented Programming in Python — Lesson 4. Some boring design Patterns</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的面向对象编程——第4课。一些无聊的设计模式</h1>
<blockquote>原文：<a href="https://medium.com/codex/object-oriented-programming-in-python-lesson-4-some-boring-design-patterns-ee01a81030c3?source=collection_archive---------11-----------------------#2022-05-16">https://medium.com/codex/object-oriented-programming-in-python-lesson-4-some-boring-design-patterns-ee01a81030c3?source=collection_archive---------11-----------------------#2022-05-16</a></blockquote><div><div class="dt gx gy gz ha hb"/><div class="hc hd he hf hg"><figure class="hi hj fa fc hk hl es et paragraph-image"><div role="button" tabindex="0" class="hm hn di ho bf hp"><div class="es et hh"><img src="../Images/db150015c62a9d2cc7c7b546d8cfe04a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7J21pAqU1ko5EvRTKJI2-g.png"/></div></div></figure><div class=""/><p id="1bac" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated">这是五课系列中的第四课，总结了面向对象编程的实际需要，并介绍了面向对象语言提供的常用工具。这些例子是用Python编写的，强调了Python的实现和方法。在前面的章节中，我们学到了面向对象编程的基本词汇:功能<em class="jp">可替代性</em>——使用<em class="jp">消息</em>范例——的<em class="jp">对象</em>，其行为和数据封装在<em class="jp">类</em>中。然后，基于在实践中应用面向对象的设计必须<em class="jp">遵守</em>的观察，遵循已建立的习惯用法、模式和架构，我们深入研究了一些“重量级”多态设计模式应用的详细示例，集中在递归数据结构上。相比之下，第四课以低调的方式进行，考虑一些几乎每天都需要的次要设计模式，它们的实现在Python这样的动态“鸭式”语言中得到了简化。</p><h2 id="2187" class="jq jr hu bd js jt ju jv jw jx jy jz ka jc kb kc kd jg ke kf kg jk kh ki kj kk bi translated">本课中的部分:</h2><ol class=""><li id="b444" class="kl km hu it b iu kn iy ko jc kp jg kq jk kr jo ks kt ku kv bi translated">“动态可插入工厂”模式语言，按类型(基于“工厂方法”)</li><li id="3c92" class="kl km hu it b iu kw iy kx jc ky jg kz jk la jo ks kt ku kv bi translated">“动态可插拔工厂”模式语言，举例来说(“基于原型”)</li><li id="143e" class="kl km hu it b iu kw iy kx jc ky jg kz jk la jo ks kt ku kv bi translated">“访问者”模式，重新审视。</li></ol></div><div class="ab cl lb lc gq ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="hc hd he hf hg"><h2 id="e44f" class="jq jr hu bd js jt ju jv jw jx jy jz ka jc kb kc kd jg ke kf kg jk kh ki kj kk bi translated">1.“动态可插拔工厂”，按类型</h2><p id="1036" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc li je jf jg lj ji jj jk lk jm jn jo hc bi translated">一个完整的设计模式融合了两个视角。(1)从需求角度来看，设计模式是在<em class="jp">上下文</em>中对<em class="jp">问题</em>的<em class="jp">响应</em>。(2)从实现的角度来看，它是一种<em class="jp">模式</em>(顾名思义)，用于在空间中排列项目，向(潜在用户)建议功能。(我使用术语“项目”和“空间”，而不是“代码构造”和“程序”，以尊重建筑架构的原始设计模式，它启发了我们的软件设计模式)。除此之外，还有一个至关重要的约束:“重复一百万次，它(设计模式实现)将永远不会相同！”也就是说，一个诚实的设计模式可能永远不会被简化为一个通用的可重用工件，比如函数、类模板、基类等等。</p><p id="9a47" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated">然而，可悲的事实是，尽管后一种约束对于一些软件设计的结构化和多态模式(例如第2章中讨论的“复合”模式)来说确实是真实的，但是一些软件的规范设计模式却很难做到这一点。一些次要的设计模式可能——并且已经——被自动化了。软件的一些设计模式所应对的一些问题是依赖于平台的，是自己造成的。</p><p id="bad4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated">“动态可插拔工厂”是一种<em class="jp">模式语言</em>，涉及三种模式——<em class="jp">工厂</em>、<em class="jp">单例、</em>和<em class="jp">工厂方法</em>——以及<em class="jp">注册</em>和<em class="jp">映射关键字到功能</em>的习惯用法。</p><p id="c4f5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated">例如，考虑一个<em class="jp">消息工厂</em>，它使应用程序能够以多种形式接收消息<em class="jp">(也就是说，不需要明确地知道具体接收了什么，并且有多种和无限的选择)。这个问题的复杂性的关键在于，在<em class="jp">面向对象的</em>范例中，“接收”这样的消息必须涉及<em class="jp">创建</em>一个自治的、封装的消息<em class="jp">对象</em>，这进一步要求预定义一个消息<em class="jp">类</em>，以及它的不止一个具体子类(考虑到消息类型的结构——以及可能的功能——多样性)。这个重要的架构并没有指出面向对象范例的不足。复杂性是问题领域固有的。面向对象的解释通过阐明和形式化其复杂性，促进精确处理，公正地对待问题。(相比之下，另一种选择是忽略复杂性，并且不可避免地浪费大量时间通过试错来找到它)。因此，给定消息id和原始消息块，消息工厂能够安静地创建正确消息类型的消息。</em></p><p id="b930" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated"><em class="jp">进入“注册”习语！</em>(只是“习语”——还没酷到配得上“设计模式”的称号)。</p><p id="949f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated">消息工厂的设计是<em class="jp"> open </em>(用于扩展)。使用每个消息id的消息创建者的<em class="jp">注册</em>从工厂中删除了所有可用的具体消息类型的知识。相反，将这种解决方案与“开关/案例”机制的原型替代方案进行比较，在该方案中，所有消息类型——以及原始消息布局和从块中序列化它们的能力——都必须预先知道，并且在使用上下文中显式。虽然这种替代方法对于小而有限的消息类型仍然有效，例如在message-id <em class="jp">枚举中，</em>但它在现实世界的消息传递系统中没有用，在现实世界中，消息类型(及其处理)通常是由第三方动态添加的。因此，这里我们可能需要做的最后一件事就是硬编码消息类型、它们的布局和它们的创建过程！</p><p id="b8fd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated">术语“动态可插拔工厂”是由John Vlissides(以“四人帮”闻名)在《面向对象编程杂志》的一篇文章中提出的，他详细阐述了规范的<em class="jp">抽象工厂</em>模式，引入了两个额外的特性:(1)它是<em class="jp">动态的</em>(特点是能够通过<em class="jp">添加</em>主题类型来创建)和(2) <em class="jp">可插拔的</em>(要创建的类型，以及它们的创建过程，是从之外的<em class="jp">中积累而来的)。</em></p><p id="c4d9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated"><em class="jp">以下是动态可插拔工厂功能的总结:</em></p><p id="cbd8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated">消息工厂将<em class="jp"> message-id </em>映射到<em class="jp">“创建消息(给定原始消息块)的能力”</em>。特别是:</p><ol class=""><li id="8ca4" class="kl km hu it b iu iv iy iz jc ll jg lm jk ln jo ks kt ku kv bi translated">消息工厂能够“创建消息”，使用消息id和消息块，给出消息对象。</li><li id="5cbd" class="kl km hu it b iu kw iy kx jc ky jg kz jk la jo ks kt ku kv bi translated">消息工厂能够“注册消息创建者”，使用message-id和一个(匿名)消息创建者。消息工厂不知道消息创建者和消息(后者创建的)的类型。</li></ol><p id="90e9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated"><em class="jp">输入“独生子女”！</em></p><p id="935b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated">在哪里可以找到这个信息工厂？显然，我们的消息工厂必须是<em class="jp">Singleton</em>——另一种设计模式。作为单例意味着(1)只有一个，以及(2)它总是可访问的和准备好的(当需要的时候)。考虑一下允许多个消息工厂(每个工厂中有不同数量的消息创建者)的实现会导致什么样的混乱。显然，在一个健全的宇宙中，肯定只有一个消息工厂，而且它必须是全球性的T21，对所有人都可用。</p><p id="705f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated">一个“单例”实体封装了一个全局可用的<em class="jp">资源</em>。在严格的(Pythonic之前的)<em class="jp">面向对象的</em>解释中，它曾经被实现为一个<em class="jp">类</em>，该类保证有一个<em class="jp">实例</em>。为什么要达到这个长度——类、实例——而不是仅仅分配一个全局字典对象呢？虽然全局变量确实是全局可用的，但我们不能保证(在许多编程语言中)它将被完全初始化并在需要时可用(例如，在初始化时被另一个全局对象使用)。</p><p id="8b05" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated">与一些人的直觉相反，是第二个品质(需要时做好准备)——而不是第一个品质(只有一个这样的品质)造就了独生子女！例如，在基于应用程序框架的设计中，考虑应用程序。只有一个应用程序。但是应用程序的单一性(只有一个这样的)仍然不能使它成为单一的！这里不需要有保证的就绪机制，因为没有人从外部处理应用程序。相反，是应用程序从内部解决其他所有人的问题。并且不需要按需创建。应用程序是在程序入口点静态创建的，这已经足够好了。</p><p id="8aa4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated"><em class="jp">下面是单例功能的总结:</em></p><ol class=""><li id="7302" class="kl km hu it b iu iv iy iz jc ll jg lm jk ln jo ks kt ku kv bi translated">“Singleton”被实现为一个被限制(程序上)为单个实例的类。</li><li id="6197" class="kl km hu it b iu kw iy kx jc ky jg kz jk la jo ks kt ku kv bi translated">Singleton <em class="jp">类</em>能够显示Singleton实例。(是的，类本身就是一个对象，有自己的方法！)</li><li id="e525" class="kl km hu it b iu kw iy kx jc ky jg kz jk la jo ks kt ku kv bi translated">singleton实例——类的隐藏成员(而不是任何对象)——由第一个访问请求初始化(通常，如果它不存在，通过测试)。</li><li id="44bb" class="kl km hu it b iu kw iy kx jc ky jg kz jk la jo ks kt ku kv bi translated">此外，在必要的情况下，Singleton实例可以是线程安全的(避免并发初始化，这可能导致多个“Singleton”实例的意外增长，其中只有一个实例是全局可用的)。</li></ol><p id="1853" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated"><em class="jp">进入“工厂法”！</em></p><p id="ad29" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated">然后，一个<em class="jp">在消息工厂注册</em>到底是为了什么？在<em class="jp">消息创建器的必需功能背后隐藏着什么魔力？</em>完成模式语言的最后一个模式是“工厂方法”。一个<em class="jp">工厂方法</em>能够创建一个某种类型的对象，并且只能创建该类型的对象(并且该类型对于客户端来说是未知的)。拥有工厂方法使客户能够创建适当类型的对象，同时不必知道该类型是什么。(这可能很难解释，但在许多编程环境中是一个合理的要求)。显然，工厂方法自然适合动态可插拔工厂中“创建者”的角色。</p><p id="56f1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated">非常不方便的是，在规范的工厂方法解决方案中，为了迎合强类型语言，所需的工厂方法必须形成与主题(例如，消息)层次结构平行的类层次结构。虽然在面向对象的解释中，每个消息必须作为一个类来实现，并且所有这些类必须从抽象类message中派生，但是我们必须在此之上添加一个<em class="jp">并行</em>消息创建者层次结构，每个创建者一个。</p><figure class="lp lq lr ls fe hl es et paragraph-image"><div class="es et lo"><img src="../Images/a9118ef527f0769ad1a9abe7f4c6422e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1368/format:webp/1*QtucYUIIkGLVHU_k2WNf6A.png"/></div></figure><p id="071e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated">如前所述，这很麻烦！然而，在支持泛型的地方(例如，在C++中)，使用适当的类模板基础结构，定义特定的消息创建者可以简化为一个宏调用。因此，这消除了(API用户的)复杂性。</p><p id="ca53" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated">下面是一个用Python“按常规”呈现动态可插拔消息工厂的(相当强迫的)尝试:</p><figure class="lp lq lr ls fe hl"><div class="bz dz l di"><div class="lt lu l"/></div></figure><p id="2aa0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated"><em class="jp">脚注:</em></p><ol class=""><li id="d239" class="kl km hu it b iu iv iy iz jc ll jg lm jk ln jo ks kt ku kv bi translated">所有消息都以相同的标题开始。</li><li id="88d1" class="kl km hu it b iu kw iy kx jc ky jg kz jk la jo ks kt ku kv bi translated">将从所有者消息中接收消息id和大小。</li><li id="1dcf" class="kl km hu it b iu kw iy kx jc ky jg kz jk la jo ks kt ku kv bi translated">数据大小供第三方使用(本例中未使用)。</li><li id="24e0" class="kl km hu it b iu kw iy kx jc ky jg kz jk la jo ks kt ku kv bi translated">为了简单起见，消息被编码为具有固定大小字段的纯文本。</li><li id="eaa0" class="kl km hu it b iu kw iy kx jc ky jg kz jk la jo ks kt ku kv bi translated">抽象基础<em class="jp">消息</em>只负责报头。数据是特定于子类的。</li><li id="72c9" class="kl km hu it b iu kw iy kx jc ky jg kz jk la jo ks kt ku kv bi translated">首先对报头进行序列化，然后是数据。缓冲区(在本例中)是由消息创建的。</li><li id="4cf2" class="kl km hu it b iu kw iy kx jc ky jg kz jk la jo ks kt ku kv bi translated">首先是头被反序列化，然后是数据。</li><li id="baf3" class="kl km hu it b iu kw iy kx jc ky jg kz jk la jo ks kt ku kv bi translated">数据序列化是特定于子类的。</li><li id="b80f" class="kl km hu it b iu kw iy kx jc ky jg kz jk la jo ks kt ku kv bi translated">数据反序列化是子类特定的。</li><li id="18a5" class="kl km hu it b iu kw iy kx jc ky jg kz jk la jo ks kt ku kv bi translated">消息创建者可以创建一些消息。</li><li id="20ac" class="kl km hu it b iu kw iy kx jc ky jg kz jk la jo ks kt ku kv bi translated">Get-id用于注册。</li><li id="a275" class="kl km hu it b iu kw iy kx jc ky jg kz jk la jo ks kt ku kv bi translated">单例实例隐藏在类中。</li><li id="32a9" class="kl km hu it b iu kw iy kx jc ky jg kz jk la jo ks kt ku kv bi translated">工厂方法创建者通过消息id注册。</li><li id="6264" class="kl km hu it b iu kw iy kx jc ky jg kz jk la jo ks kt ku kv bi translated">消息的创建会以静默方式委托给注册的创建者。</li><li id="49f3" class="kl km hu it b iu kw iy kx jc ky jg kz jk la jo ks kt ku kv bi translated">单一实例是按需创建的。该实现不期望并发。</li><li id="9d58" class="kl km hu it b iu kw iy kx jc ky jg kz jk la jo ks kt ku kv bi translated">消息队列存储消息缓冲区(而不是对象！)</li><li id="9f00" class="kl km hu it b iu kw iy kx jc ky jg kz jk la jo ks kt ku kv bi translated">要存储的消息被反序列化。</li><li id="fcda" class="kl km hu it b iu kw iy kx jc ky jg kz jk la jo ks kt ku kv bi translated">从存储的报头中提取消息id。</li><li id="35d5" class="kl km hu it b iu kw iy kx jc ky jg kz jk la jo ks kt ku kv bi translated">单体消息工厂使用message-id创建适当的消息。</li><li id="657b" class="kl km hu it b iu kw iy kx jc ky jg kz jk la jo ks kt ku kv bi translated">空消息从缓冲区序列化。</li></ol><p id="9840" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated">人们不必是Python专家，也能明显看出这种设计需要简化，去掉一些多余的细节。这又让我们看到，这种模式语言最初要解决的一些<em class="jp">小问题</em>是平台依赖的，是自己造成的！(不否认整个动态可插拔工厂问题本身的有效性和有用性！)</p><p id="4e6a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated">特别是，以下Python特性在这里可能会很有用:</p><ol class=""><li id="eaae" class="kl km hu it b iu iv iy iz jc ll jg lm jk ln jo ks kt ku kv bi translated"><em class="jp">模块</em>的可用性。Python模块很容易满足单例的这两个要求。(1)只有一个这样的请求(不执行两次<code class="dv lv lw lx ly b">import</code>请求)。以及(2)当从另一个模块寻址时，保证该模块被完全初始化(在此之前必须已经有一个<code class="dv lv lw lx ly b">import</code>请求)，(递归导入循环除外，它无论如何都是无效的)。</li><li id="706e" class="kl km hu it b iu kw iy kx jc ky jg kz jk la jo ks kt ku kv bi translated">你可以把整个模块看作是单例的模块，或者是存在于模块内部的对象——两种方法都可以。在任何情况下，都不需要请求任何人<em class="jp">揭示</em>(并创建)实例！</li><li id="07cc" class="kl km hu it b iu kw iy kx jc ky jg kz jk la jo ks kt ku kv bi translated">Python中的<em class="jp">类</em>对象的可用性。当对象创建只是简单的初始化(使用提供的特定消息构造函数)时，类对象就足够了。实际上很少有必要去定义一个并行的创建者层次结构。</li></ol><p id="b675" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated"><em class="jp">这里是动态可插拔工厂的“本地”Python渲染:</em></p><figure class="lp lq lr ls fe hl"><div class="bz dz l di"><div class="lt lu l"/></div></figure><p id="e654" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated"><em class="jp">脚注:</em></p><ol class=""><li id="bff3" class="kl km hu it b iu iv iy iz jc ll jg lm jk ln jo ks kt ku kv bi translated">邮件及其标题不受更改的影响。</li><li id="9253" class="kl km hu it b iu kw iy kx jc ky jg kz jk la jo ks kt ku kv bi translated">(单例)消息工厂被简化为一个字典对象。</li><li id="3e0f" class="kl km hu it b iu kw iy kx jc ky jg kz jk la jo ks kt ku kv bi translated">传入消息按其类型初始化，并在工厂对象中注册。</li><li id="3e59" class="kl km hu it b iu kw iy kx jc ky jg kz jk la jo ks kt ku kv bi translated">消息创建者注册基于本机类型。未使用用户定义的创建者。</li></ol></div><div class="ab cl lb lc gq ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="hc hd he hf hg"><h2 id="1fcb" class="jq jr hu bd js jt ju jv jw jx jy jz ka jc kb kc kd jg ke kf kg jk kh ki kj kk bi translated">3.例如“动态可插拔工厂”</h2><p id="9a23" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc li je jf jg lj ji jj jk lk jm jn jo hc bi translated">基于工厂方法的动态可插拔工厂解决了将消息id映射到消息对象的需要。因此，当输入(类型提示)和输出(该类型的某个对象)之间存在这种一对一的关联时，以及当默认情况下创建对象<em class="jp"/>时，这是很有用的。但是它没有解决创建对象的需要，尽管这些对象由输入提示决定，但不一定是不同的类型！我们可能需要使用一个工厂来通过示例填充我们的世界<em class="jp">:使用由<em class="jp">内容</em>以及<em class="jp">类型确定的对象！</em></em></p><p id="ad30" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated">后一种需求的一个例子是GUI工厂(动态的和可插拔的)，用于可视化地创建形状<em class="jp"/>，这意味着不(必须)按类型，但也按内容。这里的创建提示将是一个<em class="jp">图标</em>——一个可见的例子。图形编辑器的用户从工具箱拖动(复制)对象到画布。此外，用户还可以从画布中选择一个形状，并将其拖到工具箱中，从而添加另一个图标供选择。</p><figure class="lp lq lr ls fe hl es et paragraph-image"><div class="es et lz"><img src="../Images/8dd81439a8b031ed6ad76c7e74f6a3ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1012/format:webp/1*QxaOiY71BDaWUpB-YXBz1g.png"/></div></figure><p id="315e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated">在面向对象的解释中，这个例子必须由适当类型<em class="jp">和内容的对象支持！没有必要为这项工作开发工厂方法。操作对象已经装备了所有需要的东西。</em></p><p id="e5e6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated">在这个解决方案中，工厂注册对象(与要创建的对象类型相同)，通常响应<code class="dv lv lw lx ly b">clone</code>，返回对象的副本(“克隆”)。</p></div><div class="ab cl lb lc gq ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="hc hd he hf hg"><h2 id="b148" class="jq jr hu bd js jt ju jv jw jx jy jz ka jc kb kc kd jg ke kf kg jk kh ki kj kk bi translated">4.“访问者”模式再探</h2><p id="ed92" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc li je jf jg lj ji jj jk lk jm jn jo hc bi translated">其他可以用Python这样的鸭式语言简化的设计模式是高度多态的模式，如“访问者”模式，其中可替换性依赖于密集的继承层次。例如，这里是“访问者”模式的简化版本(在本系列的第3章中详细讨论)，集中在<em class="jp">接受/访问</em>循环上。</p><p id="e45b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated">但首先，简单提醒一下。对形状的许多操作是可能的，由于某种原因，必须从外部进行。虽然这些功能涉及形状数据和可能的内在形状逻辑，但它们可能不是形状的方法，因为它们同样依赖于其他机器和基础设施，而这些机器和基础设施不是特定于形状的，并且是可配置的。例如，<em class="jp">显示形状</em>。虽然这种能力当然依赖于获得形状的尺寸并知道如何处理它们(例如，圆的半径)，但它还涉及显示技术的类型(矢量或像素图形)、屏幕分辨率、放大倍数、纵横比、字体的使用等等，这些都与形状无关，可以随意重新配置。</p><p id="10bc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated">这个问题域的特点是<em class="jp">双多态</em>——形状的类型和它的操纵器的类型都是可替换的。但却是<em class="jp">不对称</em>。操纵者需要形状。事实上，所有的操纵器类型都需要预先知道所有的形状类型(以操纵它们中的每一个)。但是这些形状与操纵器指令无关，就他们所知，这些指令是不确定的。他们只是授予操纵器(这里称为“访问者”)访问权限，不管它是什么。</p><p id="e9a8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated">这个问题有不止一个既定的解决方案。这里我们应用传统的<em class="jp">面向对象</em>“访问者”模式，它使用了<em class="jp">双分派</em>的习语。访问者对形状的每个操作请求都包含两个多态消息:从访问者到形状和从形状到访问者。</p><p id="0daa" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated">首先，这是一个“按常规”的(相当强迫的)解决方案，其特点是一个<code class="dv lv lw lx ly b">accept </code>方法的<em class="jp">多态</em>实现。</p><figure class="lp lq lr ls fe hl"><div class="bz dz l di"><div class="lt lu l"/></div></figure><ol class=""><li id="b570" class="kl km hu it b iu iv iy iz jc ll jg lm jk ln jo ks kt ku kv bi translated">一个形状(它是任何形状的接口)能够接受一个“形状访问者”，无论后者能够进行什么操作。注意“Shape Visitor”是正向声明！(稍后将定义该类)。</li><li id="8202" class="kl km hu it b iu kw iy kx jc ky jg kz jk la jo ks kt ku kv bi translated"><code class="dv lv lw lx ly b">accept</code>的具体<em class="jp"> Circle </em>实现引导访问者访问该对象，揭示其作为一个圆的真实性质。</li><li id="03da" class="kl km hu it b iu kw iy kx jc ky jg kz jk la jo ks kt ku kv bi translated">“形状访问者”是任何形状操纵器的接口，能够<em class="jp">访问</em>每个已知的形状类型。(因此，所有形状类型都必须事先知道！)该方法是特定于子类的。</li><li id="c798" class="kl km hu it b iu kw iy kx jc ky jg kz jk la jo ks kt ku kv bi translated">“形状画家”是一个具体的形状访问者，以所有已知形状类型的具体<code class="dv lv lw lx ly b">visit</code>方法为特色。</li><li id="f56e" class="kl km hu it b iu kw iy kx jc ky jg kz jk la jo ks kt ku kv bi translated">要求形状绘制者绘制一个匿名形状(例如，一行中的一个)。它不需要知道形状的真实类型来完成这项工作(或者是吗？).它请求这个形状，不管它是什么，去<em class="jp">接受</em>它，这将最终以形状画家请求<em class="jp">访问</em>特定形状而结束。(因为形状知道自己的类型！)</li><li id="b90d" class="kl km hu it b iu kw iy kx jc ky jg kz jk la jo ks kt ku kv bi translated">一个即时创建的形状绘制者被要求绘制一个形状——实际上是一个圆形，也是即时创建的。</li></ol><p id="cfa4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated">这个<em class="jp">接受</em>方法的等级制度显然是多余的。所有的<code class="dv lv lw lx ly b">accept </code>方法都是相同的，唯一的区别是名称的形状类型部分。利用Python对元数据的轻松访问，我们可以将访问者方法选择功能集中在基本形状中，<em class="jp">如下:</em></p><figure class="lp lq lr ls fe hl"><div class="bz dz l di"><div class="lt lu l"/></div></figure><p id="9a5a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated"><em class="jp">脚注:</em></p><ol class=""><li id="1fa5" class="kl km hu it b iu iv iy iz jc ll jg lm jk ln jo ks kt ku kv bi translated">虽然Shape只是一个接口，但是它没有抽象方法<em class="jp"/>,因此，在这里子类化ABC是没有意义的。</li><li id="1cff" class="kl km hu it b iu kw iy kx jc ky jg kz jk la jo ks kt ku kv bi translated"><code class="dv lv lw lx ly b">accept</code>是基础形状的一个具体方法，它不意味着被子类形状覆盖。</li><li id="4706" class="kl km hu it b iu kw iy kx jc ky jg kz jk la jo ks kt ku kv bi translated">在公共的<em class="jp"> accept </em>中，构造了所需的访问者方法名(根据前缀“visit”和实际的类名)。尽管该方法在基本形状中是“硬编码”的，但在运行时，它将检索响应消息的实际形状的类，例如，<em class="jp"> Circle </em>。我们可以肯定它永远不会是<em class="jp">形状，因为</em>我们不打算创造这样的物体。</li><li id="feee" class="kl km hu it b iu kw iy kx jc ky jg kz jk la jo ks kt ku kv bi translated">这个解决方案不需要预先知道所有的形状类型，冒着尝试访问不支持的形状的风险！</li><li id="c7f6" class="kl km hu it b iu kw iy kx jc ky jg kz jk la jo ks kt ku kv bi translated">通用的<em class="jp"> accept </em>方法从这个对象的字典中检索适当的函数(通过构造的名字)并使用这个对象激活它。</li><li id="e03f" class="kl km hu it b iu kw iy kx jc ky jg kz jk la jo ks kt ku kv bi translated">在这个解决方案中，具体的形状不覆盖<code class="dv lv lw lx ly b">accpet</code>！</li><li id="1734" class="kl km hu it b iu kw iy kx jc ky jg kz jk la jo ks kt ku kv bi translated">形状访问者及其实现不受更改的影响。</li></ol><p id="75e2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated">最后，给定这个简单的基于名称的运行时调度，整个双重调度策略就变得多余了！如果我们将分派机制从Shape中移除，并将其放入基本访问者中，我们最终会得到一个不关心访问者存在的Shape层次结构和一个关心发现其自身方法的Shape访问者层次结构。这是一个简单实用的面向对象的解决方案，其中每个对象都被限制在自己的职责范围内，从问题域中消除了跨层次的双重分派噪音。我们仍然有双重分派(我们在两次调用中到达所需的方法)，但是它隐藏在访问者层次结构中。</p><figure class="lp lq lr ls fe hl"><div class="bz dz l di"><div class="lt lu l"/></div></figure><p id="d9f8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hc bi translated"><em class="jp">脚注:</em></p><ol class=""><li id="647d" class="kl km hu it b iu iv iy iz jc ll jg lm jk ln jo ks kt ku kv bi translated">形状是无辜的所有知识的游客层次。</li><li id="4b94" class="kl km hu it b iu kw iy kx jc ky jg kz jk la jo ks kt ku kv bi translated">调度现在位于抽象的基本访问者。</li></ol><h2 id="d0d5" class="jq jr hu bd js jt ju jv jw jx jy jz ka jc kb kc kd jg ke kf kg jk kh ki kj kk bi translated">5.接下来呢？</h2><p id="0bf7" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc li je jf jg lj ji jj jk lk jm jn jo hc bi translated">在前四课中，我们介绍了针对功能可替代性设计挑战的面向对象解决方案:消息范式，涉及将一条<em class="jp">消息</em>传递给一个<em class="jp">未知</em>类型的对象，在运行时由它的<em class="jp">类</em>中的<em class="jp">方法</em>(同名)解析。我们已经看到Python的“duck typing”是如何在任何非正式但语义上与<em class="jp">相关的</em>类型中实现可替换性的。为了强调根据既定实践进行面向对象设计和编程的重要性，我们经历了一些主要的设计模式，比如复合和访问者。然后，我们考虑了一些次要的设计模式，如动态可插拔工厂、单例模式和原型模式，利用Python对元数据的方便访问来简化它们的实现。在剩下的课程中，我们将考虑继承层次结构中不为人所知的过程方面，总结Python面向对象基础设施所带来的设计机会，并以我们开始的主题——也是整个系列的支柱——结束，讨论可替代性原则。</p><h2 id="ebc7" class="jq jr hu bd js jt ju jv jw jx jy jz ka jc kb kc kd jg ke kf kg jk kh ki kj kk bi translated">本课程的课程:</h2><ol class=""><li id="25ac" class="kl km hu it b iu kn iy ko jc kp jg kq jk kr jo ks kt ku kv bi translated"><a class="ae ma" rel="noopener" href="/codex/object-oriented-programming-in-python-lesson-1-substitutability-and-inheritance-e5c6661dfca5">可替代性和继承性</a></li><li id="4176" class="kl km hu it b iu kw iy kx jc ky jg kz jk la jo ks kt ku kv bi translated"><a class="ae ma" rel="noopener" href="/codex/object-oriented-programming-in-python-chapter-2-the-composite-pattern-4b7da542d5b0">面向对象可替代性的荣耀:“复合”模式</a></li><li id="1d61" class="kl km hu it b iu kw iy kx jc ky jg kz jk la jo ks kt ku kv bi translated"><a class="ae ma" rel="noopener" href="/codex/object-oriented-programming-in-python-chapter-3-the-visitor-pattern-d0b176d4807d">面向对象可替代性的限制:“访问者”模式</a></li><li id="f1e6" class="kl km hu it b iu kw iy kx jc ky jg kz jk la jo ks kt ku kv bi translated"><strong class="it hv">一些无聊的设计图案</strong> <em class="jp"> ←(你来了！)</em></li><li id="4ac3" class="kl km hu it b iu kw iy kx jc ky jg kz jk la jo ks kt ku kv bi translated">继承的限制</li></ol></div></div>    
</body>
</html>