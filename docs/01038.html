<html>
<head>
<title>A complete guide to architect your Flutter application</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建您的Flutter应用程序的完整指南</h1>
<blockquote>原文：<a href="https://medium.com/codex/a-complete-guide-to-architect-your-flutter-application-a5a4da662549?source=collection_archive---------3-----------------------#2021-04-01">https://medium.com/codex/a-complete-guide-to-architect-your-flutter-application-a5a4da662549?source=collection_archive---------3-----------------------#2021-04-01</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="eeb0" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">介绍</h1><p id="52ce" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">回到2018年，当我开始学习Flutter时，我花了很多精力，因为我发现跨平台开发非常有用和高效。从Android应用程序开发背景来看，最初，理解Flutter框架以及它如何管理应用程序状态需要一段时间。但是后来，我发现Flutter有很大的潜力。</p><p id="9da3" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">在使用Flutter时，我使用了很多状态管理方法，但是由于没有官方推荐的方法，所以很难说哪一种是最好的。</p><p id="32ce" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">如前所述，来自Android背景，我发现<a class="ae kg" href="https://pub.dev/packages/stacked" rel="noopener ugc nofollow" target="_blank">堆栈</a>插件非常容易用来设计Flutter应用程序。在本文中，我将展示如何使用堆叠框架设计和架构Flutter应用程序。</p></div><div class="ab cl kh ki gp kj" role="separator"><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km"/></div><div class="hb hc hd he hf"><h1 id="38c5" class="if ig hi bd ih ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc bi translated">目标</h1><p id="a72f" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">在本文中，我们将了解如何:</p><ul class=""><li id="0f47" class="kt ku hi jf b jg kb jk kc jo kv js kw jw kx ka ky kz la lb bi translated">使用堆叠插件设置Flutter应用程序的基础架构</li><li id="61f9" class="kt ku hi jf b jg lc jk ld jo le js lf jw lg ka ky kz la lb bi translated">使用依赖注入进行层分离</li><li id="d61a" class="kt ku hi jf b jg lc jk ld jo le js lf jw lg ka ky kz la lb bi translated">代码生成器，为DI、routes和JSON解析生成样板代码</li><li id="84b0" class="kt ku hi jf b jg lc jk ld jo le js lf jw lg ka ky kz la lb bi translated">使用改进的插件进行API调用(大多数Android开发人员可能对此很熟悉)</li></ul><p id="ddbc" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">除了基本的架构设置，本文还演示了</p><ul class=""><li id="0586" class="kt ku hi jf b jg kb jk kc jo kv js kw jw kx ka ky kz la lb bi translated">项目结构</li><li id="2843" class="kt ku hi jf b jg lc jk ld jo le js lf jw lg ka ky kz la lb bi translated">使用视图模型导航(无上下文)</li><li id="2ad4" class="kt ku hi jf b jg lc jk ld jo le js lf jw lg ka ky kz la lb bi translated">屏幕之间轻松共享数据</li><li id="16e9" class="kt ku hi jf b jg lc jk ld jo le js lf jw lg ka ky kz la lb bi translated">还有几个…</li></ul></div><div class="ab cl kh ki gp kj" role="separator"><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km"/></div><div class="hb hc hd he hf"><h1 id="2784" class="if ig hi bd ih ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc bi translated">什么是堆叠？</h1><p id="3636" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">Stacked是一个由<a class="ae kg" href="https://www.filledstacks.com/" rel="noopener ugc nofollow" target="_blank"> FilledStacks </a>社区开发的用于颤振应用的状态管理系统。它有助于管理国家，是MVVM风格的建筑。你可以从<a class="ae kg" href="https://pub.dev/packages/stacked" rel="noopener ugc nofollow" target="_blank">这里</a>下载这个插件，并将其添加到你的pubspec.yaml文件中，如下所示:</p><blockquote class="lh li lj"><p id="dc2c" class="jd je lk jf b jg kb ji jj jk kc jm jn ll kd jq jr lm ke ju jv ln kf jy jz ka hb bi translated"><br/>依附关系:^2.0.0</p></blockquote><h1 id="d897" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">它是如何工作的？</h1><p id="0dca" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">架构非常简单。它由3个主要部分组成，其他的都取决于你的实现风格。</p><figure class="lp lq lr ls fd lt er es paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="er es lo"><img src="../Images/1448284bd9dea8ad6b6f4f9da016c850.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*csAvW3KVcPJkYffU.png"/></div></div></figure><p id="5547" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">这些作品是:</p><ul class=""><li id="6640" class="kt ku hi jf b jg kb jk kc jo kv js kw jw kx ka ky kz la lb bi translated"><strong class="jf hj">视图</strong>:向用户显示UI。单个小部件也可以称为视图(为了术语的一致性)。在这种情况下，视图不是“页面”,它只是一个UI表示。</li><li id="8e8f" class="kt ku hi jf b jg lc jk ld jo le js lf jw lg ka ky kz la lb bi translated"><strong class="jf hj"> ViewModel </strong>:管理视图的状态、业务逻辑以及用户交互所需的任何其他逻辑。它通过使用服务来实现这一点</li><li id="6f82" class="kt ku hi jf b jg lc jk ld jo le js lf jw lg ka ky kz la lb bi translated"><strong class="jf hj">服务</strong>:单一功能/特性集的包装器。这通常用于包装诸如显示对话框、包装数据库功能、集成API等。</li></ul><p id="2f15" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">像MVVM一样，每个视图模型都属于一个视图。因此，您可以为每个视图创建一个单独的视图模型，也可以根据您的需求重用视图模型。另一方面，服务是全局声明的，可以由应用程序中的任何ViewModel访问。</p><figure class="lp lq lr ls fd lt er es paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="er es ma"><img src="../Images/27110974f7b73b48a184167a986244e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*sQ7x8ZELIIpsw6go.png"/></div></div></figure><p id="54dd" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">设计应用程序时，请始终牢记以下原则:</p><ul class=""><li id="1851" class="kt ku hi jf b jg kb jk kc jo kv js kw jw kx ka ky kz la lb bi translated">每个层组件应该只知道它下面的组件。这意味着，视图有视图模型的信息，但是视图模型应该没有视图的信息。</li><li id="ab65" class="kt ku hi jf b jg lc jk ld jo le js lf jw lg ka ky kz la lb bi translated">视图不应该直接使用服务。服务应该只能通过ViewModel或其他业务层访问</li><li id="2f78" class="kt ku hi jf b jg lc jk ld jo le js lf jw lg ka ky kz la lb bi translated">视图应该不包含任何逻辑。如果逻辑来自仅支持UI的项目，那么我们执行最少的所需逻辑，并将其余部分传递给视图模型</li><li id="3257" class="kt ku hi jf b jg lc jk ld jo le js lf jw lg ka ky kz la lb bi translated">视图应该只在其视图模型中呈现状态</li><li id="2fe0" class="kt ku hi jf b jg lc jk ld jo le js lf jw lg ka ky kz la lb bi translated">表示页面视图的小部件的视图模型只绑定到一个视图</li><li id="c7d6" class="kt ku hi jf b jg lc jk ld jo le js lf jw lg ka ky kz la lb bi translated">如果UI需要相同的功能，视图模型可以重用</li><li id="8ff1" class="kt ku hi jf b jg lc jk ld jo le js lf jw lg ka ky kz la lb bi translated">视图模型不应该知道其他视图模型</li></ul></div><div class="ab cl kh ki gp kj" role="separator"><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km"/></div><div class="hb hc hd he hf"><h1 id="5076" class="if ig hi bd ih ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc bi translated">使用DI(依赖注入)的层分离</h1><p id="5673" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">遵循的最重要的原则是<a class="ae kg" href="https://en.wikipedia.org/wiki/Separation_of_concerns" rel="noopener ugc nofollow" target="_blank"> <strong class="jf hj">分离顾虑</strong> </a>。在View或ViewModel中编写所有代码是一个常见的错误。这些基于UI的类应该只包含处理UI的逻辑。</p><h1 id="fac4" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">为什么是DI？</h1><p id="e02d" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">随着你的应用程序的增长，在某些时候你需要把你的应用程序的逻辑放在独立于你的部件的类中。让您的小部件不存在直接的依赖关系会让您的代码更有条理，更易于测试和维护。</p><p id="b82d" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">对于DI，我们使用了<a class="ae kg" href="https://pub.dev/packages/get_it" rel="noopener ugc nofollow" target="_blank"> get_it </a>插件，您可以将它添加到您的pubspec.yaml文件中，如下所示:</p><blockquote class="lh li lj"><p id="7ea5" class="jd je lk jf b jg kb ji jj jk kc jm jn ll kd jq jr lm ke ju jv ln kf jy jz ka hb bi translated"><br/>获取依赖关系:^6.0.0</p></blockquote></div><div class="ab cl kh ki gp kj" role="separator"><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km"/></div><div class="hb hc hd he hf"><h1 id="f74d" class="if ig hi bd ih ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc bi translated">编码发生器</h1><p id="ca7f" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">Flutter社区太棒了，他们制作了一个代码生成插件(我最喜欢的插件之一:)，减少了编写样板代码的工作量。<a class="ae kg" href="https://pub.dev/packages/build_runner" rel="noopener ugc nofollow" target="_blank"> build_runner </a>包提供了一种使用Dart代码生成文件的具体方法。文件总是直接在磁盘上生成，并且重建是<em class="lk">增量的。</em></p><p id="a90e" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">所有自动生成的文件都有这些扩展名:</p><ul class=""><li id="2c3d" class="kt ku hi jf b jg kb jk kc jo kv js kw jw kx ka ky kz la lb bi translated">g.dart</li><li id="1e7a" class="kt ku hi jf b jg lc jk ld jo le js lf jw lg ka ky kz la lb bi translated">. gr.dart</li><li id="8ed0" class="kt ku hi jf b jg lc jk ld jo le js lf jw lg ka ky kz la lb bi translated">. config .镖</li></ul><p id="0b56" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">对于代码生成，您需要做几件事情:</p><ul class=""><li id="c862" class="kt ku hi jf b jg kb jk kc jo kv js kw jw kx ka ky kz la lb bi translated">为自动生成的代码定义文件名。它应该具有带. g.dart扩展名的原始文件名</li><li id="7f7a" class="kt ku hi jf b jg lc jk ld jo le js lf jw lg ka ky kz la lb bi translated">定义需要生成什么代码。对于函数，它应该有一个$前缀</li><li id="99a0" class="kt ku hi jf b jg lc jk ld jo le js lf jw lg ka ky kz la lb bi translated">使用build_runner工具生成代码</li></ul><p id="f5dc" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">例:我们举一个TodoEntity类的例子。您需要在导入下面写入零件文件名(将自动生成):</p><p id="ad3a" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><code class="du mb mc md me b">part 'todo_entity.g.dart';</code></p><p id="7cc8" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">要使用build_runner工具生成代码，请在终端上运行下面的命令(路径应该指向您的项目)</p><p id="8dd7" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><code class="du mb mc md me b">flutter pub run build_runner build</code></p><p id="a506" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated"><strong class="jf hj">注意:</strong>每次在原文件中进行修改时，都需要运行build_runner命令进行代码生成。</p></div><div class="ab cl kh ki gp kj" role="separator"><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km"/></div><div class="hb hc hd he hf"><h1 id="47a6" class="if ig hi bd ih ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc bi translated">网络电话改造</h1><p id="fb29" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">最初，当我处理网络调用的<a class="ae kg" href="https://pub.dev/packages/http" rel="noopener ugc nofollow" target="_blank"> http </a>包时，我真的很怀念以前在Android中使用改造库进行API调用的乐趣和轻松。幸运的是，有针对Dart 插件的<a class="ae kg" href="https://pub.dev/packages/retrofit" rel="noopener ugc nofollow" target="_blank">改进(再次感谢令人敬畏的Flutter社区)可供API调用。这与Android可用的改造库非常相似。对于示例代码，我在服务层中使用了翻新来进行API调用。下面是TodoApiService类的示例代码:</a></p><pre class="lp lq lr ls fd mf me mg mh aw mi bi"><span id="d693" class="mj ig hi me b fi mk ml l mm mn">@RestApi()<br/>abstract class TodoApiService {<br/><br/>  factory TodoApiService(Dio dio, {String baseUrl}) = _TodoApiService;<br/><br/>  @GET("todos")<br/>  Future&lt;List&lt;TodoEntity&gt;&gt; getTodos();<br/><br/>  @GET("todos/{id}")<br/>  Future&lt;TodoEntity&gt; getTodoDetail(@Path("id") int todoId);<br/><br/>}</span></pre><p id="d15d" class="pw-post-body-paragraph jd je hi jf b jg kb ji jj jk kc jm jn jo kd jq jr js ke ju jv jw kf jy jz ka hb bi translated">像Android的改进一样，这个类的代码生成由Dart库的改进负责。很简单，对吧！</p></div><div class="ab cl kh ki gp kj" role="separator"><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km"/></div><div class="hb hc hd he hf"><h1 id="9239" class="if ig hi bd ih ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc bi translated">项目结构</h1><p id="9eec" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">为了使事情简单易懂，我在生产应用程序中使用了以下项目结构:</p><figure class="lp lq lr ls fd lt er es paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="er es mo"><img src="../Images/fb1a1201fb8df99cce1e5a74d0cf4e7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tBBiu8vd8G8A9ImlUT_5Ow.png"/></div></div></figure></div><div class="ab cl kh ki gp kj" role="separator"><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km"/></div><div class="hb hc hd he hf"><h1 id="f3b4" class="if ig hi bd ih ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc bi translated">使用视图模型导航(无上下文)</h1><p id="de77" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我在Flutter中最关心的一个问题是，为了导航的目的，我们需要将上下文引用传递给Navigator。因此，在代码中，我不得不从ViewModel返回视图，只是为了导航到一个不同的屏幕，我觉得这不是一个好的选择。我在寻找一些可以通过ViewModel导航的东西，发现了<a class="ae kg" href="https://pub.dev/packages/auto_route" rel="noopener ugc nofollow" target="_blank"> auto_route </a>插件。在ExtendedNavigator的帮助下，您可以设置应用程序的所有路线，并且使用根上下文，我们可以导航到任何所需的屏幕。为了简化，我创建了一个NavigationService类来处理应用程序中的路由。下面是我在ViewModel中使用的代码，用于导航到TodoDetailScreen:</p><pre class="lp lq lr ls fd mf me mg mh aw mi bi"><span id="4ee0" class="mj ig hi me b fi mk ml l mm mn">_navigationService.push(Routes.<em class="lk">todoDetailScreen</em>);</span></pre><h1 id="73bb" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">最后的想法</h1><p id="741c" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">使用堆叠框架提供的MVVM架构模式，事情变得非常容易编写和理解。有了DI，每一层都可以很容易地重用和测试。小型应用程序的项目结构看起来很清晰，但是，对于大型企业应用程序，这可能不是最佳解决方案。在下一篇文章中，我将展示我们如何使用Bob叔叔的<a class="ae kg" href="https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html" rel="noopener ugc nofollow" target="_blank"> Clean Architecture </a>来构建Flutter应用程序。</p></div><div class="ab cl kh ki gp kj" role="separator"><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km"/></div><div class="hb hc hd he hf"><div class="lp lq lr ls fd mp"><a href="https://github.com/GeekySingh/flutter_stacked_architecture_with_retrofit" rel="noopener  ugc nofollow" target="_blank"><div class="mq ab dw"><div class="mr ab ms cl cj mt"><h2 class="bd hj fi z dy mu ea eb mv ed ef hh bi translated">geeky Singh/flutter _ stacked _ architecture _ with _ reform</h2><div class="mw l"><h3 class="bd b fi z dy mu ea eb mv ed ef dx translated">使用堆叠插件设计Flutter应用程序架构指南这个示例演示了如何设置基础插件</h3></div><div class="mx l"><p class="bd b fp z dy mu ea eb mv ed ef dx translated">github.com</p></div></div><div class="my l"><div class="mz l na nb nc my nd ly mp"/></div></div></a></div></div></div>    
</body>
</html>