<html>
<head>
<title>Chapter 07</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">第07章</h1>
<blockquote>原文：<a href="https://medium.com/codex/chapter-07-386544fd71fd?source=collection_archive---------23-----------------------#2022-04-18">https://medium.com/codex/chapter-07-386544fd71fd?source=collection_archive---------23-----------------------#2022-04-18</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="1cf4" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated"><strong class="ak">遗传和多态性</strong></h2></div><p id="e311" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当子类需要修改继承方法的行为时，它会重新定义被继承的方法。</p><h1 id="e631" class="jt ju hi bd jv jw jx jy jz ka kb kc kd io ke ip kf ir kg is kh iu ki iv kj kk bi translated"><strong class="ak">-传承- </strong></h1><figure class="km kn ko kp fd kq er es paragraph-image"><div class="er es kl"><img src="../Images/47729bc5510ce7b58eb859dbde81c9ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:810/0*9z4FMa7G8uQgIL8D"/></div></figure><p id="86ea" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">子类通过继承来继承其父类的方法和实例变量。方法可以根据子类的特定需求被重写，但是实例变量不能被重写，因为它们不指定任何行为。</p><figure class="km kn ko kp fd kq er es paragraph-image"><div class="er es kt"><img src="../Images/c30fd2d464e5f3876a61c8b9f16e34dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:716/0*04xSsBx406eEdLww"/></div></figure><h1 id="1ff7" class="jt ju hi bd jv jw jx jy jz ka kb kc kd io ke ip kf ir kg is kh iu ki iv kj kk bi translated"><strong class="ak">-创建代码继承- </strong></h1><ul class=""><li id="07c7" class="ku kv hi iz b ja kw jd kx jg ky jk kz jo la js lb lc ld le bi translated">第一步:寻找具有相似属性和行为的人。</li><li id="32d9" class="ku kv hi iz b ja lf jd lg jg lh jk li jo lj js lb lc ld le bi translated">第二步:把那些共同的特征和行为放入它们自己的类别中。</li><li id="50f0" class="ku kv hi iz b ja lf jd lg jg lh jk li jo lj js lb lc ld le bi translated">第三步:检查是否有任何子类被允许使用特定的行为。</li><li id="33a7" class="ku kv hi iz b ja lf jd lg jg lh jk li jo lj js lb lc ld le bi translated">第四步-:找到其他具有相似功能的子类，并抽象地将它们连接到父类。</li><li id="ccaa" class="ku kv hi iz b ja lf jd lg jg lh jk li jo lj js lb lc ld le bi translated">第五步-:完成类的层次结构。</li></ul><p id="baf6" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在具有继承关系的多个类型中调用方法时，必须使用点运算符。当您在类层次结构中向上移动时，应该调用这些方法</p><pre class="km kn ko kp fd lk ll lm ln aw lo bi"><span id="9f27" class="lp ju hi ll b fi lq lr l ls lt">Dog dog = new Dog();<br/>dog.sound();<br/>dog.eat();</span></pre><p id="b2ec" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当我们谈论IS-A和HAS-A关系时，我们谈论的是两个不同的概念。当两个类之间有继承时，我们可以使用IS-A关系。例如，圆是一种形状，而猫是一种动物。但是，我们不能在继承中创建HAS-A连接，但是我们可以使用它作为告诉实例变量的引用。在本例中，浴室有一个浴盆意味着浴室有一个浴盆实例变量。</p><p id="b92d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果类B扩展了类A，那么类B是-A类A，如果类C扩展了类B，那么类C是-A类B，例如，类C同时扩展了类B和类C的行为。C类具有与A类和b类相同的能力。</p><p id="8a81" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您应该使用super关键字在您的类中同时应用超类方法和重写方法。</p><figure class="km kn ko kp fd kq er es paragraph-image"><div class="er es lu"><img src="../Images/4610cd9c541f55d560844e9b5c21f9ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:454/0*G8g6uPZKOZEOFBs-"/></div></figure><p id="4b61" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这里，您可以稍后使用超类方法roam和覆盖方法roam。</p><p id="fbd4" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当子类从父类继承时，它可以从父类的实例变量和方法中访问，但是如果实例变量和方法是私有的，则不能直接继承。私有成员是唯一可以继承的成员。</p><ul class=""><li id="1056" class="ku kv hi iz b ja jb jd je jg lv jk lw jo lx js lb lc ld le bi translated">当一个类是超类的特定类型时，应用继承。延伸之后，应该就说得通了。</li><li id="7a9d" class="ku kv hi iz b ja lf jd lg jg lh jk li jo lj js lb lc ld le bi translated">当你有一个行为应该被许多相同类型的类共享时，考虑继承。</li><li id="f5f7" class="ku kv hi iz b ja lf jd lg jg lh jk li jo lj js lb lc ld le bi translated">只有在需要重用另一个类的代码时，才使用继承。IS-A连接应该在父类和子类之间。</li><li id="1832" class="ku kv hi iz b ja lf jd lg jg lh jk li jo lj js lb lc ld le bi translated">如果子类和超类之间没有IS-A连接，就不要应用继承。</li></ul><p id="9dbd" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">继承中的利益</strong></p><p id="bdf1" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您可以利用继承来防止重复代码。您将所有的公共代码放在一个类中，让其他子类从超类继承它。如果您希望更新公共代码，您必须只在超类中进行；否则会影响所有子类。</p><p id="8333" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这种继承也确保了超类下的所有子类都可以访问超类的所有特性。</p><p id="516b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">多态性</strong></p><p id="10f3" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当我们谈论没有应用多态性的普通对象声明时，对象类型和引用类型是相同的。</p><figure class="km kn ko kp fd kq er es paragraph-image"><div class="er es ly"><img src="../Images/7587419c57a3071b4b39de5f951a14bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:938/0*AOQp_IpC-X7UrjlB"/></div></figure><p id="0bc0" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当使用多态性时，对象类型和引用类型可以改变。</p><figure class="km kn ko kp fd kq er es paragraph-image"><div class="er es lz"><img src="../Images/bd727d148aec1b8e55613425da73179b.png" data-original-src="https://miro.medium.com/v2/resize:fit:954/0*GW7DVHV2UC3sVE7V"/></div></figure><p id="02fe" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当您定义一个具有多态性的引用变量时，您可以将它赋给任何一个对象，该对象为引用变量的指定类型传递IS-A关系。</p><figure class="km kn ko kp fd kq er es paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="er es ma"><img src="../Images/7c0bd2d9afc03c9b375c9735e7ca5372.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*vmPb6z3c6LKpBayQ"/></div></div></figure><p id="1122" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们可以有多态的参数和返回类型。</p><figure class="km kn ko kp fd kq er es paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="er es mf"><img src="../Images/11999960bbabfe6ad3008bc7d838ec7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*g6NFcayqyW0mnNlY"/></div></div></figure><p id="e56c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">压倒一切</strong></p><ul class=""><li id="c567" class="ku kv hi iz b ja jb jd je jg lv jk lw jo lx js lb lc ld le bi translated">当重写时，参数和返回类型应该与超类相同。</li><li id="ae2a" class="ku kv hi iz b ja lf jd lg jg lh jk li jo lj js lb lc ld le bi translated">您不能重写方法并使其成为私有方法。超类应该有相同的公共访问修饰符。</li></ul><figure class="km kn ko kp fd kq er es paragraph-image"><div class="er es mg"><img src="../Images/cb7af45813f1437661abba2e969c68dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:540/format:webp/1*LsgDJJwMdLBmXmPZGuQQ2g.png"/></div><figcaption class="mh mi et er es mj mk bd b be z dx translated">示例01</figcaption></figure><figure class="km kn ko kp fd kq er es paragraph-image"><div class="er es ml"><img src="../Images/721e89d3ef871063d2b4a76bcc6ff354.png" data-original-src="https://miro.medium.com/v2/resize:fit:804/format:webp/1*1J22A8F4Sqy0Zaz65MpV9A.png"/></div><figcaption class="mh mi et er es mj mk bd b be z dx translated">示例02</figcaption></figure><p id="721b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">超载</strong></p><p id="bdd5" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">重载一个方法指的是拥有一个或两个以上的同名但参数不同的方法。</p><ul class=""><li id="4991" class="ku kv hi iz b ja jb jd je jg lv jk lw jo lx js lb lc ld le bi translated">可以根据传入的输入调整返回类型。</li><li id="387d" class="ku kv hi iz b ja lf jd lg jg lh jk li jo lj js lb lc ld le bi translated">仅仅改变返回类型是无法实现重载的。</li><li id="e365" class="ku kv hi iz b ja lf jd lg jg lh jk li jo lj js lb lc ld le bi translated">访问级别可以以任何方式更改。</li></ul><figure class="km kn ko kp fd kq er es paragraph-image"><div class="er es mm"><img src="../Images/7050d43574c979d75e7485d6010faea1.png" data-original-src="https://miro.medium.com/v2/resize:fit:754/format:webp/1*-WPe9HueZW_Vs7JiJjCf4A.png"/></div></figure></div></div>    
</body>
</html>