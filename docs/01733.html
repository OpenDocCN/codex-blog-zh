<html>
<head>
<title>Moving Data From Cassandra (OLTP) to Data Warehouse</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将数据从Cassandra (OLTP)移动到数据仓库</h1>
<blockquote>原文：<a href="https://medium.com/codex/moving-data-from-cassandra-oltp-to-data-warehouse-6af1de724fac?source=collection_archive---------3-----------------------#2021-05-25">https://medium.com/codex/moving-data-from-cassandra-oltp-to-data-warehouse-6af1de724fac?source=collection_archive---------3-----------------------#2021-05-25</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="3b9d" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">概观</h1><p id="f59c" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">数据应该实时或接近实时地流向分析引擎，以便将跨国数据增量上传到数据仓库系统。在我的例子中，我的OLTP是卡珊德拉，OLAP是雪花。OLAP系统要求Cassandra定期提供数据。与此场景相关的要求是:</p><ol class=""><li id="4ad5" class="kb kc hi jf b jg kd jk ke jo kf js kg jw kh ka ki kj kk kl bi translated">需要大幅降低数据复制的频率。</li><li id="abc0" class="kb kc hi jf b jg km jk kn jo ko js kp jw kq ka ki kj kk kl bi translated">数据必须一致。卡珊德拉和雪花应该同步。</li><li id="feb9" class="kb kc hi jf b jg km jk kn jo ko js kp jw kq ka ki kj kk kl bi translated">在少数情况下，所有的突变都必须被捕获</li><li id="7076" class="kb kc hi jf b jg km jk kn jo ko js kp jw kq ka ki kj kk kl bi translated">目前，生产集群数据大小以Pb为单位；每小时至少生成100千兆字节的数据。</li></ol><p id="ec74" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated">有了这样的粒度要求，就不应该将数据从OLTP系统拷贝到OLAP，因为读取路径会造成入侵，而写入Cassandra的路径会导致对TPS的影响。因此，我们需要提供不同的解决方案来将Cassandra数据复制到Snowflake。</p><p id="87da" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated">复制整个数据(以TB为单位)将是非常低效的，并且不会提供任何好处，因为唯一的期望是在雪花上应用所有新的Cassandra突变。</p><h1 id="0497" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">OLTP生态系统</h1><ul class=""><li id="15aa" class="kb kc hi jf b jg jh jk jl jo ku js kv jw kw ka kx kj kk kl bi translated">整个OLTP遵循微服务架构。</li><li id="d89a" class="kb kc hi jf b jg km jk kn jo ko js kp jw kq ka kx kj kk kl bi translated">我们已经实施了一种“每个服务一个数据库”的方法。</li><li id="62e4" class="kb kc hi jf b jg km jk kn jo ko js kp jw kq ka kx kj kk kl bi translated">在OLTP端，GraphQL用于从Cassandra传输数据。</li><li id="8c8a" class="kb kc hi jf b jg km jk kn jo ko js kp jw kq ka kx kj kk kl bi translated">每个微服务都遵循存储库设计模式。</li></ul><h1 id="9ed5" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">潜在的解决方案</h1><p id="c5dd" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我们考虑了以下解决方案。这是总结。</p><p id="74b6" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated">如果你的分析引擎是基于Cassandra的，使用方法五到八。如果OLTP系统是从头开始设计的，请使用方法一、二或四。</p><p id="0d9e" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated">然而，当您拥有现有的运行中的OLTP和OLAP系统时，许多解决方案会彻底消失。我们需要一个通用的非侵入式解决方案，不需要对现有系统(包括微服务实施和领域数据模型)进行任何更改。我们缩小了CDC和增量备份加快照的方法范围。实际上，这些是在OLAP上应用OLTP突变的通用选项。一般来说，CDC方法是可行的，因为它在数据复制方面提供了精确的粒度级别，因为每个操作都会被捕获并可以在目标系统上执行。这适用于整个RDBMS世界和NoSQL解决方案，如MongoDB和InfluxDB。然而，卡珊德拉的CDC非常基础，目前有许多开放的问题。</p><figure class="kz la lb lc fd ld er es paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="er es ky"><img src="../Images/bd73126180d392113b908ff26e0e9621.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Xk0l7CIPW2lZ6yWiZ2r8rw.png"/></div></div></figure><figure class="kz la lb lc fd ld er es paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="er es lk"><img src="../Images/038f245058c3b768f115575c300b0689.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*bkDa0X271zogtSMq.jpg"/></div></div></figure><figure class="kz la lb lc fd ld er es paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="er es lk"><img src="../Images/e44c0540cc9db8ef37afd04f5f4f1d72.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*C7AdtxnsgXiCXstI.jpg"/></div></div></figure><h1 id="05af" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">卡珊德拉疾病控制中心</h1><p id="ec93" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">变更数据捕获(CDC)日志记录捕获并跟踪已更改的数据。CDC日志记录是按表配置的，对存储CDC日志所消耗的磁盘空间量有限制。CDC日志使用与提交日志相同的二进制格式。通用架构包括作为CDC审计复制日志的Kafka和像Debezium这样的CDC连接器。然而，根据当前的Cassandra实现，CDC功能有许多问题，如事件重复和事件无序。因为这些问题，CDC的可靠性不是100%。Cassandra的文档明确指出，客户端程序/CDC日志消费者必须处理这些问题，并要求采用Cassandra使用的技术来实现可靠性，如上次写入成功、时间戳冲突等技术。目前，没有第三方工具提供这样的功能。Debezium和优步的DBEvents是两个很有前途的项目，可以满足CDC的需求；然而，卡珊德拉CDC连接器仍处于培育阶段。根据Cassandra 4.x路线图，没有提高CDC功能可靠性的计划。CDC的当前问题需要复杂的工程设计，并且需要付出巨大的努力来保证高数据质量和新鲜度。这就是这种方法被抛弃的原因。</p><h1 id="8093" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">同步复制群集中的Cassandra</h1><p id="f9a7" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">这种方法是通用的。该方法启动了另一个Cassandra集群(OLAP)，并使用Cassandra的多DC复制功能将数据实时复制到该集群。该集群应该非常小，复制因子应该为1，因为该集群充当中间数据存储。这两个群集将保持同步，并且在复制因子和节点方面有所不同。OLTP集群将使用local.quorum的一致性级别，微服务应用程序实例将只知道这些Cassandra节点。所以，现状没有改变。</p><p id="56d8" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated">使用OLTP集群将数据复制到雪花的Spark作业将指向一个复制集群。对我们来说，这种方法最大的缺点是这两个集群是彼此的镜像副本。因此，用户在复制群集上执行的任何操作都会应用到生产群集；这样就不能截断复制群集数据，也不能添加触发器。</p><p id="86e7" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated">这也意味着复制群集将保留生产数据的整个拷贝。例如，如果生产群集上的RF为3，复制群集RF为1，则复制群集的大小将是生产群集的三分之一。就成本而言，这一比例大致保持不变。另一个缺点是，每次使用时都必须将数据的整个副本上传到数据仓库。</p><p id="5135" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated">这是一种开销，因为一般分析数据是仅附加的。因此，复制如此大的数据存储库并不是明智的做法。久而久之，数据的大小将会是Pb——想象一下复制这些数据所需的计算能力。这就是为什么尽管这种方法很吸引人并且易于采用，维护开销也很少，但它有很大的缺点。</p><h1 id="567c" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">增量备份加快照</h1><p id="2a03" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">最后，我们只剩下这种方法。在Cassandra中，快照和增量备份功能非常可靠。这些功能的最初目的是支持备份。如果磁盘或系统硬件出现故障，即使整个活动站点离线，也不需要从备份中恢复。只要有一个节点有复制的数据，Cassandra就可以恢复该数据，而不需要依赖任何外部源。在Cassandra中，捕获快照不是写入或读取入侵操作。Cassandra通过节点工具命令提供了一个本地节点级快照选项。快照创建了到现有Cassandra数据文件的硬链接。这与提供时间点恢复功能的增量备份功能一起使用。粒度可以微调到10到15分钟。然而，这不是接近实时的数据复制。使用这种方法，您无法达到几秒钟或两到五分钟的精确度和粒度。如果这是要求，那么我建议以基础架构开销为代价，继续使用以前的同步复制方法。</p><p id="4122" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated">通常，分析引擎要求定期从生产集群接收增量。这就是大多数数据仓库解决方案的工作方式。我们的业务需求目前表明，我们每天都从生产集群接收增量。将来，我们希望支持每小时一次的频率。考虑到成本因素和业务需求，这种方法轻而易举地胜出。</p><p id="f540" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated">以下小节解释了该方法的高级设计。</p><p id="76fb" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated">数据文件夹包含每个键空间的子文件夹。每个子文件夹包含三种文件:</p><p id="ef6e" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated"><strong class="jf hj">数据文件:</strong>SSTable(排序字符串表)是一个键值字符串对(按键排序)的文件。</p><p id="7407" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated"><strong class="jf hj">索引文件:</strong> (Key，offset)对(指向数据文件)</p><p id="4c1c" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated"><strong class="jf hj"> Bloom filter: </strong>数据文件中的所有键</p><p id="af55" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated">增量备份操作捕获所有的突变，包括删除。按照我们的要求，我们只需要在代理键空间的情况下捕获删除突变。对于其他关键空间，我们不关心删除。事实上，在大多数键空间上，我们不必删除数据。对于复制集群，不必保留所有数据。一旦Spark作业被触发，您就可以查询键空间来获取数据，然后将数据上传到Snowflake。</p><p id="35a8" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated">上传完成后，您可以在keyspace上执行truncate命令，以确保数据大小保持在一定的限制之下。对于增量备份，只需要一个模式。因此，如果模式是完整的，那么增量备份可以简单地继续加载增量，并且Spark作业将继续将键空间中的全部数据复制到雪花。</p><p id="d56e" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated">在需要捕获所有突变的情况下，需要旧数据。这在下面的流程图中有详细说明。Spark作业将需要复制和截断数据。从那里，很容易对每个键空间进行配置。在需要缺失突变的情况下，必须保留所有数据。所以将keyspace数据复制到Snowflake的奇怪情况仍然存在。但是，这个问题很容易解决，就像在这个集群中一样，对于有问题的键空间，可以启用触发器。一旦触发器被启用，每一批突变都会触发一个事件。Cassandra触发器可以在程序中实现的事实也有所帮助。</p><p id="c48e" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated">一个重要的设计决策是确保Spark作业将数据从生产集群复制到复制集群，然后将数据从复制集群迁移到雪花作业，这些作业不会并行执行。在这种情况下，可能会出现数据争用问题，因为会出现多个写入者和突变。为了避免这种情况，必须使用Spark调度程序。Spark调度器配置将确保这两个作业不会并行执行。</p><p id="11c7" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated">AWS部署如下:</p><figure class="kz la lb lc fd ld er es paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="er es ll"><img src="../Images/d682e23d7f765890c47621d09e25523d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*lFRCnkj2o9be5OrX.png"/></div></div><figcaption class="lm ln et er es lo lp bd b be z dx translated"><em class="lq"> AWS部署</em></figcaption></figure><p id="fc31" class="pw-post-body-paragraph jd je hi jf b jg kd ji jj jk ke jm jn jo kr jq jr js ks ju jv jw kt jy jz ka hb bi translated">下面的流程图总结了整个方法。</p><figure class="kz la lb lc fd ld er es paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="er es lr"><img src="../Images/da705aec4269fd96d6d38981170a9360.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*x0QTQGOQg_VvnMSY.png"/></div></div><figcaption class="lm ln et er es lo lp bd b be z dx translated"><em class="lq">进场总结</em></figcaption></figure></div></div>    
</body>
</html>