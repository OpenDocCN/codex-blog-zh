<html>
<head>
<title>Working with Vue 3 dialogs using promises</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用承诺处理Vue 3对话框</h1>
<blockquote>原文：<a href="https://medium.com/codex/best-way-to-work-with-dialogs-in-vue-b992e7ca1818?source=collection_archive---------2-----------------------#2022-02-02">https://medium.com/codex/best-way-to-work-with-dialogs-in-vue-b992e7ca1818?source=collection_archive---------2-----------------------#2022-02-02</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/c122ba9b7c759d3981c50944eeb7b71e.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/0*N3GWhzuYCa9_3Lj_.png"/></div></figure></div><div class="ab cl im in gp io" role="separator"><span class="ip bw bk iq ir is"/><span class="ip bw bk iq ir is"/><span class="ip bw bk iq ir"/></div><div class="hb hc hd he hf"><p id="4e30" class="pw-post-body-paragraph it iu hi iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq hb bi translated">在本文中，我将带您浏览PrimeVue和Vuetify等组件库提供了哪些对话框。然后我会告诉你我认为更好的方法。最后，我会告诉你如何使用<a class="ae jr" href="https://github.com/rlemaigre/vue3-promise-dialog" rel="noopener ugc nofollow" target="_blank"> vue3-promise-dialog </a>。</p></div><div class="ab cl im in gp io" role="separator"><span class="ip bw bk iq ir is"/><span class="ip bw bk iq ir is"/><span class="ip bw bk iq ir"/></div><div class="hb hc hd he hf"><h1 id="5dbe" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">以通常的方式对话</h1><p id="6c42" class="pw-post-body-paragraph it iu hi iv b iw kq iy iz ja kr jc jd je ks jg jh ji kt jk jl jm ku jo jp jq hb bi translated">大多数组件库都提供对话框组件。</p><p id="db26" class="pw-post-body-paragraph it iu hi iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq hb bi translated">这是PrimeVue 中的一个<a class="ae jr" href="https://primefaces.org/primevue/showcase/#/dialog" rel="noopener ugc nofollow" target="_blank">例子:</a></p><figure class="kv kw kx ky fd ij"><div class="bz dy l di"><div class="kz la l"/></div></figure><p id="3add" class="pw-post-body-paragraph it iu hi iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq hb bi translated">和<a class="ae jr" href="https://vuetifyjs.com/en/components/dialogs/" rel="noopener ugc nofollow" target="_blank">另一个来自Vuetify </a>:</p><figure class="kv kw kx ky fd ij"><div class="bz dy l di"><div class="kz la l"/></div></figure><p id="ae26" class="pw-post-body-paragraph it iu hi iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq hb bi translated">如您所见，组件库鼓励您将对话框的代码(模板和逻辑)嵌入到打开它的父组件中。这有几个缺点:</p><ul class=""><li id="b2c1" class="lb lc hi iv b iw ix ja jb je ld ji le jm lf jq lg lh li lj bi translated">这使得构建可重用的对话框变得不可能，因为每个对话框都被绑定到它的打开站点。</li><li id="52df" class="lb lc hi iv b iw lk ja ll je lm ji ln jm lo jq lg lh li lj bi translated">对话框的逻辑和模板与其父组件的逻辑和模板混合在一起。当一个父组件必须打开几个对话框时，这变得更加混乱。</li><li id="15d9" class="lb lc hi iv b iw lk ja ll je lm ji ln jm lo jq lg lh li lj bi translated">无法从JS/TS文件打开对话框。</li><li id="ab8a" class="lb lc hi iv b iw lk ja ll je lm ji ln jm lo jq lg lh li lj bi translated">对话框只是从用户获取数据的一种方式，打开它并等待结果应该像异步函数调用一样简单，就像从服务器获取数据一样。组件库的方式并不是这样。</li></ul><h1 id="8852" class="js jt hi bd ju jv lp jx jy jz lq kb kc kd lr kf kg kh ls kj kk kl lt kn ko kp bi translated">使用承诺的对话</h1><p id="e17b" class="pw-post-body-paragraph it iu hi iv b iw kq iy iz ja kr jc jd je ks jg jh ji kt jk jl jm ku jo jp jq hb bi translated">众所周知，从服务器请求数据是一个异步过程，最好用承诺来处理。例如，<a class="ae jr" href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API" rel="noopener ugc nofollow" target="_blank">获取API </a>是一个基于承诺的API。</p><pre class="kv kw kx ky fd lu lv lw lx aw ly bi"><span id="e0ad" class="lz jt hi lv b fi ma mb l mc md">let response = await fetch('http://example.com/movies.json');</span></pre><p id="6c54" class="pw-post-body-paragraph it iu hi iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq hb bi translated">现在，就像从服务器获取数据一样，使用对话框从用户获取数据<em class="me">也是一个异步过程，当用户关闭对话框时，它可能会在将来的某个时间点以一个值完成。为什么从用户获取数据的API与从服务器获取数据的API会有任何不同？</em></p><p id="5f56" class="pw-post-body-paragraph it iu hi iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq hb bi translated">使用promises，打开一个确认对话框(例如)就像这样简单:</p><pre class="kv kw kx ky fd lu lv lw lx aw ly bi"><span id="6856" class="lz jt hi lv b fi ma mb l mc md">let ok = await confirm('Are you sure you want to do this ?');<br/>if (ok) {<br/>    // Do something<br/>}</span></pre><p id="8413" class="pw-post-body-paragraph it iu hi iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq hb bi translated">当对话框关闭时，promise解析为用户在对话框中输入的值(在确认对话框的情况下为布尔值，但如果对话框包括表单，则可以是任何数据结构)。</p><p id="9974" class="pw-post-body-paragraph it iu hi iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq hb bi translated">这种方法有几个优点:</p><ul class=""><li id="0597" class="lb lc hi iv b iw ix ja jb je ld ji le jm lf jq lg lh li lj bi translated">对话框没有绑定到它的打开位置，所以很容易构建可重用的对话框。</li><li id="bf88" class="lb lc hi iv b iw lk ja ll je lm ji ln jm lo jq lg lh li lj bi translated">可以从父Vue组件或任何JS/TS文件中打开对话框。这只是一个函数调用。</li><li id="1998" class="lb lc hi iv b iw lk ja ll je lm ji ln jm lo jq lg lh li lj bi translated">在从用户和从服务器请求数据之间有一种令人愉快的对称。</li><li id="0441" class="lb lc hi iv b iw lk ja ll je lm ji ln jm lo jq lg lh li lj bi translated">对话框的代码和父组件的代码保持分离和独立。所以你必须解决两个独立的问题，这比解决它们的混合要容易得多。</li><li id="ee26" class="lb lc hi iv b iw lk ja ll je lm ji ln jm lo jq lg lh li lj bi translated">一个父组件可以使用许多对话框而不会变得一团糟。</li></ul><p id="609a" class="pw-post-body-paragraph it iu hi iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq hb bi translated">理论上这一切都很好，但是你应该如何去实现它呢？对于Vue 2，可以使用<a class="ae jr" href="https://github.com/hjkcai/vue-modal-dialogs" rel="noopener ugc nofollow" target="_blank"> vue-modal-dialog </a>。对于Vue 3，可以使用<a class="ae jr" href="https://github.com/rlemaigre/vue3-promise-dialog" rel="noopener ugc nofollow" target="_blank"> vue3-promise-dialog </a>。我将在下一节向您展示如何使用后者。</p><h1 id="137b" class="js jt hi bd ju jv lp jx jy jz lq kb kc kd lr kf kg kh ls kj kk kl lt kn ko kp bi translated">用vue3-promise-dialog许诺你的对话</h1><p id="5be2" class="pw-post-body-paragraph it iu hi iv b iw kq iy iz ja kr jc jd je ks jg jh ji kt jk jl jm ku jo jp jq hb bi translated">我将向您展示如何构建一个基本的确认对话框。它不会很漂亮，但会很实用。可以在StackBlitz上玩完整的项目:<a class="ae jr" href="https://stackblitz.com/edit/vitejs-vite-nzzfdg?file=src%2Fmain.ts&amp;terminal=dev" rel="noopener ugc nofollow" target="_blank">Vue 3+Vite+Vue 3-promise-dialog</a>。如果你想要一个漂亮的例子，看看这个小的对话框集合，它是这个库的测试用例，以及它的<a class="ae jr" href="https://rlemaigre.github.io/vue3-promise-dialog/" rel="noopener ugc nofollow" target="_blank">演示。</a></p><p id="4aa9" class="pw-post-body-paragraph it iu hi iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq hb bi translated">这是我们将要建造的:</p><figure class="kv kw kx ky fd ij er es paragraph-image"><div class="er es mf"><img src="../Images/c88c7cbdf47b3f24512448731cc9c657.png" data-original-src="https://miro.medium.com/v2/resize:fit:834/format:webp/1*qOrM9xZ6h3mSzD5M7HI2Lw.png"/></div></figure><p id="a3c6" class="pw-post-body-paragraph it iu hi iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq hb bi translated">首先安装库:</p><pre class="kv kw kx ky fd lu lv lw lx aw ly bi"><span id="b5e0" class="lz jt hi lv b fi ma mb l mc md">npm i vue3-promise-dialog</span></pre><p id="5e7e" class="pw-post-body-paragraph it iu hi iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq hb bi translated">然后安装插件:</p><pre class="kv kw kx ky fd lu lv lw lx aw ly bi"><span id="bb90" class="lz jt hi lv b fi ma mb l mc md">import { createApp } from 'vue'<br/>import App from './App.vue'<br/>import {PromiseDialog} from "vue3-promise-dialog"</span><span id="1ec7" class="lz jt hi lv b fi mg mb l mc md">const app = createApp(App);<br/>app.use(PromiseDialog);<br/>app.mount('#app')</span></pre><p id="5155" class="pw-post-body-paragraph it iu hi iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq hb bi translated">接下来将<code class="du mh mi mj lv b">DialogWrapper</code>组件添加到应用程序根组件的末尾:</p><pre class="kv kw kx ky fd lu lv lw lx aw ly bi"><span id="2a9f" class="lz jt hi lv b fi ma mb l mc md">&lt;template&gt;<br/>    &lt;div id="app"&gt;<br/>        &lt;!-- your content --&gt;<br/>        &lt;DialogWrapper :transition-attrs="{name: 'dialog'}"/&gt;<br/>    &lt;/div&gt;<br/>&lt;/template&gt;</span></pre><p id="ae80" class="pw-post-body-paragraph it iu hi iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq hb bi translated">您的对话框将在那个<code class="du mh mi mj lv b">DialogWrapper</code>中打开。在内部，<code class="du mh mi mj lv b">DialogWrapper </code>使用一个转换标签来转换你的对话框进入和退出视图。在我上面的例子中，转换的名称是<code class="du mh mi mj lv b">dialog</code>。使用<code class="du mh mi mj lv b">dialog-enter-from</code>、<code class="du mh mi mj lv b">dialog-leave-to</code>等类来制作对话框出现和消失的动画。为了简单起见，我们在这里不做任何事情。</p><p id="0f05" class="pw-post-body-paragraph it iu hi iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq hb bi translated">下面是我们确认对话框的代码:</p><figure class="kv kw kx ky fd ij"><div class="bz dy l di"><div class="kz la l"/></div></figure><p id="1f69" class="pw-post-body-paragraph it iu hi iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq hb bi translated">如你所见，这是一个普通的Vue组件。这是一个黑色的背景和一个居中的div，带有“是”和“否”按钮。它有一个<code class="du mh mi mj lv b">text</code>道具来控制显示给用户的问题。除了一个<code class="du mh mi mj lv b">returnValue</code>函数和当用户点击按钮时对<code class="du mh mi mj lv b">$close</code>的调用之外，它没有什么特别之处。我现在将解释这两件事。</p><p id="383c" class="pw-post-body-paragraph it iu hi iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq hb bi translated">当你在一个对话框中调用<code class="du mh mi mj lv b">$close(this)</code>时，对话框关闭，它的承诺解析为<code class="du mh mi mj lv b">returnValue()</code>函数的结果。通常对话框会包含一个表单，<code class="du mh mi mj lv b">returnValue()</code>函数会返回用户在表单中输入的任何数据。在我们的例子中，没有形式，所以函数只返回true。因为我们希望承诺在用户单击YES时解析为该值，所以我们在单击YES按钮时调用<code class="du mh mi mj lv b">$close(this)</code>。</p><p id="0ec9" class="pw-post-body-paragraph it iu hi iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq hb bi translated">当您使用第二个参数(例如null或false)调用<code class="du mh mi mj lv b">$close(this, ...)</code>时，promise将使用该值进行解析。在我们的例子中，我们希望当用户点击NO时，承诺解析为false，所以我们在点击NO按钮时调用<code class="du mh mi mj lv b">$close(this, false)</code>。如果对话框有一个表单和一个取消按钮，当用户点击取消时，你可能想调用<code class="du mh mi mj lv b">$close(this, null)</code>。</p><p id="9059" class="pw-post-body-paragraph it iu hi iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq hb bi translated">这就是关闭对话框并返回值的方法。现在你如何打开它并得到承诺？您使用<code class="du mh mi mj lv b">openDialog</code>功能。</p><p id="9c89" class="pw-post-body-paragraph it iu hi iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq hb bi translated">在我们的例子中，我们的目标是让这个API打开我们的确认对话框:</p><pre class="kv kw kx ky fd lu lv lw lx aw ly bi"><span id="e3f1" class="lz jt hi lv b fi ma mb l mc md">let yes = await confirm("Are you sure ?");</span></pre><p id="4454" class="pw-post-body-paragraph it iu hi iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq hb bi translated">让我们看看异步<code class="du mh mi mj lv b">confirm</code>函数是如何实现的:</p><pre class="kv kw kx ky fd lu lv lw lx aw ly bi"><span id="586c" class="lz jt hi lv b fi ma mb l mc md">import { openDialog } from 'vue3-promise-dialog';<br/>import ConfirmDialog from '../components/ConfirmDialog.vue';</span><span id="6049" class="lz jt hi lv b fi mg mb l mc md">export async function confirm(text: string) {<br/>  return await openDialog(ConfirmDialog, {text});<br/>}</span></pre><p id="9ac3" class="pw-post-body-paragraph it iu hi iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq hb bi translated">因此，要打开一个对话框并得到一个承诺，你调用<code class="du mh mi mj lv b">openDialog</code>并作为第一个参数传递你想要打开的对话框，作为第二个参数传递它的道具。该函数在类型方面很聪明:它将从组件定义中推断道具的类型，从<code class="du mh mi mj lv b">returnValue()</code>函数中推断返回类型。因此，如果你传入一个错误的道具，你的IDE将会抱怨。如果您等待承诺并将值赋给一个变量，该变量将具有正确的类型，因为TypeScript将从赋值中推断出它。</p></div><div class="ab cl im in gp io" role="separator"><span class="ip bw bk iq ir is"/><span class="ip bw bk iq ir is"/><span class="ip bw bk iq ir"/></div><div class="hb hc hd he hf"><p id="007a" class="pw-post-body-paragraph it iu hi iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq hb bi translated">现在你知道了。我希望你喜欢这篇文章！感谢您的阅读。</p></div></div>    
</body>
</html>