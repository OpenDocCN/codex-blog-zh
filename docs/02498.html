<html>
<head>
<title>A Quick Guide on OOPs Concept in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中OOPs概念的快速指南</h1>
<blockquote>原文：<a href="https://medium.com/codex/a-quick-guide-on-oops-concept-in-python-3ee6c40cf673?source=collection_archive---------6-----------------------#2021-07-23">https://medium.com/codex/a-quick-guide-on-oops-concept-in-python-3ee6c40cf673?source=collection_archive---------6-----------------------#2021-07-23</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/96c662e0a527a4af7df55b96128aa593.png" data-original-src="https://miro.medium.com/v2/resize:fit:1114/format:webp/1*ixEc6uzuyCZqSLr4eifL0w.png"/></div><figcaption class="im in et er es io ip bd b be z dx translated">概观</figcaption></figure><p id="93db" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">互联网上有很多关于这个主题的文章，我已经尽力以快速指南的形式概括了OOPs的概念</p><p id="46f2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">什么是哎呀？</strong></p><p id="3604" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">面向对象编程</strong> (OOP)是一种基于“对象”概念的编程范式，其中可能包含数据，以字段的形式，通常称为属性；和程序形式的代码，通常称为方法。</p><p id="80ec" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">例如，一个人是一个具有某些属性的物体，如身高、性别、年龄等。它还具有某些方法，如移动、交谈等。</p></div><div class="ab cl jo jp gp jq" role="separator"><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt"/></div><div class="hb hc hd he hf"><p id="9304" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">哎呀的积木</strong></p><ul class=""><li id="aaf0" class="jv jw hi is b it iu ix iy jb jx jf jy jj jz jn ka kb kc kd bi translated">目标</li><li id="6a29" class="jv jw hi is b it ke ix kf jb kg jf kh jj ki jn ka kb kc kd bi translated">班级</li><li id="f2e9" class="jv jw hi is b it ke ix kf jb kg jf kh jj ki jn ka kb kc kd bi translated">遗产</li><li id="bfb0" class="jv jw hi is b it ke ix kf jb kg jf kh jj ki jn ka kb kc kd bi translated">多态性</li><li id="64f7" class="jv jw hi is b it ke ix kf jb kg jf kh jj ki jn ka kb kc kd bi translated">抽象</li><li id="859a" class="jv jw hi is b it ke ix kf jb kg jf kh jj ki jn ka kb kc kd bi translated">包装</li></ul></div><div class="ab cl jo jp gp jq" role="separator"><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt"/></div><div class="hb hc hd he hf"><p id="2cd6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">什么是对象？</strong></p><p id="0069" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对象是具有状态和行为的实体。它可以是任何现实世界中的物体，如鼠标、键盘、椅子、桌子、笔等。</p><p id="ee96" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Python中的一切都是对象，几乎一切都有属性和方法。所有函数都有一个内置属性__doc__，它返回函数源代码中定义的docstring</p><p id="9fcb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当我们定义一个<strong class="is hj">类</strong>时，只有对象的描述或蓝图被创建。在我们创建<strong class="is hj">对象</strong>之前<strong class="is hj">没有内存分配</strong>。</p></div><div class="ab cl jo jp gp jq" role="separator"><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt"/></div><div class="hb hc hd he hf"><p id="c7ba" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">什么是阶级？</strong></p><p id="84bc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一个类是那个对象的蓝图。</p><p id="a9f3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们可以把一个类想象成一个房子的草图(原型)。它包含了所有关于地板、门、窗等的细节。根据这些描述，我们建造房子。房子是客体。</p><p id="c98b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因为许多房子可以从一个房子的蓝图中建造出来，所以我们可以从一个类中创建许多对象。一个对象也被称为一个类的实例，创建这个对象的过程被称为<strong class="is hj">实例化</strong>。</p></div><div class="ab cl jo jp gp jq" role="separator"><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt"/></div><div class="hb hc hd he hf"><p id="88fa" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在Python中定义一个类和对象</p><p id="ac5a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">就像Python中的函数定义以<strong class="is hj"> def </strong>关键字开始一样，类定义以<strong class="is hj"> class </strong>关键字开始。</p><p id="62e6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">例如:</p><pre class="kj kk kl km fd kn ko kp kq aw kr bi"><span id="d4e4" class="ks kt hi ko b fi ku kv l kw kx">class employee:<br/>    age = 30<br/>    designation = Manager</span><span id="1055" class="ks kt hi ko b fi ky kv l kw kx">    def greet(self):<br/>        print('Hello')</span></pre><p id="a38f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们看到类对象可以用来访问不同的属性。</p><p id="6ac9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">它还可以用于<strong class="is hj">创建</strong>该类的新对象实例(实例化)。创建<strong class="is hj">对象</strong>的过程类似于<strong class="is hj">函数调用</strong>。</p><pre class="kj kk kl km fd kn ko kp kq aw kr bi"><span id="d05f" class="ks kt hi ko b fi ku kv l kw kx">emp_obj = employee()</span></pre><p id="91c2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这将创建一个名为emp_obj的新对象实例。我们可以使用对象名前缀来访问对象的属性。<br/> <strong class="is hj">属性</strong>可能是数据或者方法。对象的<strong class="is hj">方法</strong>是该类对应的函数。<br/>也就是说，既然employee.greet是一个函数对象(类的属性)，那么employee.greet就会是一个方法对象。</p><p id="818f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">“自我”一词</strong></p><p id="959a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">self用来表示类的<strong class="is hj">实例</strong>。<br/>使用这个关键字，你可以<strong class="is hj">访问</strong>python中类的<strong class="is hj">属性</strong>和<strong class="is hj">方法</strong>。它将属性与给定的参数绑定在一起。<br/> <strong class="is hj"> self </strong>也用于引用类内的<strong class="is hj">变量</strong>字段。让我们举个例子，看看它是如何工作的:</p><pre class="kj kk kl km fd kn ko kp kq aw kr bi"><span id="6a07" class="ks kt hi ko b fi ku kv l kw kx">class Office:<br/> <br/># name made in constructor<br/>   def __init__(self, US):<br/>       self.location = US<br/> <br/>   def office_location(self):<br/>       return self.location</span></pre></div><div class="ab cl jo jp gp jq" role="separator"><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt"/></div><div class="hb hc hd he hf"><p id="4f0d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">继承</strong></p><p id="2b15" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><a class="ae kz" href="https://www.geeksforgeeks.org/inheritance-in-python/" rel="noopener ugc nofollow" target="_blank">继承</a>是一个类<strong class="is hj">继承另一个类的<strong class="is hj">属性</strong>和<strong class="is hj">方法</strong>的过程。<br/>继承了<strong class="is hj">属性</strong>和<strong class="is hj">方法</strong>的类称为父类。从<strong class="is hj">父</strong>类继承属性的类是<strong class="is hj">子</strong>类。</strong></p><p id="0217" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">基本语法:</strong></p><pre class="kj kk kl km fd kn ko kp kq aw kr bi"><span id="c041" class="ks kt hi ko b fi ku kv l kw kx">class parent:<br/>    statements<br/>                    <br/>class child(parent):<br/>    statements</span></pre><p id="32ce" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在继承的子类中，可以使用<a class="ae kz" href="https://www.geeksforgeeks.org/python-super/" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj"> super() </strong> </a>函数引用父类。super函数返回超类的一个临时对象，允许访问它的子类的所有方法。</p></div><div class="ab cl jo jp gp jq" role="separator"><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt"/></div><div class="hb hc hd he hf"><p id="6939" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">继承的类型</strong></p><ol class=""><li id="b0ec" class="jv jw hi is b it iu ix iy jb jx jf jy jj jz jn la kb kc kd bi translated">单一继承<br/>单一继承使派生类能够<strong class="is hj">从单一父类</strong>继承属性和行为。它允许派生类继承基类的属性和行为，从而实现代码的可重用性，并为现有代码添加新功能。</li><li id="daaf" class="jv jw hi is b it ke ix kf jb kg jf kh jj ki jn la kb kc kd bi translated">多重继承<br/>一个<strong class="is hj">类</strong>可以从Python中的多个基类<strong class="is hj">派生</strong>，类似于C++。这叫做多重继承。<br/>在多重继承中，所有基类的特性都被继承到派生类中。多重继承的语法类似于单继承。</li><li id="ad7d" class="jv jw hi is b it ke ix kf jb kg jf kh jj ki jn la kb kc kd bi translated">多级继承<br/>我们也可以从<strong class="is hj">派生类</strong>中<strong class="is hj">继承</strong>。这被称为多级继承。在Python中可以是任意深度。<br/>在多级继承中，基类和派生类的特征被继承到新的派生类中。</li><li id="120f" class="jv jw hi is b it ke ix kf jb kg jf kh jj ki jn la kb kc kd bi translated">分层继承<br/>当<strong class="is hj">从一个<strong class="is hj">单库</strong>中创建多个派生类</strong>时，这种类型的继承称为分层继承。在这个程序中，我们有一个父类(基类)和两个子类(派生类)。</li><li id="8ffe" class="jv jw hi is b it ke ix kf jb kg jf kh jj ki jn la kb kc kd bi translated">混合继承<br/> <strong class="is hj">由多种类型的继承</strong>组成的继承称为混合继承</li></ol></div><div class="ab cl jo jp gp jq" role="separator"><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt"/></div><div class="hb hc hd he hf"><p id="21f6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">多态性</strong></p><p id="5061" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">多态性是指<strong class="is hj">多种形式</strong>。在python中，我们可以找到采用多种形式的同一个操作符或函数。<br/>这也有助于创建具有相同名称的类方法的不同类。这有助于<strong class="is hj">重用</strong>大量代码并降低代码复杂度。<br/> <a class="ae kz" href="https://www.geeksforgeeks.org/polymorphism-in-python/" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj">多态性</strong> </a>也与遗传有关，我们将在下面的一些例子中看到。</p><pre class="kj kk kl km fd kn ko kp kq aw kr bi"><span id="7d7a" class="ks kt hi ko b fi ku kv l kw kx">class Square:<br/>    side = 5     <br/>    def area_sq(self):<br/>        return self.side * self.side</span><span id="101c" class="ks kt hi ko b fi ky kv l kw kx">class Triangle:<br/>    base = 5<br/>    height = 2<br/>    def area_tri(self):<br/>        return 0.5 * self.base * self.height</span><span id="427e" class="ks kt hi ko b fi ky kv l kw kx">sq = Square()<br/>tri = Triangle()<br/>print("Area of square: ", sq.area_sq())<br/>print("Area of triangle: ", tri.area_tri())</span><span id="ee33" class="ks kt hi ko b fi ky kv l kw kx">Output:<br/>Area of square: 25 <br/>Area of triangle: 5.0</span></pre></div><div class="ab cl jo jp gp jq" role="separator"><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt"/></div><div class="hb hc hd he hf"><p id="3b78" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">抽象</strong></p><p id="d819" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Python中的抽象是对用户隐藏应用程序的真正实现，只强调它的使用的过程。例如，假设你买了一个新的电子产品。除了这个小工具，您还会得到一个用户指南，指导如何使用这个应用程序，但是这个用户指南没有关于这个小工具内部工作的信息。</p><p id="83db" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">通过Python中的抽象过程，程序员可以隐藏一个应用的所有<strong class="is hj">无关数据/进程</strong>，以便<strong class="is hj">降低</strong> <strong class="is hj">复杂性</strong>和<strong class="is hj">提高效率</strong>。</p><p id="c7eb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在Python中，<a class="ae kz" href="https://www.geeksforgeeks.org/abstract-classes-in-python/" rel="noopener ugc nofollow" target="_blank">抽象</a>可以通过在我们的程序中使用<strong class="is hj">抽象类</strong>和方法来实现。</p><p id="efc9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">抽象方法不包含任何实现。相反，所有的实现都可以在继承抽象类的子类<strong class="is hj">的方法中定义。<br/>一个<strong class="is hj">抽象类</strong>通过从‘ABC’模块导入一个名为‘ABC’的类并继承‘ABC’类来创建。<br/>下面是创建抽象类的语法。</strong></p><pre class="kj kk kl km fd kn ko kp kq aw kr bi"><span id="08cb" class="ks kt hi ko b fi ku kv l kw kx"><strong class="ko hj">Syntax</strong><br/>from abc import ABC<br/>Class ClassName(ABC):</span></pre><p id="9a4e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">封装</strong></p><p id="1605" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">Python中的封装</strong>是<strong class="is hj">将</strong>的变量和方法包装成一个实体的过程。在编程中，一个类是一个例子，它将所有定义在<strong class="is hj">中的变量和方法封装在</strong>中。</p><p id="7482" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在Python中，<a class="ae kz" href="https://www.geeksforgeeks.org/encapsulation-in-python/" rel="noopener ugc nofollow" target="_blank">封装</a>可以通过将类的数据成员声明为私有或受保护来实现。在Python中，'<strong class="is hj"> Private </strong>和'<strong class="is hj"> Protected </strong>'被称为<strong class="is hj">访问修饰符</strong>，因为它们修改类中定义的变量或方法的访问</p><p id="844c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">示例:</p><pre class="kj kk kl km fd kn ko kp kq aw kr bi"><span id="9486" class="ks kt hi ko b fi ku kv l kw kx">class Computer:</span><span id="b2d1" class="ks kt hi ko b fi ky kv l kw kx">def __init__(self):<br/>        self.__maxprice = 900</span><span id="6c48" class="ks kt hi ko b fi ky kv l kw kx">def sell(self):<br/>        print("Selling Price: {}".format(self.__maxprice))</span><span id="ea9f" class="ks kt hi ko b fi ky kv l kw kx">def setMaxPrice(self, price):<br/>        self.__maxprice = price</span><span id="5ef1" class="ks kt hi ko b fi ky kv l kw kx">c = Computer()<br/>c.sell()</span><span id="e9e8" class="ks kt hi ko b fi ky kv l kw kx"># change the price<br/>c.__maxprice = 1000<br/>c.sell()</span><span id="10f4" class="ks kt hi ko b fi ky kv l kw kx"># using setter function<br/>c.setMaxPrice(1000)<br/>c.sell()</span><span id="a13f" class="ks kt hi ko b fi ky kv l kw kx">Output:<br/>Selling Price: 900<br/>Selling Price: 900<br/>Selling Price: 1000</span></pre><p id="0ad4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在上面的程序中，我们定义了一个计算机类。</p><p id="d2b9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们用<code class="du lb lc ld ko b">__init__()</code>的方法存储了<code class="du lb lc ld ko b">Computer</code>的最高售价。我们试图修改价格。但是，我们不能改变它，因为Python将__maxprice视为私有属性。</p><p id="6f22" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如图所示，要改变这个值，我们必须使用一个setter函数，即<code class="du lb lc ld ko b">setMaxPrice()</code>，它将价格作为一个参数。</p></div><div class="ab cl jo jp gp jq" role="separator"><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt"/></div><div class="hb hc hd he hf"><p id="a656" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">结论:</strong></p><ul class=""><li id="d357" class="jv jw hi is b it iu ix iy jb jx jf jy jj jz jn ka kb kc kd bi translated">面向对象编程使程序既容易理解又高效。</li><li id="dfe8" class="jv jw hi is b it ke ix kf jb kg jf kh jj ki jn ka kb kc kd bi translated">因为类是可共享的，所以代码可以重用。</li><li id="b1c6" class="jv jw hi is b it ke ix kf jb kg jf kh jj ki jn ka kb kc kd bi translated">通过数据抽象，数据是安全的。</li><li id="f60c" class="jv jw hi is b it ke ix kf jb kg jf kh jj ki jn ka kb kc kd bi translated">多态性允许不同的对象使用相同的接口，因此程序员可以编写高效的代码。</li></ul></div><div class="ab cl jo jp gp jq" role="separator"><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt"/></div><div class="hb hc hd he hf"><p id="d53c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">参考文献</strong></p><ol class=""><li id="d679" class="jv jw hi is b it iu ix iy jb jx jf jy jj jz jn la kb kc kd bi translated"><a class="ae kz" href="https://www.programiz.com/python-programming/object-oriented-programming" rel="noopener ugc nofollow" target="_blank">https://www . programiz . com/python-programming/object-oriented-programming</a></li><li id="6131" class="jv jw hi is b it ke ix kf jb kg jf kh jj ki jn la kb kc kd bi translated"><a class="ae kz" href="https://www.geeksforgeeks.org/object-oriented-programming-in-python-set-1-class-and-its-members/" rel="noopener ugc nofollow" target="_blank">https://www . geeks forgeeks . org/object-oriented-programming-in-python-set-1-class-and-its-members/</a></li><li id="8fc7" class="jv jw hi is b it ke ix kf jb kg jf kh jj ki jn la kb kc kd bi translated"><a class="ae kz" href="https://www.analyticsvidhya.com/blog/2020/09/object-oriented-programming/" rel="noopener ugc nofollow" target="_blank">https://www . analyticsvidhya . com/blog/2020/09/面向对象编程/ </a></li><li id="2897" class="jv jw hi is b it ke ix kf jb kg jf kh jj ki jn la kb kc kd bi translated"><a class="ae kz" href="https://towardsdatascience.com/2-must-know-oop-concepts-in-python-48d643a7385" rel="noopener" target="_blank">https://towards data science . com/2-must-know-OOP-concepts-in-python-48d 643 a 7385</a></li><li id="3fe5" class="jv jw hi is b it ke ix kf jb kg jf kh jj ki jn la kb kc kd bi translated"><a class="ae kz" href="https://www.datacamp.com/community/tutorials/python-oop-tutorial" rel="noopener ugc nofollow" target="_blank">https://www . data camp . com/community/tutorials/python-OOP-tutorial</a></li><li id="18d2" class="jv jw hi is b it ke ix kf jb kg jf kh jj ki jn la kb kc kd bi translated"><a class="ae kz" href="https://www.youtube.com/watch?v=ZDa-Z5JzLYM" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=ZDa-Z5JzLYM</a></li></ol></div></div>    
</body>
</html>