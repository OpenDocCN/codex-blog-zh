<html>
<head>
<title>Recursion: A General Approach</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">递归:一种通用方法</h1>
<blockquote>原文：<a href="https://medium.com/codex/recursion-a-general-approach-ba2c2abbc7ff?source=collection_archive---------23-----------------------#2021-07-30">https://medium.com/codex/recursion-a-general-approach-ba2c2abbc7ff?source=collection_archive---------23-----------------------#2021-07-30</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="1e28" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">基于<a class="ae jd" href="https://www.merriam-webster.com/dictionary/recursion" rel="noopener ugc nofollow" target="_blank"><em class="je">【merriam-webster.com】</em></a>，递归是一种计算机编程技术，涉及使用<strong class="ih hj">一次或多次调用自己的过程、子例程、函数或算法，直到<em class="je">满足指定条件</em>。执行粗体句子的函数称为递归函数。</strong></p><p id="4203" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">递归是如何工作的有很多可视化的表示，比如Sierpiński三角形和递归树，如下所示。</p><figure class="jg jh ji jj fd jk er es paragraph-image"><div class="er es jf"><img src="../Images/991334ad427182a635892012fe4d0e88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1268/0*TbAoCoFUtaLqn6BO"/></div><figcaption class="jn jo et er es jp jq bd b be z dx translated">递归树。<a class="ae jd" href="https://www.101computing.net/recursive-tree-challenge/" rel="noopener ugc nofollow" target="_blank">https://www.101computing.net/recursive-tree-challenge/</a></figcaption></figure><figure class="jg jh ji jj fd jk er es paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="er es jr"><img src="../Images/45d26f1fce2ccfbd35475baad8d515e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*awshXQoFRKPfx5VF"/></div></div><figcaption class="jn jo et er es jp jq bd b be z dx translated">舍尔皮斯基三角。<a class="ae jd" href="https://commons.wikimedia.org/wiki/File:Sierpinski_triangle_evolution.svg" rel="noopener ugc nofollow" target="_blank">https://commons . wikimedia . org/wiki/File:Sierpinski _ triangle _ evolution . SVG</a></figcaption></figure><p id="0af3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">递归是计算机编程中解决问题方法的一个很好的例子。分解确实在这个算法中发挥了作用。什么是分解？这里可以看<a class="ae jd" href="https://medium.com/p/e5f211260134/edit" rel="noopener">；)</a></p><p id="839d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了解决我们的主要问题(在这种情况下进行第五次递归)，我们必须知道如何首先制作较小的三角形，这被归类为我们的子问题。</p></div><div class="ab cl jw jx gp jy" role="separator"><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb"/></div><div class="hb hc hd he hf"><p id="9b2d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">递归函数有两种，直接和间接。</strong></p><p id="f85c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这段代码被称为直接函数，因为它调用同一个函数Fun。</p><pre class="jg jh ji jj fd kd ke kf kg aw kh bi"><span id="0172" class="ki kj hi ke b fi kk kl l km kn">void dirFun()<br/>{<br/> // some code..<br/> dirFun();<br/> // some code..<br/>}</span></pre><p id="68f4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个如果调用另一个函数(比如Fun_1)而Fun_1直接或间接调用Fun这个函数，就叫间接函数。</p><pre class="jg jh ji jj fd kd ke kf kg aw kh bi"><span id="ed05" class="ki kj hi ke b fi kk kl l km kn">void indirFun1()<br/>{<br/> // some code..<br/> indirFun2();<br/> // some code..<br/>}</span><span id="f107" class="ki kj hi ke b fi ko kl l km kn">void indirFun2()<br/>{<br/> // some code..<br/> indirFun1();<br/> //</span></pre><p id="59f2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">我第一次说的定义中的‘特定条件’是什么意思？</strong></p><p id="3bc9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">特定条件通常也被称为<strong class="ih hj"><em class="je"/></strong>。我们必须正确地创建一个基本条件来限制我们的程序，这样它就不会是一个无限循环。</p><p id="f146" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们如何确定它是否是正确的基本条件？</p><pre class="jg jh ji jj fd kd ke kf kg aw kh bi"><span id="1d76" class="ki kj hi ke b fi kk kl l km kn">int fact(int n)<br/>{<br/> if (n == 100) // &lt;- wrong base case!<br/> return 1;</span><span id="ead9" class="ki kj hi ke b fi ko kl l km kn">else<br/> return n*fact(n-1);<br/>}</span></pre><p id="5b08" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面的代码块是一个递归函数，用来计算一个数n的阶乘。你看出为什么它出错了吗？首先，让我把这段代码翻译成更人性化的语言。</p><p id="94e4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="je">嘿，我要做一个函数求n的阶乘，这些是要求。如果n等于100，请给我1。不管别的什么，请给我n *阶乘(n-1)吧！</em></p><p id="b672" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">等等，什么？阶乘只有在为0或1时才等于1，而不是100。这就是为什么它是错误的基础案例。</p><p id="04a0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">如果用错误的基础条件运行函数会发生什么？</strong></p><p id="3856" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">堆栈溢出！你可能对这个很熟悉。堆栈溢出是由于<strong class="ih hj">过度使用内存</strong>导致的计算机程序错误。此错误发生在调用堆栈中。我们可以把栈想象成我们代码的容器。堆栈可用的内存量有限。它的大小由<a class="ae jd" href="https://en.wikipedia.org/wiki/Programming_language" rel="noopener ugc nofollow" target="_blank">编程语言、</a> <a class="ae jd" href="https://en.wikipedia.org/wiki/Computer_architecture" rel="noopener ugc nofollow" target="_blank">架构</a>、CPU上是否有<a class="ae jd" href="https://en.wikipedia.org/wiki/Multithreading_(computer_architecture)" rel="noopener ugc nofollow" target="_blank">多线程</a>以及有多少内存可用来决定。当堆栈溢出发生时，通常会冻结或关闭程序。</p><p id="c3ec" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">说起无限循环，递归函数和迭代有关系吗？</strong></p><p id="f3ea" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">是啊！递归通常被用作使代码看起来更干净、更简单的替代方法。这是一个使用迭代和递归的比较，以找到从数字a到数字b的总和。</p><pre class="jg jh ji jj fd kd ke kf kg aw kh bi"><span id="93d2" class="ki kj hi ke b fi kk kl l km kn">// using iteration</span><span id="19ca" class="ki kj hi ke b fi ko kl l km kn">int main()<br/>{<br/> int a,b;<br/> cout &lt;&lt; “a= “;<br/> cin &gt;&gt; a;<br/> cout &lt;&lt; “b= “;<br/> cin &gt;&gt; b;</span><span id="8fa2" class="ki kj hi ke b fi ko kl l km kn">int sum = 0;<br/> for (int i=a; i&lt;=b; i++)<br/> {<br/> sum += i;<br/> }<br/> <br/> cout &lt;&lt; “total sum from “ &lt;&lt; a &lt;&lt; “ to “ &lt;&lt; b &lt;&lt; “ is “ &lt;&lt; sum;<br/> return 0;<br/>}</span><span id="b513" class="ki kj hi ke b fi ko kl l km kn">// using recursion</span><span id="8235" class="ki kj hi ke b fi ko kl l km kn">int recursion101(int a , int b)<br/>{<br/> if (a == b)<br/> {<br/> return a;<br/> }<br/>return a +recursion(a+1, b);<br/>}</span><span id="6f76" class="ki kj hi ke b fi ko kl l km kn">int main()<br/>{<br/> int a,b;<br/> cout &lt;&lt; “a= “;<br/> cin &gt;&gt; a;<br/> cout &lt;&lt; “b= “;<br/> cin &gt;&gt; b;</span><span id="1ada" class="ki kj hi ke b fi ko kl l km kn">cout &lt;&lt; “total sum from “ &lt;&lt; a &lt;&lt; “ to “ &lt;&lt; b &lt;&lt; “ is “ &lt;&lt; sum;<br/> return 0;<br/>}</span></pre><p id="db5d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">注意<strong class="ih hj">I&lt;= b</strong>in for(int I = a；I&lt;= b；i++)和<strong class="ih hj"> if (a == b) </strong>功能相同！它们作为一个基本条件！</p><p id="5915" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">尽管递归比迭代代码更简洁，但并不总是需要使用递归。用迭代求解斐波那契比递归好。如果我们拒绝使用迭代，就会出现冗余。在此图中，Tia希望通过迭代找到第5个斐波那契数，Rosi希望使用递归来找到。当您使用迭代时，它保留每个先前的值，然后计算下一个值，而不将它们设置为输出。当你使用递归函数时，每次迭代，它都会设置为一个新值。在Tia方面，每个F(n)只有一个值。但是在Rosi这边，F(3)和F(0)有两个值，F(2)有三个值，F(1)有五个值。</p><figure class="jg jh ji jj fd jk er es paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="er es kp"><img src="../Images/d5d0eb2255983804dd4adfb6e5e9bab5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Js_hAEpxTBw4O-vt"/></div></div><figcaption class="jn jo et er es jp jq bd b be z dx translated">我的演示幻灯片XD</figcaption></figure><p id="75ff" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">实际上，递归的实现并不像这篇文章那么简单，但我希望这篇文章能帮助你抓住一般概念来理解递归算法。祝你好运！</p></div></div>    
</body>
</html>