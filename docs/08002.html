<html>
<head>
<title>LeetCode 322. Coin Change — Python Solution</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">LeetCode 322。硬币兑换Python解决方案</h1>
<blockquote>原文：<a href="https://medium.com/codex/leetcode-322-coin-change-python-solution-3ee10793cd6b?source=collection_archive---------3-----------------------#2022-07-10">https://medium.com/codex/leetcode-322-coin-change-python-solution-3ee10793cd6b?source=collection_archive---------3-----------------------#2022-07-10</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="d6b2" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">盲75 —编程和技术面试问题—解释系列</h2></div><h2 id="18a8" class="ix iy hi bd iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju bi translated">问题是:</h2><figure class="jw jx jy jz fd ka er es paragraph-image"><div role="button" tabindex="0" class="kb kc di kd bf ke"><div class="er es jv"><img src="../Images/e078f8347c0df9fc246194015e5dfdca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*-Oi8mgDhXU_CG_gg.png"/></div></div></figure><h2 id="3874" class="ix iy hi bd iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju bi translated">解释是:</h2><p id="436d" class="pw-post-body-paragraph kh ki hi kj b kk kl ij km kn ko im kp ji kq kr ks jm kt ku kv jq kw kx ky kz hb bi translated">最初我认为这个解决方案很简单，将硬币分类，然后从最大的硬币到最小的硬币，直到总数为0。这个解决方案的问题是，数量可能大于最大的硬币，但如果使用最大的硬币，你就无法达到0。这就是问题变得更加复杂的地方。使用自底向上的动态编程技术效果最好。你可以从0.01美元(总数是一美分，而不是美元总数)一直计算到总数，然后对每一整美元检查每一枚硬币，如果硬币少于或等于总数，在硬币总数上再加一枚硬币，以达到先前的总数。在这个循环之后，返回最小数量的硬币来增加这个数量。</p><h2 id="26fc" class="ix iy hi bd iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju bi translated">动态规划解:O(n * k)</h2><p id="4f9f" class="pw-post-body-paragraph kh ki hi kj b kk kl ij km kn ko im kp ji kq kr ks jm kt ku kv jq kw kx ky kz hb bi translated">首先创建一个数组，用来记录需要的最小硬币数量。将该数组中的每个索引设置为数量加1。这在返回声明中使用，以检查硬币的总和是否达到该金额，并确定所需硬币的最小金额。为了计算出总数，你必须将0-index设置为0。这是因为一旦你到达一个硬币，将设置金额为0，你可以添加一个硬币到硬币计数。现在从1到数量(n)循环，对于每个数量循环所有的硬币(k)。对于每个硬币，你要断言硬币小于或等于金额。如果是，您希望将数组中的索引设置为自身的最小值(如果另一个硬币有效，这将是该数量)和1加上该数量的硬币计数减去该硬币(达到前一数量所需的硬币数量)。这将是每个数额将有最低数额的硬币需要达到该数额。顶层循环完成后，返回达到该数量所需的硬币数量，只要它不等于该数量加1(其初始值)。如果等于该值，则返回-1，因为没有硬币组合可以达到该值。</p><pre class="jw jx jy jz fd la lb lc ld aw le bi"><span id="47d3" class="ix iy hi lb b fi lf lg l lh li">class Solution:<br/> def coinChange(self, coins: List[int], amount: int) -&gt; int:<br/>  dp = [amount + 1] * (amount + 1)<br/>  dp[0] = 0<br/> <br/>  for a in range(1, amount + 1):<br/>   for c in coins:<br/>    if a — c &gt;= 0:<br/>     dp[a] = min(dp[a], 1 + dp[a — c])<br/> <br/>  return dp[amount] if dp[amount] != amount + 1 else -1</span></pre><h1 id="cb1a" class="lj iy hi bd iz lk ll lm jd ln lo lp jh io lq ip jl ir lr is jp iu ls iv jt lt bi translated">信息:</h1><p id="7e55" class="pw-post-body-paragraph kh ki hi kj b kk kl ij km kn ko im kp ji kq kr ks jm kt ku kv jq kw kx ky kz hb bi translated">网址:<a class="ae lu" href="http://www.nkwade.dev/" rel="noopener ugc nofollow" target="_blank">nkwade . dev</a><br/>LinkedIn:<a class="ae lu" href="http://www.linkedin.com/in/nkwade/" rel="noopener ugc nofollow" target="_blank">linkedin.com/in/nkwade</a><br/>GitHub:<a class="ae lu" href="http://www.github.com/nkwade" rel="noopener ugc nofollow" target="_blank">github.com/nkwade</a><br/>邮箱:<a class="ae lu" href="mailto:nicholas@nkwade.dev" rel="noopener ugc nofollow" target="_blank"> nicholas@nkwade.dev </a></p></div></div>    
</body>
</html>