<html>
<head>
<title>Activity vs Fragment in Android</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Android中的活动与片段</h1>
<blockquote>原文：<a href="https://medium.com/codex/activity-vs-fragment-in-android-d9595a79119?source=collection_archive---------0-----------------------#2021-08-14">https://medium.com/codex/activity-vs-fragment-in-android-d9595a79119?source=collection_archive---------0-----------------------#2021-08-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="05fa" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">这两个基本Android UI组件的比较以及如何使用Kotlin正确使用它们</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/14acd000c0126a8e93d36a2dcc5d0865.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*aZvwp0jcnfEkjGDK"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">照片由<a class="ae jn" href="https://unsplash.com/@glencarrie?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">格伦·凯莉</a>在<a class="ae jn" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><p id="6a4e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">很多时候，在论坛和StackOverflow上阅读，我遇到过有人询问如何正确建立片段视图，或者难以理解与活动的区别。</p><p id="6e6b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这篇文章的目的是解释什么区分活动和片段，如何正确地设置它们各自的布局，以及何时使用其中的一个或另一个。</p><p id="448f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">先说他们的定义。</p></div><div class="ab cl kk kl gp km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="hb hc hd he hf"><h1 id="edfa" class="kr ks hi bd kt ku kv kw kx ky kz la lb io lc ip ld ir le is lf iu lg iv lh li bi translated">什么是活动？</h1><p id="dc3b" class="pw-post-body-paragraph jo jp hi jq b jr lj ij jt ju lk im jw jx ll jz ka kb lm kd ke kf ln kh ki kj hb bi translated">仅仅通过阅读这两种结构的定义，就可以看出它们是非常不同的。</p><p id="5e02" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">根据Android开发者的<a class="ae jn" href="https://developer.android.com/reference/android/app/Activity" rel="noopener ugc nofollow" target="_blank">官方文档</a>，</p><blockquote class="lo lp lq"><p id="d48e" class="jo jp lr jq b jr js ij jt ju jv im jw ls jy jz ka lt kc kd ke lu kg kh ki kj hb bi translated">一个<strong class="jq hj">活动</strong>是用户可以做的一个单一的、集中的事情。几乎所有的活动都与用户交互，所以Activity类负责为您创建一个窗口，您可以在其中放置带有<code class="du lv lw lx ly b">setContentView(View)</code>的UI</p></blockquote><h1 id="fde3" class="kr ks hi bd kt ku lz kw kx ky ma la lb io mb ip ld ir mc is lf iu md iv lh li bi translated">什么是碎片？</h1><p id="968f" class="pw-post-body-paragraph jo jp hi jq b jr lj ij jt ju lk im jw jx ll jz ka kb lm kd ke kf ln kh ki kj hb bi translated">另一方面，这是来自<a class="ae jn" href="https://developer.android.com/guide/fragments" rel="noopener ugc nofollow" target="_blank">官方文档</a>的片段定义:</p><blockquote class="lo lp lq"><p id="1305" class="jo jp lr jq b jr js ij jt ju jv im jw ls jy jz ka lt kc kd ke lu kg kh ki kj hb bi translated">一个<strong class="jq hj">片段</strong>代表了你的应用程序UI的可重用部分。片段定义和管理自己的布局，有自己的生命周期，可以处理自己的输入事件。片段不能独立存在——它们必须由一个活动或另一个片段托管。</p></blockquote><p id="8f4d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">从定义中可以看出，关键的区别在于<strong class="jq hj">片段依赖于活动才能存在</strong>，因此它只代表用户界面的一部分。</p><p id="7abb" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">相反，可以将活动看作是一个容器，所有其他UI组件(包括片段)都将放在这个容器下。没有活动，就没有用户界面。</p></div><div class="ab cl kk kl gp km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="hb hc hd he hf"><h1 id="4463" class="kr ks hi bd kt ku kv kw kx ky kz la lb io lc ip ld ir le is lf iu lg iv lh li bi translated">关于视图绑定的快速说明</h1><p id="f293" class="pw-post-body-paragraph jo jp hi jq b jr lj ij jt ju lk im jw jx ll jz ka kb lm kd ke kf ln kh ki kj hb bi translated">随着<a class="ae jn" href="https://developer.android.com/jetpack" rel="noopener ugc nofollow" target="_blank"> Android Jetpack </a>的推出，引用视图的旧方式已经更新。</p><p id="f4c4" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在，视图绑定自动生成一个类，允许直接引用布局中的所有视图ID，而不是使用<code class="du lv lw lx ly b">findViewById</code>方法。</p><p id="5dde" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">要在Android应用程序中设置视图绑定，您需要在您的<code class="du lv lw lx ly b">build.gradle</code>应用程序文件中指定<code class="du lv lw lx ly b">viewBinding</code>标志:</p><pre class="iy iz ja jb fd me ly mf mg aw mh bi"><span id="9edb" class="mi ks hi ly b fi mj mk l ml mm">android {<br/>    ...<br/>    buildFeatures {<br/>        viewBinding true<br/>    }<br/>}</span></pre><p id="28ae" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">有关视图绑定的更多信息，请查看官方文档。</p></div><div class="ab cl kk kl gp km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="hb hc hd he hf"><h1 id="8fac" class="kr ks hi bd kt ku kv kw kx ky kz la lb io lc ip ld ir le is lf iu lg iv lh li bi translated">如何设置活动</h1><p id="1fc8" class="pw-post-body-paragraph jo jp hi jq b jr lj ij jt ju lk im jw jx ll jz ka kb lm kd ke kf ln kh ki kj hb bi translated">为了正确地创建和设置一个活动，您需要创建一个新的Kotlin类，它扩展了<code class="du lv lw lx ly b">AppCompactActivity</code>类。</p><p id="910b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">几个<strong class="jq hj">文件命名约定</strong>:</p><ul class=""><li id="e7e0" class="mn mo hi jq b jr js ju jv jx mp kb mq kf mr kj ms mt mu mv bi translated">对于布局文件，使用<em class="lr">蛇形语法</em>指定布局类型，后跟布局名称。比如<code class="du lv lw lx ly b">activity_main.xml</code>。</li><li id="c5e5" class="mn mo hi jq b jr mw ju mx jx my kb mz kf na kj ms mt mu mv bi translated">对于布局类，指定布局的名称，后跟布局的类型，使用<em class="lr">骆驼大小写语法</em>。比如说<code class="du lv lw lx ly b">MainActivity.kt</code>。</li></ul><p id="0634" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">首先，您需要为您的活动创建一个布局文件。<br/>Android中的布局文件是XML文件，保存在您项目的<code class="du lv lw lx ly b">layout</code> resource文件夹中。</p><p id="dc42" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">因此，创建一个简单的<code class="du lv lw lx ly b">activity_main.xml</code>文件，并用一个容器布局填充(我将使用一个<code class="du lv lw lx ly b">LinearLayout</code>，只是为了简单起见)，以及一个<code class="du lv lw lx ly b">TextView</code>。</p><pre class="iy iz ja jb fd me ly mf mg aw mh bi"><span id="5867" class="mi ks hi ly b fi mj mk l ml mm">&lt;?xml version="1.0" encoding="utf-8"?&gt;<br/>&lt;LinearLayout       <br/>    xmlns:android="http://schemas.android.com/apk/res/android"<br/>    android:layout_width="match_parent"<br/>    android:layout_height="match_parent"<br/>    android:gravity="center"<br/>    android:orientation="vertical"&gt;<br/><br/>    &lt;TextView<br/>        android:id="@+id/text_view"<br/>        android:layout_width="wrap_content"<br/>        android:layout_height="wrap_content" /&gt;<br/><br/>&lt;/LinearLayout&gt;</span></pre><p id="cbc0" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在让我们回到我们的活动类，第一步是<strong class="jq hj">在<code class="du lv lw lx ly b">onCreate</code>方法中初始化布局</strong>。<br/>然后，使用<code class="du lv lw lx ly b">setContentView</code>方法初始化活动将引用的布局。</p><p id="bd06" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">下面是一个简单活动的示例:</p><pre class="iy iz ja jb fd me ly mf mg aw mh bi"><span id="261f" class="mi ks hi ly b fi mj mk l ml mm">private lateinit var binding: ActivityMainBinding</span><span id="21b7" class="mi ks hi ly b fi nb mk l ml mm">class MainActivity: AppCompatActivity() <br/>{<br/>    override fun onCreate(savedInstanceState: Bundle?) { <br/>        super.onCreate(savedInstanceState)<br/>        binding = ActivityMainBinding.inflate(layoutInflater) <br/>        val view = binding.root       <br/>        setContentView(view)</span><span id="c68b" class="mi ks hi ly b fi nb mk l ml mm">        binding.textView = "This is an Activity example"<br/>    }<br/>}</span></pre><p id="60cc" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">如你所见，你可以通过使用绑定的布局引用来引用你的<code class="du lv lw lx ly b">TextView</code>。</p><p id="da67" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">一旦你完成了你的活动设置<strong class="jq hj">，你需要在你的<em class="lr">Android manifest . XML</em></strong>文件中声明它，在<code class="du lv lw lx ly b">&lt;application&gt;</code>标签中，让Android系统知道它的存在:</p><pre class="iy iz ja jb fd me ly mf mg aw mh bi"><span id="b914" class="mi ks hi ly b fi mj mk l ml mm">&lt;activity android:name=".MainActivity" /&gt;</span></pre><p id="b971" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">如果您需要指定一个活动作为应用程序的起点，您需要做的就是在您的<code class="du lv lw lx ly b">&lt;activity&gt;</code>标签中添加两个特定的<code class="du lv lw lx ly b">&lt;intent-filter&gt;</code>:</p><pre class="iy iz ja jb fd me ly mf mg aw mh bi"><span id="6fa8" class="mi ks hi ly b fi mj mk l ml mm">&lt;activity android:name=".MainActivity"&gt;<br/>    &lt;intent-filter&gt;<br/>        &lt;action android:name="android.intent.action.MAIN" /&gt;<br/>        &lt;category android:name="android.intent.category.LAUNCHER" /&gt;<br/>    &lt;/intent-filter&gt;<br/>&lt;/activity&gt;</span></pre><p id="0f5b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">完成设置后，您的活动将在应用程序启动时显示。</p><h1 id="dbdc" class="kr ks hi bd kt ku lz kw kx ky ma la lb io mb ip ld ir mc is lf iu md iv lh li bi translated">如何设置片段</h1><p id="1d7a" class="pw-post-body-paragraph jo jp hi jq b jr lj ij jt ju lk im jw jx ll jz ka kb lm kd ke kf ln kh ki kj hb bi translated">为了在您的应用程序中利用片段，<strong class="jq hj">您需要将所需的依赖关系</strong>添加到您的项目<code class="du lv lw lx ly b">build.gradle</code>文件中:</p><pre class="iy iz ja jb fd me ly mf mg aw mh bi"><span id="0e2a" class="mi ks hi ly b fi mj mk l ml mm">buildscript {<br/>    ...<br/><br/>    repositories {<br/>        google()<br/>        ...<br/>    }<br/>}<br/><br/>allprojects {<br/>    repositories {<br/>        google()<br/>        ...<br/>    }<br/>}</span></pre><p id="e16a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">一旦您添加了所需的存储库，您只需要在您的应用程序<code class="du lv lw lx ly b">build.gradle</code>文件中指定AndroidX片段库:</p><pre class="iy iz ja jb fd me ly mf mg aw mh bi"><span id="076c" class="mi ks hi ly b fi mj mk l ml mm">dependencies {<br/>    def fragment_version = "&lt;specify-the-latest-version&gt;"<br/><br/>    implementation "androidx.fragment:fragment-ktx:$fragment_version"<br/>}</span></pre><p id="1143" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">有关如何正确设置环境的更多信息，请参考<a class="ae jn" href="https://developer.android.com/guide/fragments/create" rel="noopener ugc nofollow" target="_blank">官方文档</a>。</p><p id="4a8a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">要创建一个片段，您需要创建一个扩展<code class="du lv lw lx ly b">Fragment</code>类的类。</p><p id="a1a3" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">同样，我将为这个片段创建一个简单的布局文件，名为<code class="du lv lw lx ly b">fragment_main.xml</code>，类似于上面的文件:</p><pre class="iy iz ja jb fd me ly mf mg aw mh bi"><span id="94b1" class="mi ks hi ly b fi mj mk l ml mm">&lt;?xml version="1.0" encoding="utf-8"?&gt;<br/>&lt;LinearLayout       <br/>    xmlns:android="http://schemas.android.com/apk/res/android"<br/>    android:layout_width="match_parent"<br/>    android:layout_height="match_parent"<br/>    android:gravity="center"<br/>    android:orientation="vertical"&gt;<br/><br/>    &lt;TextView<br/>        android:id="@+id/text_view"<br/>        android:layout_width="wrap_content"<br/>        android:layout_height="wrap_content" /&gt;<br/><br/>&lt;/LinearLayout&gt;</span></pre><p id="9a43" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">片段的布局在<code class="du lv lw lx ly b">onCreateView</code>方法中初始化:</p><pre class="iy iz ja jb fd me ly mf mg aw mh bi"><span id="b81b" class="mi ks hi ly b fi mj mk l ml mm">private var _binding: FragmentMainBinding? = null<br/>private val binding set() = _binding!!</span><span id="a078" class="mi ks hi ly b fi nb mk l ml mm">class MainFragment: Fragment() <br/>{<br/>    override fun onCreateView(<br/>        inflater: LayoutInflater,<br/>        container: ViewGroup?,<br/>       savedInstanceState: Bundle?<br/>    ): View? {<br/>        _binding = FragmentMainBinding.inflate(inflater, container, false)<br/>        val view = binding.root</span><span id="d834" class="mi ks hi ly b fi nb mk l ml mm">        binding.textView = "This is a Fragment example"</span><span id="5610" class="mi ks hi ly b fi nb mk l ml mm">        return view<br/>    }</span><span id="6e68" class="mi ks hi ly b fi nb mk l ml mm">    override fun onDestroyView() {<br/>        super.onDestroyView()<br/>        _binding = null<br/>    }<br/>}</span></pre><p id="d059" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">与活动不同，片段不需要在<em class="lr"> AndroidManifest.xml. </em>中声明</p><p id="3c62" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">您可能还注意到了一个事实，即视图绑定引用是可选的。<br/>一旦片段从应用程序中移除，这个变量就在<code class="du lv lw lx ly b">onDestroyView</code>方法中被清除。<br/>这是为了避免潜在的内存泄漏问题，因为内存中保存了未使用的对象引用。</p><p id="321d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">然后你需要将你的片段添加到你的活动布局文件中，使用<code class="du lv lw lx ly b">FragmentContainerView</code>布局来使用和显示它:</p><pre class="iy iz ja jb fd me ly mf mg aw mh bi"><span id="9a28" class="mi ks hi ly b fi mj mk l ml mm">&lt;?xml version="1.0" encoding="utf-8"?&gt;<br/>&lt;LinearLayout       <br/>    xmlns:android="http://schemas.android.com/apk/res/android"<br/>    android:layout_width="match_parent"<br/>    android:layout_height="match_parent"<br/>    android:gravity="center"<br/>    android:orientation="vertical"&gt;</span><span id="f542" class="mi ks hi ly b fi nb mk l ml mm">    &lt;androidx.fragment.app.FragmentContainerView<br/>        android:layout_width="match_parent"<br/>        android:layout_height="0dp" <br/>        android:layout_weight="1"<br/>        android:name="com.example.MainFragment" /&gt;<!-- --> </span><span id="1d20" class="mi ks hi ly b fi nb mk l ml mm">    &lt;androidx.fragment.app.FragmentContainerView<br/>        android:layout_width="match_parent"<br/>        android:layout_height="0dp" <br/>        android:layout_weight="1"<br/>        android:name="com.example.Main2Fragment" /&gt;</span><span id="80ac" class="mi ks hi ly b fi nb mk l ml mm">&lt;/LinearLayout&gt;</span></pre><p id="2d4a" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><code class="du lv lw lx ly b">FragmentContainerView</code>将显示在<code class="du lv lw lx ly b">android:name</code>属性中指定的片段。</p><p id="5b61" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">如您所见，<strong class="jq hj">由于组件的模块化，您可以在单个活动中指定多个片段，</strong>。</p></div><div class="ab cl kk kl gp km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="hb hc hd he hf"><h1 id="2c5f" class="kr ks hi bd kt ku kv kw kx ky kz la lb io lc ip ld ir le is lf iu lg iv lh li bi translated">结论</h1><p id="0a26" class="pw-post-body-paragraph jo jp hi jq b jr lj ij jt ju lk im jw jx ll jz ka kb lm kd ke kf ln kh ki kj hb bi translated">虽然活动和片段一开始看起来很相似，可以互换，但实际上，它们是非常不同的。</p><p id="5bf4" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我希望这个指南能帮助你更好地理解并在你的Android应用中更好地使用这些UI组件。</p><p id="c149" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">编码快乐！</p></div></div>    
</body>
</html>