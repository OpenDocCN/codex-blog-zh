<html>
<head>
<title>Hibernate is difficult for string_agg, or sorting by a nested collection</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Hibernate对于string_agg或者按嵌套集合排序来说比较困难</h1>
<blockquote>原文：<a href="https://medium.com/codex/hibernate-is-difficult-for-string-agg-or-sorting-by-a-nested-aggregated-collection-f1b3d3132729?source=collection_archive---------14-----------------------#2022-06-13">https://medium.com/codex/hibernate-is-difficult-for-string-agg-or-sorting-by-a-nested-aggregated-collection-f1b3d3132729?source=collection_archive---------14-----------------------#2022-06-13</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="7d48" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当你需要它们的时候，有一些技巧和几乎没有用例。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/aacbeac5e2289754831df93cf502b817.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*U9x7FE-3ypGYgeUK"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">分类鸟类</figcaption></figure><h2 id="e42d" class="jt ju hi bd jv jw jx jy jz ka kb kc kd iq ke kf kg iu kh ki kj iy kk kl km kn bi translated">我们将在此介绍的内容:</h2><p id="a861" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">1.设置通过嵌套集合排序的用例<br/> 2。提出一个问题<br/> 3。展示如何在原生SQL <br/> 4中实现这一点。展示如何使用HQL作为解决方案<br/> 5。结束这个故事</p><h2 id="d4d1" class="jt ju hi bd jv jw jx jy jz ka kb kc kd iq ke kf kg iu kh ki kj iy kk kl km kn bi translated">用例:有指定课程的学生</h2><p id="c706" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">其中有一个管理员，出于某种原因，他希望将所有学生按他们的课程组合在一列中进行排序。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="kt ku l"/></div></figure><p id="9f76" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">不仅课程本身必须在列中排序，我们还必须确保根据这种排序对学生进行排序😞。如今的要求是疯狂的。</p><p id="e5f6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个模型对于这个练习来说非常简单:</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="kt ku l"/></div><figcaption class="jp jq et er es jr js bd b be z dx translated">没有课程的学生就像没有马的牛仔</figcaption></figure><h2 id="1f18" class="jt ju hi bd jv jw jx jy jz ka kb kc kd iq ke kf kg iu kh ki kj iy kk kl km kn bi translated">问题hibernate没有现成的支持</h2><p id="dc43" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">你可以尝试用hibernate magic排序，不要太成功，因为它不会为你聚合课程</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="kt ku l"/></div></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kv"><img src="../Images/62ccffafd1467dd6eccaa6ca79c3c720.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GOBh0VChgHO1FTdL8MhtNw.png"/></div></div></figure><p id="14c8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果查看生成的sql，失败是显而易见的。这是一个非常基本的分类，没有考虑到所有其他课程</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="kt ku l"/></div></figure><h2 id="e4f7" class="jt ju hi bd jv jw jx jy jz ka kb kc kd iq ke kf kg iu kh ki kj iy kk kl km kn bi translated">原生SQL方法</h2><p id="7758" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">首先，我们必须确保课程本身已经分类</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kw"><img src="../Images/bcbdfbfb3eec86413e8bd2ed97663d14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qyejhB6vDEz2CDkkv4UqJQ.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">不是我们想要的</figcaption></figure><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="kt ku l"/></div></figure><p id="cc65" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以用上面的原生SQL实现我们想要的，但是Hibernate本身没有任何好处。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kx"><img src="../Images/49505adb332c94ee9f6934b4f6b1cd9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bjrEVaVXQngxxUwjUAR8Ug.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">但这很有效🤔让我们装运它。</figcaption></figure><h2 id="1595" class="jt ju hi bd jv jw jx jy jz ka kb kc kd iq ke kf kg iu kh ki kj iy kk kl km kn bi translated">用Spring数据逼近(或者Hibernate？)</h2><p id="0254" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">首先，我们需要为Hibernate注册自定义函数来启用聚合和内部排序(参见<code class="du ky kz la lb b">ORDER BY ?3</code>技巧)</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="kt ku l"/></div><figcaption class="jp jq et er es jr js bd b be z dx translated">不要忘记在application.properties中启用此对话框，如“spring . JPA . properties . hibernate . dialect = com . example . hibernate fun . postgresrichdialect”</figcaption></figure><p id="3054" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我们可以使用聚合在几乎是普通的查询语言上构建一个查询，这正好给出了我们想要的结果:</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="kt ku l"/></div></figure><p id="d617" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">方法调用和默认排序调用的用法很简单:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lc"><img src="../Images/1861c37f04e0a20459e326df8eb5075f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4YqX2gRUuqclnBJMoLgGAw.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">代码示例</figcaption></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ld"><img src="../Images/b6a8ae64ac7029a28d09e7ee5d99a828.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tOyWuuoC0962XozymfxBWg.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">期待已久的结果</figcaption></figure><p id="6e3d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">结论</strong> —不使用hibernate或任何ORM，坚持死简单jdbc。但是如果你有兴趣尝试一下上面的代码，去回购<a class="ae le" href="https://github.com/anatolyD/hibernate-aggs" rel="noopener ugc nofollow" target="_blank">https://github.com/anatolyD/hibernate-aggs</a>的测试部分</p></div></div>    
</body>
</html>