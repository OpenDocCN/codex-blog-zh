# Python 中的并行编程——第 4 课。多重处理

> 原文：<https://medium.com/codex/parallel-programming-in-python-lesson-4-multi-processing-90f597da89ba?source=collection_archive---------14----------------------->

![](img/e528ebd9f3ea1a80ff179c57af1bbe8b.png)

这是系列课程的第四部分，涵盖了 Python 编程语言为并行编程提供的各种工具，以及使用每种工具的动机。在之前的课程中，我们探索了*事件驱动*设计的应用需求，并学习了如何区分真正需要并行代码的需求(例如通过多线程)。我们详细研究了 Python 线程工具，并讨论了(线程之间)同步的需要以及各种可用的同步原语。在这一课中，我们来看看 Python light *多处理*的替代方案(多线程)。

*本课章节:*

1.  线程的交易流程
2.  将事件用作同步布尔值
3.  在进程间共享数据
4.  在进程间序列化数据
5.  额外的多重处理功能
6.  调用另一个程序，被阻止
7.  处理失败的调用程序执行
8.  收集调用的程序输出

## 1.线程的交易流程

以 Python 的*多处理*模块为特色的*进程*非常类似于以 Python 的*线程*模块为特色的*线程*(我们已经在前面的课程中学习过了)，但是由于操作系统提供的进程，它位于一个单独的内存空间中。它具有相似的同步原语(在接口级)，外加一些额外的功能。但是，在表面之下，实现考虑了所涉及的不同存储空间，这一点我们马上就会看到。

让我们从调整前一课中的*生产者/消费者*示例(确切地说:由*消息队列同步的版本)*开始，并将其调整为使用*进程*而不是*线程、*，看看这是否可行。除此之外，程序几乎没有变化！

*注释(对应于已注释的数字):*

1.  这次我们使用的是*多处理*模块。为了维护我们的线程示例的逻辑，我们导入了*可连接的*队列。(由于某种原因，这里的默认消息队列是不可加入的)。
2.  这一次，生产者继承了多重处理
3.  消费者(这是一个普通的函数，不像生产者那样封装)在流程中显式启动。
4.  生产者使用消费者的队列进行初始化。

*输出:(如果你的 IDE 没有显示另一个进程的输出，从命令行运行！)*

```
Round 1 
Round 2 
Round 3 
Round 4 
Round 5 
Round 6 
Round 7 
Round 8 
Round 9 
Round 10 
Round 11 
Round 12 
...
```

出事了！程序继续运行超过第十条消息，必须终止。哪里出了问题？以下调试消息可能有助于澄清错误。

1.  程序仍在运行。结束标志必须为假。
2.  这个程序不再运行了。结束标志必须为真。

*输出:(如果你的 IDE 没有显示另一个进程的输出，从命令行运行！)*

```
... 
Round 7 
Running: flag = False 
Round 8 
Running: flag = False 
Round 9 
Running: flag = False 
Round 10 
Stopping: flag = True 
Running: flag = False 
Round 11 
...
```

程序在*应该停止后继续运行。*显然，*看到的结束标志*仍然是*假的*，尽管(已验证！)的事实，它被设置为*真*早一分钟！

为什么结束标志*被设置为真*(已被验证)，但*仍然为假？*解决方案很简单:它不是同一个*结束标志！结束标志位于生产者对象中，在这个故事中有两个生产者。为什么会有两个制作人？因为有两个过程(“多重处理”，记得吗？).事情是这样的:*

1.  主进程创建一个生产者，它将其 end-flag 初始化为 false。
2.  生产者(被声明为*进程*)名副其实，在后台启动另一个进程，并在那里默默地创建自己的副本。
3.  当请求*启动*时，生产者的主循环启动，但在生产者的进程中。发生在该生产者身上的任何事情(例如，其结束标志的值)都与留在主进程中的生产者无关。
4.  主程序命令它的生产者停止。因为这个方法调用是*同步的*，它影响本地生产者中的结束标志。真正的生产者(进程中的生产者)没有理由意识到这一点，因此，将继续无限期地运行。

当生产者是一根线时，为什么这种伎俩会奏效呢？因为只有一个生产者(线程),而且它和它的客户在同一个内存空间。在这种配置中，我们可以异步和同步地与生产者通信。

通过打印进程 ID 和生产者的地址，两个单独的对象(并且在两个单独的进程中)的事实无疑得到了证明:

*输出:(如果你的 IDE 没有显示另一个进程的输出，从命令行运行！)*

```
Main program. Process: 5884 
Producer constructor. Process: 5884 
Producer main loop. Process: 7372 
Round 1 
Round 2 
Round 3 
Round 4 
Round 5 
Round 6 
Round 7 
Round 8 
Round 9 
Round 10 
Producer stop method. Process: 5884 
Round 11 
Round 12
...
```

正如我们可以从进程 id 看出的，生产者是在主程序中初始化的。对于子进程中的生产者，构造函数*不再被调用*(因为，一旦被初始化，它就被悄悄地复制到那里——被酸洗和去酸洗)。停止请求被发送到主程序中的制作人。生产者主循环发生在另一个进程中！

*士气:*与一个流程的通信一定是*异步的！*我们不能使用*变量*在进程间通信(因为相对于另一个进程，该变量位于错误的内存空间)。Python 的多重处理为我们提供了两种解决方案:

1.  使用*同步原语*(多处理版本)来代替。
2.  使用一个*同步变量*(并让多处理模块在进程间编组值)。

## 2.将事件用作同步布尔值

这个例子将布尔结束标志升级为一个*事件，*作为一个全局布尔，它的值可以被两个进程访问。(但它不是用来实际持有和释放任何人的，这是真实事件应该做的)。

1.  该程序使用多重处理。
2.  生产者从外部接收事件。生产者被简化为一个函数，因为它不再有*状态*(结束标志)，并且不再需要“停止”设置器(它拥有的唯一可寻址方法)。
3.  非阻塞地查询事件的值。
4.  生产者功能是使用事件(主程序的本地事件)启动的。
5.  主程序发出事件信号。

*输出:(如果你的 IDE 没有显示另一个进程的输出，从命令行运行！)*

```
Round 1 
Round 2 
Round 3 
Round 4 
Round 5 
Round 6 
Round 7 
Round 8 
Round 9 
Round 10 
[End of input]
```

## 3.在进程间共享数据

由于多重处理模块的缘故，我们可以使用一个适当的布尔值，而不是使用布尔类型的事件。出于某种原因(可能是性能)，进程间共享的变量库仅限于 Python/C 接口中定义的 C 语言*基本类型*(与 Python 习惯相反，是*强类型的！)*。

1.  我们将使用多重处理。价值
2.  该程序使用了 *ctypes* (C 语言接口)模块。
3.  生产者被升级回一个类(因为它有状态并有一个 setter)。
4.  多重处理。Value 封装了一个 C 变量，其值在进程间自动共享。
5.  值的真值返回内部变量的真值(本例中为布尔值)。
6.  存储在 value 对象内部的值被赋为 True (python 风格，而不是 C 风格的“True”)。这里一个灾难性的程序错误是将新值赋给值持有者，而不是它的内容(Python 会默默地服从，但结果可能不符合您的意图！)如: **self.toStop = True** 。这将取代多重处理。值，这在语法上是正确的，但是会终止同步！
7.  结束标志同步不再涉及主程序。

*附加共享值功能:*

*   标量值可以是任何熟悉的 C 语言类型，如 *bool、char、int、uint、long、double、*等。)
*   对于多个值，使用共享(同类)数组。
*   值类型也可以由单字母代码指定，例如“c”(代表字符)，“I”代表有符号整数，等等。
*   (一些)Python 类型(包括 dict 和 list)也可以共享，需要启动一个*管理器*进程。

## 4.在进程间序列化数据

在通信被限制在*两个进程之间的*稳定流*的情况下，*基于队列的同步可以通过*管道得到某种程度的简化。*

*备注:*

1.  该程序使用多重处理。
2.  使用管道(的一端)初始化生成器。
3.  生产者通过管道发送消息。
4.  这个解决方案用 *ack* 代替了类似消息队列事件的行为。发送消息后，生产者等待 ack(来自同一个管道)，阻塞。
5.  远程连接必须显式关闭(在生成器端)，以释放另一端。
6.  使用管道(的另一端)初始化使用者。
7.  消费者等待来自管道的消息，阻塞。
8.  尝试从关闭的连接(在另一端)接收会导致错误，使用者将其解释为消息流的合法结尾
9.  消费者等待两秒钟，然后发送 ack。(在这里，消费者设定速度)。
10.  远程连接在消费者端也是显式关闭的。
11.  主程序打开一个管道，给出两个连接(从一个二元组解包)。
12.  使用管道的一个*连接*端初始化消费者。
13.  使用管道的另一个*连接*端初始化生成器。
14.  本地连接也需要显式关闭，以正确处理管道！

*附加管道功能:*

*   默认情况下，管道是*全双工*(两种连接都可以用于发送和接收)。这可能是受约束的(例如左侧的*仅接收*，右侧的*仅发送*)。
*   除了 Python 字符串，管道还可以传输原始字节数组和任意 Python 对象，只要它们是 *pickle-able* (使用 Python 的 *pickle* 工具可以序列化)。

## 5.额外的多重处理功能

使用多处理功能(作为多线程的替代)涉及启动额外进程和上下文切换的明显开销，但这被认为是可以忽略的，特别是与优势相比时，优势主要是:

*   不容易出现共享资源损坏和竞争情况。
*   获得*同时性*(需要的地方)*，*从臭名昭著的 GIL 的暴政下解放出来(Python 的全局解释器锁)。

普遍的共识是继续对 I/O 密集型应用程序使用多线程，对 CPU 密集型应用程序使用多处理。

多处理模块的另一个有用的特性(但不适用于我们的生产者/消费者示例)是一个*工作进程池*，它可以用于调用多个值上的函数，并使用 *asyncResult* 收集结果——一种未来值。

## 6.调用另一个程序，被阻止

该模块的名称“多重处理”有点让人误解。所指的进程是自动启动的，虽然可以通过操作系统进程列表看到它们，但它们并不被视为真正的进程。如果这是您所需要的(显式启动一个进程，监控其进度，例如收集其输出)，您必须求助于与操作系统进程功能接口的*子进程*模块。

子流程模块用一个统一简单的界面代替了各种系统调用。典型的功能是调用另一个程序*阻塞*(即等待它返回)并检索它的返回代码，或它的整个控制台输出，post fact。显然，这个工具不适合我们的生产者/消费者测试用例，它需要逐个处理消息。

下面是一个调用 *shell 命令*(一个程序，在单独的进程中运行)并检索其*返回代码的例子:*

```
>>> rc = subprocess.call( ['dir', 'C:\\python27'], shell=True )
Volume in drive C has no label. Volume Serial Number is 3AC3-56FA Directory of C:\\python27 
19-Aug-16 21:19 <DIR> . 
19-Aug-16 21:19 <DIR> .. 
19-Aug-16 21:19 <DIR> DLLs 
19-Aug-16 21:19 <DIR> Doc 
19-Aug-16 21:19 <DIR> include 
12-Nov-16 19:18 <DIR> Lib 
19-Aug-16 21:19 <DIR> libs 
27-Jun-16 14:22 38,591 
LICENSE.txt 
26-Jun-16 21:27 460,946 
NEWS.txt 08-Nov-15 19:05 12,139 
py2exe-wininst.log 27-Jun-16 14:20 27,136 
python.exe 27-Jun-16 14:20 27,648 
pythonw.exe ... 
12 File(s) 1,328,385 bytes 10 Dir(s) 99,487,002,624 bytes free 
>>> rc 0
```

## 7.处理失败的程序执行

*下面的例子调用一个 shell 命令并捕获它的异常(实际上，非零返回代码):*

```
>>> try: 
    rc = subprocess.check_call( ['dir', 'C:\\python270'], shell=True ) 
except subprocess.CalledProcessError as error: 
    print('Command failed. rc:', error.returncode) 
Volume in drive C has no label. Volume Serial Number is 3AC3-56FA 
Directory of C:\ 
File Not Found 
Command failed. 
rc: 1
```

## 8.收集调用的程序输出

以下示例调用一个 shell 命令，并将它的整个控制台输出(一部分)收集为一个字符串:*

```
try: 
    data = subprocess.check_output( ['dir', 'C:\\python27'], shell=True) 
    print(f'received {len(data.split('\n'))} lines') 
except subprocess.CalledProcessError as error: 
    print('command failed. rc:', error.returncode) 
received 30 lines
```

## 接下来呢？

在接下来的课程中，我们将考虑 Python 中传统多线程/处理的替代并行解决方案:具有拉和推迭代器的协作处理和基于分派的协作处理(*异步*执行)。

1.  [简介](/codex/parallel-programming-in-python-lesson-1-introduction-210e33d02ea6?source=friends_link&sk=5273e19224913fbd6a3b74f41871a754)
2.  [螺纹](/codex/parallel-programming-in-python-lesson-2-the-thread-b3986e215d4f?source=friends_link&sk=5ad6a9c99ce8947be53af4949ce6f086)
3.  [同步原语(多线程)](/@Avner_17989/parallel-programming-in-python-lesson-3-synchronization-primitives-78ac09befc43)
4.  同步原语(多处理)——*(你来了！)*
5.  协作处理—同步
6.  协作处理—异步