<html>
<head>
<title>Breadth First Search Algorithm</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">广度优先搜索算法</h1>
<blockquote>原文：<a href="https://medium.com/codex/breadth-first-search-algorithm-a2377f1e55c0?source=collection_archive---------12-----------------------#2021-08-16">https://medium.com/codex/breadth-first-search-algorithm-a2377f1e55c0?source=collection_archive---------12-----------------------#2021-08-16</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/eb8c8092ed9adedd09b7ab4045db7b06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y04UBfA8FLdNO6IP9b-3gQ.jpeg"/></div></div></figure><div class=""/><p id="8345" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在学习广度优先搜索(BFS)中需要掌握的一个重要概念是图遍历。首先，如果不熟悉的话，<em class="jo">图</em>是一种非线性数据结构，由有限的顶点(也称为节点)和连接图的顶点的边(视觉上表示为线)组成。</p><p id="80b4" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="jo">图遍历</em>是按照定义的顺序访问每个顶点和边一次的过程。顶点和边的一次性访问以及它们的访问顺序都很重要，这取决于解决问题的算法。同样，跟踪哪些顶点被访问过也很重要，通常通过标记它们来完成。</p><p id="4ce3" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">BFS是遍历图的最常见的方法，主要用于查找图中的最短路径。BFS是一种遍历算法，在这种算法中，您从选定的节点(通常称为起始节点或源节点)开始遍历，并逐层遍历图表，在移动到下一级节点之前，访问与源节点相邻的所有节点。换句话说，水平地<em class="jo">探索图的节点</em>，访问当前层的所有节点，然后移动到下一层。</p><h2 id="c1bb" class="jp jq ht bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj bi translated">功能</h2><p id="16c9" class="pw-post-body-paragraph iq ir ht is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hb bi translated">BFS通过合并队列来工作。首先将源节点添加到队列中，随后是该节点的未访问的相邻节点。一旦源节点不再有任何未访问的邻居，它就被从队列中删除。从第一层开始的队列中的下一个被用来代替源节点，并且该节点的所有未被访问的相邻节点被放置在队列中。一旦该节点不再有任何未访问的邻居，就将其从队列中移除，并且该过程对队列中的下一个节点继续，直到不再有未访问的节点。</p><p id="c3b6" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">加入这个队列数据结构是为了跟踪接下来要访问哪个节点，并指示从源节点到终点通过图的最短路径。BFS遵循三条规则—</p><ul class=""><li id="f4a2" class="kp kq ht is b it iu ix iy jb kr jf ks jj kt jn ku kv kw kx bi translated"><strong class="is hu">规则1: </strong>访问相邻的未访问顶点，标记为已访问，显示，插入队列。</li><li id="5374" class="kp kq ht is b it ky ix kz jb la jf lb jj lc jn ku kv kw kx bi translated"><strong class="is hu">规则2: </strong>如果没有相邻顶点，从队列中删除第一个顶点。</li><li id="8914" class="kp kq ht is b it ky ix kz jb la jf lb jj lc jn ku kv kw kx bi translated"><strong class="is hu">规则3: </strong>重复<strong class="is hu">规则1 </strong>和<strong class="is hu">规则2 </strong>直到队列清空。</li></ul><h2 id="fcc1" class="jp jq ht bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj bi translated">视觉示例</h2><figure class="le lf lg lh fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es ld"><img src="../Images/071328f5c6079a4923d627e8b222e038.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v3uF5M76tmm6Q5ZZMFubuA.jpeg"/></div></div><figcaption class="li lj et er es lk ll bd b be z dx translated">第一步</figcaption></figure><p id="3cf6" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们首先初始化图表的队列。</p><figure class="le lf lg lh fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es ld"><img src="../Images/37a1827c4792fdd16d47562f2ad5acc0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BA4dkUA0KtlzgNPa1OohvQ.jpeg"/></div></div><figcaption class="li lj et er es lk ll bd b be z dx translated">第二步</figcaption></figure><p id="dc96" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">接下来，选择源节点，在本例中是0。</p><figure class="le lf lg lh fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es ld"><img src="../Images/dd5d60c9c4513ba57ac3584eb45e20a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9JrJwtR7XsFtWQ_NvA2Iqw.jpeg"/></div></div><figcaption class="li lj et er es lk ll bd b be z dx translated">第三步</figcaption></figure><p id="36b0" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们的BFS算法通过访问相邻节点(具有一条分离边的节点)开始遍历。在我们的示例图中，我们首先访问节点1，并将该节点放入队列中。</p><figure class="le lf lg lh fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es ld"><img src="../Images/480f12172e7e5692ee6680f6c56c2f49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Lp2UTFNBroQbjhJ07kqHgQ.jpeg"/></div></div><figcaption class="li lj et er es lk ll bd b be z dx translated">第四步</figcaption></figure><p id="2fed" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">接下来，相邻的未被访问的节点2被访问，并被放置在节点1之后的队列中。</p><figure class="le lf lg lh fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es ld"><img src="../Images/d4ddc8532923badd334ac78e6fe585e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*knn-w9k1_pZgod9MiyNW1g.jpeg"/></div></div><figcaption class="li lj et er es lk ll bd b be z dx translated">第五步</figcaption></figure><p id="5500" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">正如您可能已经预料到的，下一步是访问源节点的最后一个未访问的邻居节点3，并将它放在节点2之后的队列中。</p><figure class="le lf lg lh fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es ld"><img src="../Images/0b7ce98e2fbb57aade403fc2b830922e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Jk27Y0bDYZPtwhNtiztNSg.jpeg"/></div></div><figcaption class="li lj et er es lk ll bd b be z dx translated">第六步</figcaption></figure><p id="f5dc" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">由于源节点(本例中的节点0)不再有任何未被访问的相邻节点，队列中的下一个节点(节点1)被出队并用于代替源节点进行遍历的下一步。节点4是节点1的唯一未被访问的邻居节点，因此被访问并放置在队列中。尽管现在已经访问了该图中的所有节点，但是为了让BFS算法进行解析，它需要将所有节点从队列中出列，以确认该图中没有其他未被访问的节点。</p><h2 id="823d" class="jp jq ht bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj bi translated">结论</h2><p id="0914" class="pw-post-body-paragraph iq ir ht is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hb bi translated">BFS算法是大多数需要快速搜索图结构的人的首选。这种算法有利于分析图中的节点并找到从一个节点到另一个节点的最短路径。BFS有一个简单但健壮的架构，允许以最少的迭代次数遍历图形。与其他算法相比，BFS算法具有很高的精确度，不会陷入无限循环。</p></div></div>    
</body>
</html>