<html>
<head>
<title>Element collection Vs One to Many in JPA and Hibernate</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JPA和Hibernate中的元素集合与一对多</h1>
<blockquote>原文：<a href="https://medium.com/codex/element-collection-vs-one-to-many-in-jpa-andhibernate-e4ae83642d99?source=collection_archive---------4-----------------------#2022-06-17">https://medium.com/codex/element-collection-vs-one-to-many-in-jpa-andhibernate-e4ae83642d99?source=collection_archive---------4-----------------------#2022-06-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/aa0dd8e0bfafdb8dd1e9d7e10281d8f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ris6RDwB6xOoPzHz"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">布莱克·康纳利在<a class="ae hv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><div class=""/><figure class="ev ex iw ix iy hk er es paragraph-image"><div class="er es iv"><img src="../Images/5edc2aaa3ec4df622dcf5e56326ca1c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:768/format:webp/1*FNicM7gisjwo3KVkqr9o5w.jpeg"/></div></figure><h2 id="721b" class="iz ja hy bd jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw bi translated">简介:</h2><p id="fcd0" class="pw-post-body-paragraph jx jy hy jz b ka kb kc kd ke kf kg kh jk ki kj kk jo kl km kn js ko kp kq kr hb bi translated">任何项目内部都会有一个数据库，用于保存和从中获取数据，并将数据保存在表中。您可以使用关系数据库，如MySQL和Postgress，也可以使用NoSQL数据库，如Mongo DB或Cassandra DB。</p><p id="2dfe" class="pw-post-body-paragraph jx jy hy jz b ka ks kc kd ke kt kg kh jk ku kj kk jo kv km kn js kw kp kq kr hb bi translated">顺便说一下，本文将在spring项目中解释JPA，用于表示关系数据库，我将重点关注<strong class="jz hz">一对多</strong>注释和<strong class="jz hz">元素集合</strong>注释。</p></div><div class="ab cl kx ky gp kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="hb hc hd he hf"><h2 id="63fe" class="iz ja hy bd jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw bi translated">春靴中的JPA:</h2><p id="2de5" class="pw-post-body-paragraph jx jy hy jz b ka kb kc kd ke kf kg kh jk ki kj kk jo kl km kn js ko kp kq kr hb bi translated">Spring Boot JPA是用于管理Java应用程序中关系数据的Java规范。它允许我们在Java对象/类和关系数据库之间访问和持久化数据。JPA遵循对象关系映射(ORM)。它是一组接口。</p><blockquote class="le lf lg"><p id="2530" class="jx jy lh jz b ka ks kc kd ke kt kg kh li ku kj kk lj kv km kn lk kw kp kq kr hb bi translated">有关<a class="ae hv" href="https://www.javatpoint.com/spring-boot-jpa#:~:text=Spring%20Boot%20JPA%20is%20a,is%20a%20set%20of%20interfaces." rel="noopener ugc nofollow" target="_blank"> JPA </a>的更多信息</p></blockquote></div><div class="ab cl kx ky gp kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="hb hc hd he hf"><h2 id="0777" class="iz ja hy bd jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw bi translated">一对多注释:</h2><p id="dca0" class="pw-post-body-paragraph jx jy hy jz b ka kb kc kd ke kf kg kh jk ki kj kk jo kl km kn js ko kp kq kr hb bi translated">如果我们创建两个实体(表格)之间的关系，我们需要使用<strong class="jz hz">一对多注释</strong>。</p><p id="d159" class="pw-post-body-paragraph jx jy hy jz b ka ks kc kd ke kt kg kh jk ku kj kk jo kv km kn js kw kp kq kr hb bi translated">请看下面的代码:</p><p id="b0f5" class="pw-post-body-paragraph jx jy hy jz b ka ks kc kd ke kt kg kh jk ku kj kk jo kv km kn js kw kp kq kr hb bi translated">我们可以表示商店，商店有许多分支，它们都是一个实体，这意味着它们在我们的数据库中都有一个表。</p><p id="f3af" class="pw-post-body-paragraph jx jy hy jz b ka ks kc kd ke kt kg kh jk ku kj kk jo kv km kn js kw kp kq kr hb bi translated"><code class="du ll lm ln lo b">Strore.java</code></p><pre class="lp lq lr ls fd lt lo lu lv aw lw bi"><span id="da73" class="iz ja hy lo b fi lx ly l lz ma">@Entity<br/>@Table(name = "store")<br/>public class Store{</span><span id="792e" class="iz ja hy lo b fi mb ly l lz ma">@Id    <br/>@GeneratedValue(strategy = GenerationType.IDENTITY)    <br/>private Long id;     </span><span id="ea91" class="iz ja hy lo b fi mb ly l lz ma">@Column(name = "name")    private String name; </span><span id="5043" class="iz ja hy lo b fi mb ly l lz ma">@Column(name = "ad_video_url")    private String adVideoUrl;</span><span id="12fb" class="iz ja hy lo b fi mb ly l lz ma">@OneToMany(mappedBy = "store" , cascade = CascadeType.ALL)       <br/>private Set&lt;Branch&gt; branches = new HashSet&lt;&gt;();</span><span id="02d7" class="iz ja hy lo b fi mb ly l lz ma">}</span></pre><p id="751c" class="pw-post-body-paragraph jx jy hy jz b ka ks kc kd ke kt kg kh jk ku kj kk jo kv km kn js kw kp kq kr hb bi translated">而<code class="du ll lm ln lo b">branch.java</code></p><pre class="lp lq lr ls fd lt lo lu lv aw lw bi"><span id="970f" class="iz ja hy lo b fi lx ly l lz ma">@Entity<br/>public class Branch{<br/>@Id    <br/>@GeneratedValue(strategy = GenerationType.IDENTITY)    <br/>private Long id;</span><span id="a320" class="iz ja hy lo b fi mb ly l lz ma">@Column(name = "name")    <br/>private String name;</span><span id="c106" class="iz ja hy lo b fi mb ly l lz ma">@Column(name = "ad_video_url")    <br/>private String adVideoUrl;</span><span id="d7c7" class="iz ja hy lo b fi mb ly l lz ma">//if you want you can remove the following annotation<br/>@ManyToOne    <br/>@JsonIgnoreProperties(value = "branches", allowSetters = true)    private AscStore store;</span><span id="6d3f" class="iz ja hy lo b fi mb ly l lz ma">} <br/></span></pre><p id="9263" class="pw-post-body-paragraph jx jy hy jz b ka ks kc kd ke kt kg kh jk ku kj kk jo kv km kn js kw kp kq kr hb bi translated">运行代码后，hibernate将在数据库中创建两个表，第一个表称为store，第二个表称为branch。现在我们需要为两个实体创建一个存储库，以便从数据库中插入和获取数据。</p><p id="e57b" class="pw-post-body-paragraph jx jy hy jz b ka ks kc kd ke kt kg kh jk ku kj kk jo kv km kn js kw kp kq kr hb bi translated">我们可以使用<code class="du ll lm ln lo b">@Repository</code>来创建一个存储库组件。</p><p id="0c68" class="pw-post-body-paragraph jx jy hy jz b ka ks kc kd ke kt kg kh jk ku kj kk jo kv km kn js kw kp kq kr hb bi translated"><code class="du ll lm ln lo b">StoreRepository.java</code></p><pre class="lp lq lr ls fd lt lo lu lv aw lw bi"><span id="e54e" class="iz ja hy lo b fi lx ly l lz ma">@<!-- -->Repository<br/>public interface StoreRepository extend JpaRepository&lt;Store,Long&gt;<br/>{<br/>}</span></pre><p id="3eb2" class="pw-post-body-paragraph jx jy hy jz b ka ks kc kd ke kt kg kh jk ku kj kk jo kv km kn js kw kp kq kr hb bi translated">现在我们需要为分支实体创建一个存储库。</p><p id="2cdb" class="pw-post-body-paragraph jx jy hy jz b ka ks kc kd ke kt kg kh jk ku kj kk jo kv km kn js kw kp kq kr hb bi translated"><code class="du ll lm ln lo b">BranchRepository.java</code></p><pre class="lp lq lr ls fd lt lo lu lv aw lw bi"><span id="8d73" class="iz ja hy lo b fi lx ly l lz ma">@<!-- -->Repository<br/>public interface BranchRepository extend JpaRepository&lt;Branch,Long&gt;<br/>{<br/>}</span></pre><p id="6d78" class="pw-post-body-paragraph jx jy hy jz b ka ks kc kd ke kt kg kh jk ku kj kk jo kv km kn js kw kp kq kr hb bi translated">在那之后，我们在<strong class="jz hz">店</strong>和<strong class="jz hz">分店</strong>之间有了新的关系</p></div><div class="ab cl kx ky gp kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="hb hc hd he hf"><h2 id="9753" class="iz ja hy bd jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw bi translated">Elementcollection批注:</h2><p id="0278" class="pw-post-body-paragraph jx jy hy jz b ka kb kc kd ke kf kg kh jk ki kj kk jo kl km kn js ko kp kq kr hb bi translated">ElementCollection是一个标准的JPA注释，现在它比专有的Hibernate annotation collection ofelements更受欢迎。</p><p id="8ae4" class="pw-post-body-paragraph jx jy hy jz b ka ks kc kd ke kt kg kh jk ku kj kk jo kv km kn js kw kp kq kr hb bi translated">意味着集合不是实体的集合，而是简单类型(字符串等)的集合。)或可嵌入元素的集合(用<code class="du ll lm ln lo b">@embeddable</code>标注的类</p><p id="c3c5" class="pw-post-body-paragraph jx jy hy jz b ka ks kc kd ke kt kg kh jk ku kj kk jo kv km kn js kw kp kq kr hb bi translated">这也意味着元素完全由包含实体所拥有:当实体被修改时它们被修改，当实体被删除时它们被删除，等等。他们不能有自己的生命周期。</p><p id="9e23" class="pw-post-body-paragraph jx jy hy jz b ka ks kc kd ke kt kg kh jk ku kj kk jo kv km kn js kw kp kq kr hb bi translated">看看下面的代码，看看我们如何实现<strong class="jz hz"> Elementcollection </strong>类。</p><p id="45d4" class="pw-post-body-paragraph jx jy hy jz b ka ks kc kd ke kt kg kh jk ku kj kk jo kv km kn js kw kp kq kr hb bi translated">最简单的术语，<strong class="jz hz"> @ElementCollection </strong>告诉编译器我们正在映射一个集合，其中，<strong class="jz hz"> @CollectionTable </strong>给出目标表的名称，然后<strong class="jz hz"> @JoinColumn </strong>指定我们要连接的实际列，如下所示:</p><p id="699b" class="pw-post-body-paragraph jx jy hy jz b ka ks kc kd ke kt kg kh jk ku kj kk jo kv km kn js kw kp kq kr hb bi translated">从上一个例子中，我们现在有了两个实体<strong class="jz hz">商店</strong>和<strong class="jz hz">分支</strong>，以及它们之间的关系，现在我将添加一个新的类<strong class="jz hz">产品</strong>。</p><p id="2ae7" class="pw-post-body-paragraph jx jy hy jz b ka ks kc kd ke kt kg kh jk ku kj kk jo kv km kn js kw kp kq kr hb bi translated"><code class="du ll lm ln lo b">product.java</code>阶级</p><pre class="lp lq lr ls fd lt lo lu lv aw lw bi"><span id="8ac0" class="iz ja hy lo b fi lx ly l lz ma">@Embeddable<br/>@Data<br/>public class product{</span><span id="59a9" class="iz ja hy lo b fi mb ly l lz ma">// we dont need to use id becouse it is not a entity</span><span id="adeb" class="iz ja hy lo b fi mb ly l lz ma">@Colume(name="product_name")<br/>private String productName;</span><span id="78cb" class="iz ja hy lo b fi mb ly l lz ma">@Colume(name="product_prict")<br/>private Double productPrice;</span><span id="1c5b" class="iz ja hy lo b fi mb ly l lz ma">}</span></pre><p id="db1f" class="pw-post-body-paragraph jx jy hy jz b ka ks kc kd ke kt kg kh jk ku kj kk jo kv km kn js kw kp kq kr hb bi translated">现在我们将在<code class="du ll lm ln lo b">store.java</code>类中添加一个新的<strong class="jz hz"> Elementcollection </strong>注释，并从<strong class="jz hz">产品</strong>类中添加一个新的<strong class="jz hz">产品</strong>对象。</p><pre class="lp lq lr ls fd lt lo lu lv aw lw bi"><span id="2a76" class="iz ja hy lo b fi lx ly l lz ma">@Entity<br/>@Table(name = "store")<br/>public class Store{</span><span id="9399" class="iz ja hy lo b fi mb ly l lz ma">@Id    <br/>@GeneratedValue(strategy = GenerationType.IDENTITY)    <br/>private Long id;</span><span id="4a5a" class="iz ja hy lo b fi mb ly l lz ma">@Column(name = "name")    private String name;</span><span id="4a8e" class="iz ja hy lo b fi mb ly l lz ma">@Column(name = "ad_video_url")    private String adVideoUrl;</span><span id="6c33" class="iz ja hy lo b fi mb ly l lz ma">@OneToMany(mappedBy = "store" , cascade = CascadeType.ALL)       <br/>private Set&lt;Branch&gt; branches = new HashSet&lt;&gt;();</span><span id="fda9" class="iz ja hy lo b fi mb ly l lz ma">@ElementCollection(fetch = FetchType.LAZY)<br/>@CollectionTable(name = "store_product", joinColumns = @JoinColumn(name = "store_id", nullable = false), uniqueConstraints = @UniqueConstraint(columnNames = {"store_id"}))<br/>private Set&lt;Product&gt; products = new HashSet&lt;&gt;();</span><span id="6b79" class="iz ja hy lo b fi mb ly l lz ma">}</span></pre><p id="c99c" class="pw-post-body-paragraph jx jy hy jz b ka ks kc kd ke kt kg kh jk ku kj kk jo kv km kn js kw kp kq kr hb bi translated">现在创建之后，您的数据库将看到Product表以<code class="du ll lm ln lo b">storeId</code>作为主键。但它是商店表的外键，而不是产品表的主键。</p><p id="e063" class="pw-post-body-paragraph jx jy hy jz b ka ks kc kd ke kt kg kh jk ku kj kk jo kv km kn js kw kp kq kr hb bi translated">可嵌入对象没有<strong class="jz hz">存储库</strong>，因为它依赖于实体，例如<strong class="jz hz">产品可嵌入对象</strong>依赖于<strong class="jz hz">商店实体</strong>。我们可以在不使用<strong class="jz hz">存储库的情况下插入它。</strong></p></div><div class="ab cl kx ky gp kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="hb hc hd he hf"><h2 id="4cd1" class="iz ja hy bd jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw bi translated">这两种方法的区别在于:</h2><p id="4231" class="pw-post-body-paragraph jx jy hy jz b ka kb kc kd ke kf kg kh jk ki kj kk jo kl km kn js ko kp kq kr hb bi translated"><strong class="jz hz">实体:</strong></p><p id="91d5" class="pw-post-body-paragraph jx jy hy jz b ka ks kc kd ke kt kg kh jk ku kj kk jo kv km kn js kw kp kq kr hb bi translated">当创建一个实体时，您可以将它与JPA存储库相关联，以编写您的查询或使用JPA的内置查询。</p><p id="01e7" class="pw-post-body-paragraph jx jy hy jz b ka ks kc kd ke kt kg kh jk ku kj kk jo kv km kn js kw kp kq kr hb bi translated"><strong class="jz hz">可嵌入:</strong></p><p id="7cc8" class="pw-post-body-paragraph jx jy hy jz b ka ks kc kd ke kt kg kh jk ku kj kk jo kv km kn js kw kp kq kr hb bi translated">当创建一个可嵌入的类时，必须与任何实体类相关，因为它依赖于实体类。我们不能创建一个仓库。</p></div><div class="ab cl kx ky gp kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="hb hc hd he hf"><h2 id="e806" class="iz ja hy bd jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw bi translated">结论:</h2><p id="0c67" class="pw-post-body-paragraph jx jy hy jz b ka kb kc kd ke kf kg kh jk ki kj kk jo kl km kn js ko kp kq kr hb bi translated">每个应用程序都有数据，这些数据将在程序中显示给应用程序客户端，因此我们有一个数据库、Jpa和hibernate。</p><p id="225b" class="pw-post-body-paragraph jx jy hy jz b ka ks kc kd ke kt kg kh jk ku kj kk jo kv km kn js kw kp kq kr hb bi translated">但是我们如何设计数据库，取决于应用程序的业务逻辑。</p><p id="57a7" class="pw-post-body-paragraph jx jy hy jz b ka ks kc kd ke kt kg kh jk ku kj kk jo kv km kn js kw kp kq kr hb bi translated">不要忘记在文章上拍手，每篇文章可以拍手50次。还有你在这里找到我的<a class="ae hv" href="https://www.linkedin.com/in/abd-alrhman-alkraien-83a93a1b1/" rel="noopener ugc nofollow" target="_blank"><strong class="jz hz">LinkedIn</strong></a></p></div><div class="ab cl kx ky gp kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="hb hc hd he hf"><h2 id="3df9" class="iz ja hy bd jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw bi translated">参考资料:</h2><ul class=""><li id="d7e7" class="mc md hy jz b ka kb ke kf jk me jo mf js mg kr mh mi mj mk bi translated"><a class="ae hv" href="https://www.javatpoint.com/spring-boot-jpa#:~:text=Spring%20Boot%20JPA%20is%20a,is%20a%20set%20of%20interfaces" rel="noopener ugc nofollow" target="_blank">https://www . Java point . com/Spring-boot-JPA #:~:text = Spring % 20 boot % 20 JPA % 20 is % 20a，is % 20a % 20 set % 20 of % 20 interfaces</a>。</li><li id="02c8" class="mc md hy jz b ka ml ke mm jk mn jo mo js mp kr mh mi mj mk bi translated"><a class="ae hv" href="https://stackoverflow.com/questions/8969059/difference-between-onetomany-and-elementcollection#:~:text=I%20believe%20%40ElementCollection%20is%20mainly,what%20you%20want%20to%20achieve" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/8969059/difference-between-one tomany-and-element collection #:~:text = I % 20 believe % 20% 40 element collection % 20 is % 20 majority，what % 20 you % 20 want % 20 to % 20 achieve</a>。</li><li id="68a0" class="mc md hy jz b ka ml ke mm jk mn jo mo js mp kr mh mi mj mk bi translated"><a class="ae hv" rel="noopener" href="/nerd-for-tech/elementcollection-vs-onetomany-in-hibernate-7fb7d2ac00ea">https://medium . com/nerd-for-tech/element collection-vs-onetomany-in-hibernate-7 FB 7d 2 AC 00 ea</a></li></ul></div></div>    
</body>
</html>