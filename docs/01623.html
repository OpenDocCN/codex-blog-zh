<html>
<head>
<title>What is Vector in C++? Get started in 5 minutes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C++中的Vector是什么？5分钟后开始</h1>
<blockquote>原文：<a href="https://medium.com/codex/what-is-vector-in-c-get-started-in-5-minutes-298c0415b6c1?source=collection_archive---------6-----------------------#2021-05-17">https://medium.com/codex/what-is-vector-in-c-get-started-in-5-minutes-298c0415b6c1?source=collection_archive---------6-----------------------#2021-05-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/67122650dd22975e17535dbb597e4149.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RHKF5ZAL99ozTjuJZdLRkg.png"/></div></div></figure><p id="ae53" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">C++ vector是标准模板库(STL)中的一个模板类，作为一个更精确的数组。与数组不同，<strong class="is hj">向量可以在你插入或删除元素时自动调整大小</strong>，所以当处理不断变化的数据时，它们非常有用。在你的C++程序中使用向量可以让你更灵活更有效地存储数据。今天，我们将深入探讨C++向量，并讨论它的好处、功能和初始化。</p><p id="1c56" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">我们将介绍</strong>:</p><ul class=""><li id="bcf5" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated">C++里的<code class="du jx jy jz ka b">std::vector</code>是什么？</li><li id="aeb2" class="jo jp hi is b it kb ix kc jb kd jf ke jj kf jn jt ju jv jw bi translated">C++向量函数</li><li id="47f9" class="jo jp hi is b it kb ix kc jb kd jf ke jj kf jn jt ju jv jw bi translated">如何初始化一个C++向量</li><li id="5101" class="jo jp hi is b it kb ix kc jb kd jf ke jj kf jn jt ju jv jw bi translated">接下来学什么</li></ul><h1 id="c1b7" class="kg kh hi bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">C++里的<code class="du jx jy jz ka b">std::vector</code>是什么？</h1><p id="235f" class="pw-post-body-paragraph iq ir hi is b it le iv iw ix lf iz ja jb lg jd je jf lh jh ji jj li jl jm jn hb bi translated">C++向量(也称为<code class="du jx jy jz ka b">std::vector</code>)是<strong class="is hj">序列容器，表示大小可以改变的数组</strong>。它们用于处理动态数据，并且它们<strong class="is hj">为它们的元素使用连续的存储位置</strong>。使用常规指针上的偏移量可以有效地访问元素。在内部，C++向量使用动态分配的数组来存储它们的元素。该数组可能需要重新分配，以便在插入新元素时其大小可以增长。</p><p id="48b0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Vector容器可能会分配额外的存储空间来适应潜在的增长，因此容器的容量可能会比实际存储的容量大。您可以使用库来应用不同的增长策略，以在重新分配和内存使用之间取得平衡，但是重新分配应该只发生在以对数增长的大小间隔上。这允许您在向量末尾插入单个元素时使用<em class="lj">摊提常数时间</em>复杂度。</p><p id="0b00" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">由于C++矢量执行自动重新分配，<strong class="is hj">它们能够以有效的方式管理存储和动态增长</strong>。虽然它们比数组消耗更多的内存，但是它们的效率和灵活性使得使用向量是值得的。</p><p id="a2eb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们讨论一下C++ vector的更多好处:</p><ul class=""><li id="4f2c" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated">没有最大大小，如果您事先不知道您的数据有多大，这很有帮助</li><li id="08c7" class="jo jp hi is b it kb ix kc jb kd jf ke jj kf jn jt ju jv jw bi translated">它们的调整大小功能使得处理动态元素变得更加容易</li><li id="792f" class="jo jp hi is b it kb ix kc jb kd jf ke jj kf jn jt ju jv jw bi translated">由于C++ vector是一个模板类，您不必键入相同的代码来处理不同的数据</li><li id="7d52" class="jo jp hi is b it kb ix kc jb kd jf ke jj kf jn jt ju jv jw bi translated">每当内存总量用完时，就会自动进行重新分配</li><li id="6c0d" class="jo jp hi is b it kb ix kc jb kd jf ke jj kf jn jt ju jv jw bi translated">您可以轻松地复制和指定其他向量</li></ul><h1 id="2afc" class="kg kh hi bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">C++向量函数</h1><p id="3d3e" class="pw-post-body-paragraph iq ir hi is b it le iv iw ix lf iz ja jb lg jd je jf lh jh ji jj li jl jm jn hb bi translated">有许多与C++向量相关的公共成员函数。让我们来看看其中的一些功能及其作用。</p><ul class=""><li id="c5b1" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated"><code class="du jx jy jz ka b">cbegin</code>:返回一个指向容器中第一个元素的<code class="du jx jy jz ka b">const_iterator</code></li></ul><blockquote class="lk ll lm"><p id="0e6d" class="iq ir lj is b it iu iv iw ix iy iz ja ln jc jd je lo jg jh ji lp jk jl jm jn hb bi translated"><strong class="is hj"> <em class="hi">注意</em> </strong> <em class="hi"> : A </em> <code class="du jx jy jz ka b"><em class="hi">const_iterator</em></code> <em class="hi">是指向const内容的迭代器。可以像</em> <code class="du jx jy jz ka b"><em class="hi">vector::begin</em></code> <em class="hi">返回的</em> <code class="du jx jy jz ka b"><em class="hi">iterator</em></code> <em class="hi">一样增减，但不能用来修改它指向的内容。</em></p></blockquote><ul class=""><li id="da9a" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated"><code class="du jx jy jz ka b">cend</code>:返回一个指向容器中<em class="lj">末尾</em>元素的<code class="du jx jy jz ka b">const_iterator</code></li><li id="a716" class="jo jp hi is b it kb ix kc jb kd jf ke jj kf jn jt ju jv jw bi translated"><code class="du jx jy jz ka b">crbegin</code>:返回一个指向容器中最后一个元素的<code class="du jx jy jz ka b">const_reverse_iterator</code></li><li id="9893" class="jo jp hi is b it kb ix kc jb kd jf ke jj kf jn jt ju jv jw bi translated"><code class="du jx jy jz ka b">crend</code>:返回一个<code class="du jx jy jz ka b">const_reverse_iterator</code>，指向容器中第一个元素之前的理论元素</li><li id="6a0a" class="jo jp hi is b it kb ix kc jb kd jf ke jj kf jn jt ju jv jw bi translated"><code class="du jx jy jz ka b">emplace_back</code>:在vector的末尾插入一个新元素，就在当前最后一个元素之后</li><li id="e4e1" class="jo jp hi is b it kb ix kc jb kd jf ke jj kf jn jt ju jv jw bi translated"><code class="du jx jy jz ka b">max_size</code>:返回最大尺寸</li><li id="da59" class="jo jp hi is b it kb ix kc jb kd jf ke jj kf jn jt ju jv jw bi translated"><code class="du jx jy jz ka b">pop_back</code>:删除矢量中的最后一个元素</li><li id="51a9" class="jo jp hi is b it kb ix kc jb kd jf ke jj kf jn jt ju jv jw bi translated"><code class="du jx jy jz ka b">push_back</code>:在矢量的末尾添加一个新元素</li><li id="45b1" class="jo jp hi is b it kb ix kc jb kd jf ke jj kf jn jt ju jv jw bi translated"><code class="du jx jy jz ka b">rbegin</code>:返回一个<em class="lj">反向迭代器</em>，指向向量中的最后一个元素</li></ul><blockquote class="lk ll lm"><p id="eff4" class="iq ir lj is b it iu iv iw ix iy iz ja ln jc jd je lo jg jh ji lp jk jl jm jn hb bi translated"><strong class="is hj"> <em class="hi">注</em> </strong> <em class="hi">:反向迭代器向后迭代。增加一个反向迭代器会将它移向容器的开头。</em></p></blockquote><ul class=""><li id="d249" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated"><code class="du jx jy jz ka b">rend</code>:返回一个<em class="lj">反向迭代器</em>，指向向量中第一个元素之前的理论元素</li><li id="25b5" class="jo jp hi is b it kb ix kc jb kd jf ke jj kf jn jt ju jv jw bi translated"><code class="du jx jy jz ka b">shrink_to_fit</code>:请求容器减少其容量以适应其大小</li><li id="a807" class="jo jp hi is b it kb ix kc jb kd jf ke jj kf jn jt ju jv jw bi translated"><code class="du jx jy jz ka b">std::vector::end</code>:返回一个迭代器，引用向量容器中的<em class="lj">末尾</em>元素</li><li id="8ddb" class="jo jp hi is b it kb ix kc jb kd jf ke jj kf jn jt ju jv jw bi translated"><code class="du jx jy jz ka b">vector::capacity</code>:返回当前分配给矢量的存储空间大小</li><li id="d33c" class="jo jp hi is b it kb ix kc jb kd jf ke jj kf jn jt ju jv jw bi translated"><code class="du jx jy jz ka b">vector::front</code>:返回对vector中第一个元素的引用</li><li id="d689" class="jo jp hi is b it kb ix kc jb kd jf ke jj kf jn jt ju jv jw bi translated"><code class="du jx jy jz ka b">vector::back</code>:返回向量的最后一个元素</li><li id="0972" class="jo jp hi is b it kb ix kc jb kd jf ke jj kf jn jt ju jv jw bi translated"><code class="du jx jy jz ka b">vector::size</code>:返回向量中元素的个数</li></ul><blockquote class="lk ll lm"><p id="6fac" class="iq ir lj is b it iu iv iw ix iy iz ja ln jc jd je lo jg jh ji lp jk jl jm jn hb bi translated"><strong class="is hj"> <em class="hi">注意</em> </strong> <em class="hi">:返回vector中保存的实际对象的数量，不一定等于其存储容量。</em></p></blockquote><ul class=""><li id="413e" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated"><code class="du jx jy jz ka b">vector::begin</code>:返回指向向量中第一个元素的迭代器</li></ul><h1 id="bb55" class="kg kh hi bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">如何初始化一个C++向量</h1><p id="f1d3" class="pw-post-body-paragraph iq ir hi is b it le iv iw ix lf iz ja jb lg jd je jf lh jh ji jj li jl jm jn hb bi translated">现在我们知道了更多关于C++向量的基础知识和一些函数，让我们来讨论一下初始化方法。</p><p id="b389" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">在C++ </strong>中有四种方式来初始化一个向量:</p><h1 id="1029" class="kg kh hi bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">1.使用数组</h1><p id="a143" class="pw-post-body-paragraph iq ir hi is b it le iv iw ix lf iz ja jb lg jd je jf lh jh ji jj li jl jm jn hb bi translated">该方法将一个数组传递给vector类的构造函数。传递的数组包含将填充vector的元素。</p><pre class="lq lr ls lt fd lu ka lv lw aw lx bi"><span id="108c" class="ly kh hi ka b fi lz ma l mb mc">#include &lt;iostream&gt;<br/>#include &lt;vector&gt;<br/>using namespace std;<br/><br/>int main() {<br/><br/>  vector&lt;int&gt; vec{1,2,3,4,5}; <br/><br/>  for (int i = 0; i &lt; vec.size(); i++)<br/>  {<br/>    cout &lt;&lt; vec[i] &lt;&lt; " "; <br/>  }<br/>  return 0; <br/>}</span></pre><blockquote class="lk ll lm"><p id="e167" class="iq ir lj is b it iu iv iw ix iy iz ja ln jc jd je lo jg jh ji lp jk jl jm jn hb bi translated"><strong class="is hj"> <em class="hi">输出</em> </strong> <em class="hi"> : </em> 1 2 3 4 5</p></blockquote><h1 id="8067" class="kg kh hi bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">2.一次推送一个值</h1><p id="399e" class="pw-post-body-paragraph iq ir hi is b it le iv iw ix lf iz ja jb lg jd je jf lh jh ji jj li jl jm jn hb bi translated">使用vector类方法<code class="du jx jy jz ka b">push_back</code>，可以将需要填充向量的所有元素一次一个地推入向量中。</p><pre class="lq lr ls lt fd lu ka lv lw aw lx bi"><span id="c57f" class="ly kh hi ka b fi lz ma l mb mc">#include &lt;iostream&gt;<br/>#include &lt;vector&gt;<br/>using namespace std;<br/><br/>int main() {<br/><br/>  vector&lt;int&gt; vec;  <br/><br/>  vec.push_back(1); <br/>  vec.push_back(2); <br/>  vec.push_back(3);<br/>  vec.push_back(4); <br/>  vec.push_back(5); <br/><br/>  for (int i = 0; i &lt; vec.size(); i++)<br/>  {<br/>    cout &lt;&lt; vec[i] &lt;&lt; " "; <br/>  }<br/>  return 0; <br/>}</span></pre><blockquote class="lk ll lm"><p id="df23" class="iq ir lj is b it iu iv iw ix iy iz ja ln jc jd je lo jg jh ji lp jk jl jm jn hb bi translated"><strong class="is hj"> <em class="hi">输出</em> </strong> <em class="hi"> : </em> 1 2 3 4 5</p></blockquote><h1 id="99b8" class="kg kh hi bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">3.使用vector类的重载构造函数</h1><p id="d02c" class="pw-post-body-paragraph iq ir hi is b it le iv iw ix lf iz ja jb lg jd je jf lh jh ji jj li jl jm jn hb bi translated">这种方法主要用于向量需要填充相同值的多个元素时(例如，如果向量需要填充十个1)。</p><pre class="lq lr ls lt fd lu ka lv lw aw lx bi"><span id="bc79" class="ly kh hi ka b fi lz ma l mb mc">#include &lt;iostream&gt;<br/>#include &lt;vector&gt;<br/>using namespace std;<br/><br/>int main() {<br/><br/>  int num_of_ele = 10; <br/><br/>  // the overloaded constructor takes the number of <br/>  // values and the value itself as parameters.<br/>  vector&lt;int&gt; vec(num_of_ele, 1); <br/><br/>  for (int i = 0; i &lt; vec.size(); i++)<br/>  {<br/>    cout &lt;&lt; vec[i] &lt;&lt; " "; <br/>  }<br/>  return 0; <br/>}</span></pre><blockquote class="lk ll lm"><p id="6470" class="iq ir lj is b it iu iv iw ix iy iz ja ln jc jd je lo jg jh ji lp jk jl jm jn hb bi translated"><strong class="is hj"> <em class="hi">输出</em> </strong> <em class="hi"> : </em> 1 1 1 1 1 1 1 1</p></blockquote><h1 id="3a8c" class="kg kh hi bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">4.使用已经初始化的向量</h1><p id="2daa" class="pw-post-body-paragraph iq ir hi is b it le iv iw ix lf iz ja jb lg jd je jf lh jh ji jj li jl jm jn hb bi translated">该方法将已经初始化的vector的<code class="du jx jy jz ka b">begin()</code>和<code class="du jx jy jz ka b">end()</code>迭代器传递给vector类构造函数。新向量被初始化，并由旧向量中的元素填充。</p><pre class="lq lr ls lt fd lu ka lv lw aw lx bi"><span id="cc75" class="ly kh hi ka b fi lz ma l mb mc">#include &lt;iostream&gt;<br/>#include &lt;vector&gt;<br/>using namespace std;<br/><br/>int main() {<br/><br/>  vector&lt;int&gt; vec_1{1,2,3,4,5};<br/><br/>  vector&lt;int&gt; vec_2(vec_1.begin(), vec_1.end());<br/><br/>  for (int i = 0; i &lt; vec_2.size(); i++)<br/>  {<br/>    cout &lt;&lt; vec_2[i] &lt;&lt; " "; <br/>  }<br/>  return 0; <br/>}</span></pre><blockquote class="lk ll lm"><p id="8289" class="iq ir lj is b it iu iv iw ix iy iz ja ln jc jd je lo jg jh ji lp jk jl jm jn hb bi translated"><strong class="is hj"> <em class="hi">输出</em> </strong> <em class="hi"> : </em> 1 2 3 4 5</p></blockquote><h1 id="0f90" class="kg kh hi bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">接下来学什么</h1><p id="2126" class="pw-post-body-paragraph iq ir hi is b it le iv iw ix lf iz ja jb lg jd je jf lh jh ji jj li jl jm jn hb bi translated">在你的程序中使用C++ vectors将允许你更灵活和有效地存储你的数据。它们是处理不断变化的数据的理想工具。现在你已经知道了更多关于向量的知识，你已经准备好学习更多的C++概念了。</p><p id="372d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">接下来推荐的一些概念包括:</p><ul class=""><li id="5b8b" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated">C++模板</li><li id="7e95" class="jo jp hi is b it kb ix kc jb kd jf ke jj kf jn jt ju jv jw bi translated">现代C++的并发性</li><li id="d5a4" class="jo jp hi is b it kb ix kc jb kd jf ke jj kf jn jt ju jv jw bi translated">C++中的嵌入式编程</li><li id="ee4e" class="jo jp hi is b it kb ix kc jb kd jf ke jj kf jn jt ju jv jw bi translated">等等。</li></ul><p id="d049" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">快乐学习！</p></div></div>    
</body>
</html>