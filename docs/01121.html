<html>
<head>
<title>The Absolute Essentials of Data Structures You Need to Know to Solve Coding Interview Problems</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">解决编码面试问题你需要知道的数据结构的绝对要点</h1>
<blockquote>原文：<a href="https://medium.com/codex/the-absolute-essentials-of-data-structures-you-need-to-know-to-solve-coding-interview-problems-fbfb13700d5c?source=collection_archive---------13-----------------------#2021-04-05">https://medium.com/codex/the-absolute-essentials-of-data-structures-you-need-to-know-to-solve-coding-interview-problems-fbfb13700d5c?source=collection_archive---------13-----------------------#2021-04-05</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><h2 id="4b33" class="hg hh hi bd b fp hj hk hl hm hn ho dx hp translated" aria-label="kicker paragraph">编码面试的主数据结构</h2><div class=""/><div class=""><h2 id="d147" class="pw-subtitle-paragraph io hr hi bd b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf dx translated">了解这些DSA主题，通过大量的实践，您可以解决任何编码问题</h2></div><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es jg"><img src="../Images/074f458a361ff0575ef7c3dd47aa5e36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h3L6E6_3LBZENqtI5a9atQ.png"/></div></div></figure><h2 id="93c7" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ho bi translated">以下是本文所涵盖主题的目录:</h2><ul class=""><li id="97f9" class="kp kq hi kr b ks kt ku kv kd kw kh kx kl ky kz la lb lc ld bi translated">什么是编码</li><li id="faa1" class="kp kq hi kr b ks le ku lf kd lg kh lh kl li kz la lb lc ld bi translated">数据结构</li><li id="7b1a" class="kp kq hi kr b ks le ku lf kd lg kh lh kl li kz la lb lc ld bi translated">复杂性分析</li><li id="c33a" class="kp kq hi kr b ks le ku lf kd lg kh lh kl li kz la lb lc ld bi translated">记忆</li><li id="4ebd" class="kp kq hi kr b ks le ku lf kd lg kh lh kl li kz la lb lc ld bi translated">大O符号</li><li id="add4" class="kp kq hi kr b ks le ku lf kd lg kh lh kl li kz la lb lc ld bi translated">对数</li><li id="0c2b" class="kp kq hi kr b ks le ku lf kd lg kh lh kl li kz la lb lc ld bi translated">数组</li><li id="e93b" class="kp kq hi kr b ks le ku lf kd lg kh lh kl li kz la lb lc ld bi translated">链接列表</li><li id="fcd6" class="kp kq hi kr b ks le ku lf kd lg kh lh kl li kz la lb lc ld bi translated">哈希表</li><li id="1978" class="kp kq hi kr b ks le ku lf kd lg kh lh kl li kz la lb lc ld bi translated">堆栈和队列</li><li id="25ef" class="kp kq hi kr b ks le ku lf kd lg kh lh kl li kz la lb lc ld bi translated">用线串</li><li id="87a1" class="kp kq hi kr b ks le ku lf kd lg kh lh kl li kz la lb lc ld bi translated">图表</li><li id="7fe9" class="kp kq hi kr b ks le ku lf kd lg kh lh kl li kz la lb lc ld bi translated">树</li></ul></div><div class="ab cl lj lk gp ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="hb hc hd he hf"><h1 id="197a" class="lq jt hi bd ju lr ls lt jy lu lv lw kc ix lx iy kg ja ly jb kk jd lz je ko ma bi translated">什么是编码</h1><p id="c4b1" class="pw-post-body-paragraph mb mc hi kr b ks kt is md ku kv iv me kd mf mg mh kh mi mj mk kl ml mm mn kz hb bi translated">→操纵数据</p><p id="1d4a" class="pw-post-body-paragraph mb mc hi kr b ks mo is md ku mp iv me kd mq mg mh kh mr mj mk kl ms mm mn kz hb bi translated">→在最基本的层面上，软件工程师所做的是操纵输入数据以产生一些期望的输出数据。</p></div><div class="ab cl lj lk gp ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="hb hc hd he hf"><h1 id="d191" class="lq jt hi bd ju lr ls lt jy lu lv lw kc ix lx iy kg ja ly jb kk jd lz je ko ma bi translated"><strong class="ak">数据结构</strong></h1><p id="b8a2" class="pw-post-body-paragraph mb mc hi kr b ks kt is md ku kv iv me kd mf mg mh kh mi mj mk kl ml mm mn kz hb bi translated">→一种组织数据的方法，以便有效地处理数据，产生所需的输出。</p></div><div class="ab cl lj lk gp ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="hb hc hd he hf"><h1 id="9e3c" class="lq jt hi bd ju lr ls lt jy lu lv lw kc ix lx iy kg ja ly jb kk jd lz je ko ma bi translated"><strong class="ak">复杂性分析</strong></h1><p id="f3e0" class="pw-post-body-paragraph mb mc hi kr b ks kt is md ku kv iv me kd mf mg mh kh mi mj mk kl ml mm mn kz hb bi translated">→确定算法效率的过程。</p><ul class=""><li id="0283" class="kp kq hi kr b ks mo ku mp kd mt kh mu kl mv kz la lb lc ld bi translated">涉及到<strong class="kr hs">时间复杂度</strong> &amp; <strong class="kr hs">空间复杂度</strong></li><li id="720b" class="kp kq hi kr b ks le ku lf kd lg kh lh kl li kz la lb lc ld bi translated">时间和空间复杂度都用<strong class="kr hs">大O</strong>T10】符号表示。</li><li id="c5ed" class="kp kq hi kr b ks le ku lf kd lg kh lh kl li kz la lb lc ld bi translated"><strong class="kr hs">时间复杂度→ </strong>算法有多快</li><li id="537f" class="kp kq hi kr b ks le ku lf kd lg kh lh kl li kz la lb lc ld bi translated"><strong class="kr hs">空间复杂度</strong> →一个算法使用多少额外的存储空间</li></ul><p id="f250" class="pw-post-body-paragraph mb mc hi kr b ks mo is md ku mp iv me kd mq mg mh kh mr mj mk kl ms mm mn kz hb bi translated">您需要做的是确定在解决特定的编码问题时应该使用哪种数据结构，以及当您对数据结构应用特定的函数和操作来解决问题时，时间和空间复杂性的结果是什么。</p></div><div class="ab cl lj lk gp ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="hb hc hd he hf"><h1 id="710d" class="lq jt hi bd ju lr ls lt jy lu lv lw kc ix lx iy kg ja ly jb kk jd lz je ko ma bi translated"><strong class="ak">内存</strong></h1><p id="927b" class="pw-post-body-paragraph mb mc hi kr b ks kt is md ku kv iv me kd mf mg mh kh mi mj mk kl ml mm mn kz hb bi translated">→临时存储代码中声明的变量和函数的地方。</p><p id="9028" class="pw-post-body-paragraph mb mc hi kr b ks mo is md ku mp iv me kd mq mg mh kh mr mj mk kl ms mm mn kz hb bi translated">内存可以被看作是一块有边界的画布，上面有有限数量的存储数据的槽。因为内存空间是有限的，所以尽量减少内存空间的使用是很重要的。</p><h2 id="6c45" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ho bi translated">数据存储在存储器的<strong class="ak">位</strong>中。</h2><ul class=""><li id="943f" class="kp kq hi kr b ks kt ku kv kd kw kh kx kl ky kz la lb lc ld bi translated">一个内存插槽可以容纳8位(1字节)。</li><li id="002b" class="kp kq hi kr b ks le ku lf kd lg kh lh kl li kz la lb lc ld bi translated">1个<strong class="kr hs">字节</strong>可以代表多达256个数据值(2⁸).</li><li id="2396" class="kp kq hi kr b ks le ku lf kd lg kh lh kl li kz la lb lc ld bi translated">一个8位整数总共可以表示256个数字，从0到255。</li><li id="0d94" class="kp kq hi kr b ks le ku lf kd lg kh lh kl li kz la lb lc ld bi translated">例如，数字1可以表示为8位二进制整数0000 0001</li></ul><h2 id="d564" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ho bi translated">我们如何表示更大的数据(例如大于255的数字)？</h2><p id="bed4" class="pw-post-body-paragraph mb mc hi kr b ks kt is md ku kv iv me kd mf mg mh kh mi mj mk kl ml mm mn kz hb bi translated">→使用更大的数据格式(例如32位整数、64位整数等。)</p><ul class=""><li id="45a7" class="kp kq hi kr b ks mo ku mp kd mt kh mu kl mv kz la lb lc ld bi translated">因为每个字节可以代表8位，所以32位整数需要32位，或4个字节，或4个内存槽</li><li id="dfc5" class="kp kq hi kr b ks le ku lf kd lg kh lh kl li kz la lb lc ld bi translated">当表示由超过1个字节组成的数据时，我们需要连续的内存槽来完整地存储数据。当操作系统为一段数据分配内存时，只会分配能够存储整个数据的连续内存插槽</li></ul><p id="7a96" class="pw-post-body-paragraph mb mc hi kr b ks mo is md ku mp iv me kd mq mg mh kh mr mj mk kl ms mm mn kz hb bi translated">需要注意的是，当你在这些整数“形式”中表示整数时，这个“形式”中的所有整数都是一个<strong class="kr hs">固定宽度的整数</strong>——所有32位整数都有32位，即使一个数并不真的需要全部32位。未使用的位简单地用0填充。</p><ul class=""><li id="6d9f" class="kp kq hi kr b ks mo ku mp kd mt kh mu kl mv kz la lb lc ld bi translated">例如，用32位整数表示的数字1是</li></ul><p id="366d" class="pw-post-body-paragraph mb mc hi kr b ks mo is md ku mp iv me kd mq mg mh kh mr mj mk kl ms mm mn kz hb bi">00000000 00000000 00000000 00000001</p><p id="4e09" class="pw-post-body-paragraph mb mc hi kr b ks mo is md ku mp iv me kd mq mg mh kh mr mj mk kl ms mm mn kz hb bi translated">当这样的整数被存储在存储器中时，4个连续的槽被分配来存储每8位。字节序列的顺序由“<strong class="kr hs">字节序</strong>决定。</p><ul class=""><li id="302e" class="kp kq hi kr b ks mo ku mp kd mt kh mu kl mv kz la lb lc ld bi translated">在<strong class="kr hs">小端字节序(LE) </strong>系统中，最低有效(或最右)字节(00000001)存储在4个槽的第一个(地址号最低的槽:</li></ul><p id="8e29" class="pw-post-body-paragraph mb mc hi kr b ks mo is md ku mp iv me kd mq mg mh kh mr mj mk kl ms mm mn kz hb bi">00000001 00000000 00000000 00000000</p><ul class=""><li id="9f83" class="kp kq hi kr b ks mo ku mp kd mt kh mu kl mv kz la lb lc ld bi translated">在<strong class="kr hs">大端字节序(BE) </strong>系统中，最高有效(或最左边)字节(00000000)存储在地址号最低的槽中:</li></ul><p id="c5c9" class="pw-post-body-paragraph mb mc hi kr b ks mo is md ku mp iv me kd mq mg mh kh mr mj mk kl ms mm mn kz hb bi">00000000 00000000 00000000 00000001</p><p id="e182" class="pw-post-body-paragraph mb mc hi kr b ks mo is md ku mp iv me kd mq mg mh kh mr mj mk kl ms mm mn kz hb bi translated">除了像存储整数一样存储一段数据，内存插槽还可以存储对包含某段数据的另一个内存插槽(或内存地址)的引用。</p><p id="687c" class="pw-post-body-paragraph mb mc hi kr b ks mo is md ku mp iv me kd mq mg mh kh mr mj mk kl ms mm mn kz hb bi translated">→这种存储对另一个存储器地址的引用的存储器槽充当“<strong class="kr hs">指针</strong>，指向存储某段数据的存储器地址。</p><p id="2b40" class="pw-post-body-paragraph mb mc hi kr b ks mo is md ku mp iv me kd mq mg mh kh mr mj mk kl ms mm mn kz hb bi translated">访问内存槽(一个字节或一系列字节)被认为是一个非常基本的基本操作，只需要一个操作单元，因为访问指定地址的内存槽是即时完成的，就像访问数组的索引一样。</p></div><div class="ab cl lj lk gp ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="hb hc hd he hf"><h1 id="799f" class="lq jt hi bd ju lr ls lt jy lu lv lw kc ix lx iy kg ja ly jb kk jd lz je ko ma bi translated"><strong class="ak">大O批注</strong></h1><p id="386b" class="pw-post-body-paragraph mb mc hi kr b ks kt is md ku kv iv me kd mf mg mh kh mi mj mk kl ml mm mn kz hb bi translated">→大O记法用于表示一个算法的时间复杂度和空间复杂度。</p><p id="f797" class="pw-post-body-paragraph mb mc hi kr b ks mo is md ku mp iv me kd mq mg mh kh mr mj mk kl ms mm mn kz hb bi translated"><strong class="kr hs">时间复杂度</strong>衡量算法运行的速度——更准确地说，它衡量算法随着输入大小的增加而运行的速度。</p><p id="8981" class="pw-post-body-paragraph mb mc hi kr b ks mo is md ku mp iv me kd mq mg mh kh mr mj mk kl ms mm mn kz hb bi translated"><strong class="kr hs">空间复杂度</strong>衡量算法使用了多少额外的内存空间——更准确地说，它衡量相对于输入大小需要多少额外的内存空间。</p><p id="d28f" class="pw-post-body-paragraph mb mc hi kr b ks mo is md ku mp iv me kd mq mg mh kh mr mj mk kl ms mm mn kz hb bi translated"><strong class="kr hs">大O </strong>是一个<strong class="kr hs">渐近</strong>符号→我们分析一个算法相对于输入大小的复杂度。随着输入n的增加(趋于无穷大)，使用的速度和空间有多快。</p><p id="c189" class="pw-post-body-paragraph mb mc hi kr b ks mo is md ku mp iv me kd mq mg mh kh mr mj mk kl ms mm mn kz hb bi translated">这意味着，当你用大O表示时空复杂性时，你忽略了任何常数和任何不重要的项。</p><ul class=""><li id="91e8" class="kp kq hi kr b ks mo ku mp kd mt kh mu kl mv kz la lb lc ld bi translated">例如，一个算法，比方说，无论输入n的大小是多少，都需要正好30次运算，将被表示为具有O(1)的时间复杂度，即使确切的时间函数是f(30)。</li><li id="1821" class="kp kq hi kr b ks le ku lf kd lg kh lh kl li kz la lb lc ld bi translated">类似地，例如，已经被计算为具有f(3n)的时间函数的算法将被简单地表示为O(n)。</li><li id="19c5" class="kp kq hi kr b ks le ku lf kd lg kh lh kl li kz la lb lc ld bi translated">此外，如果您有一个算法，该算法有三个分别花费O(1)、O(n)和O(n)时间的函数，则该算法的时间函数将表示为f(n + n + 1)。</li><li id="c4a4" class="kp kq hi kr b ks le ku lf kd lg kh lh kl li kz la lb lc ld bi translated">然而，由于我们正在研究随着n变得越来越大而趋于无穷大，算法将花费多少时间，随着n变得足够大，n和1与n相比将变得越来越不重要，以至于n和1可以被简单地忽略。</li><li id="7c54" class="kp kq hi kr b ks le ku lf kd lg kh lh kl li kz la lb lc ld bi translated">因此，时间复杂度可以简单地用最高有效项→ O(n)来表示。</li></ul><h2 id="0737" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ho bi translated">当你有不止一个输入的时候呢？</h2><p id="6a22" class="pw-post-body-paragraph mb mc hi kr b ks kt is md ku kv iv me kd mf mg mh kh mi mj mk kl ml mm mn kz hb bi translated">→当一个算法接受多个可变大小的输入时，比如n和m，您必须表示这两个输入。</p><ul class=""><li id="ca82" class="kp kq hi kr b ks mo ku mp kd mt kh mu kl mv kz la lb lc ld bi translated">例如，如果有一个算法对所有n个输入执行单个操作，而对所有m个输入执行另一个操作，则这将是O(n + m)。你不能把这个组合成O(2n)或者O(2m)就说是O(n)或者O(m)。是O(n + m)。</li><li id="a950" class="kp kq hi kr b ks le ku lf kd lg kh lh kl li kz la lb lc ld bi translated">重要的是，这可能很棘手，但如果你有一个n和m的阶数不同的时间函数，比如f(n + mlogm + n)，你可以忽略n(与n相比，它的重要性较低)，但你不能忽略mlogm，因为n和m是不同的输入。时间复杂度将为O(n + mlogm)。</li></ul><p id="6fa9" class="pw-post-body-paragraph mb mc hi kr b ks mo is md ku mp iv me kd mq mg mh kh mr mj mk kl ms mm mn kz hb bi translated">另外，请注意，虽然大O符号通常被解释为在编码面试的上下文中表达算法的最坏情况复杂性，但对于特定的算法，最坏情况可能不同于平均情况。</p><p id="1153" class="pw-post-body-paragraph mb mc hi kr b ks mo is md ku mp iv me kd mq mg mh kh mr mj mk kl ms mm mn kz hb bi translated">→在这种情况下，你应该确定平均和最坏情况的复杂性。</p></div><div class="ab cl lj lk gp ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="hb hc hd he hf"><h1 id="ba87" class="lq jt hi bd ju lr ls lt jy lu lv lw kc ix lx iy kg ja ly jb kk jd lz je ko ma bi translated"><strong class="ak">对数</strong></h1><p id="60c5" class="pw-post-body-paragraph mb mc hi kr b ks kt is md ku kv iv me kd mf mg mh kh mi mj mk kl ml mm mn kz hb bi translated">→对数是计算机科学中广泛使用的数学概念，在编码面试的情况下，用来描述某些算法的复杂度分析。</p><h2 id="421c" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ho bi translated"><strong class="ak">对数的定义(以2为底):</strong></h2><p id="2960" class="pw-post-body-paragraph mb mc hi kr b ks kt is md ku kv iv me kd mf mg mh kh mi mj mk kl ml mm mn kz hb bi translated"><em class="mw"> log2(n) = k当且仅当2^k = n </em></p><p id="b282" class="pw-post-body-paragraph mb mc hi kr b ks mo is md ku mp iv me kd mq mg mh kh mr mj mk kl ms mm mn kz hb bi translated">当输入的大小为n时，log(n)基本上意味着获得n所需的2的幂。</p><ul class=""><li id="8862" class="kp kq hi kr b ks mo ku mp kd mt kh mu kl mv kz la lb lc ld bi translated">例如，如果有一个输入n，其中n = 8，log(n) = log(8) = 3，因为2 = 8。</li></ul><p id="198c" class="pw-post-body-paragraph mb mc hi kr b ks mo is md ku mp iv me kd mq mg mh kh mr mj mk kl ms mm mn kz hb bi translated">从时间复杂度分析的角度来看，这真正意味着，输入n的大小每增加一倍，需要完成的操作数量只增加1个单位。</p><ul class=""><li id="1361" class="kp kq hi kr b ks mo ku mp kd mt kh mu kl mv kz la lb lc ld bi translated">例如，让我们将n的大小加倍，使它现在是16。log(16) = 4。这只是比n为8时多了1个单位。</li><li id="c0be" class="kp kq hi kr b ks le ku lf kd lg kh lh kl li kz la lb lc ld bi translated">随着n的规模越来越大，所需运算次数的边际增量越来越小。</li><li id="4d09" class="kp kq hi kr b ks le ku lf kd lg kh lh kl li kz la lb lc ld bi translated">这是一个非常重要的概念，与线性复杂度相比，它允许非常快的算法时间复杂度，更不用说其他更慢形式的时间复杂度了。</li></ul><p id="9978" class="pw-post-body-paragraph mb mc hi kr b ks mo is md ku mp iv me kd mq mg mh kh mr mj mk kl ms mm mn kz hb bi translated">另一种看待log(n)与时间复杂度分析的关系的方式是，当您有一个大小为n的输入时，每个操作会消除一半的输入元素(log的底2基本上是这样的)，直到只剩下一个元素供操作处理，在这样的序列中从n到1所需的操作总数就是log(n) = k。</p><ul class=""><li id="4888" class="kp kq hi kr b ks mo ku mp kd mt kh mu kl mv kz la lb lc ld bi translated">例如，如果n = 1，000，000，第一个操作消除1，000，000的一半，或500，000，下一个操作依次消除500，000的一半，或250，000，等等，直到只剩下1。log(1，000，000) ~= 20。我们只需要做20次运算来处理1，000，000的输入。</li><li id="35a9" class="kp kq hi kr b ks le ku lf kd lg kh lh kl li kz la lb lc ld bi translated">另一方面，如果你有一个线性复杂度，对于同样大小的n = 1，000，000，你需要做1，000，000次运算。</li><li id="1d31" class="kp kq hi kr b ks le ku lf kd lg kh lh kl li kz la lb lc ld bi translated">1，000，000 vs. 20是一个非常大的差别，而且这个差别随着n的大小的增加变得越来越大。</li></ul></div><div class="ab cl lj lk gp ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="hb hc hd he hf"><h1 id="35c9" class="lq jt hi bd ju lr ls lt jy lu lv lw kc ix lx iy kg ja ly jb kk jd lz je ko ma bi translated"><strong class="ak">数组</strong></h1><p id="942d" class="pw-post-body-paragraph mb mc hi kr b ks kt is md ku kv iv me kd mf mg mh kh mi mj mk kl ml mm mn kz hb bi translated">→数组是最基本的数据结构。</p><p id="03ed" class="pw-post-body-paragraph mb mc hi kr b ks mo is md ku mp iv me kd mq mg mh kh mr mj mk kl ms mm mn kz hb bi translated">从我们对内存的讨论中可以看出，当一块数据或一系列固定大小的数据存储在内存中时，操作系统会将它们分配给一系列可以连续存储全部数据的内存插槽。</p><p id="8f60" class="pw-post-body-paragraph mb mc hi kr b ks mo is md ku mp iv me kd mq mg mh kh mr mj mk kl ms mm mn kz hb bi translated">假设我们有一个包含3个整数元素的数组:[1，2，3]。假设每个整数都是32位整数。</p><ul class=""><li id="0c81" class="kp kq hi kr b ks mo ku mp kd mt kh mu kl mv kz la lb lc ld bi translated">这意味着每个整数需要32位或4个字节。</li><li id="e170" class="kp kq hi kr b ks le ku lf kd lg kh lh kl li kz la lb lc ld bi translated">因为数组有3个整数，所以它需要4 * 3 = 12字节的内存空间。</li><li id="a6e8" class="kp kq hi kr b ks le ku lf kd lg kh lh kl li kz la lb lc ld bi translated">当操作系统存储该数组时，它必须找到一个具有12个连续可用地址的内存插槽序列，并将数组数据存储在该地址序列中。</li><li id="c959" class="kp kq hi kr b ks le ku lf kd lg kh lh kl li kz la lb lc ld bi translated">更一般地，n个元素的阵列，其中每个元素是32位整数(4字节)，将需要4n字节的存储空间。</li><li id="bd25" class="kp kq hi kr b ks le ku lf kd lg kh lh kl li kz la lb lc ld bi translated">这也意味着数组被分配了一个字节序列的内存空间，其中数组的第一个元素存储在字节序列的第一个字节中。</li></ul><p id="d44a" class="pw-post-body-paragraph mb mc hi kr b ks mo is md ku mp iv me kd mq mg mh kh mr mj mk kl ms mm mn kz hb bi translated">现在，让我们看一下在阵列上执行一些常见操作的复杂性:</p><ul class=""><li id="d0de" class="kp kq hi kr b ks mo ku mp kd mt kh mu kl mv kz la lb lc ld bi translated"><strong class="kr hs"> GET </strong> —访问给定索引处的元素:O(1) →操作系统通过将索引号乘以每个元素的大小来访问给定索引处的元素。因为每个元素都是固定宽度的，并且数组的第一个元素位于存储数组的字节序列的第一个字节，所以第x个元素位于所分配的内存空间的第x个字节。因此，操作系统简单地访问数组的第x个元素(32位整数),从所分配的内存地址的开始处获取x *字节的内存地址。</li><li id="009b" class="kp kq hi kr b ks le ku lf kd lg kh lh kl li kz la lb lc ld bi translated"><strong class="kr hs"> SET </strong> —更新给定索引处的元素:O(1) →在给定索引处设置元素，在时间复杂度上本质上和访问元素是一样的。</li><li id="9e70" class="kp kq hi kr b ks le ku lf kd lg kh lh kl li kz la lb lc ld bi translated"><strong class="kr hs"> COPY </strong> —复制数组:O(n) →复制整个数组本质上需要访问所有元素—遍历数组。每当一个操作需要遍历数组时，它将花费O(n)时间。当复制数组并将其存储在另一个内存地址序列中时，这需要额外的n空间。所以这也需要O(n)空间。</li><li id="7f85" class="kp kq hi kr b ks le ku lf kd lg kh lh kl li kz la lb lc ld bi translated"><strong class="kr hs"> INSERT </strong> —在开头、中间或结尾插入一个元素:O(n) →本质上，为现有数组分配的内存空间可能只够恰好适合该数组，例如，紧接在存储数组最后一个元素之后的下一个内存槽被一些其他数据占用。因此，本质上，将元素插入到数组中，无论元素插入到数组中的什么位置，都需要复制所有现有元素，并重新分配由插入的元素+现有元素的副本组成的新数组，这需要遍历所有元素— O(n)次。此外，由于必须使用新的存储空间来适应新的阵列，这也需要O(n)空间。</li></ul><p id="582e" class="pw-post-body-paragraph mb mc hi kr b ks mo is md ku mp iv me kd mq mg mh kh mr mj mk kl ms mm mn kz hb bi translated">这就引出了数组的关键子主题:<strong class="kr hs">静态数组与动态数组。</strong></p><h2 id="2441" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ho bi translated">静态数组</h2><p id="990c" class="pw-post-body-paragraph mb mc hi kr b ks kt is md ku kv iv me kd mf mg mh kh mi mj mk kl ml mm mn kz hb bi translated">→静态数组有一个固定的内存空间大小，这个大小不能改变。</p><h2 id="f5d4" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ho bi translated">动态数组</h2><p id="81cb" class="pw-post-body-paragraph mb mc hi kr b ks kt is md ku kv iv me kd mf mg mh kh mi mj mk kl ml mm mn kz hb bi translated">→另一方面，动态数组的数组大小是可以改变的。在大多数语言和操作系统中，动态数组是这样构造的，它用两倍于原始数组大小的容量进行初始化，然后每当没有更多空间来容纳额外的元素时，数组的大小就加倍。</p><p id="1912" class="pw-post-body-paragraph mb mc hi kr b ks mo is md ku mp iv me kd mq mg mh kh mr mj mk kl ms mm mn kz hb bi translated">因此，对于动态数组，在数组末尾插入一个元素只需要O(1)次运算，当末尾有空间可用于额外的元素时，但是当空间被填满并且没有更多的空间可用时，数组的大小需要加倍，然后被重新分配给新的合适的内存槽，因此需要O(n)次运算。</p><ul class=""><li id="89c3" class="kp kq hi kr b ks mo ku mp kd mt kh mu kl mv kz la lb lc ld bi translated">在数学上，这渐进地收敛到2n个操作。每次数组大小加倍都需要n次操作，但是随着大小的增加，大小加倍所花费的时间越来越长，因为每次数组大小加倍都必须插入双倍数量的元素。这实质上将O(n)操作的频率减少了两倍，而O(1)的频率增加了一倍。这可以表示为n + n/2 + n/4 + n/8 … + 1，收敛到2n。所以从数学上来说，在末尾插入动态数组也需要O(n)时间。</li><li id="253c" class="kp kq hi kr b ks le ku lf kd lg kh lh kl li kz la lb lc ld bi translated">但从概念上讲，由于O(n)的频率越来越小而O(1)的频率越来越高，所以我们说在动态数组末尾插入一个元素的<strong class="kr hs">摊销</strong>时间复杂度为O(1)。</li><li id="9f7d" class="kp kq hi kr b ks le ku lf kd lg kh lh kl li kz la lb lc ld bi translated">对于在开头或中间插入，动态数组帮助不大，因为元素无论如何都必须移位。</li><li id="aae6" class="kp kq hi kr b ks le ku lf kd lg kh lh kl li kz la lb lc ld bi translated"><strong class="kr hs">在开头/中间删除</strong> —删除开头(和中间)的元素:O(n) →同样，删除开头或中间的元素需要移动元素以填充删除的空间，对于静态和动态数组都需要O(n)时间。</li><li id="8572" class="kp kq hi kr b ks le ku lf kd lg kh lh kl li kz la lb lc ld bi translated"><strong class="kr hs">删除末尾</strong> —删除末尾的一个元素:O(1) →无论是静态数组还是动态数组，删除末尾的一个元素只是需要删除它，需要不断的运算。</li></ul><h2 id="f050" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ho bi translated">总结:</h2><figure class="jh ji jj jk fd jl er es paragraph-image"><div class="er es mx"><img src="../Images/4222e5a7608e190ac0d8494482021e4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1330/format:webp/1*A4GmDtEvY2nury5crumeDg.png"/></div></figure></div><div class="ab cl lj lk gp ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="hb hc hd he hf"><h1 id="e816" class="lq jt hi bd ju lr ls lt jy lu lv lw kc ix lx iy kg ja ly jb kk jd lz je ko ma bi translated"><strong class="ak">链表</strong></h1><p id="e261" class="pw-post-body-paragraph mb mc hi kr b ks kt is md ku kv iv me kd mf mg mh kh mi mj mk kl ml mm mn kz hb bi translated">→链表在概念上类似于数组，因为它们本质上是一个从左到右读取的元素列表，但关键区别在于它们在内存中的存储方式。</p><ul class=""><li id="cd40" class="kp kq hi kr b ks mo ku mp kd mt kh mu kl mv kz la lb lc ld bi translated">数组(静态)的主要缺点是需要连续的内存插槽来存储它</li><li id="a795" class="kp kq hi kr b ks le ku lf kd lg kh lh kl li kz la lb lc ld bi translated">链表克服了数组的这个缺点。</li><li id="fd55" class="kp kq hi kr b ks le ku lf kd lg kh lh kl li kz la lb lc ld bi translated">链表的“元素”是“节点”，每个节点以指针属性的形式“链接”到下一个节点(或元素)。这意味着链表中的节点不必像数组中的元素那样在内存中背对背放置。</li><li id="16b2" class="kp kq hi kr b ks le ku lf kd lg kh lh kl li kz la lb lc ld bi translated">数组中的每个节点可以位于内存画布中的任何位置，但是每个节点都有一个指针，指向链表中的下一个节点。</li><li id="99d5" class="kp kq hi kr b ks le ku lf kd lg kh lh kl li kz la lb lc ld bi translated">因此，每个节点都有两个属性:值和指向下一个节点 (next)的指针<strong class="kr hs">。</strong></li><li id="b4e3" class="kp kq hi kr b ks le ku lf kd lg kh lh kl li kz la lb lc ld bi translated">链表的一个很大的缺点是，由于每个节点不是背靠背地存储在内存中，而是通过每个节点的指针的引用来链接，所以访问除了头节点(第一个节点)之外的特定节点需要从头节点开始，并逐个指针地遍历每个节点。这需要O(n)时间。</li><li id="42dc" class="kp kq hi kr b ks le ku lf kd lg kh lh kl li kz la lb lc ld bi translated">搜索具有特定值的节点也需要O(n)，因为需要遍历来定位该值。</li><li id="2b8d" class="kp kq hi kr b ks le ku lf kd lg kh lh kl li kz la lb lc ld bi translated">从链表中插入和移除节点都需要首先通过遍历访问节点，然后执行插入或移除操作。这需要O(n)进行访问+ O(1)进行插入/删除，或者基本上是O(n)。</li><li id="c31e" class="kp kq hi kr b ks le ku lf kd lg kh lh kl li kz la lb lc ld bi translated">在链表中添加和删除一个节点本质上涉及到覆盖“下一个”指针。这要求您访问要插入/移除的节点之前的节点。</li></ul><p id="991c" class="pw-post-body-paragraph mb mc hi kr b ks mo is md ku mp iv me kd mq mg mh kh mr mj mk kl ms mm mn kz hb bi translated">链表跟踪头节点(第一个节点)和尾节点(最后一个节点)，指向一个“空”作为它的“下一个”属性。根据你如何构造一个链表，你可以选择跟踪或者不跟踪尾节点。如果跟踪尾节点，则尾节点的查找时间将为O(1)，而如果不跟踪，则必须从头到尾遍历一次，需要O(n)。</p><h2 id="4ed3" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ho bi translated">链表分为两种类型:</h2><ul class=""><li id="fcaa" class="kp kq hi kr b ks kt ku kv kd kw kh kx kl ky kz la lb lc ld bi translated"><strong class="kr hs">单链表</strong> →除了value属性之外，还有指向下一个节点的指针(“next”属性)。单向(“单向”)链表。</li><li id="4825" class="kp kq hi kr b ks le ku lf kd lg kh lh kl li kz la lb lc ld bi translated"><strong class="kr hs">双向链表</strong> →除了value属性，还有两个指针，一个指向下一个节点(“next”)，另一个指向上一个节点(“prev”)。头节点的“prev”属性指向“null”，尾节点的“next”属性指向“null”。双向(“双向”)链表。</li><li id="6a7c" class="kp kq hi kr b ks le ku lf kd lg kh lh kl li kz la lb lc ld bi translated"><strong class="kr hs">循环链表→ </strong>循环链表没有明确的头节点或尾节点，由于尾部指向其头部(而不是null)，形成循环关系。循环链表可以是<strong class="kr hs">单向循环链表</strong>或<strong class="kr hs">双向循环链表</strong>。</li></ul><h2 id="a7e7" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ho bi translated">总结:</h2><figure class="jh ji jj jk fd jl er es paragraph-image"><div class="er es my"><img src="../Images/c36ecbaf8e4bed5ece55b28bc2a8cd0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1326/format:webp/1*7bwcImiNHpJfhFkS1xqo-g.png"/></div></figure><p id="566f" class="pw-post-body-paragraph mb mc hi kr b ks mo is md ku mp iv me kd mq mg mh kh mr mj mk kl ms mm mn kz hb bi translated">*假设没有跟踪尾节点。这里假设对于单链表，不跟踪尾部节点，但是对于双向链表，它们与头部一起被跟踪。</p><p id="f89b" class="pw-post-body-paragraph mb mc hi kr b ks mo is md ku mp iv me kd mq mg mh kh mr mj mk kl ms mm mn kz hb bi translated">* *对于移除单链表中的尾节点，即使跟踪尾节点，时间仍然是O(n ),因为要移除尾节点，您需要访问尾之前的节点，但是在单链表中，您没有“prev”属性来直接从尾访问前一个节点。您必须遍历节点，直到“next”属性指向尾部(它的“next”为null)。</p><p id="7971" class="pw-post-body-paragraph mb mc hi kr b ks mo is md ku mp iv me kd mq mg mh kh mr mj mk kl ms mm mn kz hb bi translated">→某些操作的复杂性取决于如何构建链表。例如，如果构建单链表，使得每次插入/移除节点时更新尾节点，那么访问或插入尾节点将花费O(1)时间。</p></div><div class="ab cl lj lk gp ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="hb hc hd he hf"><h1 id="1ef5" class="lq jt hi bd ju lr ls lt jy lu lv lw kc ix lx iy kg ja ly jb kk jd lz je ko ma bi translated"><strong class="ak">哈希表</strong></h1><p id="5c84" class="pw-post-body-paragraph mb mc hi kr b ks kt is md ku kv iv me kd mf mg mh kh mi mj mk kl ml mm mn kz hb bi translated">→哈希表是一个键值存储。</p><p id="58ff" class="pw-post-body-paragraph mb mc hi kr b ks mo is md ku mp iv me kd mq mg mh kh mr mj mk kl ms mm mn kz hb bi translated">对于哈希表来说<strong class="kr hs">最重要的一点是，对于查找、插入和删除</strong>，它的速度非常快，平均时间为常数O(1)。</p><p id="4c17" class="pw-post-body-paragraph mb mc hi kr b ks mo is md ku mp iv me kd mq mg mh kh mr mj mk kl ms mm mn kz hb bi translated">构建哈希表有很多方法，但是最常见的<strong class="kr hs">哈希表使用的是动态链表数组</strong>。</p><h2 id="641e" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ho bi translated">在哈希表中的查找是如何在常量时间内完成的？</h2><p id="4f8c" class="pw-post-body-paragraph mb mc hi kr b ks kt is md ku kv iv me kd mf mg mh kh mi mj mk kl ml mm mn kz hb bi translated">→哈希表使用哈希函数将一个键(通常是一个字符串，也可以是任何其他可以被哈希的数据)转换成一个哈希值，然后映射到底层动态数组中的一个索引。与该键相关联的值被添加到存储在动态数组的映射索引处的链表中，并且对该键的引用也与该值一起存储。因此，只要最小化<strong class="kr hs">冲突</strong>，就可以在O(1)中立即通过密钥访问哈希表。</p><ul class=""><li id="c05b" class="kp kq hi kr b ks mo ku mp kd mt kh mu kl mv kz la lb lc ld bi translated">当多个键映射到基础动态数组的同一索引时，就会发生冲突。存储在动态数组的每个索引处的链表允许存储已经映射到同一索引的多个键。</li><li id="d58e" class="kp kq hi kr b ks le ku lf kd lg kh lh kl li kz la lb lc ld bi translated">如果使用的散列函数不好，则键的分布非常不均匀，极端的情况是所有键都映射到一个索引，并且都存储在该索引处的一个链表中。这基本上需要O(n)来访问某个值，因为您必须遍历链表来查找该值。</li><li id="4e03" class="kp kq hi kr b ks le ku lf kd lg kh lh kl li kz la lb lc ld bi translated">然而，如果使用非常好的散列函数，平均来说，动态数组的键的分布将是平衡的，使得时间复杂度基本上是O(1)。</li><li id="006d" class="kp kq hi kr b ks le ku lf kd lg kh lh kl li kz la lb lc ld bi translated">如果底层动态数组用完了可用的索引，那么必须调整它的大小(加倍)，以便可以映射更多的键。这与调整动态数组的大小本质上是相同的概念，摊销时间复杂度为O(1)。</li></ul><h2 id="65d5" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ho bi translated">总结:</h2><figure class="jh ji jj jk fd jl er es paragraph-image"><div class="er es mz"><img src="../Images/58e0433efbff1ba6108f0d24737a6061.png" data-original-src="https://miro.medium.com/v2/resize:fit:1328/format:webp/1*bT5nO2WARBs2NSRVRRfqpw.png"/></div></figure></div><div class="ab cl lj lk gp ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="hb hc hd he hf"><h1 id="93ef" class="lq jt hi bd ju lr ls lt jy lu lv lw kc ix lx iy kg ja ly jb kk jd lz je ko ma bi translated"><strong class="ak">堆栈&amp;队列</strong></h1><h2 id="3d2a" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ho bi translated"><strong class="ak">栈</strong></h2><p id="48b3" class="pw-post-body-paragraph mb mc hi kr b ks kt is md ku kv iv me kd mf mg mh kh mi mj mk kl ml mm mn kz hb bi translated">→具有后进先出结构的类似数组的数据结构</p><ul class=""><li id="744a" class="kp kq hi kr b ks mo ku mp kd mt kh mu kl mv kz la lb lc ld bi translated">堆栈通常用动态数组或链表来实现。</li><li id="8183" class="kp kq hi kr b ks le ku lf kd lg kh lh kl li kz la lb lc ld bi translated">动态数组比较常见。</li></ul><figure class="jh ji jj jk fd jl er es paragraph-image"><div class="er es na"><img src="../Images/8b17665e804f5e7743751e763fdcc52e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1230/format:webp/1*MUXi1tOdlsJfEdZdiJBEag.png"/></div></figure><h2 id="e8c3" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ho bi translated"><strong class="ak">队列</strong></h2><p id="e4ba" class="pw-post-body-paragraph mb mc hi kr b ks kt is md ku kv iv me kd mf mg mh kh mi mj mk kl ml mm mn kz hb bi translated">→具有FIFO结构的类似数组的数据结构(先进先出)</p><ul class=""><li id="c96d" class="kp kq hi kr b ks mo ku mp kd mt kh mu kl mv kz la lb lc ld bi translated">队列通常用(双向)链表来实现。</li><li id="26d1" class="kp kq hi kr b ks le ku lf kd lg kh lh kl li kz la lb lc ld bi translated">如果使用一个数组来创建一个队列，那么出列将需要O(n)。</li></ul><figure class="jh ji jj jk fd jl er es paragraph-image"><div class="er es nb"><img src="../Images/983ec86727e4fc9cc83a7384962b11cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1232/format:webp/1*8MsBOkkSKF4aCCnLxLUN_w.png"/></div></figure></div><div class="ab cl lj lk gp ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="hb hc hd he hf"><h1 id="8585" class="lq jt hi bd ju lr ls lt jy lu lv lw kc ix lx iy kg ja ly jb kk jd lz je ko ma bi translated"><strong class="ak">琴弦</strong></h1><p id="78c0" class="pw-post-body-paragraph mb mc hi kr b ks kt is md ku kv iv me kd mf mg mh kh mi mj mk kl ml mm mn kz hb bi translated">→字符串是一种原始数据类型，其行为类似于数据结构(字符数组)。</p><ul class=""><li id="45f0" class="kp kq hi kr b ks mo ku mp kd mt kh mu kl mv kz la lb lc ld bi translated">字符串中的每个字符都通过字符编码标准(如ASCII或Unicode)映射到一个整数，这决定了在内存中存储字符串所需的字节数。</li></ul><h2 id="c545" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ho bi translated"><strong class="ak">弦乐需要记住的一件非常重要的事情</strong>:</h2><ul class=""><li id="7113" class="kp kq hi kr b ks kt ku kv kd kw kh kx kl ky kz la lb lc ld bi translated">根据您使用的语言，字符串可以是可变的或不可变的。</li><li id="dc04" class="kp kq hi kr b ks le ku lf kd lg kh lh kl li kz la lb lc ld bi translated">例如，在C++中，字符串基本上是一个字符数组，你基本上可以像修改数组一样修改字符串</li><li id="2e56" class="kp kq hi kr b ks le ku lf kd lg kh lh kl li kz la lb lc ld bi translated">然而，在大多数其他语言中，如JavaScript、Python和Java，字符串是不可变的。一旦你有了一个字符串，你不能改变它。如果你想改变一个字符串，唯一的方法是创建一个新的字符串。</li></ul><p id="c1a4" class="pw-post-body-paragraph mb mc hi kr b ks mo is md ku mp iv me kd mq mg mh kh mr mj mk kl ms mm mn kz hb bi translated">→这意味着当您使用“string”+=“char”语法时，例如，在JavaScript中，这不仅仅是将“char”附加到“string”的末尾。实际上，它创建了一个全新的n + m大小的字符串，并将这个新字符串重新赋给原来的变量。</p><p id="a3d6" class="pw-post-body-paragraph mb mc hi kr b ks mo is md ku mp iv me kd mq mg mh kh mr mj mk kl ms mm mn kz hb bi translated">看一下下面的例子:</p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="nc nd l"/></div></figure><p id="6e78" class="pw-post-body-paragraph mb mc hi kr b ks mo is md ku mp iv me kd mq mg mh kh mr mj mk kl ms mm mn kz hb bi translated">由于字符串的不变性，上面的例子看起来非常昂贵。</p><p id="415b" class="pw-post-body-paragraph mb mc hi kr b ks mo is md ku mp iv me kd mq mg mh kh mr mj mk kl ms mm mn kz hb bi translated">→它需要O(n)，因为对于长度为n的str中的每个字符，它都创建了一个长度为I的新字符串&lt;= n by copying and re-assigning all of the characters, which itself takes O(n) operations. Performing O(n) operations (creating new string) n times (length of str) essentially leads to a time complexity of O(n²).</p><h2 id="5c46" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ho bi translated">Therefore, when you need to deal with strings, <em class="ne">您不应该使用这样的语法直接操作字符串</em>。</h2><ul class=""><li id="938b" class="kp kq hi kr b ks kt ku kv kd kw kh kx kl ky kz la lb lc ld bi translated">您应该首先将字符串拆分成一个由单个字符组成的数组→ O(n)</li><li id="262b" class="kp kq hi kr b ks le ku lf kd lg kh lh kl li kz la lb lc ld bi translated">然后执行所需的操作(追加等。)在数组上→ O(1)</li><li id="5e7c" class="kp kq hi kr b ks le ku lf kd lg kh lh kl li kz la lb lc ld bi translated">然后将字符重新连接成一个新的字符串→ O(n)</li></ul><p id="9def" class="pw-post-body-paragraph mb mc hi kr b ks mo is md ku mp iv me kd mq mg mh kh mr mj mk kl ms mm mn kz hb bi translated">这比直接在字符串上做一堆O(n)操作要有效得多。</p></div><div class="ab cl lj lk gp ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="hb hc hd he hf"><h1 id="85db" class="lq jt hi bd ju lr ls lt jy lu lv lw kc ix lx iy kg ja ly jb kk jd lz je ko ma bi translated"><strong class="ak">图表</strong></h1><p id="86cf" class="pw-post-body-paragraph mb mc hi kr b ks kt is md ku kv iv me kd mf mg mh kh mi mj mk kl ml mm mn kz hb bi translated">→图是相互连接或不连接的节点的集合。</p><h2 id="cb20" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ho bi translated">图表由两部分组成:</h2><ul class=""><li id="57a9" class="kp kq hi kr b ks kt ku kv kd kw kh kx kl ky kz la lb lc ld bi translated"><strong class="kr hs">顶点</strong>:节点</li><li id="b2ab" class="kp kq hi kr b ks le ku lf kd lg kh lh kl li kz la lb lc ld bi translated"><strong class="kr hs">边</strong>:节点之间的连接</li></ul><h2 id="3797" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ho bi translated"><strong class="ak">连接的</strong>与<strong class="ak">断开的</strong>图表</h2><ul class=""><li id="788c" class="kp kq hi kr b ks kt ku kv kd kw kh kx kl ky kz la lb lc ld bi translated">连通图是指图中每对顶点都有一条路径，由一条或多条边连接。</li><li id="5c89" class="kp kq hi kr b ks le ku lf kd lg kh lh kl li kz la lb lc ld bi translated">在有向图的情况下，该图是:</li></ul><p id="6978" class="pw-post-body-paragraph mb mc hi kr b ks mo is md ku mp iv me kd mq mg mh kh mr mj mk kl ms mm mn kz hb bi translated"><strong class="kr hs">强连通</strong>如果每对顶点之间存在双向连接</p><p id="3d4d" class="pw-post-body-paragraph mb mc hi kr b ks mo is md ku mp iv me kd mq mg mh kh mr mj mk kl ms mm mn kz hb bi translated"><strong class="kr hs">弱连接</strong>如果连接不必是双向的</p><ul class=""><li id="da53" class="kp kq hi kr b ks mo ku mp kd mt kh mu kl mv kz la lb lc ld bi translated">不连通的图是不连通的图。</li></ul><h2 id="bd6a" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ho bi translated"><strong class="ak">有向</strong> vs. <strong class="ak">无向</strong>图</h2><ul class=""><li id="1d8f" class="kp kq hi kr b ks kt ku kv kd kw kh kx kl ky kz la lb lc ld bi translated">有向图有从一个顶点到另一个顶点的有向边。顶点之间的连接是单向的。只能在一个方向上移动。</li><li id="9eaf" class="kp kq hi kr b ks le ku lf kd lg kh lh kl li kz la lb lc ld bi translated">无向图的边是非定向的，或者说本质上顶点之间的连接是双向的。可以双向穿越。</li></ul><h2 id="a353" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ho bi translated"><strong class="ak">循环</strong>对比<strong class="ak">非循环</strong>图</h2><ul class=""><li id="d972" class="kp kq hi kr b ks kt ku kv kd kw kh kx kl ky kz la lb lc ld bi translated">循环图是具有一个或多个循环的图。</li><li id="cd65" class="kp kq hi kr b ks le ku lf kd lg kh lh kl li kz la lb lc ld bi translated">无圈图是没有圈的图。</li></ul><p id="e81c" class="pw-post-body-paragraph mb mc hi kr b ks mo is md ku mp iv me kd mq mg mh kh mr mj mk kl ms mm mn kz hb bi translated">当三个或更多顶点连接成一个闭环时，就形成了一个<strong class="kr hs">循环</strong>。连续遍历路径将导致在当前路径中已经访问过的顶点。顶点以环形方式连接。</p><h2 id="504c" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ho bi translated">遍历一个图有两种方式:</h2><ul class=""><li id="cc45" class="kp kq hi kr b ks kt ku kv kd kw kh kx kl ky kz la lb lc ld bi translated"><strong class="kr hs">深度优先搜索(DFS): </strong>先深入再广泛</li><li id="86fe" class="kp kq hi kr b ks le ku lf kd lg kh lh kl li kz la lb lc ld bi translated">广度优先搜索(BFS): 先广后深</li></ul><p id="2da5" class="pw-post-body-paragraph mb mc hi kr b ks mo is md ku mp iv me kd mq mg mh kh mr mj mk kl ms mm mn kz hb bi translated">在DFS和BFS中，你需要访问每个顶点和每个顶点的边，所以遍历需要O(V + E)时间。</p><p id="a399" class="pw-post-body-paragraph mb mc hi kr b ks mo is md ku mp iv me kd mq mg mh kh mr mj mk kl ms mm mn kz hb bi translated">图通常在代码中表示为邻接表，邻接表实质上是底层动态数组和链表的散列映射，其将顶点存储为关键字，并将每个顶点的连接边存储为映射到相应链表的关键字的值。</p><p id="40b6" class="pw-post-body-paragraph mb mc hi kr b ks mo is md ku mp iv me kd mq mg mh kh mr mj mk kl ms mm mn kz hb bi translated">因为这需要所有顶点和所有边的内存空间，所以实现一个图需要O(V + E)空间。</p></div><div class="ab cl lj lk gp ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="hb hc hd he hf"><h1 id="cfe1" class="lq jt hi bd ju lr ls lt jy lu lv lw kc ix lx iy kg ja ly jb kk jd lz je ko ma bi translated"><strong class="ak">树木</strong></h1><p id="b032" class="pw-post-body-paragraph mb mc hi kr b ks kt is md ku kv iv me kd mf mg mh kh mi mj mk kl ml mm mn kz hb bi translated">→树是一种特殊类型的图形</p><p id="563a" class="pw-post-body-paragraph mb mc hi kr b ks mo is md ku mp iv me kd mq mg mh kh mr mj mk kl ms mm mn kz hb bi translated">树有利于分层存储数据。</p><p id="1e0d" class="pw-post-body-paragraph mb mc hi kr b ks mo is md ku mp iv me kd mq mg mh kh mr mj mk kl ms mm mn kz hb bi translated">在编码面试中，树经常被用来测试你的递归知识。</p><ul class=""><li id="9bbd" class="kp kq hi kr b ks mo ku mp kd mt kh mu kl mv kz la lb lc ld bi translated">必须连接<em class="mw">采油树</em>。如果断开连接，它就不是一棵树。</li><li id="b56d" class="kp kq hi kr b ks le ku lf kd lg kh lh kl li kz la lb lc ld bi translated">树是有根节点的有向无环图。</li></ul><h2 id="a963" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ho bi translated">一棵树有:</h2><ul class=""><li id="bddd" class="kp kq hi kr b ks kt ku kv kd kw kh kx kl ky kz la lb lc ld bi translated">根节点</li><li id="9333" class="kp kq hi kr b ks le ku lf kd lg kh lh kl li kz la lb lc ld bi translated">每个节点有零个或多个子节点</li></ul><p id="eb95" class="pw-post-body-paragraph mb mc hi kr b ks mo is md ku mp iv me kd mq mg mh kh mr mj mk kl ms mm mn kz hb bi translated">每个节点及其子节点可以被视为递归形成的树的子树。</p><ul class=""><li id="677e" class="kp kq hi kr b ks mo ku mp kd mt kh mu kl mv kz la lb lc ld bi translated">没有孩子的树的节点被称为<strong class="kr hs">叶节点</strong>(或<strong class="kr hs">叶节点</strong>)。</li><li id="4802" class="kp kq hi kr b ks le ku lf kd lg kh lh kl li kz la lb lc ld bi translated">根节点和它的叶子之间的路径叫做<strong class="kr hs">分支</strong>。</li><li id="2678" class="kp kq hi kr b ks le ku lf kd lg kh lh kl li kz la lb lc ld bi translated">一棵树的高度等于最长树枝的深度。</li><li id="7230" class="kp kq hi kr b ks le ku lf kd lg kh lh kl li kz la lb lc ld bi translated">节点的<strong class="kr hs">深度</strong>是它到根节点的距离。(又名<strong class="kr hs">级</strong>)。</li></ul><p id="0c3c" class="pw-post-body-paragraph mb mc hi kr b ks mo is md ku mp iv me kd mq mg mh kh mr mj mk kl ms mm mn kz hb bi translated">树的类型有很多种——<strong class="kr hs">二叉树</strong>、<strong class="kr hs"> n叉树</strong>、<strong class="kr hs">堆</strong>、<strong class="kr hs">树</strong>等。</p><p id="3c38" class="pw-post-body-paragraph mb mc hi kr b ks mo is md ku mp iv me kd mq mg mh kh mr mj mk kl ms mm mn kz hb bi translated"><strong class="kr hs">二叉树:</strong>节点最多可以有两个子节点的树。</p><p id="a24a" class="pw-post-body-paragraph mb mc hi kr b ks mo is md ku mp iv me kd mq mg mh kh mr mj mk kl ms mm mn kz hb bi translated">N叉树:节点最多可以有N个子节点的树。</p><p id="ceb1" class="pw-post-body-paragraph mb mc hi kr b ks mo is md ku mp iv me kd mq mg mh kh mr mj mk kl ms mm mn kz hb bi translated"><strong class="kr hs">平衡二叉树:</strong>二叉树在技术上可以是不平衡的，这样节点都以线性方式连续有一个子节点。平衡二叉树是这样一种二叉树，其中所有节点都有高度相差不超过1的左右子树。</p><p id="60d0" class="pw-post-body-paragraph mb mc hi kr b ks mo is md ku mp iv me kd mq mg mh kh mr mj mk kl ms mm mn kz hb bi translated">遍历一棵树(访问所有节点)需要O(n)时间，其中n是节点数。</p><h2 id="82ab" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ho bi translated">遍历树有三种主要方式:</h2><ul class=""><li id="671c" class="kp kq hi kr b ks kt ku kv kd kw kh kx kl ky kz la lb lc ld bi translated"><strong class="kr hs">预排序:</strong>先访问根节点，再访问左节点，再访问右节点</li><li id="ad5a" class="kp kq hi kr b ks le ku lf kd lg kh lh kl li kz la lb lc ld bi translated"><strong class="kr hs">按顺序:</strong>先访问左节点，再访问根节点，再访问右节点</li><li id="9a0e" class="kp kq hi kr b ks le ku lf kd lg kh lh kl li kz la lb lc ld bi translated"><strong class="kr hs">后置顺序:</strong>先访问左节点，再访问右节点，最后访问根节点</li></ul><p id="bc5b" class="pw-post-body-paragraph mb mc hi kr b ks mo is md ku mp iv me kd mq mg mh kh mr mj mk kl ms mm mn kz hb bi translated"><strong class="kr hs">二叉查找树(BST): </strong>二叉查找树是一种特殊类型的二叉树，它对树的结构有特定的规则。对于所有节点，其左子节点必须小于父节点，右子节点必须大于父节点。</p><p id="8881" class="pw-post-body-paragraph mb mc hi kr b ks mo is md ku mp iv me kd mq mg mh kh mr mj mk kl ms mm mn kz hb bi translated">在二叉查找树中搜索一个节点平均需要O(logn)时间，其中n是节点的数量。如果二叉查找树不平衡，最坏情况下的搜索时间可以是O(n)。</p><p id="7601" class="pw-post-body-paragraph mb mc hi kr b ks mo is md ku mp iv me kd mq mg mh kh mr mj mk kl ms mm mn kz hb bi translated"><strong class="kr hs">完全二叉树:</strong>完全二叉树的节点完全填充到最后一级，对于最后一级，节点从左到右填充。</p><p id="d6a0" class="pw-post-body-paragraph mb mc hi kr b ks mo is md ku mp iv me kd mq mg mh kh mr mj mk kl ms mm mn kz hb bi translated"><strong class="kr hs">完全(严格)二叉树:</strong>节点有0或2个子节点的二叉树。它不能有1个子代。</p><p id="c791" class="pw-post-body-paragraph mb mc hi kr b ks mo is md ku mp iv me kd mq mg mh kh mr mj mk kl ms mm mn kz hb bi translated"><strong class="kr hs">完美二叉树:</strong>既完全&amp;满又完全充满最大节点数的树。</p></div><div class="ab cl lj lk gp ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="hb hc hd he hf"><h2 id="81bb" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ho bi translated">参考:</h2><p id="9732" class="pw-post-body-paragraph mb mc hi kr b ks kt is md ku kv iv me kd mf mg mh kh mi mj mk kl ml mm mn kz hb bi translated">算法专家(algoexpert.io)</p><p id="3586" class="pw-post-body-paragraph mb mc hi kr b ks mo is md ku mp iv me kd mq mg mh kh mr mj mk kl ms mm mn kz hb bi translated">Abdul Bari教授的讲座(在YouTube和Udemy上)</p></div></div>    
</body>
</html>