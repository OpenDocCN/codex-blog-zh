<html>
<head>
<title>Developing a video game in Haskell</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Haskell开发视频游戏</h1>
<blockquote>原文：<a href="https://medium.com/codex/developing-a-video-game-in-haskell-e8259050e4dc?source=collection_archive---------10-----------------------#2022-05-28">https://medium.com/codex/developing-a-video-game-in-haskell-e8259050e4dc?source=collection_archive---------10-----------------------#2022-05-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="f721" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我能在某个地方的网络服务器上运行它就好了…</p><p id="1008" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对我的孩子来说，我创造的游戏没有广告，没有游戏中的购买，也没有情感操纵的上瘾。我创造了棋盘游戏、纸牌游戏和视频游戏。所以，当我的小儿子要求我根据他们的想法制作一个电子游戏时，我怎么能拒绝呢？</p><p id="cc7b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">已有35年历史的haskell编程语言是函数式编程的一种有趣的形式，主要用于学术界，尽管最初的项目也希望应用于商业产品。它是一种通用编程语言，这意味着我们可以用它来制作视频游戏。</p><p id="a990" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">完美？</p><p id="acd2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">也许不是。</p><p id="7e84" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Haskell没有事实上的图像和GUI库。它允许我们使用其他人编写的现有库，比如用于Unix和Linux终端的<a class="ae jd" href="https://en.wikipedia.org/wiki/Curses_%28programming_library%29" rel="noopener ugc nofollow" target="_blank"> curses </a>，以及用于窗口操作系统的<a class="ae jd" href="https://www.qt.io/" rel="noopener ugc nofollow" target="_blank"> Qt </a>。它可以驱动<a class="ae jd" href="https://www.stackage.org/package/warp" rel="noopener ugc nofollow" target="_blank">网站和web服务器</a>，这意味着我们可以在HTML、CSS、Javascript、SVG和Canvas中构建前端。</p><p id="6ef8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">直到今天，我的目标是在某个网站或web应用程序中实现视频游戏，运行在某个web服务器上。事情是这样的:我寻找一个可以让我们运行haskell web应用程序的商业web主机，结果一无所获。所以我不得不在某个地方租一些原材料，并在上面部署游戏和网络服务器。意味着我要负责维护服务器。</p><p id="f26e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">不了，谢谢你。</p><p id="2bf5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">haskell编程语言足够简单，可以快速学习基础知识。实现一个<a class="ae jd" href="https://en.wikipedia.org/wiki/Video_game_programming#Game_structure" rel="noopener ugc nofollow" target="_blank">游戏循环</a>也不是太难:</p><pre class="je jf jg jh fd ji jj jk bn jl jm bi"><span id="a9e7" class="jn jo hi jj b be jp jq l jr js">{- | This is the game loop. It keeps looping stages until the <br/> - player quits. It assumes that the stage will give the player <br/> - options for keys to press to have actions performed. It then <br/> - asks the player for their input, uses that to figure out <br/> - which stage to show next, and recurses in on itself. <br/> -}<br/>loop :: Stages.Stage -&gt; Stages.UserName -&gt; IO ()<br/>loop Stages.Quit player = TW.wrap $ Stages.show Stages.Quit player<br/>loop stage player = do <br/> let t = Stages.show stage player<br/> TW.wrap t<br/> getChar &gt;&gt;= \k -&gt; loop (Stages.next stage (Keys.read k)) player</span></pre><p id="9b73" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">参考:<a class="ae jd" href="https://git.sr.ht/~aev/maskies/tree/main/item/src/main/haskell/Main.hs" rel="noopener ugc nofollow" target="_blank">https://git . Sr . ht/~ AEV/maskies/tree/main/item/src/main/haskell/main . hs</a></p><p id="5480" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这就产生了游戏循环，一个我命名为“循环”的功能。它有两个参数:一个阶段和一个用户名，并返回一个I/O操作。</p><p id="5740" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">舞台是玩家将看到的下一个场景。特殊阶段是开始和退出。总得从某个地方开始！</p><p id="288d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">用户名在程序开始时就被要求输入，并在游戏循环中从一个阶段进入下一个阶段。这些阶段是动态构建的，包含了用户的名字。</p><p id="72b8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该函数有两个实现。第一种是特例:退出。如果玩家表示想要退出游戏，它需要显示再见，并停止循环。第二种是正常情况:显示舞台，然后接收玩家的输入，然后找出下一个要显示哪个舞台，调用游戏循环来显示。</p><p id="1a9f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">游戏循环调用自己。<a class="ae jd" href="http://learnyouahaskell.com/recursion" rel="noopener ugc nofollow" target="_blank">递归</a>是haskell中一个直接的构造。我认为这是haskell最强大的特性。<a class="ae jd" href="https://www.haskell.org/ghc/" rel="noopener ugc nofollow" target="_blank"> Glasgow haskell编译器(ghc) </a>非常擅长优化递归函数。</p><p id="006d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可能已经注意到Stages.show函数的结果是在一个名为t的变量中捕获的，该变量随后被传递给函数TW.wrap，然后游戏等待玩家按键。这里没有任何关于GUI的提示。这是一个基于文本的游戏，可以在控制台或终端上玩。这个选择是经过深思熟虑的:我想在创建任何图形之前，充实游戏的故事，并测试游戏的玩法。</p><p id="23df" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">说到图形:</p><figure class="je jf jg jh fd ju er es paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="er es jt"><img src="../Images/b8fe50406edcc4ea4e652fcb0f7c7655.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EHAMkLQbyBTDGzPReox7ig.png"/></div></div><figcaption class="kb kc et er es kd ke bd b be z dx translated">冰激凌店的后门。宝藏工作室原创艺术</figcaption></figure><p id="c90e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">图片参考及鸣谢:【https://www.patreon.com/posts/66989254 T4】</p><p id="2af9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">事实上，我们已经决定了美术和声音设计，并且已经开始实现本文前面提到的web服务器，来托管游戏的图形版本。</p><p id="d043" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是我们不要想太多。回到文字版。</p><p id="7a2d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们发现函数Stages.show返回一个传递给TW.wrap函数的值。该值是一个文本。Stages.show获取一个阶段的名称，并返回其文本，如果需要的话，还会添加玩家的名称。wrap将该文本输出到屏幕，在终端宽度内换行。您会看到:haskell没有一种本机内置的方法来换行。这取决于解释器或UI客户机来完成。</p><p id="b86e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这就是我们在haskell的墙壁上看到的第一个裂缝:为了包装文本行，包装函数必须能够访问所有可能的文本。这意味着游戏中的每一条文本路径都必须提前渲染。这意味着我们失去了haskell编程语言的一个强大特性:懒惰。</p><p id="1f62" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">懒惰意味着程序会尽可能长时间地避免执行动作，只在绝对必要时才执行。这是一个很好的优化策略，可以实现闪电般的快速实时执行。但这也意味着文本不能换行。</p><p id="d250" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了包装文本，进行包装的库需要非惰性文本。但是haskell中的普通文本是懒惰的。因此，我们显式地将惰性文本转换为非惰性或严格的文本。</p><p id="e9d2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于每个阶段。</p><p id="23fc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在飞行中。</p><p id="1892" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">拜拜，优化。</p><p id="5195" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们不对文本进行换行，终端将会在任何需要的地方，在最奇怪的地方，对单词进行拆分，而不管语法和语义。因此，对于基于文本的游戏，换行是必要的。</p><p id="870e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于阶段本身，我们利用haskell的数据类型系统。这样，如果我们忘记编写一个程序，编译器就会抱怨。当前的实现有265个阶段:接近完成。我们预计需要大约300个阶段。</p><p id="7291" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了让玩家从一个阶段进入下一个阶段，我们可以选择几种架构。我们选择了一个无国籍的。我们只需要知道玩家最后处于哪个阶段，按了哪个键，就可以确定下一个阶段。根据玩家的选择，游戏将在各个阶段呈现不同的路线。有点像你自己选择的冒险，混合了一个不错的旧地下城游戏。</p><pre class="je jf jg jh fd ji jj jk bn jl jm bi"><span id="7593" class="jn jo hi jj b be jp jq l jr js">{- | This function wires Key events to stages, <br/> -   to determine which stage to show next. <br/> -   If the event is Wait, the same stage gets <br/> -   returned as put in. If the event is Q, <br/> -   the function returns the Quit event. If <br/> -   the player enters a key that is not wired<br/> -   up to a stage here, the function throws <br/> -   an error. <br/> -}<br/>next :: Stage -&gt; K.Key -&gt; Stage<br/>next theStage K.Wait = theStage<br/>next _ K.Q = Quit<br/>next Init _ = A1DarkHallway<br/>next A1DarkHallway K.H = A1Help<br/>next A1Help K.J2 = B1DarkHallway<br/>next A1Help K.J3 = C1aw<br/>next A1Help K.J4 = D1Intro<br/>next A1Help _ = A1LightAppears<br/>...</span></pre><p id="5be0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里我们看到了函数“next”的前几行。它根据当前阶段和玩家按下的键来确定下一阶段。每一行都是一个特例，一个函数的特殊实现。这是haskell声明结果变化的方式，不需要求助于if-then-else结构，或者case和switch结构。当前版本知道532个实现。我们希望它完成后能知道大约700个。</p><p id="7c6f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有了这么多的变化，自动游戏路线测试变得很有必要。为了这个目的，我们让游戏可以接受玩家的按键作为标准输入。我们在称为连线的文件中收集已知路线，将它们运行到游戏中，捕获其输出，并将其转发到测试程序中。</p><pre class="je jf jg jh fd ji jj jk bn jl jm bi"><span id="ab58" class="jn jo hi jj b be jp jq l jr js">cat "$wirefile" | ./Maskies | tail -7 | ./WireTest "$wire"</span></pre><p id="03fd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">参考:<a class="ae jd" href="https://git.sr.ht/~aev/maskies/tree/main/item/src/test/bash/test.sh" rel="noopener ugc nofollow" target="_blank">https://git . Sr . ht/~ AEV/maskies/tree/main/item/src/test/bash/test . sh</a></p><p id="a839" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们在每次编译后都运行测试，以确保所有的路由都能继续产生预期的结果。</p><p id="4f33" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当然，这给了人们作弊的机会……<a class="ae jd" href="https://en.wikipedia.org/wiki/Konami_Code" rel="noopener ugc nofollow" target="_blank">作弊代码</a>是一回事。</p><p id="101d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">将游戏编译成可在其他人的电脑上使用的可执行文件被证明有点麻烦。我们在让ghc<a class="ae jd" href="https://www.haskell.org/ghcup/" rel="noopener ugc nofollow" target="_blank">在我们自己的各种设备上安装</a>时遇到了足够多的困难，以避免将这种折磨强加给玩家。因此，我们必须提供一个大部分(如果不是全部的话)预编译的可执行文件。(顺便说一句，这是将整个事情作为web应用程序运行的一个令人信服的理由。)</p><p id="eedb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">将程序编译成可执行文件似乎足够简单。在终端中，我们命令:</p><pre class="je jf jg jh fd ji jj jk bn jl jm bi"><span id="6f15" class="jn jo hi jj b be jp jq l jr js">ghc -v --make -O2 -o ../bin/Maskies ./Main.hs</span></pre><p id="badf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是这失败了，因为ghc不够聪明，无法解析我们程序所依赖的库包。我们必须明确:</p><pre class="je jf jg jh fd ji jj jk bn jl jm bi"><span id="988b" class="jn jo hi jj b be jp jq l jr js">ghc -v --make -package random -package word-wrap -package terminal-size -O2 -o ../bin/Maskies ./Main.hs</span></pre><p id="b339" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是这也可能失败，因为它不允许指定包的版本，并且程序需要的版本可能不是操作系统上可用的版本…</p><p id="6e36" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这就是<a class="ae jd" href="https://www.haskell.org/cabal/" rel="noopener ugc nofollow" target="_blank"> cabal </a>和<a class="ae jd" href="https://docs.haskellstack.org/" rel="noopener ugc nofollow" target="_blank"> stack </a>介入的地方:haskell的竞争性依赖和构建管理器。</p><p id="5274" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">亲爱的haskell创建者们，为什么向一个程序添加库会如此困难，以至于需要创建两个相互竞争的依赖管理器？</p><p id="92f1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">墙上有更多的裂缝。</p><p id="9fa1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是等等，还有呢！</p><p id="5af3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">还记得我说过，这个游戏最好是一个运行在网络服务器上的网络应用吗？事实证明haskell也非常适合运行web服务器:</p><div class="kf kg ez fb kh ki"><a href="https://sr.ht/~aev/example-haskell-web-app/" rel="noopener  ugc nofollow" target="_blank"><div class="kj ab dw"><div class="kk ab kl cl cj km"><h2 class="bd hj fi z dy kn ea eb ko ed ef hh bi translated">一个用haskell编写的web应用程序的示例实现，基于WARP…</h2><div class="kp l"><h3 class="bd b fi z dy kn ea eb ko ed ef dx translated">基于WARP和WAI，用haskell编写的web应用程序的示例实现。</h3></div><div class="kq l"><p class="bd b fp z dy kn ea eb ko ed ef dx translated">sr.ht</p></div></div></div></a></div><p id="3bc5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">还记得我说过不可能找到运行haskell应用程序的web主机吗？</p><p id="8162" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这就是<a class="ae jd" href="https://www.heroku.com/" rel="noopener ugc nofollow" target="_blank"> Heroku </a>的用武之地。Heroku提供托管服务器(借用自<a class="ae jd" href="https://aws.amazon.com/" rel="noopener ugc nofollow" target="_blank"> AWS </a>，让我们使用<a class="ae jd" href="https://en.wikipedia.org/wiki/CI/CD" rel="noopener ugc nofollow" target="_blank"> CI/CD </a>将任何程序编译到它的服务器上。太好了！所以让我们的haskell web服务器在上面运行。</p><p id="ac69" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">呃。Heroku需要建造背包。它没有为haskell提供构建包。有几个定制的haskell构建包，但是没有一个能构建我的程序…我现在可以学习如何创建Heroku构建包吗？一种选择是将cabal和ghc的全部放入AWS S3桶中，这需要公开以便Heroku找到并执行它……这看起来很奇怪。为什么我不能把我们开发服务器上的所有东西都编译成可执行文件，在Heroku上运行呢？</p><p id="859b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">墙上的裂缝？更像是整栋大楼倒塌了。</p><p id="4859" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我看不到前进的方向。我不会托管自己的服务器，然后负责维护它。这就是网络主机存在的原因。</p><p id="5785" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我将完成这个游戏，在它的文本版本中。然后我会将它转换成python或php，这两种语言都可以在各种商业web主机上很好地运行。</p><p id="fec8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">很有趣，哈斯克尔。再见。谢谢你的鱼。但我需要用一种能让我接触到客户的语言来工作。</p></div></div>    
</body>
</html>