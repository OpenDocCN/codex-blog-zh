<html>
<head>
<title>Parser combinators in Rust</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Rust中的解析器组合子</h1>
<blockquote>原文：<a href="https://medium.com/codex/parser-combinators-in-rust-ed08cc3bc4a?source=collection_archive---------5-----------------------#2021-03-30">https://medium.com/codex/parser-combinators-in-rust-ed08cc3bc4a?source=collection_archive---------5-----------------------#2021-03-30</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/6daa6ce19e8cbcea7975455b462a18dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e2L-T-DfCdDaEBGyapYtoA.jpeg"/></div></figure><p id="8930" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">由在英国布里斯托尔工作的<a class="ae jl" href="https://twitter.com/doma_dev" rel="noopener ugc nofollow" target="_blank"> doma团队</a>于2021年3月30日星期二<em class="jk">发表。</em></p><h1 id="9a7e" class="jm jn hi bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated">TL；速度三角形定位法(dead reckoning)</h1><ul class=""><li id="963f" class="kk kl hi io b ip km it kn ix ko jb kp jf kq jj kr ks kt ku bi translated">不要使用正则表达式进行解析</li><li id="1cc0" class="kk kl hi io b ip kv it kw ix kx jb ky jf kz jj kr ks kt ku bi translated">解析器组合子是用高阶函数构造可组合计算的一种方式</li><li id="d7ea" class="kk kl hi io b ip kv it kw ix kx jb ky jf kz jj kr ks kt ku bi translated">解析器组合子很容易用来快速获得结果</li><li id="83e7" class="kk kl hi io b ip kv it kw ix kx jb ky jf kz jj kr ks kt ku bi translated">对于99%的实际应用来说，它们已经足够了，只有当你的库的唯一目的是解析时，它们才不够用</li></ul><h1 id="6ce5" class="jm jn hi bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated">解析在计算中的作用</h1><p id="35c4" class="pw-post-body-paragraph im in hi io b ip km ir is it kn iv iw ix la iz ja jb lb jd je jf lc jh ji jj hb bi translated">数据处理是计算的支柱。要运行一个算法，首先必须在内存中建立一些数据结构。填充数据结构的方法是获取一些原始数据并将其加载到内存中。数据科学家处理原始数据，对其进行清理，并创建格式良好的数据集。编程语言设计者将源代码文件标记化，然后将它们解析成抽象语法树。Web-scraper作者导航抓取的HTML并提取感兴趣的值。</p><p id="57b1" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">非正式地说，这些步骤中的每一步都可以称为“解析”。这篇文章讲述了如何在愤怒中完成<em class="jk">完整、可组合和正确的解析</em>。这是什么意思呢？</p><ul class=""><li id="a8e6" class="kk kl hi io b ip iq it iu ix ld jb le jf lf jj kr ks kt ku bi translated"><em class="jk">愤怒解析</em>务实地考虑数据转换的问题。不需要理论上的最佳解决方案。相反，目标是尽可能快地编写一个正确的解析器。</li><li id="0c07" class="kk kl hi io b ip kv it kw ix kx jb ky jf kz jj kr ks kt ku bi translated"><em class="jk">可组合解析</em>意味着结果解析器可能由“更小”的组件组成。它本身可以在以后作为“更大的”解析器的一个组件使用。</li><li id="008e" class="kk kl hi io b ip kv it kw ix kx jb ky jf kz jj kr ks kt ku bi translated"><em class="jk">完全解析</em>意味着输入将被完全使用。如果输入可能有任何偏差或错误，其作者应该在结果解析器中对它们进行编码。</li></ul><p id="4c3e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">那么我们如何实现呢？先说如何<em class="jk">不</em>做到。</p><h1 id="5cbb" class="jm jn hi bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated">忘记正则表达式</h1><p id="f109" class="pw-post-body-paragraph im in hi io b ip km ir is it kn iv iw ix la iz ja jb lb jd je jf lc jh ji jj hb bi translated">由于现在已经消亡的Perl编程语言的流行，整整一代计算机程序员都在徒劳地试图用正则表达式解析非正则语言。正则表达式只不过是有限状态自动机的编码。</p><figure class="lh li lj lk fd ij er es paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="er es lg"><img src="../Images/20fd3762b70344793ef71b6b98984fd1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*LDgLqnDjVXWGoSun.jpg"/></div></div></figure><p id="3ccf" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><em class="jk">箭头上的项目是{0，1}字母表的字符。圆圈是状态，q1是“接受状态”。箭头表示状态转换。</em></p><p id="da38" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">非确定性有限状态自动机可以相当优雅地接受许多非平凡的语言。经典的例子是，不存在接受“ab”、“aabb”、“aaabbb”等形式的字符串的正则表达式，换句话说，不能用正则表达式解决匹配括号的问题。为此需要最简单的堆垛机。</p><figure class="lh li lj lk fd ij er es paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="er es lg"><img src="../Images/3d3f8e8431ec993a35e11a7678e1901a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*d5wVjYugHLrkJiwq.jpg"/></div></div></figure><p id="57b5" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><em class="jk">栈自动机可以同时处于几种状态。一个没有转换的状态在任何输入下都会“嘶嘶”作响。</em> <code class="du lp lq lr ls b"><em class="jk">(@\*</em></code> <em class="jk">匹配任意堆栈状态的字符'</em> <code class="du lp lq lr ls b"><em class="jk">(</em></code> <em class="jk">'。</em> <code class="du lp lq lr ls b"><em class="jk">ε@ε</em></code> <em class="jk">当自动机到达状态p时立即匹配，但仅当堆栈为空时。</em> <a class="ae jl" href="https://blackwells.co.uk/bookshop/product/Introduction-to-Automata-Theory-Languages-and-Computation-by-John-E-Hopcroft-author-Rajeev-Motwani-author-Jeffrey-D-Ullman-author/9781292039053" rel="noopener ugc nofollow" target="_blank"> <em class="jk">对形式语言感兴趣的人最好的入门书</em> </a> <em class="jk">。</em></p><p id="1b9d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">因此，正则表达式远没有提供足够的工具来处理上下文无关的语法。但是它们可能足够强大来清理数据或提取一些值，所以我们为什么说你永远不应该使用它们呢？实用性原因！</p><p id="805b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">让我们从一些Regex Cookbook帖子中举个例子(<a class="ae jl" rel="noopener" href="/factory-mind/regex-cookbook-most-wanted-regex-aa721558c3c1">中等收入链接</a>)。通过这种方式，我们知道这是行业中使用的实际方法。下面是作者提供的一个正则表达式:</p><pre class="lh li lj lk fd lt ls lu lv aw lw bi"><span id="2b38" class="lx jn hi ls b fi ly lz l ma mb">^(((h..ps?|f.p):\/\/)?(?:([\w\-\.])+(\[?\.\]?)([\w]){2,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\[?\.\]?){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)))*([\w\/+=%&amp;_\.~?\-]*)$</span></pre><p id="ee54" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">许多人可以肤浅地理解这里发生了什么。这个正则表达式似乎与链接有关，但是即使我们求助于<a class="ae jl" href="https://regex101.com/r/6qUtv2/1/" rel="noopener ugc nofollow" target="_blank">自动解释</a>，事情也不会变得更清楚。嗯，根据作者的说法，这个正则表达式应该能够检测“不合法”的URL。现在让我们看看它和任何其他足够大的正则表达式失败的所有方式。</p><ol class=""><li id="9cd3" class="kk kl hi io b ip iq it iu ix ld jb le jf lf jj mc ks kt ku bi translated">它是错误的:它不匹配<code class="du lp lq lr ls b">https://​ctflearn​.​com​/​</code>(注意零宽度空格)。</li><li id="e859" class="kk kl hi io b ip kv it kw ix kx jb ky jf kz jj mc ks kt ku bi translated">它需要外部标记，所以没有即插即用:它不匹配<code class="du lp lq lr ls b">␣https://ctflearn.com/</code>(注意前导空格)。</li><li id="9e7c" class="kk kl hi io b ip kv it kw ix kx jb ky jf kz jj mc ks kt ku bi translated">外部标记化是这个表达式特有的:它不匹配<code class="du lp lq lr ls b">https://ctflearn.com,</code>(注意尾部逗号)。</li><li id="4f13" class="kk kl hi io b ip kv it kw ix kx jb ky jf kz jj mc ks kt ku bi translated">修复它是不可能的:在每个可打印字符周围匹配可选字符会把它从一段大的可读性差的代码变成一段巨大的完全不可读的代码。你的大脑甚至无法猜出<code class="du lp lq lr ls b">h..ps</code>和<code class="du lp lq lr ls b">f.p</code>位。</li><li id="0f6a" class="kk kl hi io b ip kv it kw ix kx jb ky jf kz jj mc ks kt ku bi translated">它不能用于提取值。正则表达式不“将数据解析成数据结构”。相反，他们接受或拒绝附加条件。因此，需要额外的后处理来利用它们的输出。</li></ol><p id="eb61" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">正则表达式有内在的问题。对我们来说，这意味着只应该使用简短的表达式。作者专门将它们与<code class="du lp lq lr ls b">grep</code>、<code class="du lp lq lr ls b">find</code>和<code class="du lp lq lr ls b">vim</code>一起使用。</p><p id="bfae" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如今，很高兴地，一种更好的解析方法成为主流，在所有流行的语言中都有可用的库。从标题就能猜到，它叫做“解析器组合子”。</p><h1 id="d43e" class="jm jn hi bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated">可组合解析分步指南</h1><p id="2042" class="pw-post-body-paragraph im in hi io b ip km ir is it kn iv iw ix la iz ja jb lb jd je jf lc jh ji jj hb bi translated">本着之前博客的精神，让我们解决一些实际问题。考虑到你必须编写一个交互式的TODO应用程序，这是实用性的顶峰。它指定了以下命令:</p><ul class=""><li id="d53e" class="kk kl hi io b ip iq it iu ix ld jb le jf lf jj kr ks kt ku bi translated"><code class="du lp lq lr ls b">add ${some word}* ${some #hashtag}*</code>(追加项目ID)</li><li id="36a4" class="kk kl hi io b ip kv it kw ix kx jb ky jf kz jj kr ks kt ku bi translated"><code class="du lp lq lr ls b">done ${some item ID}</code>(将项目ID处的条目标记为已解决)</li><li id="4121" class="kk kl hi io b ip kv it kw ix kx jb ky jf kz jj kr ks kt ku bi translated"><code class="du lp lq lr ls b">search ${some word or some #hashtag}+</code>(跨条目搜索，返回匹配项目id列表)</li></ul><p id="136c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">让我们首先定义我们将如何表示解析的数据，省略那些无聊的部分:</p><pre class="lh li lj lk fd lt ls lu lv aw lw bi"><span id="ce17" class="lx jn hi ls b fi ly lz l ma mb">pub <em class="jk">enum </em>Entry {<br/>    Done (Index),<br/>    Add (Description, <em class="jk">Vec</em>&lt;Tag&gt;),<br/>    Search (SearchParams),<br/>}</span></pre><p id="758d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在让我们使用<code class="du lp lq lr ls b">nom</code>库来享受表达性和声明性解析。它有或曾经有宏API和函数API。因为在版本5中，库的宏API很容易出错，我们将使用函数API，我们已经在版本6中测试过了。</p><p id="6a75" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们将逐行解析这些命令。从<em class="jk">声明</em>一行的顶级解析开始，并认识您的第一个解析器组合符:<code class="du lp lq lr ls b">alt</code>。</p><pre class="lh li lj lk fd lt ls lu lv aw lw bi"><span id="82c9" class="lx jn hi ls b fi ly lz l ma mb">pub <em class="jk">fn </em>command(<em class="jk">input</em>: &amp;<em class="jk">str</em>) <br/>-&gt; IResult&lt;&amp;<em class="jk">str</em>, Entry&gt; { /* A */<br/>    alt((done, add, search))(input) /* B */<br/>}</span></pre><p id="526a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在<code class="du lp lq lr ls b">(A)</code>中声明我们的函数<code class="du lp lq lr ls b">command</code>是一个解析器。捕获解析的类型(在我们的例子中是<code class="du lp lq lr ls b">str&amp;</code>)和输出数据结构(在我们的例子中是<code class="du lp lq lr ls b">Entry</code>)。</p><p id="a007" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在<code class="du lp lq lr ls b">(B)</code>中，我们用<code class="du lp lq lr ls b"><a class="ae jl" href="https://docs.rs/nom/6.1.2/nom/branch/fn.alt.html" rel="noopener ugc nofollow" target="_blank">nom::branch::alt</a></code>组合器组合了三个解析器:<code class="du lp lq lr ls b">add</code>、<code class="du lp lq lr ls b">done</code>和<code class="du lp lq lr ls b">search</code>。它试图从最左边开始应用这些解析器，直到一个成功。</p><p id="783e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在，让我们看看三个解析器中最简单的一个:</p><pre class="lh li lj lk fd lt ls lu lv aw lw bi"><span id="7350" class="lx jn hi ls b fi ly lz l ma mb"><em class="jk">fn </em>done(<em class="jk">input</em>: &amp;<em class="jk">str</em>) -&gt; IResult&lt;&amp;<em class="jk">str</em>, Entry&gt; {<br/>    <em class="jk">let </em>(rest, value) = preceded( /* A */<br/>        pair(tag("done"), ws), /* B */<br/>        many1(digit1) /* C */<br/>    )(input)?; <br/>    <em class="jk">Ok</em>((<br/>      rest,<br/>      Entry::Done( /* D */<br/>        Index::new( vec_to_u64(value) )<br/>      ) <br/>    ))<br/>}</span></pre><p id="210d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们直接看到的第一个组合子是<code class="du lp lq lr ls b">preceded</code>。它忘记解析<code class="du lp lq lr ls b">(B)</code>，只保留<code class="du lp lq lr ls b">(C)</code>的输出。<code class="du lp lq lr ls b">(B)</code>不过还是会消耗输入！一般来说，它<em class="jk">将</em>两个计算组合成一个组合，运行两个计算，返回第二个计算返回的内容。这不同于仅仅按顺序运行它们，因为这里我们<em class="jk">建立了一个计算</em>，但是我们将在以后运行它！</p><p id="7b27" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">有趣的是，如果我们正在编写Haskell，我们不会在我们的<a class="ae jl" href="https://markkarpov.com/tutorial/megaparsec.html" rel="noopener ugc nofollow" target="_blank">解析器库</a>中找到“preceded”组合子。原因是我们在上一段中描述的叫做“右适用箭头”，或者，正如在本·克利福德的<a class="ae jl" href="https://www.youtube.com/watch?v=r_Enynu_TV0" rel="noopener ugc nofollow" target="_blank">精彩演讲</a>中所创造的“右<em class="jk">麻雀</em>”:</p><pre class="lh li lj lk fd lt ls lu lv aw lw bi"><span id="b275" class="lx jn hi ls b fi ly lz l ma mb">λ&gt; :t (*&gt;)<br/>(*&gt;) :: Applicative f =&gt; f a -&gt; f b -&gt; f b</span></pre><p id="4360" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">另外两个组合子非常简单明了。<code class="du lp lq lr ls b">pair</code>将解析器组合成一个序列，其中<code class="du lp lq lr ls b">ws</code>解析器是一个消耗单个空白的解析器。这里有一个关于<code class="du lp lq lr ls b">ws</code>的幼稚定义:<code class="du lp lq lr ls b">one_of(" \t")</code>。<code class="du lp lq lr ls b">many1</code>至少重复一次<code class="du lp lq lr ls b">digit1</code>解析才能成功。<code class="du lp lq lr ls b">digit1</code>是在<code class="du lp lq lr ls b">nom</code>本身实现的。</p><p id="e98c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在让我们巩固对如何确保我们的解析器可以被其他人使用的理解。</p><p id="0744" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们已经讨论过，要实现这一点，我们需要返回<code class="du lp lq lr ls b">IResult</code>。现在要记住它仍然是一个“结果”类型，所以它的构造函数仍然是<code class="du lp lq lr ls b">Err</code>和<code class="du lp lq lr ls b">Ok</code>:</p><ul class=""><li id="f2f5" class="kk kl hi io b ip iq it iu ix ld jb le jf lf jj kr ks kt ku bi translated"><code class="du lp lq lr ls b">Err</code>结果的变体是通过<code class="du lp lq lr ls b">?</code>修饰符构建的，该修饰符传递解析<code class="du lp lq lr ls b">(A)</code>中出现的任何潜在错误。</li><li id="57aa" class="kk kl hi io b ip kv it kw ix kx jb ky jf kz jj kr ks kt ku bi translated"><code class="du lp lq lr ls b">Ok</code>在<code class="du lp lq lr ls b">(D)</code>中，通过将<code class="du lp lq lr ls b">many1</code>输出(一个数字向量)转换为无符号64位整数来构建结果的变体。是用<code class="du lp lq lr ls b">vec_to_u64</code>函数完成的，为简洁起见省略。</li></ul><p id="533f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><code class="du lp lq lr ls b">IResult&lt;in, out&gt;</code>的<code class="du lp lq lr ls b">Ok</code>值的形状为<code class="du lp lq lr ls b">Ok((rest: in, value: out))</code>。这里的<code class="du lp lq lr ls b">rest</code>是剩余的要解析的输入，<code class="du lp lq lr ls b">value</code>是解析器的输出结果。您可以看到<code class="du lp lq lr ls b">(A)</code>中的<code class="du lp lq lr ls b">preceded</code>解析遵循了完全相同的模式。</p><p id="bb6c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这里有一些更高级的解析器，可以巩固你对如何使用anger解析器组合子的直觉:</p><pre class="lh li lj lk fd lt ls lu lv aw lw bi"><span id="56ec" class="lx jn hi ls b fi ly lz l ma mb"><em class="jk">fn </em>add(<em class="jk">input</em>: &amp;<em class="jk">str</em>) -&gt; IResult&lt;&amp;<em class="jk">str</em>, Entry&gt; {    <br/>  <em class="jk">let </em>(rest, (d, ts)) = preceded( /* B */<br/>    pair(tag("add"), ws),                     <br/>    pair(description, preceded(space0, tags)) /* A */<br/>  )(input)?;<br/>  <em class="jk">Ok</em>( (<br/>    rest,<br/>    Entry::Add( Description::new(&amp;d), ts )<br/>  ) )<br/>}<br/><br/><em class="jk">fn </em>search(<em class="jk">input</em>: &amp;<em class="jk">str</em>) -&gt; IResult&lt;&amp;<em class="jk">str</em>, Entry&gt; {<br/>  <em class="jk">let </em>(rest, mash) = preceded(<br/>    pair(tag("search"), ws),<br/>    separated_list(<br/>      tag(" "),<br/>      alt((tag_contents, search_word)) /* C */<br/>    )<br/>  )(input)?;<br/>  <em class="jk">Ok</em>((rest, mash_to_entry(mash)))<br/>}<br/><br/><em class="jk">fn </em>mash_to_entry(<em class="jk">mash</em>: <em class="jk">Vec</em>&lt;SearchWordOrTag&gt;) -&gt; Entry /* D */<br/>{ /* ... */ }</span></pre><p id="9adf" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">使用组合子进行解析是非常自我描述的，很难找到需要澄清的东西，但是这里有几个亮点:</p><ul class=""><li id="7e5e" class="kk kl hi io b ip iq it iu ix ld jb le jf lf jj kr ks kt ku bi translated">重复<code class="du lp lq lr ls b">preceded</code>来关注你需要解析出来的数据，参见<code class="du lp lq lr ls b">(A)</code>和<code class="du lp lq lr ls b">(B)</code>中的绑定。</li><li id="aa76" class="kk kl hi io b ip kv it kw ix kx jb ky jf kz jj kr ks kt ku bi translated">有时，您必须解析不同种类的列表。根据我们的经验，最好的方法是创建一个单独的数据类型来封装这种异构性(在我们的例子中是<code class="du lp lq lr ls b">SearchWordOrTag</code>，然后在选项的<code class="du lp lq lr ls b">alt</code>上使用<code class="du lp lq lr ls b">separated_list</code>解析器，就像在<code class="du lp lq lr ls b">(C)</code>中一样。最后，当你有一个匹配向量时，你可以根据需要通过使用一个转换函数把它折叠成一个更整洁的数据结构(见<code class="du lp lq lr ls b">(D)</code>)。</li></ul><p id="ea04" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这应该足以指导您开始熟悉这种惊人的基于组合子的解析方法。以下是一些离别的想法:</p><ul class=""><li id="15f3" class="kk kl hi io b ip iq it iu ix ld jb le jf lf jj kr ks kt ku bi translated">密切关注空白，这可能有点棘手，尤其是因为我们不知道nom中的自动标记化选项。</li><li id="2e3f" class="kk kl hi io b ip kv it kw ix kx jb ky jf kz jj kr ks kt ku bi translated">看看<a class="ae jl" href="https://github.com/Geal/nom/blob/master/doc/choosing_a_combinator.md" rel="noopener ugc nofollow" target="_blank">选择一个组合器</a>文档页面，看看你正在使用的nom版本(注意！此表中的条目指向组合子的宏版本，而不是函数版本)。</li><li id="17bb" class="kk kl hi io b ip kv it kw ix kx jb ky jf kz jj kr ks kt ku bi translated">如果你愿意的话，你可以看看<a class="ae jl" href="https://git.sr.ht/%7Ejonn/todo-rs-public/tree/main/item/src/parser.rs" rel="noopener ugc nofollow" target="_blank">真实地写在愤怒中的代码</a>，它启发了这篇博文中的片段。该代码由Chris hop ner和Jonn Mostovoy编写。</li></ul><p id="9787" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果解析不是你的产品或者你的库的主要目的，那么解析器组合子对于你的任务应该有足够的表现力和足够的性能。我们希望你喜欢这篇文章，祝解析愉快！</p><p id="2866" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果您有任何问题，可以直接联系<a class="ae jl" href="https://twitter.com/podmostom" rel="noopener ugc nofollow" target="_blank">乔恩</a>和<a class="ae jl" href="https://twitter.com/polastasule" rel="noopener ugc nofollow" target="_blank">宝丽</a>。在这篇文章的镜子的评论中开始关于<a class="ae jl" href="https://dev.to/doma/" rel="noopener ugc nofollow" target="_blank">发展到</a>和<a class="ae jl" href="https://doma-dev.medium.com/" rel="noopener">中等</a>的对话。</p></div><div class="ab cl md me gp mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="hb hc hd he hf"><p id="b7d7" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><em class="jk">原发布于</em><a class="ae jl" href="https://doma.dev/blog/parsing-stuff-in-rust/" rel="noopener ugc nofollow" target="_blank"><em class="jk">https://DOMA . dev</em></a><em class="jk">。</em></p></div></div>    
</body>
</html>