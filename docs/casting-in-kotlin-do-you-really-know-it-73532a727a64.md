# 在科特林选角——你真的知道吗？

> 原文：<https://medium.com/codex/casting-in-kotlin-do-you-really-know-it-73532a727a64?source=collection_archive---------2----------------------->

![](img/25fbd12916caf8ad82d15aba597b9dcc.png)

由 [Bokskapet](https://pixabay.com/photos/video-production-video-movie-film-4223885/) 拍摄的图像

在造型方面，Kotlin 编译器相当聪明。它减少了重复代码的数量，并有助于预测运行时的强制转换异常。让编译器变得智能的部分原因是智能强制转换，它是在必要时自动插入安全强制转换。此外，编译器会对可能导致运行时异常的代码抛出警告。本文帮助您进行自我测试，检查您是否能够预测 Kotlin 编译器在涉及类型转换的不同情况下会做什么。每个问题下面都有详细的解释。我们开始吧！

**1。简单本地值**

让我们用一个简单的例子来热身，这个函数定义了一个可空的字符串 val，检查它的无效性并尝试对它进行大写。

***问:*** 下面的代码会编译吗？

> **A:** 可以，编译器自动加 a (test as String)。转换，因为它可以保证在第 3 行的空值检查之后，本地声明的 val 不会改变值(因此不会变成 null)。

**2。简单全局变量**

如果我们把变量移出函数，

***问:*** 下面的代码会编译吗？

> **答:**否，因为现在在执行第 4 行之后，第 5 行之前，一些其他函数可以访问测试变量并为其赋值 null。因此，Kotlin 编译器不能保证 test 不为空，代码不会编译。

**3。委托本地值**

这个案子和以前的案子相似。唯一改变的是 val 的初始化被委托给了 lazy 函数。

***问:*** 下面的代码会编译吗？

> **答:**不会，在使用 lazy 函数时，编译器无法确定每次调用变量的 get()函数都会返回相同的值，也就是说即使第 5 行的调用不返回 null，第 6 行的调用也可能。因此，上面的代码无法编译。

如果你好奇的话，我已经在这里贴了一个例子，说明对惰性定义变量的顺序调用产生不同的结果[。](https://gist.github.com/frezafoltran/34b6da95762417f5952efdc20525129b)

**4。简单数据类变量**

现在我们有了一个具有可变属性的数据类 *test* 。

***问:*** 下面的代码会编译吗？

> **答:**不，在 SampleDataClass 的实现内部，可空变量 test 可以将其值更改为 null。这种变化可能发生在第 7 行和第 8 行的执行之间，因此，上面的代码不会编译。

**5。类型擦除**

这种情况涉及类型擦除。简而言之，根据科特林文件:

> Kotlin 在编译时确保涉及[泛型](https://kotlinlang.org/docs/generics.html)的操作的类型安全，而在运行时，泛型类型的实例不保存关于它们实际类型参数的信息。

实际上，在运行时，这意味着`List<Int>`和`List<String>`被擦除到`List<*>`。考虑到这一点，

***问:*** 下面的代码会编译吗？

> **答:**否，因为在运行时`List<String>`被擦除到`List<*>`，第二条 if 语句编译失败。编译器识别出这种检查会在运行时失败，并立即失败。

上面的第一个 if 编译通过。只要 *x* 是任何类型的`*List*`，if 条件实际上将评估为真。

**奖金**

了解类型擦除及其对泛型的影响(如`*List*` *)，*

***问:*** 下面的代码会编译吗？

> **答:**会，会编译。在运行时，`MutableList<Int>`和`MutableList<String>`具有相同的类型，所以没有办法检查测试`*MutableList*` *是否具有 int 或 Strings。为了帮助我们避免不必要的行为，我们确实从编译器那里得到了一个警告，指出有一个未检查的强制转换(在第 3 行)，正是因为类型擦除。*

暂时就这样了。我希望你对科特林的选角工作有了更多的了解。如果你喜欢这些内容，一定要关注我！