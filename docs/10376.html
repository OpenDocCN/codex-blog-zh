<html>
<head>
<title/>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1/>
<blockquote>原文：<a href="https://medium.com/codex/how-to-build-a-peer-to-peer-video-calling-app-with-webrtc-8971a940c789?source=collection_archive---------3-----------------------#2022-12-26">https://medium.com/codex/how-to-build-a-peer-to-peer-video-calling-app-with-webrtc-8971a940c789?source=collection_archive---------3-----------------------#2022-12-26</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><p id="1ac9" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated"><strong class="hj if">如何用WebRTC搭建点对点视频通话App？</strong></p><figure class="ih ii ij ik fd il er es paragraph-image"><div role="button" tabindex="0" class="im in di io bf ip"><div class="er es ig"><img src="../Images/5158477e8042fb692de951123788da44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gFxxcFfq8ObqHqvyfi6bSA.jpeg"/></div></div></figure><p id="5916" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated">如果你不熟悉网络视频会议平台和应用程序，我们相信你在疫情期间用过。从聚会到商务会议，<a class="ae is" href="https://www.mirrorfly.com/blog/best-video-conferencing-app/" rel="noopener ugc nofollow" target="_blank">视频会议平台</a>现在几乎被每个人使用。</p><p id="619b" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated">在本文中，我们将带您了解<a class="ae is" rel="noopener" href="/geekculture/build-your-video-conferencing-app-a-step-by-step-guide-6cfddeb84f51">构建视频会议应用程序</a>的步骤，在这个应用程序中，活动是实时发生的。我们还将了解使用WebRTC创建应用程序所需的各种概念。所以，让我们开始派对吧。</p><h1 id="3ec5" class="it iu hi bd iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq bi translated">什么是WebRTC？</h1><p id="e246" class="pw-post-body-paragraph hg hh hi hj b hk jr hm hn ho js hq hr hs jt hu hv hw ju hy hz ia jv ic id ie hb bi translated">WebRTC代表Web实时通信，它可以在不使用服务器的情况下实现点对点视频通话。它允许连接的对等体交换音频、视频和数据。</p><p id="77c4" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated">WebRTC技术是一个免费的、跨平台的开源项目，它通过简单的API为浏览器和移动应用程序提供了<a class="ae is" href="https://www.mirrorfly.com/blog/real-time-communication/" rel="noopener ugc nofollow" target="_blank">实时通信(RTC) </a>功能。WebRTC的使命是通过用两个新的API扩展HTML5来实现web上实时通信的未来:</p><ul class=""><li id="c3aa" class="jw jx hi hj b hk hl ho hp hs jy hw jz ia ka ie kb kc kd ke bi translated">RTCPeerConnection允许您直接与另一个对等点进行通信(<a class="ae is" href="https://www.mirrorfly.com/webrtc-video-chat.php" rel="noopener ugc nofollow" target="_blank"> WebRTC视频呼叫</a>和流)。</li><li id="9a87" class="jw jx hi hj b hk kf ho kg hs kh hw ki ia kj ie kb kc kd ke bi translated">RTCDataChannel允许您向另一个对等方发送消息(WebRTC音频/视频会议和文件共享)。</li></ul><p id="4be8" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated">WebRTC是一种IETF标准，已被多种浏览器和移动应用程序(例如Chrome、Firefox、Opera、Android和iOS)采用，支持使用实时视频聊天API为现有VoIP服务创建WebRTC兼容插件。</p><p id="9f00" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated">许多通信服务基于21世纪初的过时架构，该架构没有利用网络技术的进步。WebRTC是一个更好的选择，因为它允许用户连接他们选择的任何web应用程序，而无需安装额外的插件或下载软件。</p><p id="e9bf" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated">对于开发人员来说，WebRTC APIs允许他们轻松地将通信特性添加到他们的服务中。这是一个新的开放标准。我们可以期待看到它被用于以前难以进入的行业，如教育、医药和政府。</p><h1 id="caf3" class="it iu hi bd iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq bi translated">WebRTC是如何工作的？</h1><p id="bc4c" class="pw-post-body-paragraph hg hh hi hj b hk jr hm hn ho js hq hr hs jt hu hv hw ju hy hz ia jv ic id ie hb bi translated">WebRTC使用HTML、JavaScript和API将通信技术集成到web浏览器中，旨在简化浏览器之间的音频、视频和数据通信。<a class="ae is" href="https://www.mirrorfly.com/blog/an-ultimate-guide-for-webrtc-video-calling/" rel="noopener ugc nofollow" target="_blank">WebRTC API</a>执行许多功能，例如从设备访问视频、音频和基于文本的数据，通过浏览器启动、监控和终止小工具之间的P2P连接(或<a class="ae is" href="https://www.apphitect.ae/blog/build-a-peer-to-peer-video-chat-app-with-webrtc-and-nodejs/" rel="noopener ugc nofollow" target="_blank">点对点视频聊天</a>),以及支持跨多个数据通道的双向数据传输。</p><p id="37d1" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated">WebRTC使用P2P通信将实时音频、视频和数据从一个设备传输到另一个设备，以连接用户。WebRTC可以与STUN(NAT的会话遍历实用程序)一起使用，其中用户位于具有阻止RTC的NAT防火墙的不同IP网络上。</p><p id="752a" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated">然而，有些网络非常严格，甚至连STUN服务器都不能用来转换IP地址。在这些情况下，WebRTC使用TURN服务器在用户之间中继流量并允许他们连接。</p><h1 id="ace0" class="it iu hi bd iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq bi translated">信令事务流</h1><p id="b37e" class="pw-post-body-paragraph hg hh hi hj b hk jr hm hn ho js hq hr hs jt hu hv hw ju hy hz ia jv ic id ie hb bi translated"><strong class="hj if">信令服务器</strong></p><p id="1eb6" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated">为了在两个设备之间建立WebRTC连接，信令服务器必须确定如何通过互联网连接它们。信令服务器的工作是充当两个对等体之间的中介，允许它们找到并建立连接，同时尽可能少地暴露潜在的私人信息。</p><p id="76d3" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated"><strong class="hj if">让聊天服务器准备好发送信号</strong></p><p id="559c" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated">我们的聊天服务器通过WebSocket API在客户端和服务器之间发送JSON字符串形式的信息。为了处理注册新用户、设置用户名和发送聊天消息等任务(使用<a class="ae is" href="https://blog.contus.com/build-webrtc-video-chat-app-with-javascript/" rel="noopener ugc nofollow" target="_blank"> Javascript视频聊天应用</a>，服务器支持多种消息类型。</p><p id="d558" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated"><strong class="hj if">第一步:</strong>首先需要添加函数sendToOneUser()。它向特定的用户名发送一个字符串化的JSON消息。</p><pre class="ih ii ij ik fd kk kl km bn kn ko bi"><span id="a613" class="kp iu hi kl b be kq kr l ks kt">function sendToOneUser(target, msgString) {<br/>  connectionArray.find((conn) =&gt; conn.username === target).send(msgString);<br/>}</span></pre><p id="4779" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated"><strong class="hj if">步骤2: </strong>接下来，您需要更新主WebSocket消息处理程序。在“连接”消息处理程序的末尾，它有了一个变化:</p><pre class="ih ii ij ik fd kk kl km bn kn ko bi"><span id="1364" class="kp iu hi kl b be kq kr l ks kt">if (sendToClients) {<br/>  const msgString = JSON.stringify(msg);<br/><br/>  if (msg.target &amp;&amp; msg.target.length !== 0) {<br/>    sendToOneUser(msg.target, msgString);<br/>  } else {<br/>    for (const connection of connectionArray) {<br/>      connection.send(msgString);<br/>    }<br/>  }<br/>}</span></pre><p id="ee67" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated"><strong class="hj if">步骤3: </strong>创建信令协议</p><p id="fd6b" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated">既然我们已经创建了交换消息的机制，我们需要一个协议来定义这些消息的格式。</p><p id="7d4f" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated"><strong class="hj if">步骤4: </strong>会话描述的交换</p><p id="70b3" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated">当信令过程开始时，发起呼叫的用户创建要约。它包含SDP格式的会话描述，并且必须传送给接收用户，称为被呼叫者。</p><p id="71ab" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated"><strong class="hj if">第五步:</strong>信令交易流程</p><p id="6d91" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated">它需要通过一个中介，即信令服务器，在两个对等体之间传输消息。以下是处理信令消息的一些关键点:</p><p id="aa48" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated"><strong class="hj if"> <em class="ku">每个用户的客户端在网页浏览器内操作</em> </strong></p><ul class=""><li id="919e" class="jw jx hi hj b hk hl ho hp hs jy hw jz ia ka ie kb kc kd ke bi translated">每个用户的网络浏览器</li><li id="d281" class="jw jx hi hj b hk kf ho kg hs kh hw ki ia kj ie kb kc kd ke bi translated">信令服务器</li><li id="6b16" class="jw jx hi hj b hk kf ho kg hs kh hw ki ia kj ie kb kc kd ke bi translated">托管聊天服务的web服务器</li></ul><h2 id="3e9e" class="kv iu hi bd iv kw kx ky iz kz la lb jd hs lc ld jh hw le lf jl ia lg lh jp li bi translated">ICE候选人交换流程</h2><p id="eed7" class="pw-post-body-paragraph hg hh hi hj b hk jr hm hn ho js hq hr hs jt hu hv hw ju hy hz ia jv ic id ie hb bi translated">ICE是Interactive Connectivity Establishment的缩写，它是一种在网络地址转换(NAT)中使用的技术，用于为VOIP、点对点、即时消息和其他类型的交互式媒体建立通信。通常情况下，ICE候选项会提供数据交换的IP地址和端口号。</p><p id="faa0" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated"><strong class="hj if">STUN:</strong>NAT的会话遍历实用程序使客户端能够发现它们的公共NAT IP地址和端口。STUN客户端可以向STUN服务器发送消息，以获取有关公共IP地址和端口的信息。</p><p id="8469" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated"><strong class="hj if">转:</strong>它是横向的使用中继NAT使客户端能够通过中间服务器发送和接收数据。TURN协议是一个STUN扩展。当端点被限制在不同类型的NAT之后或者当使用对称NAT时，通过中继服务器发送媒体可能更容易。</p><p id="2964" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated"><strong class="hj if">其结构如下:</strong></p><p id="ecaa" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated"><strong class="hj if"><em class="ku">b =候选人:1 1 UDP 2130706431 192 . 168 . 1 . 102 1816 typ主机，</em> </strong></p><p id="bdb8" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated">在这种情况下，UDP指定要使用的协议，typ主机指定要使用的ice候选类型，并且主机指示候选是在防火墙内生成的。</p><p id="2b07" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated">还有一种类型是中继，这表明这种候选可以用于防火墙之外的通信。</p><p id="3ebb" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated"><strong class="hj if"> <em class="ku">下面列出一些步骤:</em> </strong></p><p id="c78c" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated"><strong class="hj if">第一步:分配</strong></p><p id="3279" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated">在WebRTC提议/回答过程中，客户收集ICE的候选人。每个候选都是潜在的媒体接收地址/端口。</p><p id="3c50" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated">第二步:交换</p><p id="4b72" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated">当要约被创建并交付给最终用户时。客户端也可以选择生成和发送他们的候选人。考生可以包含在原offer中，也可以在offer发送后单独发送。后者被称为滴流冰。</p><p id="4a81" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated">刚刚收到聘书及其随行候选人的远端客户现在将开始准备回复。答案以与要约相同的方式生成，并创建答案SDP。远端客户端可以将它们生成的候选打包到SDP中，或者单独发送它们。</p><p id="76df" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated"><strong class="hj if">步骤3:验证过程</strong></p><p id="c08d" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated">在这种情况下，当提供和应答交换发生时，每个客户端都有一个ICE代理来处理连接管理。在发送和接收所有候选人之后，验证过程开始。</p><p id="4844" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated"><strong class="hj if">第四步:协调</strong></p><p id="810a" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated">ICE代理现在必须选择哪个候选对用于媒体流中的每个成分。第一代理是控制代理，而第二代理是被动代理。当STUN检查完成时，控制代理将在验证完成后决定使用哪个候选对。</p><p id="def4" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated"><strong class="hj if">第五步:最后一步！</strong></p><p id="a44b" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated">一旦选择了候选对，媒体就应该被发送到客户端或从客户端接收。根据连接类型，媒体可以通过多种方式在客户端之间传输。</p><h2 id="f831" class="kv iu hi bd iv kw kx ky iz kz la lb jd hs lc ld jh hw le lf jl ia lg lh jp li bi translated">理论够多了，我们来写点代码吧</h2><p id="3244" class="pw-post-body-paragraph hg hh hi hj b hk jr hm hn ho js hq hr hs jt hu hv hw ju hy hz ia jv ic id ie hb bi translated">用于Android的音频/视频通话SDK使用用于Android的<a class="ae is" href="https://www.mirrorfly.com/docs/audio-video/android/quick-start/" rel="noopener ugc nofollow" target="_blank">MirrorFly SDK</a>，您可以快速轻松地将所需的实时通话功能集成到客户端应用程序中。当涉及到客户端实现时，您可以轻松地初始化和配置调用。让我们了解一下如何在你的应用中安装call SDK。</p><h1 id="e2e6" class="it iu hi bd iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq bi translated">集成呼叫SDK</h1><p id="c214" class="pw-post-body-paragraph hg hh hi hj b hk jr hm hn ho js hq hr hs jt hu hv hw ju hy hz ia jv ic id ie hb bi translated"><strong class="hj if">第一步:</strong>在这一步中，你需要在Android Studio中创建新项目或者打开一个已有的项目。</p><p id="23d9" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated"><strong class="hj if">第二步:</strong>接下来，您需要在项目的app/libs文件夹中包含以下库。</p><pre class="ih ii ij ik fd kk kl km bn kn ko bi"><span id="3cdf" class="kp iu hi kl b be kq kr l ks kt">flycommons.aar<br/>appbase.aar<br/>flynetwork.aar<br/>videocompression.aar<br/>flydatabase.aar<br/>flywebrtc.aar<br/>xmpp.aar</span></pre><p id="15e6" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated"><strong class="hj if">步骤3: </strong>将以下代码插入app/build。格拉德文件。</p><pre class="ih ii ij ik fd kk kl km bn kn ko bi"><span id="f0fc" class="kp iu hi kl b be kq kr l ks kt">plugins {<br/>    ...<br/>    id 'kotlin-android'<br/>    id 'kotlin-kapt'<br/>}<br/><br/>android {<br/>    compileOptions {<br/>        sourceCompatibility JavaVersion.VERSION_1_8<br/>        targetCompatibility JavaVersion.VERSION_1_8<br/>    }<br/><br/>    kotlinOptions {<br/>        jvmTarget = '1.8'<br/>    }<br/><br/>    packagingOptions {<br/>        exclude 'META-INF/AL2.0'<br/>        exclude 'META-INF/DEPENDENCIES'<br/>        exclude 'META-INF/LICENSE'<br/>        exclude 'META-INF/LICENSE.txt'<br/>        exclude 'META-INF/license.txt'<br/>        exclude 'META-INF/NOTICE'<br/>        exclude 'META-INF/NOTICE.txt'<br/>        exclude 'META-INF/notice.txt'<br/>        exclude 'META-INF/ASL2.0'<br/>        exclude 'META-INF/LGPL2.1'<br/>        exclude("META-INF/*.kotlin_module")<br/>    }<br/><br/>}</span></pre><p id="cb7f" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated"><strong class="hj if">步骤4: </strong>现在在app/build中包含以下依赖项。格拉德文件。</p><pre class="ih ii ij ik fd kk kl km bn kn ko bi"><span id="6a25" class="kp iu hi kl b be kq kr l ks kt">dependencies {<br/><br/>     ... // your app dependencies<br/><br/>     implementation files('libs/appbase.aar')<br/>     implementation files('libs/flycommons.aar')<br/>     implementation files('libs/flynetwork.aar')<br/>     implementation files('libs/flydatabase.aar')<br/>     implementation files('libs/videocompression.aar')<br/>     implementation files('libs/xmpp.aar')<br/>     implementation files('libs/flywebrtc.aar')<br/><br/> }</span></pre><p id="c939" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated"><strong class="hj if">步骤5: </strong>在app/build中包含以下SDK依赖项。格拉德文件。</p><pre class="ih ii ij ik fd kk kl km bn kn ko bi"><span id="650b" class="kp iu hi kl b be kq kr l ks kt">dependencies {<br/><br/>     ... // your app dependencies<br/><br/>     configurations {<br/>         all {<br/>             exclude group: 'org.json', module: 'json'<br/>             exclude group: 'xpp3', module: 'xpp3'<br/>         }<br/>     }<br/><br/>     //For lifecycle listener<br/>     implementation 'android.arch.lifecycle:extensions:1.1.1'<br/>     annotationProcessor 'android.arch.lifecycle:compiler:1.1.1'<br/><br/>     //For GreenDao<br/>     implementation 'de.greenrobot:greendao:2.1.0'<br/><br/>     //For gson parsing<br/>     implementation 'com.google.code.gson:gson:2.8.1'<br/><br/>     //for smack implementation<br/>     implementation 'org.igniterealtime.smack:smack-android:4.4.4'<br/>     implementation 'org.igniterealtime.smack:smack-tcp:4.4.4'<br/>     implementation 'org.igniterealtime.smack:smack-im:4.4.4'<br/>     implementation 'org.igniterealtime.smack:smack-extensions:4.4.4'<br/>     implementation 'org.igniterealtime.smack:smack-sasl-provided:4.4.4'<br/><br/>     implementation 'androidx.localbroadcastmanager:localbroadcastmanager:1.0.0'<br/>     implementation 'androidx.multidex:multidex:2.0.1'<br/>     implementation 'com.google.android.gms:play-services-location:17.0.0'<br/><br/>     //Dagger Dependencies<br/>     api 'com.google.dagger:dagger:2.40.5'<br/>     kapt 'com.google.dagger:dagger-compiler:2.40.5'<br/>     api 'com.google.dagger:dagger-android:2.40.5'<br/>     api 'com.google.dagger:dagger-android-support:2.40.5'<br/>     kapt 'com.google.dagger:dagger-android-processor:2.40.5'<br/><br/>     //coroutines<br/>     implementation 'org.jetbrains.kotlinx:kotlinx-coroutines-android:1.3.3'<br/>     implementation 'org.jetbrains.kotlinx:kotlinx-coroutines-test:1.3.3'<br/><br/>     //apicalls<br/>     implementation 'com.squareup.retrofit2:retrofit:2.6.1'<br/>     implementation 'com.squareup.retrofit2:converter-gson:2.6.1'<br/>     implementation 'com.squareup.okhttp3:okhttp:4.2.0'<br/>     implementation 'com.jakewharton.retrofit:retrofit2-kotlin-coroutines-adapter:0.9.2'<br/><br/>     //stetho interceptor<br/>     implementation 'com.facebook.stetho:stetho-okhttp3:1.3.1'<br/><br/>     //okhttp interceptor<br/>     implementation 'com.squareup.okhttp3:logging-interceptor:3.14.3'<br/><br/>     //shared preference encryption<br/>     implementation 'androidx.security:security-crypto:1.1.0-alpha03'<br/><br/>     //Socket - versions.gradle<br/>     implementation 'com.github.nkzawa:socket.io-client:0.6.0'<br/>     //Google - versions.gradle<br/>     implementation 'org.webrtc:google-webrtc:1.0.32006'<br/><br/>     implementation 'androidx.core:core-ktx:+'<br/>     implementation 'org.jetbrains.kotlin:kotlin-stdlib-jdk7:1.4.31'<br/><br/>     implementation 'androidx.media:media:1.0.0'<br/><br/>     //room database<br/>     implementation 'androidx.room:room-runtime:2.2.5'<br/>     kapt 'androidx.room:room-compiler:2.2.5'<br/>     implementation "androidx.room:room-ktx:2.2.5"<br/><br/>     // Lifecycle<br/>     implementation 'androidx.lifecycle:lifecycle-extensions:2.2.0'<br/>     kapt 'androidx.lifecycle:lifecycle-compiler:2.2.0'<br/><br/> }</span></pre><p id="5d6d" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated"><strong class="hj if">步骤6: </strong>为了避免导入的库冲突，在gradle.properties文件中添加以下行。</p><pre class="ih ii ij ik fd kk kl km bn kn ko bi"><span id="02c4" class="kp iu hi kl b be kq kr l ks kt">android.enableJetifier=true</span></pre><p id="41b0" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated"><strong class="hj if">第7步:</strong>在设置中插入以下一行。Gradle文件，以解决WebRTC依赖关系。</p><pre class="ih ii ij ik fd kk kl km bn kn ko bi"><span id="a398" class="kp iu hi kl b be kq kr l ks kt">dependencyResolutionManagement {<br/> repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)<br/> repositories {<br/>     google()<br/>     mavenCentral()<br/>     jcenter()<br/> }<br/>}</span></pre><p id="458f" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated"><strong class="hj if">第8步:</strong>打开AndroidManifest.xml，添加下面列出的权限。</p><pre class="ih ii ij ik fd kk kl km bn kn ko bi"><span id="484a" class="kp iu hi kl b be kq kr l ks kt">&lt;uses-permission android:name="android.permission.INTERNET" /&gt;<br/>&lt;uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" /&gt;<br/>&lt;uses-permission android:name="android.permission.RECORD_AUDIO" /&gt;<br/>&lt;uses-permission android:name="android.permission.DISABLE_KEYGUARD" /&gt;<br/>&lt;uses-permission android:name="android.permission.CAMERA" /&gt;<br/>&lt;uses-permission android:name="android.permission.READ_PHONE_STATE" /&gt;<br/>&lt;uses-permission android:name="android.permission.WAKE_LOCK" /&gt;</span></pre><p id="a769" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated"><strong class="hj if">第九步:</strong>最后可以在app/build里配置了。梯度文件</p><pre class="ih ii ij ik fd kk kl km bn kn ko bi"><span id="ac75" class="kp iu hi kl b be kq kr l ks kt">buildTypes {<br/>  debug {<br/>    buildConfigField 'String', 'SDK_BASE_URL', '"https://api-preprod-sandbox.mirrorfly.com/api/v1/"'<br/>    buildConfigField 'String', 'LICENSE', '"xxxxxxxxxxxxxxxxxxxxxxxxx"'<br/>    buildConfigField 'String', 'WEB_CHAT_LOGIN', '"https://webchat-preprod-sandbox.mirrorfly.com/"'<br/>    buildConfigField "String", "SUPPORT_MAIL", '"contussupport@gmail.com"'<br/>  }<br/>}</span></pre><h1 id="dbcb" class="it iu hi bd iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq bi translated">点对点视频通话的优势和劣势</h1><p id="cacf" class="pw-post-body-paragraph hg hh hi hj b hk jr hm hn ho js hq hr hs jt hu hv hw ju hy hz ia jv ic id ie hb bi translated"><strong class="hj if">优点:</strong></p><p id="8896" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated">Webrtc点对点(P2P)视频通话应用是与朋友和家人保持联系的好方法，以下是一些潜在的优势。</p><p id="a5ca" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated">免费:点对点视频通话的另一个好处是比传统通话使用更少的数据。所以，无论你是打算打电话给你在佛罗里达的祖父母，还是和你大学时最好的朋友通话，使用点对点视频通话将会为你节省大量的漫游费！在某些情况下，它往往是免费的，因为它们是通过互联网传输的，而不是通过传统的电话线。</p><p id="96f0" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated">点对点视频通话的一大优势就是免费！你不需要任何特殊的应用程序或设置——只要确保你的手机有良好的信号强度，并准备好与你爱的人(或老板)共度美好时光！</p><p id="175d" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated"><strong class="hj if">灵活性:</strong>您可以使用该平台与您最特殊的亲友进行高质量的<a class="ae is" href="https://www.mirrorfly.com/video-call-solution.php" rel="noopener ugc nofollow" target="_blank">实时视频通话</a>，同时使用该平台与来自不同城市的同事团队组织视频会议。</p><p id="ce7e" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated">点对点视频通话比普通电话通话有更多的优势。例如，它通常比从一个地方打电话到另一个地方更快，因为不需要像语音邮件或语音邮件系统这样的中介。</p><p id="3e47" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated"><strong class="hj if">便捷:</strong>点对点视频通话是一款功能强大的工具，可以帮助您以更加个性化的方式与朋友、家人和爱人保持联系。这种类型的通话使用互联网技术，使两个或两个以上的人能够直接沟通，而不必像运营商那样通过第三方。只要双方有在线连接和所需的软件，就可以立即开始沟通。</p><p id="46b4" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated">点对点视频通话是一种与朋友和家人保持联系的便捷方式，无需忍受长时间的电话通话。这种类型的通信允许您通过Webrtc视频呼叫和视频屏幕直接与他人联系，而不是通过电话交谈。</p><p id="bbaf" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated"><strong class="hj if">它是国际通话的最佳选择:</strong>使用Skype或FaceTime等点对点视频通话软件时，您可以用任何语言进行交流，这使它成为国际通话的最佳选择。最后，如果您的连接有任何问题(例如延迟)，那么对话中的其他参与者也会看到和听到屏幕上发生的事情！</p><p id="1ba0" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated"><strong class="hj if">缺点:</strong></p><p id="fc06" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated">点对点(P2P)视频通话应用是与朋友和家人保持联系的一种好方法，但也有一些潜在的缺点。</p><p id="dccd" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated"><strong class="hj if">随着与会者的增加而中断:</strong>我们大多数人在使用WEBRTC <a class="ae is" href="https://www.mirrorfly.com/build-video-chat-app.php" rel="noopener ugc nofollow" target="_blank">视频聊天应用</a>时仍然有许多小问题，无论是找到合适的人打电话还是毫不犹豫地与他们联系。向P2P会议呼叫添加更多的出席者会使对等网络过载，并导致较低质量的连接。</p><p id="00f8" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated"><strong class="hj if">安全威胁:</strong>点对点视频通话的缺点主要在于与通过开放网络传输和接收数据相关的潜在安全风险。可能出现的其他问题包括共享屏幕空间的冲突(称为“分割”的问题)，视频聊天期间由于智能手机的带宽限制或家庭/工作场所的互联网连接而导致的图像质量不佳等。</p><p id="90df" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated"><strong class="hj if">技术问题:</strong> P2P或点对点视频通话应用耗尽了电话资源，因此它们可能不适合长时间通话。此外，如果其中一个参与者使用有限的数据计划或在蜂窝范围之外，通话可能会失败。除了这些技术问题之外，点对点电话也可能会造成干扰，因为它们往往比传统电话包含更多的噪音。</p><p id="28a0" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated">注意:不要写视频会议，写“视频通话”</p><h1 id="0f76" class="it iu hi bd iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq bi translated">结论</h1><p id="1ec8" class="pw-post-body-paragraph hg hh hi hj b hk jr hm hn ho js hq hr hs jt hu hv hw ju hy hz ia jv ic id ie hb bi translated">WebRTC是这个领域的新生事物，在这篇文章中，我们试图涵盖您需要了解的所有内容。到目前为止，您应该能够看到WebRTC是如何让应用程序开发人员的工作变得更加简单的。</p><p id="4482" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated">在<a class="ae is" href="https://www.mirrorfly.com/blog/best-group-video-call-apps/" rel="noopener ugc nofollow" target="_blank">视频通话应用</a>的案例中，使用这项新技术更加重要，因为聊天应用都在向P2P模式发展。</p><p id="16ef" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated">使用Webrtc，开发这样一个应用程序(使用WebRTC视频聊天)并添加您的独特功能不会花费太多时间！只要确保在创建产品时牢记安全性，并使用Chrome和Firefox等高级浏览器测试每个测试版。</p><p id="070a" class="pw-post-body-paragraph hg hh hi hj b hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ie hb bi translated">立即开始创建基于网络的视频通话应用程序！</p></div></div>    
</body>
</html>