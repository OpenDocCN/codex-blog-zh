<html>
<head>
<title>Always choose ‘const’ over ‘let’ in TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在TypeScript中总是选择“const”而不是“let”</h1>
<blockquote>原文：<a href="https://medium.com/codex/always-choose-const-over-let-in-typescript-38178539c16a?source=collection_archive---------7-----------------------#2022-10-30">https://medium.com/codex/always-choose-const-over-let-in-typescript-38178539c16a?source=collection_archive---------7-----------------------#2022-10-30</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="7053" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们生活在一个代码的世界里。根据文章“计算机代码写了多少？”根据Sage McEnery的说法，在过去的20年中，大约有2.8万亿行代码被编写出来。如果你是一名软件开发人员，你最终会遇到这些问题，因为从圣诞灯泡的控制器到隔壁的电动汽车和商场的收银机，所有东西都包含代码。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/cec57d65367ea2aed662998a1a2c7c5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*49xW6k7gF9YFVOYpdeSlxQ.png"/></div></div></figure><p id="35a5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我曾经相信，当我刚开始作为一名软件开发人员工作时，我只会阅读和更新我开发的代码。今天，审查和修改别人的代码占据了我大约80%的工作。</p><p id="ac33" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这就是<strong class="ih hj">干净代码</strong>发挥作用的地方。</p><p id="9b8d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">可读性是干净代码的基本标准之一。想象一下，必须用混乱的代码维护软件。噩梦，对吧？尽管我还有很多东西要学，但我已经有了一些保持代码整洁的标准。其中之一就是我在TypeScript中总是用<code class="du jq jr js jt b">const</code>代替<code class="du jq jr js jt b">let</code>。</p><h2 id="2f2c" class="ju jv hi bd jw jx jy jz ka kb kc kd ke iq kf kg kh iu ki kj kk iy kl km kn ko bi translated">好吧，但是为什么？</h2><p id="30be" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">想一想你需要维护一个<code class="du jq jr js jt b">express.js</code>后端服务功能的情况</p><pre class="jf jg jh ji fd ku jt kv kw aw kx bi"><span id="ca4b" class="ju jv hi jt b fi ky kz l la lb">⬇️ <strong class="jt hj">EXAMPLE SERVICE FUNCTION</strong></span><span id="1f39" class="ju jv hi jt b fi lc kz l la lb">const getUsers = async (): Promise&lt;User[]&gt; =&gt; {<br/>  let users = await db.findAll...<br/>  return users?.data || []<br/>}</span></pre><p id="4ad5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">服务的主要职责通常是与数据库进行交互，并将数据映射或过滤到适当的响应结构中</p><pre class="jf jg jh ji fd ku jt kv kw aw kx bi"><span id="4220" class="ju jv hi jt b fi ky kz l la lb">❌ <strong class="jt hj">EXTENDED WITH FILTER AND MAPPER WITH REDEFINING</strong></span><span id="2d80" class="ju jv hi jt b fi lc kz l la lb">const getUsers = async (): Promise&lt;User[]&gt; =&gt; {<br/>  let users = await db.findAllInDB...<br/>  <strong class="jt hj">users = users?.data || []<br/>  users = users.filter(user =&gt; user?.data?.name &amp;&amp; user?.data?.id)<br/>  users = users.map(user =&gt; {<br/>    id: user.id,<br/>    firstName: user.name.split(' ')[0],<br/>    loyaltyPoints: await getUserLoyaltyPoints(user.id)<br/>  })</strong><br/>  return users<br/>}</span></pre><p id="84ec" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我看来，上面的代码一点也不干净。在初始定义<code class="du jq jr js jt b">users</code>变量后，进行了三次更新。随着项目的扩展，阅读它变得越来越困难，因为你总是必须阅读完整的行并记住变化；<code class="du jq jr js jt b">users</code>变为<code class="du jq jr js jt b"> users.data</code>，然后<code class="du jq jr js jt b">filter</code>被应用，<code class="du jq jr js jt b">map</code>被应用，以此类推。</p><p id="e4da" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">产生更可读代码的干净方法是总是用<code class="du jq jr js jt b">const</code>和有意义的名字重新定义变量</p><pre class="jf jg jh ji fd ku jt kv kw aw kx bi"><span id="7a2a" class="ju jv hi jt b fi ky kz l la lb">🚀 <strong class="jt hj">REDEFINING WITH CONST IS A GOOD PRACTICE</strong></span><span id="f8ee" class="ju jv hi jt b fi lc kz l la lb">const getUsers = async (): Promise&lt;User[]&gt; =&gt; {<br/>  const users = await db.findAllInDB...<br/>  <strong class="jt hj">const existingUsers = (users?.data || []).filter(<br/>   user =&gt; user?.data?.name &amp;&amp; user?.data?.id<br/>  )<br/>  const formattedUsers = existingUsers.map(user =&gt; {<br/>    id: user.id,<br/>    firstName: user.name.split(' ')[0],<br/>    loyaltyPoints: await getUserLoyaltyPoints(user.id)<br/>  })<br/>  return formattedUsers</strong><br/>}</span></pre><p id="8ac6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这些步骤更容易理解。在<code class="du jq jr js jt b">users</code>的数据库检索之后，我们定义<code class="du jq jr js jt b">existingUsers</code>(即实际存在的带有<code class="du jq jr js jt b">id</code>和<code class="du jq jr js jt b">name</code>的用户)，然后返回带有<code class="du jq jr js jt b">firstName</code>和<code class="du jq jr js jt b">loyaltyPoints</code>的<code class="du jq jr js jt b">formattedUsers</code>。</p><p id="2269" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如我前面提到的，函数或项目越大，如果单个变量被重复覆盖，代码就越难理解。</p></div><div class="ab cl ld le gp lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="hb hc hd he hf"><p id="cee4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">👋我希望这在你寻找新的学习材料时对你有用。感谢您花时间阅读这篇文章！如果你想在未来读到更多这样的故事，请订阅我的电子邮件列表。</p></div></div>    
</body>
</html>