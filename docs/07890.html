<html>
<head>
<title>Python pathlib — an alternative to the OS module</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">python path lib——操作系统模块的替代方案</h1>
<blockquote>原文：<a href="https://medium.com/codex/python-pathlib-an-alternative-to-the-os-module-3dcde93bf7df?source=collection_archive---------5-----------------------#2022-07-03">https://medium.com/codex/python-pathlib-an-alternative-to-the-os-module-3dcde93bf7df?source=collection_archive---------5-----------------------#2022-07-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="e590" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">作为一名程序员，我经常将路径作为工作的一部分。既然你在这里，我想你也是。在本文中，我将试图说服您使用<code class="du jd je jf jg b">pathlib</code>。</p><p id="63c2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jh">我想指出的是，这篇文章更适合于初级程序员或者那些刚刚开始使用Python和处理文件路径的人。然而，每个人都欢迎阅读它，学习新的东西或回忆被遗忘的东西。</em></p><p id="2ecd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">好吧…让我们来看看好东西。</p><h1 id="a6c1" class="ji jj hi bd jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf bi translated">什么是pathlib，为什么要使用它？</h1><p id="36b8" class="pw-post-body-paragraph if ig hi ih b ii kg ik il im kh io ip iq ki is it iu kj iw ix iy kk ja jb jc hb bi translated">为了回答第一个问题，官方文件指出:</p><blockquote class="kl km kn"><p id="90c1" class="if ig jh ih b ii ij ik il im in io ip ko ir is it kp iv iw ix kq iz ja jb jc hb bi translated">这个模块提供了表示文件系统路径的类，其语义适用于不同的操作系统。路径类分为纯路径和具体路径，纯路径提供没有I/O的纯计算操作，具体路径继承纯路径，但也提供I/O操作。</p></blockquote><p id="2409" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">换句话说，<strong class="ih hj">纯路径</strong>和<strong class="ih hj">具体路径</strong>是代表两种不同类型的路径对象的两个类，<code class="du jd je jf jg b">pathlib</code>将文件系统路径分成这两种类型。</p><figure class="ks kt ku kv fd kw er es paragraph-image"><div class="er es kr"><img src="../Images/b4f30976fc058d3e6c89d5c3b0f79d85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1076/format:webp/0*VBSsRUcykv6IM8tT.png"/></div></figure><ul class=""><li id="30d6" class="kz la hi ih b ii ij im in iq lb iu lc iy ld jc le lf lg lh bi translated"><strong class="ih hj">Pure</strong>:<em class="jh">Pure path</em>，<em class="jh"> PurePosixPath </em>，<em class="jh"> PureWindowsPath </em></li><li id="2a24" class="kz la hi ih b ii li im lj iq lk iu ll iy lm jc le lf lg lh bi translated"><strong class="ih hj">具体</strong> : <em class="jh">路径，PosixPath，WindowsPath </em></li></ul><p id="1cde" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">虽然具体路径允许您在文件路径上控制和执行写操作，但是纯路径提供了管理和操作文件路径的工具，而不需要这样做。</p><p id="81dd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">或者换一种说法，纯路径是具体路径的子类。它添加进行系统调用的输入/输出操作，并从父类继承操作。</p><p id="e28a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在是第二个问题:<em class="jh">为什么</em>你会使用它？</p><p id="a4b6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我看来，<strong class="ih hj"/><code class="du jd je jf jg b">pathlib</code><strong class="ih hj">模块比</strong> <code class="du jd je jf jg b">os.path</code> <strong class="ih hj">模块的方法更直接、更实用，从而提高了代码的可维护性和简单性。</strong>然而，这将在以下示例中更详细地讨论<strong class="ih hj"> </strong>。</p><p id="40da" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们看一个例子:</p><p id="0718" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">注意！</strong>我们需要Python版本≥ 3.4才能使用Pathlib。</p><p id="1783" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">假设我们有<strong class="ih hj"> N </strong>个文件需要移动到特定的文件夹。</p><figure class="ks kt ku kv fd kw er es paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="er es ln"><img src="../Images/5ceb24be7bbd5ed4447cb00562a431cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WFESxqVeCCt09CmZgIYxGg.png"/></div></div><figcaption class="ls lt et er es lu lv bd b be z dx translated">CentOS Linux | Python 3.6 |示例1</figcaption></figure><p id="de28" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们注意到的第一件事是，我们需要三次导入来将这些文件移动到另一个文件夹。如果<code class="du jd je jf jg b">trash</code>目录碰巧已经存在，则引发<code class="du jd je jf jg b">FileExistsError</code>。</p><p id="744f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">相同的例子，但使用<code class="du jd je jf jg b">pathlib</code></p><figure class="ks kt ku kv fd kw er es paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="er es lw"><img src="../Images/b0674bc2aa75ae8b7e67ecc304b7bc9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YnVl2NxYWBS_4ZwBWcqaPA.png"/></div></div><figcaption class="ls lt et er es lu lv bd b be z dx translated">CentOS Linux | Python 3.6 |示例1</figcaption></figure><p id="fc8a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du jd je jf jg b">Path.replace(<em class="jh">target</em>)</code>将文件重命名到给定的目的地，并返回一个指向目标的新路径实例。<code class="du jd je jf jg b">parents=True</code>将确保根据需要创建该路径的任何缺失父路径。如果<code class="du jd je jf jg b">exist_ok</code>为真，<code class="du jd je jf jg b">FileExistsError</code>异常将被忽略。</p></div><div class="ab cl lx ly gp lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="hb hc hd he hf"><p id="1ef5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在实践中我们可以用<code class="du jd je jf jg b">pathlib</code>做什么？</p><h1 id="98ba" class="ji jj hi bd jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf bi translated"><strong class="ak">创建路径</strong></h1><p id="b1aa" class="pw-post-body-paragraph if ig hi ih b ii kg ik il im kh io ip iq ki is it iu kj iw ix iy kk ja jb jc hb bi translated">尽管介绍了各种风格的模块，你可能只需要<code class="du jd je jf jg b">pathlib.Path</code>类。创建路径有几种不同的方法。</p><ul class=""><li id="fd8b" class="kz la hi ih b ii ij im in iq lb iu lc iy ld jc le lf lg lh bi translated">例如，我们可以使用模块提供的<code class="du jd je jf jg b">.cwd()</code>和<code class="du jd je jf jg b">.home()</code>方法。</li></ul><figure class="ks kt ku kv fd kw er es paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="er es ln"><img src="../Images/1a617d64743c985eb023f284b4db52f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AdI4WXvoA5X_3ix42Cn6Sg.png"/></div></div></figure><ul class=""><li id="ff2d" class="kz la hi ih b ii ij im in iq lb iu lc iy ld jc le lf lg lh bi translated">使用特殊操作符<code class="du jd je jf jg b">/</code></li></ul><figure class="ks kt ku kv fd kw er es paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="er es me"><img src="../Images/5986285172b2f1f37687c89f3f2cdfff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e1p6IPG1rqzguAFvSNi7eA.png"/></div></div></figure><ul class=""><li id="63ee" class="kz la hi ih b ii ij im in iq lb iu lc iy ld jc le lf lg lh bi translated">从字符串表示形式显式创建</li></ul><figure class="ks kt ku kv fd kw er es paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="er es mf"><img src="../Images/695dd96097fafbfd47f829cbeb0d84c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ad1A0vmR3BvuvI2ghgMfJQ.png"/></div></div></figure><h1 id="0327" class="ji jj hi bd jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf bi translated">读取、写入、移动和删除文件</h1><ul class=""><li id="95b3" class="kz la hi ih b ii kg im kh iq mg iu mh iy mi jc le lf lg lh bi translated"><code class="du jd je jf jg b">.read_text(<em class="jh">encoding=None, errors=None</em>)</code>:以字符串形式返回指向文件的解码内容</li><li id="4cdd" class="kz la hi ih b ii li im lj iq lk iu ll iy lm jc le lf lg lh bi translated"><code class="du jd je jf jg b">.read_bytes()</code>:返回指向文件的二进制内容作为bytes对象</li><li id="69fe" class="kz la hi ih b ii li im lj iq lk iu ll iy lm jc le lf lg lh bi translated"><code class="du jd je jf jg b">.write_text(<em class="jh">data, encoding=None, errors=None, newline=None</em>)</code>:以文本方式打开指向的文件，写入<em class="jh">数据</em>，关闭文件。同名的现有文件被覆盖。</li><li id="756f" class="kz la hi ih b ii li im lj iq lk iu ll iy lm jc le lf lg lh bi translated"><code class="du jd je jf jg b">.write_bytes(<em class="jh">data</em>)</code>:以字节模式打开指向的文件，向其中写入<em class="jh">数据</em>，关闭文件。同名的现有文件被覆盖。</li><li id="654f" class="kz la hi ih b ii li im lj iq lk iu ll iy lm jc le lf lg lh bi translated"><code class="du jd je jf jg b">.replace(<em class="jh">target</em>)</code>:将该文件或目录重命名为给定的<em class="jh">目标</em>，并返回一个指向<em class="jh">目标</em>的新路径实例。如果<em class="jh">目标</em>指向已存在的文件或空目录，则无条件替换。</li><li id="180b" class="kz la hi ih b ii li im lj iq lk iu ll iy lm jc le lf lg lh bi translated"><code class="du jd je jf jg b">.rename(<em class="jh">target</em>)</code>:将该文件或目录重命名为给定的<em class="jh">目标</em>，并返回一个指向<em class="jh">目标</em>的新路径实例。在Unix上，如果<em class="jh">目标</em>存在并且是一个文件，在用户有权限的情况下会被静默替换。在Windows上，如果<em class="jh">目标</em>存在，则会引发<code class="du jd je jf jg b">FileExistsError</code>。<em class="jh">目标</em>可以是一个字符串或另一个路径对象。</li><li id="3c51" class="kz la hi ih b ii li im lj iq lk iu ll iy lm jc le lf lg lh bi translated"><code class="du jd je jf jg b">.unlink(<em class="jh">missing_ok=False</em>)</code>:删除文件或符号链接。</li><li id="2fe6" class="kz la hi ih b ii li im lj iq lk iu ll iy lm jc le lf lg lh bi translated"><code class="du jd je jf jg b">.rmdir()</code>:删除目录</li></ul><p id="91f5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">读写方法之所以如此方便使用，是因为它们处理文件的打开和关闭。</p><p id="315d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">示例:</p><figure class="ks kt ku kv fd kw er es paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="er es mj"><img src="../Images/efdf327ecc8cde4b0bf8528fe26c8dab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*it64smlBtApkSVlNUTf0DA.png"/></div></div></figure></div><div class="ab cl lx ly gp lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="hb hc hd he hf"><h1 id="dac6" class="ji jj hi bd jk jl mk jn jo jp ml jr js jt mm jv jw jx mn jz ka kb mo kd ke kf bi translated">有用的方法和属性</h1><p id="4d9b" class="pw-post-body-paragraph if ig hi ih b ii kg ik il im kh io ip iq ki is it iu kj iw ix iy kk ja jb jc hb bi translated">这是最常用属性的简短列表</p><ul class=""><li id="05cd" class="kz la hi ih b ii ij im in iq lb iu lc iy ld jc le lf lg lh bi translated"><code class="du jd je jf jg b">.name</code>:没有目录的文件名</li><li id="2018" class="kz la hi ih b ii li im lj iq lk iu ll iy lm jc le lf lg lh bi translated"><code class="du jd je jf jg b">.suffix</code>:最终组件的文件扩展名，如果有的话</li><li id="a395" class="kz la hi ih b ii li im lj iq lk iu ll iy lm jc le lf lg lh bi translated"><code class="du jd je jf jg b">.stem</code>:不带后缀的文件名</li><li id="fbab" class="kz la hi ih b ii li im lj iq lk iu ll iy lm jc le lf lg lh bi translated"><code class="du jd je jf jg b">.parent</code>:路径的逻辑父路径</li><li id="4bb8" class="kz la hi ih b ii li im lj iq lk iu ll iy lm jc le lf lg lh bi translated"><code class="du jd je jf jg b">.anchor</code>:驱动器和根的串联</li></ul><figure class="ks kt ku kv fd kw er es paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="er es mp"><img src="../Images/b8cdfa28733b4b0ba03125882bfbe917.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eusj26eiTRRg1yzAAG_2MA.png"/></div></div></figure><p id="5add" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是最常用方法的简短列表</p><ul class=""><li id="da00" class="kz la hi ih b ii ij im in iq lb iu lc iy ld jc le lf lg lh bi translated"><code class="du jd je jf jg b">.exists()</code>:文件存在返回真，否则返回假</li><li id="65b7" class="kz la hi ih b ii li im lj iq lk iu ll iy lm jc le lf lg lh bi translated"><code class="du jd je jf jg b">.is_dir()</code>:检查路径是否为目录</li><li id="997a" class="kz la hi ih b ii li im lj iq lk iu ll iy lm jc le lf lg lh bi translated"><code class="du jd je jf jg b">.is_file()</code>:检查路径是否为文件</li><li id="45d4" class="kz la hi ih b ii li im lj iq lk iu ll iy lm jc le lf lg lh bi translated"><code class="du jd je jf jg b">.expanduser()</code>:返回一个扩展了<code class="du jd je jf jg b">~</code>和<code class="du jd je jf jg b">~user</code>结构的新路径</li><li id="f6e6" class="kz la hi ih b ii li im lj iq lk iu ll iy lm jc le lf lg lh bi translated"><code class="du jd je jf jg b">.glob()</code>:将给定的相对<em class="jh">模式</em>在该路径代表的目录中进行glob，产生所有匹配的文件</li><li id="517b" class="kz la hi ih b ii li im lj iq lk iu ll iy lm jc le lf lg lh bi translated"><code class="du jd je jf jg b">.iterdir()</code>:生成目录内容的路径对象</li><li id="3797" class="kz la hi ih b ii li im lj iq lk iu ll iy lm jc le lf lg lh bi translated"><code class="du jd je jf jg b">.mkdir()</code>:在此给定路径下创建一个新目录</li></ul><figure class="ks kt ku kv fd kw er es paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="er es mp"><img src="../Images/95006d94eec2059c684568c65dfa1954.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ean4J3UoZdcmNsiPTo7OCA.png"/></div></div></figure><h1 id="0da6" class="ji jj hi bd jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf bi translated">一些实际例子</h1><ul class=""><li id="01c7" class="kz la hi ih b ii kg im kh iq mg iu mh iy mi jc le lf lg lh bi translated">收集文件名——这可能是您必须做的事情</li></ul><figure class="ks kt ku kv fd kw er es paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="er es mq"><img src="../Images/68a4eaf076d95150f9480f7301a17c00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5XGet8psFa2XHAfy0Zz4Kw.png"/></div></div></figure><ul class=""><li id="9c01" class="kz la hi ih b ii ij im in iq lb iu lc iy ld jc le lf lg lh bi translated">将文件移动到一个特定的目录中——这个目录您已经在开头看到过了</li></ul><figure class="ks kt ku kv fd kw er es paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="er es lw"><img src="../Images/b0674bc2aa75ae8b7e67ecc304b7bc9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YnVl2NxYWBS_4ZwBWcqaPA.png"/></div></div></figure></div><div class="ab cl lx ly gp lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="hb hc hd he hf"><h1 id="dfd0" class="ji jj hi bd jk jl mk jn jo jp ml jr js jt mm jv jw jx mn jz ka kb mo kd ke kf bi translated">结论</h1><p id="2dea" class="pw-post-body-paragraph if ig hi ih b ii kg ik il im kh io ip iq ki is it iu kj iw ix iy kk ja jb jc hb bi translated">文件路径由pathlib中的对象表示，这使得使用它们更加容易。我们可以控制对象的所有组件，并且很容易从中提取出我们需要的东西。正如我已经提到的，pathlib模块使用起来更简单、更方便。</p><h1 id="ef28" class="ji jj hi bd jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf bi translated">临终遗言</h1><p id="ec5e" class="pw-post-body-paragraph if ig hi ih b ii kg ik il im kh io ip iq ki is it iu kj iw ix iy kk ja jb jc hb bi translated">不要误解我:我并不反对<code class="du jd je jf jg b">os</code>模块。Pathlib更多的是个人喜好。会完美地完成同样的工作。我是一个主动学习者，写文章帮助我更好地理解事物。我希望这些文章对其他人有用。欢迎在评论区留下修改意见，我会尽最大努力把它们包括进来。</p><p id="1d23" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">感谢您的阅读！</p></div><div class="ab cl lx ly gp lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="hb hc hd he hf"><h1 id="6536" class="ji jj hi bd jk jl mk jn jo jp ml jr js jt mm jv jw jx mn jz ka kb mo kd ke kf bi translated">参考</h1><div class="mr ms ez fb mt mu"><a href="https://realpython.com/python-pathlib/" rel="noopener  ugc nofollow" target="_blank"><div class="mv ab dw"><div class="mw ab mx cl cj my"><h2 class="bd hj fi z dy mz ea eb na ed ef hh bi translated">Python 3的pathlib模块:驯服文件系统——真正的Python</h2><div class="nb l"><h3 class="bd b fi z dy mz ea eb na ed ef dx translated">由于许多不同的原因，使用文件和与文件系统交互是很重要的。最简单的情况…</h3></div><div class="nc l"><p class="bd b fp z dy mz ea eb na ed ef dx translated">realpython.com</p></div></div><div class="nd l"><div class="ne l nf ng nh nd ni kx mu"/></div></div></a></div><div class="mr ms ez fb mt mu"><a href="https://docs.python.org/3/library/pathlib.html#pathlib.Path.write_bytes" rel="noopener  ugc nofollow" target="_blank"><div class="mv ab dw"><div class="mw ab mx cl cj my"><h2 class="bd hj fi z dy mz ea eb na ed ef hh bi translated">面向对象的文件系统路径Python 3.10.5文档</h2><div class="nb l"><h3 class="bd b fi z dy mz ea eb na ed ef dx translated">3.4版本中的新功能。这个模块提供了用语义表示文件系统路径的类…</h3></div><div class="nc l"><p class="bd b fp z dy mz ea eb na ed ef dx translated">docs.python.org</p></div></div><div class="nd l"><div class="nj l nf ng nh nd ni kx mu"/></div></div></a></div><div class="mr ms ez fb mt mu"><a href="https://www.freecodecamp.org/news/how-to-use-pathlib-module-in-python/" rel="noopener  ugc nofollow" target="_blank"><div class="mv ab dw"><div class="mw ab mx cl cj my"><h2 class="bd hj fi z dy mz ea eb na ed ef hh bi translated">python Path——如何使用Pathlib模块并举例说明</h2><div class="nb l"><h3 class="bd b fi z dy mz ea eb na ed ef dx translated">每个操作系统都有不同的构造文件路径的规则。例如，Linux使用正斜杠表示…</h3></div><div class="nc l"><p class="bd b fp z dy mz ea eb na ed ef dx translated">www.freecodecamp.org</p></div></div><div class="nd l"><div class="nk l nf ng nh nd ni kx mu"/></div></div></a></div></div></div>    
</body>
</html>