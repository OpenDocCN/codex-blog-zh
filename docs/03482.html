<html>
<head>
<title>The Difference between Kotlin’s Data Classes and Java 16 Records</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kotlin的数据类和Java 16记录的区别</h1>
<blockquote>原文：<a href="https://medium.com/codex/the-difference-between-kotlins-data-classes-and-java-16-records-7e25fdbcb50d?source=collection_archive---------5-----------------------#2021-09-05">https://medium.com/codex/the-difference-between-kotlins-data-classes-and-java-16-records-7e25fdbcb50d?source=collection_archive---------5-----------------------#2021-09-05</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="149c" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">详细的外观</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/fa17be42e9ada47edf9cf7840de0d1c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ACLyK7hnR5dW4A0z"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated"><a class="ae jn" href="https://unsplash.com/@trommelkopf?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">史蒂夫·哈维</a>在<a class="ae jn" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="77e9" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">当Java第一次在Java 14中引入记录作为预览，后来在Java 16中发布时，它让许多人想起了Kotlin的数据类。虽然它们以非常相似的方式解决相同的问题，但在处理方式上有一些不同。</p><p id="5c92" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我将按照最相关到更边缘的顺序大致列出它们。我试图找出所有存在的差异，但如果我错过了什么，请随意评论。</p><h1 id="82af" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">例子&amp;为什么它们很重要</h1><p id="e2cf" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">在讨论差异之前，我想先举几个例子。如果你已经知道它们是如何工作的，你可以跳过这一节。</p><p id="6194" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">Java的记录使用了新的关键字<code class="du lh li lj lk b">record</code>:</p><pre class="iy iz ja jb fd ll lk lm ln aw lo bi"><span id="456a" class="lp kl hi lk b fi lq lr l ls lt">record Name(String firstName, String lastName) { }</span></pre><p id="c999" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">同时，Kotlin的数据类在类前使用修饰符<code class="du lh li lj lk b">data</code>:</p><pre class="iy iz ja jb fd ll lk lm ln aw lo bi"><span id="c222" class="lp kl hi lk b fi lq lr l ls lt">data class Name(val firstName: String, val lastName: String)</span></pre><p id="8fc2" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">两者都自动创建了大部分样板代码，否则你必须创建:getters、setters、<code class="du lh li lj lk b">equals</code>、<code class="du lh li lj lk b">hashcode</code>和<code class="du lh li lj lk b">toString</code>。</p><p id="d7ef" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这不仅有助于减少样板代码，还可以使重构更加安全，因为现在您不必记得向自动生成的方法添加新的字段。</p><h1 id="900c" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">最终课程</h1><p id="26d5" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">记录和数据类都将编译成最终类。对于Kotlin，这是所有类的默认设置，但是数据类不能被声明<code class="du lh li lj lk b">open</code>。</p><h1 id="9537" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">可变成员</h1><p id="a9e1" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">Java的记录是完全不可变的。然而，对于数据类，您可以指定哪些字段是可变的，哪些是不可变的(通常使用<code class="du lh li lj lk b">var</code> vs <code class="du lh li lj lk b">val</code>关键字)。例如，在下面的代码中，<code class="du lh li lj lk b">id</code>不能被重新分配，但<code class="du lh li lj lk b">name</code>可以:</p><pre class="iy iz ja jb fd ll lk lm ln aw lo bi"><span id="6725" class="lp kl hi lk b fi lq lr l ls lt">record Person(val id: Int, var name: Name)</span></pre><p id="18c6" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在不可变字段的情况下，它会在结果代码中将它们标记为<code class="du lh li lj lk b">final</code>。Java的记录总是有<code class="du lh li lj lk b">final</code>字段。</p><h1 id="7649" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">非构造函数字段</h1><p id="ba16" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">记录不允许您定义额外的实例字段，只能定义静态字段。但是，使用数据类，您可以。当然，这些并不包括在自动生成的方法中，但是对于一些迫切需要创建的值是有用的:</p><pre class="iy iz ja jb fd ll lk lm ln aw lo bi"><span id="ac88" class="lp kl hi lk b fi lq lr l ls lt">data class Name(val firstName: String, val lastName: String) {<br/>    val fullName = firstName + ' ' + lastName<br/>}</span></pre><h1 id="87ff" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">java.lang.Record</h1><p id="de06" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">Java的记录现在总是实现新的类<code class="du lh li lj lk b"><a class="ae jn" href="https://download.java.net/java/early_access/jdk17/docs/api/java.base/java/lang/Record.html" rel="noopener ugc nofollow" target="_blank">java.lang.Record</a></code>。这个抽象类本身没有添加任何有趣的方法，但是可以用来捕捉所有记录。</p><p id="e4a1" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这个超类也意味着<strong class="jq hj">记录不能扩展其他类</strong>——尽管它们仍然可以实现接口。数据类没有这种限制。</p><h1 id="cf57" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">解构</h1><p id="d14b" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">Kotlin已经支持数据类的析构。对于Java，<a class="ae jn" href="https://cr.openjdk.java.net/~briangoetz/amber/serialization.html#sidebar-pattern-matching" rel="noopener ugc nofollow" target="_blank">目前有一个关于</a>的提议，但是目前的Java版本(包括Java 17)都不支持这个语法。</p><h2 id="afce" class="lp kl hi bd km lu lv lw kq lx ly lz ku jx ma mb kw kb mc md ky kf me mf la mg bi translated">科特林的毁灭</h2><p id="6dce" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">Kotlin的赋值语法中内置了析构。给定之前的<code class="du lh li lj lk b">Person</code>类，我现在可以做以下事情:</p><pre class="iy iz ja jb fd ll lk lm ln aw lo bi"><span id="3145" class="lp kl hi lk b fi lq lr l ls lt">val (id, name) = Person(0, Name("Oscar", "Ablinger"))</span></pre><p id="8802" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这将利用另一组自动生成的方法编译成两个不同的赋值语句。它本质上是以下两个语句的语法糖:</p><pre class="iy iz ja jb fd ll lk lm ln aw lo bi"><span id="168e" class="lp kl hi lk b fi lq lr l ls lt">val id = person.component1()<br/>val name = person.component2()</span></pre><p id="d996" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">这两个变量都是类型化的，因此当更改字段类型时，结果变量将更新它们的类型。它们也不必是详尽的，所以当您添加另一个字段时，相同的代码仍然可以工作。</p><p id="e5a8" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">然而，这意味着如果您添加一个字段作为除最后一个元素之外的任何元素，并且它与它替换的字段共享类型，<strong class="jq hj">代码将编译并且不会给出错误！这是一个很难追踪的错误来源。</strong></p><h1 id="23e7" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">toString</h1><p id="6f86" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">虽然两者都获得了自动生成的<code class="du lh li lj lk b">toString</code>方法，但Java和Kotlin的结果看起来略有不同。Java将生成以下字符串:</p><pre class="iy iz ja jb fd ll lk lm ln aw lo bi"><span id="89b5" class="lp kl hi lk b fi lq lr l ls lt">record Name(String firstName, String lastName) { }</span><span id="e29d" class="lp kl hi lk b fi mh lr l ls lt">new Name("Oscar", "Ablinger").toString();<br/>// Name[firstName=Oscar, lastName=Ablinger]</span></pre><p id="65af" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">Kotlin生成一个类似的字符串:</p><pre class="iy iz ja jb fd ll lk lm ln aw lo bi"><span id="c5a1" class="lp kl hi lk b fi lq lr l ls lt">data class Name(val firstName: String, val lastName: String)</span><span id="58cd" class="lp kl hi lk b fi mh lr l ls lt">Name("Oscar", "Ablinger").toString()<br/>// Name(firstName=Oscar, lastName=Ablinger)</span></pre><p id="e960" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">如您所见，唯一真正的区别是Java使用方括号，而Kotlin使用圆括号。令人恼火的是，IntelliJ为类生成的默认<code class="du lh li lj lk b">toString</code>使用了大括号。</p><p id="d2b0" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">您也可以使用这个生成的字符串作为<code class="du lh li lj lk b">toString</code>方法的样式指南的基础。</p><h1 id="8354" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">反射</h1><p id="9832" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">数据类本质上只是普通类的语法糖。因此，一旦被编译，很难将它们与其他类区分开来。</p><p id="3478" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">然而，使用反射可以很容易地识别记录。不仅仅是因为它们总是实现<code class="du lh li lj lk b">java.lang.Record</code>类型，还因为<code class="du lh li lj lk b">Class</code>中增加了两个新方法:<code class="du lh li lj lk b"><a class="ae jn" href="https://download.java.net/java/early_access/jdk17/docs/api/java.base/java/lang/Class.html#isRecord()" rel="noopener ugc nofollow" target="_blank">isRecord</a></code>和<code class="du lh li lj lk b"><a class="ae jn" href="https://download.java.net/java/early_access/jdk17/docs/api/java.base/java/lang/Class.html#getRecordComponents()" rel="noopener ugc nofollow" target="_blank">getRecordComponents</a></code>。</p><p id="8d59" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">如果该类是一个记录，<code class="du lh li lj lk b">isRecord</code>简单地返回<code class="du lh li lj lk b">true</code>，否则返回<code class="du lh li lj lk b">false</code>。</p><p id="4eed" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><code class="du lh li lj lk b">getRecordComponents</code>返回记录中所有字段的信息，如果不是记录，则返回<code class="du lh li lj lk b">null</code>。术语“组件”只是用来指记录的非静态字段。使用它，您可以访问与方法相同的信息:注释、名称、类型等等。</p><h1 id="c35f" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">吸气剂</h1><p id="695f" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">Kotlin在带有<code class="du lh li lj lk b">get</code>前缀的知名模式之后生成getters。记录现在去掉了这个前缀，取而代之的是将方法命名为与字段相同的名称。</p><h1 id="d4e7" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">履行</h1><p id="55ae" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">我已经写了关于<code class="du lh li lj lk b">toString</code>方法的不同结果。此外，所有方法的实现方式也不同。</p><p id="b1e0" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">Kotlin编译器只是为每个方法生成代码，而Java将实际的代码外包给一个静态方法。这些方法的实现只需调用带有必要信息的<code class="du lh li lj lk b"><a class="ae jn" href="https://download.java.net/java/early_access/jdk17/docs/api/java.base/java/lang/runtime/ObjectMethods.html#bootstrap(java.lang.invoke.MethodHandles.Lookup,java.lang.String,java.lang.invoke.TypeDescriptor,java.lang.Class,java.lang.String,java.lang.invoke.MethodHandle...)" rel="noopener ugc nofollow" target="_blank">ObjectMethods.bootstrap</a></code>方法。我假设这样做是为了尽可能减少记录的字节大小。</p><h1 id="40ec" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">结论</h1><p id="375e" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">最后，数据类和记录在用法上非常相似。虽然数据类只是简单的语法糖，但是记录为Java标准库增加了很多。尽管如此，数据类确实允许比记录更多的功能。这是否是一件严格意义上的好事是另一个争论。</p></div></div>    
</body>
</html>