<html>
<head>
<title>Integration Testing with TigerGraph</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用TigerGraph进行集成测试</h1>
<blockquote>原文：<a href="https://medium.com/codex/integration-testing-with-tigergraph-f3bc7e80179f?source=collection_archive---------7-----------------------#2021-01-11">https://medium.com/codex/integration-testing-with-tigergraph-f3bc7e80179f?source=collection_archive---------7-----------------------#2021-01-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><h2 id="8873" class="hg hh hi bd b fp hj hk hl hm hn ho dx hp translated" aria-label="kicker paragraph"><a class="ae ge" href="https://medium.com/codex" rel="noopener">抄本</a></h2><div class=""/><div class=""><h2 id="c306" class="pw-subtitle-paragraph io hr hi bd b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf dx translated">支持TigerGraph的Gradle应用程序的CI/CD和GitHub操作。</h2></div><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es jg"><img src="../Images/e063211f8504a4f2bf80c67a8887d08d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_OFTozqTq7BsW-CimJRvrg.jpeg"/></div></div><figcaption class="js jt et er es ju jv bd b be z dx translated">马特·迪恩通过<a class="ae jw" href="https://kiptoe.com/" rel="noopener ugc nofollow" target="_blank">https://kiptoe.com/</a>拍摄的照片</figcaption></figure><p id="1e3d" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">集成测试有助于我们验证我们的应用程序在与第三方软件交互时是否像在生产中一样正常工作。当集成测试包括一个数据库时，这就带来了它自己的一系列配置和设置。</p><p id="9246" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">Giraffle 是一个流行的Gradle插件，用于部署在CI/CD中应用的模式创建、加载作业和查询。已经有一些关于如何使用Giraffle进行部署的文章，但是在下面的文章中，我们将介绍一种在GitHub操作中使用本地化的TigerGraph Docker容器来运行集成测试的简单而免费的方法。</p><p id="aa2f" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">将涵盖哪些内容:</p><ol class=""><li id="63f6" class="kt ku hi jz b ka kb kd ke kg kv kk kw ko kx ks ky kz la lb bi translated">通过CLI创建简单的Gradle项目</li><li id="4344" class="kt ku hi jz b ka lc kd ld kg le kk lf ko lg ks ky kz la lb bi translated">为TigerGraph设置基本Docker编写脚本</li><li id="73a5" class="kt ku hi jz b ka lc kd ld kg le kk lf ko lg ks ky kz la lb bi translated">使用Avast Docker编写插件在梯度验证任务中启动TigerGraph</li><li id="f8e8" class="kt ku hi jz b ka lc kd ld kg le kk lf ko lg ks ky kz la lb bi translated">在测试开始运行之前，在启动时运行GSQL脚本</li><li id="b9b4" class="kt ku hi jz b ka lc kd ld kg le kk lf ko lg ks ky kz la lb bi translated">使用GitHub操作运行集成测试，作为CI/CD的一部分</li></ol><p id="08c9" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">使用的Docker映像是本文中创建和讨论的<a class="ae jw" href="https://towardsdatascience.com/efficient-use-of-tigergraph-and-docker-5e7f9918bf53" rel="noopener" target="_blank">，而用于协调旋转容器的Gradle插件是</a><a class="ae jw" href="https://github.com/avast/gradle-docker-compose-plugin" rel="noopener ugc nofollow" target="_blank"> Avast插件</a>。</p><p id="8908" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">本指南的最终代码示例可以在我的GitHub 上找到<a class="ae jw" href="https://github.com/DavidBakerEffendi/tigergraph-int-test-example" rel="noopener ugc nofollow" target="_blank">。</a></p></div><div class="ab cl lh li gp lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="hb hc hd he hf"><h1 id="6ca7" class="lo lp hi bd lq lr ls lt lu lv lw lx ly ix lz iy ma ja mb jb mc jd md je me mf bi translated">创建一个简单的Gradle项目</h1><p id="9cf0" class="pw-post-body-paragraph jx jy hi jz b ka mg is kc kd mh iv kf kg mi ki kj kk mj km kn ko mk kq kr ks hb bi translated">在要创建项目的目录中，从命令行运行以下命令。在本例中，我们将使用JDK 11和Gradle 6.7.1。</p><pre class="jh ji jj jk fd ml mm mn mo aw mp bi"><span id="7104" class="mq lp hi mm b fi mr ms l mt mu">gradle init \<br/>    --type java-application \<br/>    --test-framework junit-jupiter \<br/>    --dsl groovy</span></pre><p id="26ac" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">系统将提示您输入项目名称和源包——这两者都由您决定。</p><p id="6c14" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">最终的项目将是一个简单的Java应用程序，JUnit 5作为测试框架，Groovy作为<code class="du mv mw mx mm b">build.gradle</code>的DSL。在<code class="du mv mw mx mm b">src/main</code>和<code class="du mv mw mx mm b">src/test</code>下将分别生成一个名为<code class="du mv mw mx mm b">App</code>的类和一个名为<code class="du mv mw mx mm b">AppTest</code>的测试类。</p><h1 id="39f2" class="lo lp hi bd lq lr my lt lu lv mz lx ly ix na iy ma ja nb jb mc jd nc je me mf bi translated">在梯度任务中启动TigerGraph</h1><p id="3f19" class="pw-post-body-paragraph jx jy hi jz b ka mg is kc kd mh iv kf kg mi ki kj kk mj km kn ko mk kq kr ks hb bi translated">首先，让我们创建一个简单的Docker编写脚本，它将创建我们的Docker实例。使用的TigerGraph映像允许我们在启动时运行GSQL脚本。让我们把下面的脚本放在<code class="du mv mw mx mm b">src/test/resources/docker/tigergraph.yml</code>下面。</p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="nd ne l"/></div></figure><p id="ae9b" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">其次，让我们将Avast插件包含在我们的<code class="du mv mw mx mm b">build.gradle</code>中。在撰写本文时，最新版本是0.14.0。这个插件将在我们的集成测试中运行我们的TigerGraph Docker编写脚本。</p><pre class="jh ji jj jk fd ml mm mn mo aw mp bi"><span id="0297" class="mq lp hi mm b fi mr ms l mt mu">plugins {<br/>    id "com.avast.gradle.docker-compose" version "0.14.0"<br/>}</span></pre><p id="fbd7" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">现在让我们创建一个验证任务，它将在我们的<code class="du mv mw mx mm b">build.gradle</code>中运行集成测试。在这个例子中，我们将通过在类名中包含<code class="du mv mw mx mm b">IntTest</code>来将JUnit单元测试与集成测试分开。</p><pre class="jh ji jj jk fd ml mm mn mo aw mp bi"><span id="213e" class="mq lp hi mm b fi mr ms l mt mu">test {<br/>    useJUnitPlatform()<br/>    exclude "**/*IntTest*"<br/>    testLogging { events "FAILED", "SKIPPED" }<br/>}</span><span id="b068" class="mq lp hi mm b fi nf ms l mt mu">task intTest(type: Test) {<br/>    useJUnitPlatform()<br/>    description = "Execute integration tests."<br/>    group = "verification"<br/>    include "**/*IntTest*"<br/>    testLogging <strong class="mm hs">{ </strong>events "FAILED", "SKIPPED" <strong class="mm hs">}<br/>    </strong>doFirst <strong class="mm hs">{ </strong>dockerCompose.exposeAsEnvironment(intTest) <strong class="mm hs">}<br/></strong>}</span></pre><p id="2a18" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">然后需要告诉Avast插件我们的Docker编写脚本在哪里，以及它应该与哪个Gradle任务相关联。</p><pre class="jh ji jj jk fd ml mm mn mo aw mp bi"><span id="22d3" class="mq lp hi mm b fi mr ms l mt mu">dockerCompose <strong class="mm hs">{<br/>    </strong>tigerGraphSetup <strong class="mm hs">{<br/>        </strong>useComposeFiles = ["src/test/resources/docker/tigergraph.yml"]<br/>        isRequiredBy(project.tasks.intTest)<br/>    <strong class="mm hs">}<br/>}</strong></span></pre><p id="43ce" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">此时，<code class="du mv mw mx mm b">./gradlew intTest</code>号将会运行</p><ol class=""><li id="1496" class="kt ku hi jz b ka kb kd ke kg kv kk kw ko kx ks ky kz la lb bi translated">通过在Docker编写脚本上执行<code class="du mv mw mx mm b">docker-compose</code>来设置我们的数据库</li><li id="0c3c" class="kt ku hi jz b ka lc kd ld kg le kk lf ko lg ks ky kz la lb bi translated">运行类名中带有<code class="du mv mw mx mm b">IntTest</code>的所有测试</li><li id="e090" class="kt ku hi jz b ka lc kd ld kg le kk lf ko lg ks ky kz la lb bi translated">拆除容器及其相关联的卷</li></ol><h1 id="fd84" class="lo lp hi bd lq lr my lt lu lv mz lx ly ix na iy ma ja nb jb mc jd nc je me mf bi translated">测试前创建模式和安装查询</h1><p id="49e0" class="pw-post-body-paragraph jx jy hi jz b ka mg is kc kd mh iv kf kg mi ki kj kk mj km kn ko mk kq kr ks hb bi translated">为了将我们的测试TigerGraph实例配置成与生产中的模式和查询相似，我们需要在执行测试之前运行GSQL脚本。</p><p id="1166" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">查询将按字母顺序执行，这就是为什么只需在脚本前面加上执行顺序就很方便。</p><h2 id="3bd7" class="mq lp hi bd lq ng nh ni lu nj nk nl ly kg nm nn ma kk no np mc ko nq nr me ho bi translated">创建我们的GSQL脚本</h2><p id="e9ba" class="pw-post-body-paragraph jx jy hi jz b ka mg is kc kd mh iv kf kg mi ki kj kk mj km kn ko mk kq kr ks hb bi translated">让我们从创建第一个GSQL脚本开始，并将其放在<code class="du mv mw mx mm b">src/test/resources/config/1-schema.gsql</code>下。我们将简单地使用<a class="ae jw" href="https://docs.tigergraph.com/start/gsql-101" rel="noopener ugc nofollow" target="_blank"> GSQL 101 </a>中的模式和查询。</p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="nd ne l"/></div></figure><p id="1d94" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">然后，我们可以为我们的查询创建一个单独的脚本，并将其命名为<code class="du mv mw mx mm b">src/test/resources/config/2-queries.gsql</code>。</p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="nd ne l"/></div></figure><h2 id="c488" class="mq lp hi bd lq ng nh ni lu nj nk nl ly kg nm nn ma kk no np mc ko nq nr me ho bi translated">启用运行状况检查</h2><p id="32b4" class="pw-post-body-paragraph jx jy hi jz b ka mg is kc kd mh iv kf kg mi ki kj kk mj km kn ko mk kq kr ks hb bi translated"><code class="du mv mw mx mm b">status</code>查询是任意的，但应该是我们的最后一个查询，因为我们的Docker健康检查将使用它来指示所有查询何时已经成功安装。这是因为TigerGraph查询是按顺序安装的。</p><p id="c5dd" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">Avast插件将只在容器健康时运行测试。让我们调整Docker编写脚本，使其包含健康检查，并将我们的脚本绑定到<code class="du mv mw mx mm b">/docker-entrypoint-initdb.d</code>。</p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="nd ne l"/></div></figure><p id="df47" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">现在运行<code class="du mv mw mx mm b">./gradle intTest</code>将另外建立一个图表模式，并在运行我们的集成测试之前安装查询。这可以进一步扩展，以包括和运行加载作业。</p><h1 id="dbc4" class="lo lp hi bd lq lr my lt lu lv mz lx ly ix na iy ma ja nb jb mc jd nc je me mf bi translated">创建集成测试</h1><p id="f88f" class="pw-post-body-paragraph jx jy hi jz b ka mg is kc kd mh iv kf kg mi ki kj kk mj km kn ko mk kq kr ks hb bi translated">让我们创建一个可以在集成测试期间运行的测试类，它将调用我们的TigerGraph实例。Java 11为我们提供了一些不错的工具来发出HTTP请求，这就是我们与数据库通信的方式。</p><h2 id="8982" class="mq lp hi bd lq ng nh ni lu nj nk nl ly kg nm nn ma kk no np mc ko nq nr me ho bi translated">加载一些测试数据</h2><p id="a531" class="pw-post-body-paragraph jx jy hi jz b ka mg is kc kd mh iv kf kg mi ki kj kk mj km kn ko mk kq kr ks hb bi translated">我们的数据库需要一些虚拟数据来测试。我们可以创建一个简单的JSON有效负载，通过TigerGraph的<a class="ae jw" href="https://docs.tigergraph.com/dev/restpp-api/built-in-endpoints" rel="noopener ugc nofollow" target="_blank">内置端点</a>插入数据。用以下内容创建一个文件<code class="du mv mw mx mm b">src/test/resources/data/payload.json</code>。</p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="nd ne l"/></div></figure><p id="3a23" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">这对于这样一个小例子来说是合适的，但是对于更大的数据集，加载测试数据的另一种方式是通过一个接收CSV文件的加载作业。</p><h2 id="1123" class="mq lp hi bd lq ng nh ni lu nj nk nl ly kg nm nn ma kk no np mc ko nq nr me ho bi translated">设置我们的测试环境</h2><p id="f717" class="pw-post-body-paragraph jx jy hi jz b ka mg is kc kd mh iv kf kg mi ki kj kk mj km kn ko mk kq kr ks hb bi translated">现在在<code class="du mv mw mx mm b">AppTest</code>旁边创建一个名为<code class="du mv mw mx mm b">TigerAppIntTest</code>的测试类。提醒一下，我们将利用<code class="du mv mw mx mm b">IntTest</code>在类名中的事实来区分这是一个集成测试。</p><p id="7a6f" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">我们将通过在一个<code class="du mv mw mx mm b">@BeforeAll</code>方法期间将我们的测试数据插入数据库开始，并在一个<code class="du mv mw mx mm b">@AfterAll</code>方法期间在我们的测试结束时清除数据库。</p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="nd ne l"/></div></figure><h2 id="3949" class="mq lp hi bd lq ng nh ni lu nj nk nl ly kg nm nn ma kk no np mc ko nq nr me ho bi translated">测试查询</h2><p id="a17c" class="pw-post-body-paragraph jx jy hi jz b ka mg is kc kd mh iv kf kg mi ki kj kk mj km kn ko mk kq kr ks hb bi translated">现在我们的测试环境已经设置好了，我们可以测试<code class="du mv mw mx mm b">hello</code>查询了。下面的测试可以做到这一点。</p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="nd ne l"/></div></figure><p id="9a6b" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">一旦建立了数据库，现在运行<code class="du mv mw mx mm b">./gradlew intTest</code>将按以下顺序运行方法:<code class="du mv mw mx mm b">setUpAll</code>、<code class="du mv mw mx mm b">helloQueryTest</code>和<code class="du mv mw mx mm b">tearDownAll</code>。</p><h1 id="118d" class="lo lp hi bd lq lr my lt lu lv mz lx ly ix na iy ma ja nb jb mc jd nc je me mf bi translated">使用GitHub操作运行TigerGraph集成测试</h1><p id="0366" class="pw-post-body-paragraph jx jy hi jz b ka mg is kc kd mh iv kf kg mi ki kj kk mj km kn ko mk kq kr ks hb bi translated">使用我的<code class="du mv mw mx mm b">dbakereffendi/tigergraph</code>映像的一个优点是，考虑到CI/CD服务的资源限制，它们很小。也就是说，从下载映像到安装模式和查询，集成测试阶段仍然非常耗时。</p><p id="d4c1" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">要开始在GitHub Actions上运行我们的测试，请在您的项目<code class="du mv mw mx mm b">.github/workflows/ci.yml</code>的根目录下创建以下文件。</p><figure class="jh ji jj jk fd jl"><div class="bz dy l di"><div class="nd ne l"/></div></figure><p id="2992" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">当您向<code class="du mv mw mx mm b">main</code>分支推送或者有一个拉取请求时，这将运行单元和集成测试。根据您选择的分支名称、操作系统或Java版本调整您的配置，但这里重要的是Gradle命令。</p><h1 id="8828" class="lo lp hi bd lq lr my lt lu lv mz lx ly ix na iy ma ja nb jb mc jd nc je me mf bi translated">结论</h1><p id="f8f9" class="pw-post-body-paragraph jx jy hi jz b ka mg is kc kd mh iv kf kg mi ki kj kk mj km kn ko mk kq kr ks hb bi translated">通过使用Docker、GitHub Actions和Gradle，我们已经成功地用一个本地化的TigerGraph实例免费运行了一个TigerGraph支持的应用程序的集成测试。</p><p id="14bf" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">这可以扩展到运行加载作业，使用Giraffle部署到生产环境，或者在测试期间使用Avast插件运行多个第三方Docker服务。</p><p id="5590" class="pw-post-body-paragraph jx jy hi jz b ka kb is kc kd ke iv kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">提醒一下，本文中讨论的所有内容的完整工作示例可以在<a class="ae jw" href="https://github.com/DavidBakerEffendi/tigergraph-int-test-example" rel="noopener ugc nofollow" target="_blank">我的GitHub库</a>中找到。</p></div></div>    
</body>
</html>