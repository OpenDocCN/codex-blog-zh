<html>
<head>
<title>Efficient Object Creation with The Factory Design Pattern (in JavaScript)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用工厂设计模式高效创建对象(在JavaScript中)</h1>
<blockquote>原文：<a href="https://medium.com/codex/efficient-object-creation-with-the-factory-design-pattern-in-javascript-e99e86b89d9f?source=collection_archive---------15-----------------------#2022-03-30">https://medium.com/codex/efficient-object-creation-with-the-factory-design-pattern-in-javascript-e99e86b89d9f?source=collection_archive---------15-----------------------#2022-03-30</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/d637e49df0b32e72c870a793720ad475.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nFUEIfT7B_kHH6_YhHtKUg.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">代码中的工厂可以被视为现实生活中的工厂——它们可以根据创建所述对象所需的蓝图来生成对象(照片由<strong class="bd iu"> <em class="iv">马修·米尔曼</em> </strong>经由<a class="ae iw" href="https://www.nytimes.com/2021/09/10/realestate/prefabricated-modular-apartments.html" rel="noopener ugc nofollow" target="_blank"> <strong class="bd iu">纽约时报</strong> </a>)</figcaption></figure><p id="08af" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">当处理一个问题时，设计模式是软件开发的关键部分。理解不同的模式增加了开发人员的工具带，以确保在适当的时候选择最合适和有效的解决方案。在我们进入工厂模式本身之前，让我们深入了解一下实际工厂的概念。</p><p id="12f2" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated"><em class="jv">想象一个真实的工厂——它有什么用途？<br/>是根据蓝图生产多种物品(<em class="jv">或物品</em>)的主要场所。然后想想制造过程，就像这样简单:</em></p><p id="cf5c" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">第1—<strong class="iz hj">有人向工厂提出请求，可以要求为他们制造特定的物品</strong><br/>第2—<strong class="iz hj">工厂将从订单请求中指定的物品</strong>中检查其蓝图<br/>第3—<strong class="iz hj">工厂将根据蓝图<strong class="iz hj">制造物品</strong>，并将该物品发送给客户</strong>/请求者使用</p><p id="8b22" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">这整个过程可以比喻为工厂模式、它的实现以及它如何创建对象。对象是JavaScript中最有用和最通用的类型之一，拥有一个高效的创建模式可以使事情更有组织性和逻辑性。</p></div><div class="ab cl jw jx gp jy" role="separator"><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb"/></div><div class="hb hc hd he hf"><h2 id="e6a9" class="kd ke hi bd iu kf kg kh ki kj kk kl km ji kn ko kp jm kq kr ks jq kt ku kv kw bi translated">工厂模式是什么，它是如何工作的？</h2><p id="c608" class="pw-post-body-paragraph ix iy hi iz b ja kx jc jd je ky jg jh ji kz jk jl jm la jo jp jq lb js jt ju hb bi translated">工厂模式可以归类为创建模式，它帮助组织和集中代码中对象的创建。<strong class="iz hj">工厂提供了创建对象的通用接口，</strong>在这里可以指定我们希望创建的对象类型。如果我们以上面的真实工厂为例:<br/>1nd—<strong class="iz hj">我们在代码<br/>中调用我们的工厂</strong>2nd—<strong class="iz hj">指定工厂创建的对象类型</strong>并返回<br/> 3rd — <strong class="iz hj">工厂然后创建所述对象并返回它</strong></p><p id="3c72" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">工厂模式由几部分组成:<br/> <strong class="iz hj">创建者</strong> —声明工厂方法并可能提供默认实现<br/> <strong class="iz hj">具体创建者</strong> — <strong class="iz hj"> </strong>实现/覆盖工厂方法以返回具体产品</p><p id="9749" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated"><strong class="iz hj">产品</strong> —定义由工厂方法<br/> <strong class="iz hj">具体产品</strong>创建的对象的接口—实现产品接口</p><figure class="ld le lf lg fd ij er es paragraph-image"><div class="er es lc"><img src="../Images/9f5c2e1b3d394b89d21154e05d76c098.png" data-original-src="https://miro.medium.com/v2/resize:fit:720/0*Ut6dO-raR5MoL-ER"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">工厂模式图</figcaption></figure></div><div class="ab cl jw jx gp jy" role="separator"><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb"/></div><div class="hb hc hd he hf"><h2 id="b845" class="kd ke hi bd iu kf kg kh ki kj kk kl km ji kn ko kp jm kq kr ks jq kt ku kv kw bi translated">JavaScript中工厂模式的基本实现</h2><p id="df61" class="pw-post-body-paragraph ix iy hi iz b ja kx jc jd je ky jg jh ji kz jk jl jm la jo jp jq lb js jt ju hb bi translated">让我们来看一个使用视频游戏控制台来帮助形象化这个概念的例子:</p><p id="76f8" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated"><strong class="iz hj">1日</strong> — <strong class="iz hj">问题</strong>:在一个<em class="jv">神奇的</em>世界里，微软和索尼联手成立了SonySoft。他们打算在一个屋檐下出售任何一代的游戏机。</p><p id="1ca5" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">SonySoft现在需要一种方法来动态生成任何控制台！</p><p id="fc5b" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated"><strong class="iz hj">第二个</strong> — <strong class="iz hj">对象</strong>:在这种情况下，我们希望能够在用户请求时创建Xboxes和PlayStations，因此这些游戏机将成为我们的对象:</p><div class="ld le lf lg fd ab cb"><figure class="lh ij li lj lk ll lm paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><img src="../Images/9c6c0bb2298e92c6225d19234269f33a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1004/format:webp/1*RiYX2P2Yoi8q4XkxWYjRpg.png"/></div></figure><figure class="lh ij ln lj lk ll lm paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><img src="../Images/68b26fce7e78a4b36116987b85920a4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:998/format:webp/1*c9Dft_u7d1Z4QNikGV1NzQ.png"/></div><figcaption class="iq ir et er es is it bd b be z dx lo di lp lq translated">xbox.js/playStation.js——创建Xbox和PlayStation控制台对象的工厂函数。</figcaption></figure></div><p id="31d2" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">这两个都是<strong class="iz hj">工厂函数，它们能够映射我们从工厂本身传入的属性，然后返回我们想要的对象</strong>(用户指定的控制台)。这消除了在我们的主代码中创建新控制台对象时的冗余和混乱——现在所需要的就是一种传递控制台属性的方法。</p><p id="6e10" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated"><strong class="iz hj">第三</strong> — <strong class="iz hj">工厂</strong>:工厂负责处理对对象的请求，并使用传入的<em class="jv">类型</em>和<em class="jv">属性</em>来控制对象创建方法如何/在哪里处理请求</p><figure class="ld le lf lg fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lr"><img src="../Images/d9e722624fbe13db04dc7c972c78b713.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o_uXcQbC0pKqWHHZNpSYfg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">js——处理我们的控制台创建请求的游戏控制台工厂</figcaption></figure><p id="41d1" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">工厂中的两个主要部分是<strong class="iz hj">console objects</strong>和<strong class="iz hj"> ConsoleType </strong>(导出的createConsole方法中的<em class="jv">)。<strong class="iz hj"><br/>console objects</strong>包含了导入的工厂函数，以备后用。当我们导出createConsole()时，它接受一个<em class="jv">类型</em>参数——这个<em class="jv">类型</em>参数是用户在希望创建一个对象时指定的(该对象将是<em class="jv"> Xbox </em>或<em class="jv"> PlayStation，您将在下一部分</em>中看到)。<br/> <strong class="iz hj">控制台类型</strong>然后使用<em class="jv">类型</em>参数作为关键字，在<strong class="iz hj">控制台对象</strong>内被分配各自的工厂功能。最后，由于ConsoleType被设置为工厂函数，因此它被调用来传入与请求控制台相关联的属性，然后创建实际的控制台对象。</em></p><p id="d48e" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated"><strong class="iz hj">第四</strong> — <strong class="iz hj">创建对象</strong>:</p><p id="d829" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">现在唯一剩下的事情就是导入我们的工厂，并在我们的主代码中使用它来帮助SonySoft制作那些控制台:</p><figure class="ld le lf lg fd ij er es paragraph-image"><div class="er es ls"><img src="../Images/7317e3685a99d7815452d2c95f4aa5ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1126/format:webp/1*jaXcC2dJ5SpM17S4b_PsRQ.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">index . js——创建我们的第一个控制台，这是一个Xbox系列X/S</figcaption></figure><figure class="ld le lf lg fd ij er es paragraph-image"><div class="er es lt"><img src="../Images/c9ca51ba1e7f98e326d576834e73625a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1254/format:webp/1*tXsSxqdMVGZi0hu3KktwuQ.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">index . js——创建我们的第一个控制台，即PlayStation 2</figcaption></figure><figure class="ld le lf lg fd ij er es paragraph-image"><div class="er es lu"><img src="../Images/b2cc24e0dd0d192c60842213e77c884e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1078/format:webp/1*o_YenZ1tnWBxl6y6KrsdAw.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">index . js——创建我们的第一个控制台，这是一个超薄的红色Xbox 360</figcaption></figure><p id="2b3a" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">输出如下—</p><figure class="ld le lf lg fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lv"><img src="../Images/0b6ed9bb496206a656ee35a7cd508af1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xrLjfZn5X-hjXWKio2fa-g.png"/></div></div></figure><div class="ld le lf lg fd ab cb"><figure class="lh ij lw lj lk ll lm paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><img src="../Images/271fa93547ffe67b2d071dfae90fb718.png" data-original-src="https://miro.medium.com/v2/resize:fit:732/format:webp/1*_b24812hGVi28qwPXrDjHQ.jpeg"/></div></figure><figure class="lh ij lx lj lk ll lm paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><img src="../Images/69e4309ba8cc13457f7beca0c95ec7cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:558/format:webp/1*v6S59_CToPHtQvfsVYU3fA.jpeg"/></div></figure><figure class="lh ij ly lj lk ll lm paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><img src="../Images/211b83d12c57c38519e6688b98ef4ccf.png" data-original-src="https://miro.medium.com/v2/resize:fit:714/format:webp/1*7v7nXqNcaVaBMK2u7oc4rw.jpeg"/></div><figcaption class="iq ir et er es is it bd b be z dx lz di ma lq translated"><em class="iv">…和VIOLA </em> —我们能够使用我们的工厂成功地制造出我们的游戏机！</figcaption></figure></div><p id="65e8" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated"><em class="jv">(以上所有代码可在我的GitHub </em> <a class="ae iw" href="https://github.com/AlexDeL8/factory-pattern-example" rel="noopener ugc nofollow" target="_blank"> <strong class="iz hj"> <em class="jv">这里</em> </strong> </a> <em class="jv"> ) </em></p></div><div class="ab cl jw jx gp jy" role="separator"><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb"/></div><div class="hb hc hd he hf"><h2 id="d780" class="kd ke hi bd iu kf kg kh ki kj kk kl km ji kn ko kp jm kq kr ks jq kt ku kv kw bi translated">何时使用工厂模式&amp;何时不使用</h2><p id="6fb0" class="pw-post-body-paragraph ix iy hi iz b ja kx jc jd je ky jg jh ji kz jk jl jm la jo jp jq lb js jt ju hb bi translated">在某些情况下，工厂模式可以很好地解决问题，但也有不太好的情况:</p><p id="3a63" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated"><strong class="iz hj">何时:</strong> <br/> -当<strong class="iz hj">需要根据环境轻松生成对象的不同实例时，工厂会提供帮助</strong> ( <em class="jv">根据项目运行的环境，工厂返回的对象可能包含不同的属性， 比如URL </em> ) <br/> -在需要创建<strong class="iz hj">许多共享相同属性</strong>的小对象或<strong class="iz hj">组件<strong class="iz hj"> <br/> </strong>的情况下工作良好-在c <strong class="iz hj">将对象与其他对象</strong>的实例组合时也工作良好，这些对象只需要<strong class="iz hj">满足一个API契约</strong> ( <em class="jv">又名鸭类型</em>)即可工作(<em class="jv">有助于解耦</em>)</strong></p><p id="d04b" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated"><strong class="iz hj">何时不要:</strong><br/>——如果工厂链接开始变长，那么<strong class="iz hj">在创建对象时会包含很多复杂性</strong>(<em class="jv">当一个工厂创建其他工厂时会出现这种情况——通常可以在</em> <a class="ae iw" href="https://www.youtube.com/watch?v=v-GiuMmsXj4" rel="noopener ugc nofollow" target="_blank"> <strong class="iz hj"> <em class="jv">抽象工厂模式</em> </strong> </a>中找到)</p></div><div class="ab cl jw jx gp jy" role="separator"><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb"/></div><div class="hb hc hd he hf"><h2 id="5d8d" class="kd ke hi bd iu kf kg kh ki kj kk kl km ji kn ko kp jm kq kr ks jq kt ku kv kw bi translated">总结和资源</h2><p id="df9e" class="pw-post-body-paragraph ix iy hi iz b ja kx jc jd je ky jg jh ji kz jk jl jm la jo jp jq lb js jt ju hb bi translated">现在，您可以将这种有用、高效、简洁的创建模式添加到您的工具箱中，用JavaScript创建对象。<strong class="iz hj">继续学习的最好方法是亲自动手</strong> —您可以从在示例代码中创建更多的控制台对象开始，方法是在实现部分的末尾克隆repo，甚至从头开始创建自己的工厂！</p><p id="49b4" class="pw-post-body-paragraph ix iy hi iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hb bi translated">同样可以理解的是，有些人会希望继续深入这个概念，并希望在更多的地方学习更多的知识。关于JavaScript中工厂方法的更多资源，你可以参考下面的: <br/>📖本文受到了《学习JavaScript设计模式的<a class="ae iw" href="https://www.patterns.dev/posts/classic-design-patterns/" rel="noopener ugc nofollow" target="_blank"><strong class="iz hj"/></a><strong class="iz hj"/>书<strong class="iz hj">的影响，由</strong><a class="ae iw" href="https://addyosmani.com/" rel="noopener ugc nofollow" target="_blank"><strong class="iz hj">Addy Osmani</strong></a><strong class="iz hj"/>(以及<a class="ae iw" href="https://www.lydiahallie.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="iz hj"> Lydia Hallie </strong> </a>)。你可以在这里 找到工厂图样部分<a class="ae iw" href="https://www.patterns.dev/posts/factory-pattern/" rel="noopener ugc nofollow" target="_blank"> <strong class="iz hj">。<strong class="iz hj"> </strong> <em class="jv">我强烈建议先去参观这个！<br/>T29】🎥<em class="jv"> </em> <a class="ae iw" href="https://www.youtube.com/watch?v=EcFVTgRHJLM" rel="noopener ugc nofollow" target="_blank"> <strong class="iz hj">视频由克里斯托弗·奥克拉维</strong> </a>(一个更长的深潜模式)<em class="jv"> <br/> </em>🎥<a class="ae iw" href="https://www.youtube.com/watch?v=kuirGzhGhyw" rel="noopener ugc nofollow" target="_blank"><strong class="iz hj"/>【T42视频】(一段较短的编码视频)<br/>🎥</a><a class="ae iw" href="https://www.youtube.com/watch?v=jpegXpQpb3o" rel="noopener ugc nofollow" target="_blank"> <strong class="iz hj">视频由Mosh </strong> </a>(另一个较短的编码视频)编程</em></strong></a></p></div></div>    
</body>
</html>