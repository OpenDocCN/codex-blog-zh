<html>
<head>
<title>Design URL Shorteners</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">设计URL缩写</h1>
<blockquote>原文：<a href="https://medium.com/codex/url-shorteners-f38e87ab821f?source=collection_archive---------3-----------------------#2021-06-18">https://medium.com/codex/url-shorteners-f38e87ab821f?source=collection_archive---------3-----------------------#2021-06-18</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="56da" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">让我们设计一个类似TinyURL的URL缩短服务。该服务将提供重定向到长URL的短别名。</h2></div><p id="450a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">类似服务:<em class="jt"> bit.ly </em>、<em class="jt"> goo.gl </em>、<em class="jt"> 2020.fm </em>等。</p><figure class="jv jw jx jy fd jz er es paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="er es ju"><img src="../Images/fa01ae33ee33c465f5442c8a7701f36c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*n71aPBDy-MbuHZyQ"/></div></div></figure><h1 id="0779" class="kg kh hi bd ki kj kk kl km kn ko kp kq io kr ip ks ir kt is ku iu kv iv kw kx bi translated">为什么我们需要缩短网址？</h1><p id="d96e" class="pw-post-body-paragraph ix iy hi iz b ja ky ij jc jd kz im jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">URL缩短用于为长URL创建较短的别名。当用户点击这些别名时，会被重定向到原始URL。任何URL的较短版本在我们使用它时都会节省很多空间，例如，在打印或发布推文时，因为推文有字符限制。</p><p id="c5e6" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">例如，如果我们通过TinyURL缩短此页面:</p><p id="b15a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><a class="ae ld" href="https://twitter.com/crack_faang/status/1402494889682632716" rel="noopener ugc nofollow" target="_blank">https://twitter.com/crack_faang/status/1402494889682632716</a></p><p id="9582" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们会得到:</p><p id="a0ca" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><a class="ae ld" href="https://tinyurl.com/mjker4pf" rel="noopener ugc nofollow" target="_blank">https://tinyurl.com/mjker4pf</a></p><p id="25e0" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">缩短后的网址几乎是实际网址的1/3。</p><p id="cc26" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">URL缩短用于优化跨设备的链接，跟踪单个链接以分析受众和活动表现，隐藏相关的原始URL等。</p><h1 id="6bba" class="kg kh hi bd ki kj kk kl km kn ko kp kq io kr ip ks ir kt is ku iu kv iv kw kx bi translated">系统的要求和目标</h1><p id="2001" class="pw-post-body-paragraph ix iy hi iz b ja ky ij jc jd kz im jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">我们的网址缩写系统应满足以下要求:</p><h2 id="617e" class="le kh hi bd ki lf lg lh km li lj lk kq jg ll lm ks jk ln lo ku jo lp lq kw lr bi translated">功能要求:</h2><p id="9424" class="pw-post-body-paragraph ix iy hi iz b ja ky ij jc jd kz im jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">1.给定一个URL，我们的服务应该为它生成一个更短且唯一的别名。</p><p id="e501" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">2.当用户访问一个较短的URL时，我们的服务应该将他们重定向到原始链接。</p><p id="28ff" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">3.用户应该可以选择为他们的URL选择一个自定义别名。</p><p id="bca3" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">4.链接将在特定的时间跨度后自动过期；用户还应该能够指定到期时间。</p><h2 id="4cad" class="le kh hi bd ki lf lg lh km li lj lk kq jg ll lm ks jk ln lo ku jo lp lq kw lr bi translated">非功能性需求:</h2><p id="5cc6" class="pw-post-body-paragraph ix iy hi iz b ja ky ij jc jd kz im jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">1.系统应该是高度可用的。这是必需的，因为如果我们的服务关闭，所有的URL重定向将开始失败。</p><p id="a485" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">2.URL重定向应该以最小的延迟实时发生。</p><p id="81e7" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">3.缩短的链接不应该是可猜测的(不可预测)。</p><h2 id="21b2" class="le kh hi bd ki lf lg lh km li lj lk kq jg ll lm ks jk ln lo ku jo lp lq kw lr bi translated">扩展要求:</h2><p id="2bf2" class="pw-post-body-paragraph ix iy hi iz b ja ky ij jc jd kz im jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">1.分析，例如，重定向发生了多少次？</p><p id="440a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">2.其他服务也应该可以通过REST APIs访问我们的服务。</p><h1 id="1744" class="kg kh hi bd ki kj kk kl km kn ko kp kq io kr ip ks ir kt is ku iu kv iv kw kx bi translated">容量估计和限制</h1><p id="5c1b" class="pw-post-body-paragraph ix iy hi iz b ja ky ij jc jd kz im jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">我们的系统会被大量读取；与新的URL缩短相比，会有很多重定向请求。因此，让我们假设读写比为100:1。</p><h2 id="ff83" class="le kh hi bd ki lf lg lh km li lj lk kq jg ll lm ks jk ln lo ku jo lp lq kw lr bi translated">交通量估计</h2><p id="e39a" class="pw-post-body-paragraph ix iy hi iz b ja ky ij jc jd kz im jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">如果我们假设每月有<strong class="iz hj"> 1B新网址缩短</strong>，我们可以预期在同一时间内会有100倍以上的重定向。因此，我们每月将有<strong class="iz hj">100亿次重定向</strong>。</p><p id="debf" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们系统的每秒查询数(QPS)是多少？</p><p id="0e52" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">每秒新的网址缩写</strong> = <code class="du ls lt lu lv b">1B / (30 days * 24 hours * 3600 seconds) ~ 400 URLs/s</code></p><p id="2e62" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">每秒URL重定向或QPS </strong> = <code class="du ls lt lu lv b">100 * URL shortening = 40K/s</code></p><h2 id="fd90" class="le kh hi bd ki lf lg lh km li lj lk kq jg ll lm ks jk ln lo ku jo lp lq kw lr bi translated">存储估计</h2><p id="f5d9" class="pw-post-body-paragraph ix iy hi iz b ja ky ij jc jd kz im jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">因为我们希望1B每个月都有新的URL，并保留这些对象五年，</p><p id="a5b3" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">存储的对象总数</strong> = <code class="du ls lt lu lv b">1B * 5 years * 12 months = 60B</code></p><p id="59e8" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们假设我们存储的每个对象可以是1 KB(只是一个大概，我们稍后会深入研究)；</p><p id="3a0a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">我们需要的总存储量</strong> = <code class="du ls lt lu lv b">60B * 1KB = 60 TB</code></p><h2 id="894a" class="le kh hi bd ki lf lg lh km li lj lk kq jg ll lm ks jk ln lo ku jo lp lq kw lr bi translated">带宽估计</h2><p id="5b08" class="pw-post-body-paragraph ix iy hi iz b ja ky ij jc jd kz im jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">对于写请求，由于每秒钟我们预计会有400个新的URL，所以我们的服务的<strong class="iz hj">总传入数据将会是=每秒400 KB。</strong></p><p id="41a6" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于读取请求，由于每秒钟我们期望大约40K的URL重定向，我们的<strong class="iz hj">服务的总传出数据</strong> = <code class="du ls lt lu lv b">40K * 1KB = 40 MB/s</code></p><h2 id="03a2" class="le kh hi bd ki lf lg lh km li lj lk kq jg ll lm ks jk ln lo ku jo lp lq kw lr bi translated">内存估计</h2><p id="5cd7" class="pw-post-body-paragraph ix iy hi iz b ja ky ij jc jd kz im jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">如果我们想缓存一些经常被访问的热门网址，我们需要多少内存来存储它们？如果我们遵循80–20规则，也就是说20%的URL产生80%的流量，我们会缓存这20%的热门URL。我们会每天缓存URL。</p><p id="6484" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们每天收到的阅读查询数量= <code class="du ls lt lu lv b">40K * 24 hours * 3600 seconds ~= 4 Billion</code></p><p id="607f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了缓存20%的请求，我们需要的内存= <code class="du ls lt lu lv b">0.2 * 4 B * 1 KB ~= 800 GB</code></p><h1 id="0367" class="kg kh hi bd ki kj kk kl km kn ko kp kq io kr ip ks ir kt is ku iu kv iv kw kx bi translated">高水平的估计</h1><p id="0fd8" class="pw-post-body-paragraph ix iy hi iz b ja ky ij jc jd kz im jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">假设每月有5亿个新URL，读写比率为100:1，下面是我们服务的高级评估摘要:请随意使用这个<a class="ae ld" href="https://docs.google.com/spreadsheets/d/1MQ780cyE5UdK3w78tDa44064AkY3vS8cP-VbqrZkl7I/edit?usp=sharing" rel="noopener ugc nofollow" target="_blank"> Excel文件</a>来获得特定于您系统的评估。</p><pre class="jv jw jx jy fd lw lv lx ly aw lz bi"><span id="350c" class="le kh hi lv b fi ma mb l mc md">New URLs: 400/s</span><span id="c957" class="le kh hi lv b fi me mb l mc md">URL redirections: 40 K/s</span><span id="97e5" class="le kh hi lv b fi me mb l mc md">Incoming data: 400 KB/s</span><span id="c44e" class="le kh hi lv b fi me mb l mc md">Outgoing data: 4 MB/s</span><span id="2f5a" class="le kh hi lv b fi me mb l mc md">Storage for 5 years: 60 TB</span><span id="9c59" class="le kh hi lv b fi me mb l mc md">Memory for cache: 800 GB</span></pre><h1 id="a73a" class="kg kh hi bd ki kj kk kl km kn ko kp kq io kr ip ks ir kt is ku iu kv iv kw kx bi translated">系统API</h1><p id="3502" class="pw-post-body-paragraph ix iy hi iz b ja ky ij jc jd kz im jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">我们可以使用SOAP或REST APIs来公开服务的功能。以下可能是用于创建和删除URL的API的定义:</p><h2 id="266e" class="le kh hi bd ki lf lg lh km li lj lk kq jg ll lm ks jk ln lo ku jo lp lq kw lr bi translated">URL创建</h2><pre class="jv jw jx jy fd lw lv lx ly aw lz bi"><span id="a3c0" class="le kh hi lv b fi ma mb l mc md">createURL(api_dev_key, original_url, custom_alias = None, user_name = None, expire_date = None)</span></pre><h2 id="f5d8" class="le kh hi bd ki lf lg lh km li lj lk kq jg ll lm ks jk ln lo ku jo lp lq kw lr bi translated">因素</h2><p id="c525" class="pw-post-body-paragraph ix iy hi iz b ja ky ij jc jd kz im jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated"><strong class="iz hj"> api_dev_key (string): </strong>注册账户的api开发者密钥。这将用于根据分配给用户的配额限制用户。</p><p id="f43b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj"> original_url (string): </strong>要缩短的原始url。</p><p id="5b7a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">custom _ alias(string):</strong>URL的可选自定义键。</p><p id="fb52" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">用户名(字符串):</strong>编码中使用的可选用户名。</p><p id="6621" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj"> expire_date (string): </strong>简称URL的可选截止日期。</p><h2 id="1b79" class="le kh hi bd ki lf lg lh km li lj lk kq jg ll lm ks jk ln lo ku jo lp lq kw lr bi translated">返回(字符串)</h2><p id="699e" class="pw-post-body-paragraph ix iy hi iz b ja ky ij jc jd kz im jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">成功插入会返回缩短的URL。否则，它会返回一个错误代码。</p><h2 id="c6b0" class="le kh hi bd ki lf lg lh km li lj lk kq jg ll lm ks jk ln lo ku jo lp lq kw lr bi translated">URL删除</h2><p id="e5c8" class="pw-post-body-paragraph ix iy hi iz b ja ky ij jc jd kz im jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated"><code class="du ls lt lu lv b">deleteURL(api_dev_key, url_key)</code></p><p id="c4b1" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">其中“url_key”是表示要检索的缩短url的字符串，成功的删除将返回“URL Removed”。</p><h2 id="f5af" class="le kh hi bd ki lf lg lh km li lj lk kq jg ll lm ks jk ln lo ku jo lp lq kw lr bi translated">我们如何发现和防止虐待？​</h2><p id="ceb4" class="pw-post-body-paragraph ix iy hi iz b ja ky ij jc jd kz im jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">例如，任何服务都可能通过消耗当前设计中的所有密钥而使我们破产。因此，为了防止误用，我们可以通过用户的api_dev_key来限制他们在特定时间可以创建或访问多少URL。</p><h1 id="be7b" class="kg kh hi bd ki kj kk kl km kn ko kp kq io kr ip ks ir kt is ku iu kv iv kw kx bi translated">数据库设计</h1><p id="3275" class="pw-post-body-paragraph ix iy hi iz b ja ky ij jc jd kz im jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">关于我们将要存储的数据的性质的一些观察:</p><p id="21ba" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">1.我们需要存储数十亿条记录。</p><p id="c9b0" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">2.我们要存储的每个对象都很小(1K左右)。</p><p id="982a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">3.记录之间没有关系，除非我们想保留哪个用户创建了哪个URL。</p><p id="b315" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">4.我们的服务阅读量很大。</p><h2 id="22e9" class="le kh hi bd ki lf lg lh km li lj lk kq jg ll lm ks jk ln lo ku jo lp lq kw lr bi translated">数据库模式</h2><p id="b5a7" class="pw-post-body-paragraph ix iy hi iz b ja ky ij jc jd kz im jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">我们需要两个表，一个用于存储关于URL映射的信息，另一个用于存储用户数据。</p><figure class="jv jw jx jy fd jz er es paragraph-image"><div class="er es mf"><img src="../Images/b9a21f5349dc5e4e2e9db044033db06e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1088/format:webp/1*XOYOTTpsXqlccdytoY8sZA.png"/></div></figure><p id="26d7" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们应该使用什么样的数据库？</p><p id="3113" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因为我们预期存储数十亿行，并且我们不需要使用对象之间的关系——像DynamoDB、Cassandra或Riak这样的NoSQL商店是更好的选择。NoSQL的选择也更容易扩展。</p><h1 id="434b" class="kg kh hi bd ki kj kk kl km kn ko kp kq io kr ip ks ir kt is ku iu kv iv kw kx bi translated">散列算法</h1><p id="75dc" class="pw-post-body-paragraph ix iy hi iz b ja ky ij jc jd kz im jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">我们在这里解决的问题是为给定的URL生成一个简短且唯一的密钥。在上面提到的例子中，我们得到的缩短后的URL是:“【https://tinyurl.com/mjker4pf】T2，这个URL的最后六个字符就是我们要生成的短键。我们将在此探讨两种解决方案:</p><h1 id="d0b9" class="kg kh hi bd ki kj kk kl km kn ko kp kq io kr ip ks ir kt is ku iu kv iv kw kx bi translated">1.编码实际URL</h1><p id="5392" class="pw-post-body-paragraph ix iy hi iz b ja ky ij jc jd kz im jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">我们可以计算一个唯一的散列(例如，MD5或SHA256等。)的链接。然后可以对散列进行编码以供显示。这种编码可以是base36 ([az，0–9])或base62 ([az，AZ，0–9])，如果我们加上'+'和'/，'就可以使用base64编码。</p><p id="af6a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">短键的长度应该是多少？6、8或10个字符？</p><ul class=""><li id="2ebc" class="mg mh hi iz b ja jb jd je jg mi jk mj jo mk js ml mm mn mo bi translated">使用base64编码，一个六个字母长的密钥将产生64⁶~ = 687亿个可能的字符串。</li><li id="7ca8" class="mg mh hi iz b ja mp jd mq jg mr jk ms jo mt js ml mm mn mo bi translated">使用base64编码，一个八个字母长的密钥将产生64⁸ ~= 281万亿个可能的字符串。</li></ul><p id="ab60" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们需要在5年内生成的唯一URL哈希总数将是1B * 12个月* 5年= 60 B。对于687亿个唯一哈希，让我们假设对于我们的系统，<strong class="iz hj">六个字母的密钥就足够了</strong>。</p><h2 id="69ea" class="le kh hi bd ki lf lg lh km li lj lk kq jg ll lm ks jk ln lo ku jo lp lq kw lr bi translated">我们的解决方案有哪些不同的问题？​</h2><p id="22d0" class="pw-post-body-paragraph ix iy hi iz b ja ky ij jc jd kz im jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">首先，我们的编码方案存在以下几个问题:</p><p id="7c1b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">1.如果多个用户输入同一个网址，可以得到相同的缩短网址，这是不可接受的。</p><p id="1122" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">2.如果URL的一部分是URL编码的呢？</p><p id="0d5b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">例如<a class="ae ld" href="https://twitter.com/crackfang/status/1402494889682632716" rel="noopener ugc nofollow" target="_blank">https://twitter.com/crackfang/status/1402494889682632716</a>和<a class="ae ld" href="https://twitter.com/crackfang/status/1402494889682632716" rel="noopener ugc nofollow" target="_blank">https://Twitter . com/crack Fang % 2f status % 2f 1402494889682632716</a>除了网址编码完全相同。</p><h2 id="2c75" class="le kh hi bd ki lf lg lh km li lj lk kq jg ll lm ks jk ln lo ku jo lp lq kw lr bi translated">这些问题的解决方法</h2><ol class=""><li id="2e6d" class="mg mh hi iz b ja ky jd kz jg mu jk mv jo mw js mx mm mn mo bi translated">如果通过编码URL生成散列由于重复而失败，我们可以将用户id(应该是惟一的)附加到输入URL，使其惟一并生成散列。但是，如果用户没有登录，我们可以要求用户选择一个唯一的密钥。即使在这之后，如果我们有冲突，我们必须继续生成一个密钥，直到我们得到一个唯一的。</li><li id="87d2" class="mg mh hi iz b ja mp jd mq jg mr jk ms jo mt js mx mm mn mo bi translated">我们可以在生成哈希之前对所有URL进行URL解码，因为URL解码是一个<a class="ae ld" href="https://en.wikipedia.org/wiki/Idempotence" rel="noopener ugc nofollow" target="_blank">等幂操作</a>。</li></ol><h1 id="1b88" class="kg kh hi bd ki kj kk kl km kn ko kp kq io kr ip ks ir kt is ku iu kv iv kw kx bi translated">缩短URL的请求流</h1><figure class="jv jw jx jy fd jz er es paragraph-image"><div class="er es my"><img src="../Images/b5ccaccccdd9033a31d1ed71d2e139b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:632/0*ldX4yDig_QtUAPAU"/></div></figure><figure class="jv jw jx jy fd jz er es paragraph-image"><div class="er es mz"><img src="../Images/fb7a07bd540241b7e5c86b8589534ec7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1276/0*jEj-UhabkUr-G76C"/></div></figure><figure class="jv jw jx jy fd jz er es paragraph-image"><div class="er es mz"><img src="../Images/edf85a68c24d2678c6a3d1328763800b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1276/0*GTsCVnXRDoTfJMiM"/></div></figure><figure class="jv jw jx jy fd jz er es paragraph-image"><div class="er es na"><img src="../Images/4428fb048d458b5862986778e20de6f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/0*LP94Iz24G7Ndg4fm"/></div></figure><figure class="jv jw jx jy fd jz er es paragraph-image"><div class="er es nb"><img src="../Images/12dbae06733a574331d59413ef0a440f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1186/0*9tD4P0GCLML5v_8X"/></div></figure><figure class="jv jw jx jy fd jz er es paragraph-image"><div class="er es nc"><img src="../Images/66a07898afc1a7ff5f09de225bfe7d1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1138/0*_6YC8V52BRhhSvNw"/></div></figure><figure class="jv jw jx jy fd jz er es paragraph-image"><div class="er es nd"><img src="../Images/a298261d1a7d00bbf163944e5f7adfb2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1176/0*gtOa2Aouks8OjjDJ"/></div></figure><figure class="jv jw jx jy fd jz er es paragraph-image"><div class="er es ne"><img src="../Images/a2a50f8c496943accf40779fcc3715fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1180/0*UD8CoaWEam1ZHoZw"/></div></figure><h1 id="455c" class="kg kh hi bd ki kj kk kl km kn ko kp kq io kr ip ks ir kt is ku iu kv iv kw kx bi translated">2.离线生成密钥</h1><p id="bf33" class="pw-post-body-paragraph ix iy hi iz b ja ky ij jc jd kz im jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">我们可以有一个独立的<strong class="iz hj">密钥生成服务(KGS) </strong>，它预先生成随机的六个字母的字符串，并将它们存储在一个数据库中(姑且称之为key-DB)。然后，每当我们想要缩短一个URL，我们将只取一个已经生成的键并使用它。这种方法将使事情变得非常简单和快速，因为我们将不会编码的网址或担心重复或冲突。此外，KGS将确保key-DB中插入的所有密钥都是唯一的。</p><h2 id="b04f" class="le kh hi bd ki lf lg lh km li lj lk kq jg ll lm ks jk ln lo ku jo lp lq kw lr bi translated">并发会导致问题吗？​</h2><p id="e885" class="pw-post-body-paragraph ix iy hi iz b ja ky ij jc jd kz im jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">密钥一旦被使用，就应该在数据库中进行标记，并且永远不要再次使用。但是，如果多个服务器同时读取密钥，我们可能会遇到两个或更多服务器试图从数据库中读取同一个密钥的情况。如何解决这个并发问题？</p><p id="2ea7" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">kg可以使用两个表来存储密钥，一个表存储尚未使用的密钥，另一个表存储所有已使用的密钥。因此，只要KGS将密钥提供给其中一个服务器，它就可以将它们移动到used keys表中。</p><p id="c582" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">KGS总是可以在内存中保存一些密钥，这样每当服务器需要它们时，它就可以快速地提供它们。为了简单起见，只要KGS在内存中加载一些键，它就可以将它们移动到used keys表中。这样，我们可以确保每台服务器都获得唯一的密钥。</p><p id="c32d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果KGS在将所有加载的密钥分配给某个服务器之前就死了，我们将会浪费这些密钥，我们可以忽略这些，因为我们有相当多的密钥。</p><p id="fc87" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">KGS还必须确保不向多个服务器提供相同的密钥。为此，在从数据结构中取出密钥并将其交给服务器之前，它必须同步保存密钥的数据结构(或获得一个锁)。</p><h2 id="89d3" class="le kh hi bd ki lf lg lh km li lj lk kq jg ll lm ks jk ln lo ku jo lp lq kw lr bi translated">关键数据库的大小是多少？​</h2><p id="804c" class="pw-post-body-paragraph ix iy hi iz b ja ky ij jc jd kz im jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">使用base64编码，我们可以生成68.7B唯一的六个字母的密钥。因此，如果我们需要一个字节来存储一个字母数字字符，我们可以在6(每个键的字符数)* 60B(唯一键)=&gt; 360 GB中存储所有这些键。</p><h2 id="03af" class="le kh hi bd ki lf lg lh km li lj lk kq jg ll lm ks jk ln lo ku jo lp lq kw lr bi translated">KGS不是单点故障吗？​</h2><p id="b1d6" class="pw-post-body-paragraph ix iy hi iz b ja ky ij jc jd kz im jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">是的，它是。为了解决这个问题，我们可以有一个KGS的备用副本，只要主服务器死亡，它就可以接管生成和提供密钥。</p><h2 id="5e49" class="le kh hi bd ki lf lg lh km li lj lk kq jg ll lm ks jk ln lo ku jo lp lq kw lr bi translated">每个应用服务器可以缓存key-DB中的一些密钥吗？​</h2><p id="54a4" class="pw-post-body-paragraph ix iy hi iz b ja ky ij jc jd kz im jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">是的，这肯定能加快速度。</p><p id="5715" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">虽然在这种情况下，如果应用服务器在使用完所有密钥之前就死掉了，我们最终会丢失这些密钥。这是可以接受的，因为我们有68B个独特的六字母键。</p><h2 id="b43d" class="le kh hi bd ki lf lg lh km li lj lk kq jg ll lm ks jk ln lo ku jo lp lq kw lr bi translated">我们如何执行键查找？​</h2><p id="27c5" class="pw-post-body-paragraph ix iy hi iz b ja ky ij jc jd kz im jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">我们可以在我们的数据库中查找关键字来获得完整的URL。</p><p id="ea4e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果存在，向浏览器返回一个“HTTP 302 Redirect”状态，将存储的URL传递到请求的“Location”字段中。</p><p id="ba0e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果我们系统中不存在该密钥，则发出“HTTP 404 Not Found”状态，或者将用户重定向回主页。</p><h2 id="5785" class="le kh hi bd ki lf lg lh km li lj lk kq jg ll lm ks jk ln lo ku jo lp lq kw lr bi translated">我们应该限制自定义别名的大小吗？​</h2><p id="0188" class="pw-post-body-paragraph ix iy hi iz b ja ky ij jc jd kz im jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">由于我们的服务支持自定义别名，用户可以选择他们喜欢的任何“密钥”，但提供自定义别名不是强制性的。</p><p id="86b4" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但是，对自定义别名施加大小限制以获得一致的URL数据库是合理的(通常也是可取的)。例如，假设用户可以指定最多16个字符长的客户密钥(如上面的数据库模式所示)。</p><h1 id="40c5" class="kg kh hi bd ki kj kk kl km kn ko kp kq io kr ip ks ir kt is ku iu kv iv kw kx bi translated">URL缩短的高级系统设计</h1><figure class="jv jw jx jy fd jz er es paragraph-image"><div class="er es nf"><img src="../Images/d97b3da3dd05f7a71b07124fc470091a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1282/0*K_yvIbd7bMe2hhcl"/></div></figure><h1 id="a3da" class="kg kh hi bd ki kj kk kl km kn ko kp kq io kr ip ks ir kt is ku iu kv iv kw kx bi translated">数据划分</h1><p id="fb61" class="pw-post-body-paragraph ix iy hi iz b ja ky ij jc jd kz im jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">为了扩展我们的数据库，我们需要对它进行分区，以存储数十亿个URL的信息。因此，我们需要开发一个分区方案，将我们的数据划分并存储到不同的数据库服务器上。</p><h2 id="02f6" class="le kh hi bd ki lf lg lh km li lj lk kq jg ll lm ks jk ln lo ku jo lp lq kw lr bi translated">基于范围的划分</h2><p id="b329" class="pw-post-body-paragraph ix iy hi iz b ja ky ij jc jd kz im jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">我们可以根据URL的首字母或散列键将URL存储在单独的分区中。因此，我们将所有以字母“A”开头的URL保存在一个分区中，将那些以字母“B”开头的URL保存在另一个分区中，依此类推。这种方法称为基于范围的分区。我们甚至可以将特定的不经常出现的字母组合到一个数据库分区中。我们应该静态地提出这种分区方案，以便总是可预测地存储/查找文件。</p><p id="eada" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这种方法的主要问题是，例如，它会导致服务器不平衡；如果我们决定将所有以字母“E”开头的URL放入一个DB分区，但后来我们意识到我们有太多以字母“E”开头的URL，我们无法将它们放入一个DB分区。</p><h2 id="2b47" class="le kh hi bd ki lf lg lh km li lj lk kq jg ll lm ks jk ln lo ku jo lp lq kw lr bi translated">基于散列的分区</h2><p id="7b73" class="pw-post-body-paragraph ix iy hi iz b ja ky ij jc jd kz im jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">在这个方案中，我们获取存储对象的散列，并基于这个散列，我们计算出这个对象应该去的DB分区。在我们的例子中，我们可以使用“键”的散列或实际的URL来确定存储文件的分区。我们的哈希函数会将URL随机分配到不同的分区，例如，我们的哈希函数总是可以将任何键映射到[1…256]之间的数字。这个数字代表存储对象的分区。</p><p id="a252" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这种方法仍然会导致分区过载，这可以使用一致哈希来解决。</p><h1 id="37c3" class="kg kh hi bd ki kj kk kl km kn ko kp kq io kr ip ks ir kt is ku iu kv iv kw kx bi translated">隐藏物</h1><p id="da85" class="pw-post-body-paragraph ix iy hi iz b ja ky ij jc jd kz im jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">我们可以缓存经常访问的URL。我们可以使用一些现成的解决方案，如Memcache，它可以存储完整的URL及其各自的哈希。在访问后端存储之前，应用服务器可以快速检查缓存是否有所需的URL。</p><h2 id="e185" class="le kh hi bd ki lf lg lh km li lj lk kq jg ll lm ks jk ln lo ku jo lp lq kw lr bi translated">我们应该有多少个缓存？​</h2><p id="49a8" class="pw-post-body-paragraph ix iy hi iz b ja ky ij jc jd kz im jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">我们可以从20%的日流量开始，并且我们可以根据客户的使用模式来调整我们需要多少缓存服务器。根据上面的估计，我们需要600GB的内存来缓存20%的日常流量。由于现代服务器可以有256GB的内存，我们可以很容易地将所有的缓存放入三台机器中，或者使用一些较小的服务器来存储所有这些热门URL。</p><h2 id="3634" class="le kh hi bd ki lf lg lh km li lj lk kq jg ll lm ks jk ln lo ku jo lp lq kw lr bi translated">哪种缓存回收策略最符合我们的需求？​</h2><p id="8777" class="pw-post-body-paragraph ix iy hi iz b ja ky ij jc jd kz im jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">当缓存满了，我们想用一个更新/更热的URL替换一个链接，我们该如何选择？<strong class="iz hj">最近最少使用(LRU) </strong>可以是我们系统的合理策略。根据此策略，我们首先丢弃最近最少使用的URL。然后，我们可以使用一个<a class="ae ld" href="https://docs.oracle.com/javase/7/docs/api/java/util/LinkedHashMap.html" rel="noopener ugc nofollow" target="_blank">链接的散列图</a>或类似的数据结构来存储我们的URL和散列，跟踪最近访问了哪些URL。</p><p id="d3f2" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了进一步提高效率，我们可以复制我们的缓存服务器，以便在它们之间分配负载。</p><h2 id="5e28" class="le kh hi bd ki lf lg lh km li lj lk kq jg ll lm ks jk ln lo ku jo lp lq kw lr bi translated">如何更新每个缓存副本？​</h2><p id="6a41" class="pw-post-body-paragraph ix iy hi iz b ja ky ij jc jd kz im jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">无论何时出现缓存缺失，我们的服务器都会命中后端数据库。相反，每当发生这种情况时，我们可以更新缓存并将新条目传递给所有缓存副本。每个副本可以通过添加新条目来更新其缓存。如果副本已经有了那个条目，它可以简单地忽略它。</p><h1 id="4c9d" class="kg kh hi bd ki kj kk kl km kn ko kp kq io kr ip ks ir kt is ku iu kv iv kw kx bi translated">访问缩短的URL的请求流</h1><figure class="jv jw jx jy fd jz er es paragraph-image"><div class="er es ng"><img src="../Images/a5cfc3d88fefd4c517e236c7067ee874.png" data-original-src="https://miro.medium.com/v2/resize:fit:882/0*BbPP_7srjNecS-mg"/></div></figure><figure class="jv jw jx jy fd jz er es paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="er es nh"><img src="../Images/05bd51f8e7b54bf41953f81fc5260172.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*mCxcP8ZpWNfmX48H"/></div></div></figure><figure class="jv jw jx jy fd jz er es paragraph-image"><div class="er es ni"><img src="../Images/6141c4258433246277f8bcb88f826b8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1388/0*h8Ul48QjMmiqX1gb"/></div></figure><figure class="jv jw jx jy fd jz er es paragraph-image"><div class="er es ni"><img src="../Images/df6f2206343dd1f342294f12cf2ebb50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1388/0*w8Fbb9NLKA-nFCy5"/></div></figure><figure class="jv jw jx jy fd jz er es paragraph-image"><div class="er es nj"><img src="../Images/f8db8f49a46af40f6fdfadad6da727f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1382/0*cIpaGFxzs6pNRY8N"/></div></figure><figure class="jv jw jx jy fd jz er es paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="er es nk"><img src="../Images/9d2871d6379623610ba3967665989428.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*o6sYvgBuO1j2GAGU"/></div></div></figure><figure class="jv jw jx jy fd jz er es paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="er es nl"><img src="../Images/774b2b4f1d7226c612d0ee1052f6327b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*G4sH2huYYn6jeWI3"/></div></div></figure><figure class="jv jw jx jy fd jz er es paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="er es nm"><img src="../Images/6544a19c7b06b4115411cab28e85336b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*L1SaWEb6iiPA3xtK"/></div></div></figure><figure class="jv jw jx jy fd jz er es paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="er es nm"><img src="../Images/601806311827952892ced592f3498e8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qNz8krKbqlRHcARn"/></div></div></figure><figure class="jv jw jx jy fd jz er es paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="er es nn"><img src="../Images/c5a492ef0a496cf0b5a488e337aeb0c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ZyumgsBeQk46AbY3"/></div></div></figure><h1 id="9b5d" class="kg kh hi bd ki kj kk kl km kn ko kp kq io kr ip ks ir kt is ku iu kv iv kw kx bi translated">负载平衡器(磅)</h1><p id="30b4" class="pw-post-body-paragraph ix iy hi iz b ja ky ij jc jd kz im jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">我们可以在系统的三个位置添加负载平衡层:</p><p id="3193" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">1.客户端和应用服务器之间</p><p id="826e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">2.在应用服务器和数据库服务器之间</p><p id="3298" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">3.在应用服务器和缓存服务器之间</p><p id="444b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最初，可以采用简单的循环法；它将传入的请求平均分配给后端服务器。这种LB实现起来很简单，不会引入任何开销。这种方法的另一个好处是，如果一个服务器死了，LB将把它从轮换中去掉，并停止发送任何流量。循环LB的一个问题是，它不考虑服务器负载。如果一个服务器过载或运行缓慢，LB不会停止向该服务器发送新的请求。为了处理这个问题，可以放置一个更智能的LB解决方案，定期查询后端服务器的负载，并根据负载调整流量。</p><h1 id="264c" class="kg kh hi bd ki kj kk kl km kn ko kp kq io kr ip ks ir kt is ku iu kv iv kw kx bi translated">清除或数据库清理</h1><p id="0f99" class="pw-post-body-paragraph ix iy hi iz b ja ky ij jc jd kz im jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">条目应该永远保留，还是应该被清除？如果达到用户指定的过期时间，链接会发生什么情况？</p><p id="eec5" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果我们选择不断搜索过期链接来删除它们，这将给我们的数据库带来很大压力。</p><p id="9a30" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">相反，我们可以慢慢地删除过期的链接，做一个懒惰的清理。我们的服务将确保只有过期的链接将被删除，虽然一些过期的链接可以生存更长时间，但永远不会返回给用户。</p><ul class=""><li id="f650" class="mg mh hi iz b ja jb jd je jg mi jk mj jo mk js ml mm mn mo bi translated">每当用户试图访问过期的链接时，我们可以删除该链接并向用户返回一个错误。</li><li id="7aca" class="mg mh hi iz b ja mp jd mq jg mr jk ms jo mt js ml mm mn mo bi translated">单独的清理服务可以定期运行，从我们的存储和缓存中删除过期的链接。该服务应该是非常轻量级的，并且被安排为仅在预期用户流量较少时运行。</li><li id="87cf" class="mg mh hi iz b ja mp jd mq jg mr jk ms jo mt js ml mm mn mo bi translated">我们可以为每个链接设置一个默认的到期时间(例如，两年)。</li><li id="1fdd" class="mg mh hi iz b ja mp jd mq jg mr jk ms jo mt js ml mm mn mo bi translated">删除过期的链接后，我们可以将密钥放回key-DB中以供重用。</li></ul><h1 id="1ac1" class="kg kh hi bd ki kj kk kl km kn ko kp kq io kr ip ks ir kt is ku iu kv iv kw kx bi translated">URL缩短的组件设计</h1><figure class="jv jw jx jy fd jz er es paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="er es no"><img src="../Images/15c8c9203632e8c0f05d5ecb1778e519.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Hi7I41V3LUvKW2V8"/></div></div></figure><h1 id="0b64" class="kg kh hi bd ki kj kk kl km kn ko kp kq io kr ip ks ir kt is ku iu kv iv kw kx bi translated">遥感勘测</h1><p id="85dd" class="pw-post-body-paragraph ix iy hi iz b ja ky ij jc jd kz im jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">短网址用了多少次？什么是用户位置，等等。？我们可以统计访问者的国家、访问的日期和时间、涉及点击的网页、浏览器或访问网页的平台等等。我们如何存储这些统计数据？如果它是在每个视图中更新的DB行的一部分，那么当一个流行的URL被许多并发请求包围时会发生什么呢？</p><h1 id="c6a6" class="kg kh hi bd ki kj kk kl km kn ko kp kq io kr ip ks ir kt is ku iu kv iv kw kx bi translated">安全性和权限</h1><p id="ecbc" class="pw-post-body-paragraph ix iy hi iz b ja ky ij jc jd kz im jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">用户可以创建私有URL或允许特定的一组用户访问URL吗？我们可以在数据库中存储每个URL的权限级别(公共/私有)。我们还可以创建一个单独的表来存储有权查看特定URL的用户id。假设我们将数据存储在像Cassandra这样的NoSQL宽列数据库中，存储权限的表的键将是“Hash”(或KGS生成的“key”)，列将存储那些有权查看URL的用户的UserIDs。如果用户没有权限并试图访问一个URL，我们可以发回一个错误(HTTP 401)。</p></div></div>    
</body>
</html>