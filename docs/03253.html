<html>
<head>
<title>Containerizing Your First Application</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将您的第一个应用程序容器化</h1>
<blockquote>原文：<a href="https://medium.com/codex/containerizing-your-application-b1644385e2ef?source=collection_archive---------16-----------------------#2021-08-24">https://medium.com/codex/containerizing-your-application-b1644385e2ef?source=collection_archive---------16-----------------------#2021-08-24</a></blockquote><div><div class="dt gx gy gz ha hb"/><div class="hc hd he hf hg"><div class=""/><div class=""><h2 id="7641" class="pw-subtitle-paragraph ig hi hj bd b ih ii ij ik il im in io ip iq ir is it iu iv iw ix dy translated">让我们讨论一下什么是容器，并运行一个例子。</h2></div><figure class="iz ja jb jc fe jd es et paragraph-image"><div role="button" tabindex="0" class="je jf di jg bf jh"><div class="es et iy"><img src="../Images/8e68c0d39e60eaa67b6aef38bf89a636.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bZYRUC186rFiox2B9OVD9g.jpeg"/></div></div><figcaption class="jk jl eu es et jm jn bd b be z dy translated">由<a class="ae jo" href="https://unsplash.com/@timelabpro?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Timelab Pro </a>在<a class="ae jo" href="https://unsplash.com/s/photos/containers?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="94e8" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">这是<strong class="jr hk">系列的第一部分</strong>，我正在计划一个关于容器的系列。接下来是<strong class="jr hk">谷歌云</strong>上的<strong class="jr hk"> Kubernetes </strong>，敬请关注。</p><p id="1511" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">很难定义容器是什么。让我们从了解它们不是什么开始。容器是<strong class="jr hk">不是虚拟化</strong>；这是最难理解的事情之一，至少对我来说是这样。为什么？嗯，通常我们通过选择我们想要使用的操作系统来开始定义一个容器…</p><h1 id="1d53" class="kl km hj bd kn ko kp kq kr ks kt ku kv ip kw iq kx is ky it kz iv la iw lb lc bi translated">什么是容器？</h1><p id="3414" class="pw-post-body-paragraph jp jq hj jr b js ld ik ju jv le in jx jy lf ka kb kc lg ke kf kg lh ki kj kk hc bi translated">容器是打包我们的应用程序的一种方式，我个人认为它们相当于一个EXE文件，但是对于成年人来说。容器的概念是将一个进程与主机系统中的所有其他进程隔离开来，给你的进程一个自己的文件系统和硬件分区。这意味着启动一个容器和启动一个新进程一样快。与虚拟化相反，启动一个实例可能需要几分钟。</p><p id="2a1a" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">这里，<em class="li">你的进程</em>实际上是由主机系统运行的，容器共享主机OS的内核，OS的共享部分是只读的，因此它们不能访问主机OS的许多工具集；这就是为什么选择操作系统通常是在容器上配置应用程序的第一步。</p><p id="73b9" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">选择操作系统就是选择设置和执行与主机内核匹配的应用程序所需的工具集。</p><p id="397f" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">这就是为什么你不能简单地在Linux上运行Windows容器，反之亦然。</p><p id="568a" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">因此，定义容器包括定义将要运行的应用程序以及这个应用程序需要执行的所有依赖项。</p><blockquote class="lj lk ll"><p id="2c73" class="jp jq li jr b js jt ik ju jv jw in jx lm jz ka kb ln kd ke kf lo kh ki kj kk hc bi translated">如果您的二进制文件没有链接到任何其他库，那么您几乎可以只使用一个二进制文件而不使用其他任何东西。</p></blockquote><h1 id="cf04" class="kl km hj bd kn ko kp kq kr ks kt ku kv ip kw iq kx is ky it kz iv la iw lb lc bi translated">让我们建造一个容器</h1><p id="f623" class="pw-post-body-paragraph jp jq hj jr b js ld ik ju jv le in jx jy lf ka kb kc lg ke kf kg lh ki kj kk hc bi translated"><strong class="jr hk"> <em class="li">这个例子是关于容器而不是app </em> </strong>。在本例中，我们将使用以下工具:</p><ul class=""><li id="e873" class="lp lq hj jr b js jt jv jw jy lr kc ls kg lt kk lu lv lw lx bi translated">码头工人；<a class="ae jo" href="https://docs.docker.com/get-docker/" rel="noopener ugc nofollow" target="_blank">获取Docker </a></li><li id="6843" class="lp lq hj jr b js ly jv lz jy ma kc mb kg mc kk lu lv lw lx bi translated">科特林；<a class="ae jo" href="https://formulae.brew.sh/formula/kotlin#default" rel="noopener ugc nofollow" target="_blank">我用的是酿造</a>；如果你不知道Kotlin是什么以及可能的额外需求(比如Java的JVM ),请查阅官方文档</li><li id="1146" class="lp lq hj jr b js ly jv lz jy ma kc mb kg mc kk lu lv lw lx bi translated">Maven<a class="ae jo" href="https://formulae.brew.sh/formula/maven" rel="noopener ugc nofollow" target="_blank">我用的brew</a>；查看<a class="ae jo" href="https://maven.apache.org/" rel="noopener ugc nofollow" target="_blank">官方文档</a></li></ul><p id="d1f2" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">版本现在不是很重要，因为应用程序没有做任何花哨的事情，只要去找最新的就可以了；安装完工具集后，通过检查每个工具版本来验证它是否安装正确。</p><h2 id="301b" class="md km hj bd kn me mf mg kr mh mi mj kv jy mk ml kx kc mm mn kz kg mo mp lb mq bi translated">验证工具集</h2><p id="b73f" class="pw-post-body-paragraph jp jq hj jr b js ld ik ju jv le in jx jy lf ka kb kc lg ke kf kg lh ki kj kk hc bi translated">码头工人:</p><pre class="iz ja jb jc fe mr ms mt mu aw mv bi"><span id="ee9d" class="md km hj ms b fj mw mx l my mz">$&gt; docker --version<br/>Docker version 20.10.8, build 3967b7d</span></pre><p id="75fe" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">科特林:</p><pre class="iz ja jb jc fe mr ms mt mu aw mv bi"><span id="d460" class="md km hj ms b fj mw mx l my mz">$&gt; kotlin -version<br/>Kotlin version 1.5.21-release-314 (JRE 16.0.2+0)</span></pre><p id="7676" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">Maven:</p><pre class="iz ja jb jc fe mr ms mt mu aw mv bi"><span id="ccbb" class="md km hj ms b fj mw mx l my mz">$&gt; mvn --version<br/><strong class="ms hk">Apache Maven 3.8.2</strong> (ea98e05a04480131370aa0c110b8c54cf726c06f)<br/>Maven home: /usr/local/Cellar/maven/3.8.2/libexec<br/><strong class="ms hk">Java version: 16.0.2</strong>, vendor: <strong class="ms hk">Homebrew</strong>, runtime: /usr/local/Cellar/openjdk/16.0.2/libexec/openjdk.jdk/Contents/Home</span></pre><h2 id="f0e6" class="md km hj bd kn me mf mg kr mh mi mj kv jy mk ml kx kc mm mn kz kg mo mp lb mq bi translated">让我们得到代码</h2><p id="6109" class="pw-post-body-paragraph jp jq hj jr b js ld ik ju jv le in jx jy lf ka kb kc lg ke kf kg lh ki kj kk hc bi translated">现在我们知道我们的工具已经就位，让我们做一些有趣的事情，一些代码克隆。转到您将用作工作目录的文件夹，然后提取repo。</p><pre class="iz ja jb jc fe mr ms mt mu aw mv bi"><span id="ca27" class="md km hj ms b fj mw mx l my mz">git clone <a class="ae jo" href="https://github.com/Escoto/KotlinSpringSample" rel="noopener ugc nofollow" target="_blank">https://github.com/Escoto/KotlinSpringSample.git</a></span></pre><p id="0225" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">Git不是必需的，你可以直接去下载它，但是它会让你的生活更轻松。</p><p id="54c8" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">它带有2个开箱即用的控制器，可以随意修改，但首先要确保它能正常工作。正如我在开始时所说的，这个例子是关于容器而不是代码质量的…</p><figure class="iz ja jb jc fe jd es et paragraph-image"><div role="button" tabindex="0" class="je jf di jg bf jh"><div class="es et na"><img src="../Images/c7de1f974d1c1ba6f961bac80be6ee2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K0uo7bJF7jiuwzno7Z8DkQ.png"/></div></div><figcaption class="jk jl eu es et jm jn bd b be z dy translated"><a class="ae jo" href="https://github.com/Escoto/KotlinSpringSample/blob/main/src/main/kotlin/com/kotlintesting/restapi/RestapiApplication.kt" rel="noopener ugc nofollow" target="_blank">样本代码</a>来自<a class="ae jo" href="https://github.com/Escoto" rel="noopener ugc nofollow" target="_blank"> <strong class="bd kn"> Escoto </strong> </a> (me)</figcaption></figure><p id="fbda" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">在项目的根目录下运行以下命令</p><pre class="iz ja jb jc fe mr ms mt mu aw mv bi"><span id="08df" class="md km hj ms b fj mw mx l my mz">$&gt; mvn compile<br/>$&gt; mvn package</span></pre><p id="feeb" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">都应该是好的；现在测试一下</p><pre class="iz ja jb jc fe mr ms mt mu aw mv bi"><span id="2ec9" class="md km hj ms b fj mw mx l my mz">$&gt; mvn spring-boot:run</span></pre><p id="7b0a" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">一旦它运行，您的控制台应该看起来有点像这样</p><figure class="iz ja jb jc fe jd es et paragraph-image"><div role="button" tabindex="0" class="je jf di jg bf jh"><div class="es et nb"><img src="../Images/e0781718ac96af3961091e31a78de628.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DMmx3G31T503xwGCYPiUHA.png"/></div></div><figcaption class="jk jl eu es et jm jn bd b be z dy translated">Spring应该正在运行并监听端口:8080</figcaption></figure><p id="3d5c" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">检查API是否按预期工作</p><pre class="iz ja jb jc fe mr ms mt mu aw mv bi"><span id="f17e" class="md km hj ms b fj mw mx l my mz"><a class="ae jo" href="http://localhost:8080/" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/</a><br/><a class="ae jo" href="http://localhost:8080/hello/name" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/hello/hame</a></span></pre><p id="97a6" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">在您的浏览器中，您应该会看到<code class="dv nc nd ne ms b">Hello World!</code>。</p><figure class="iz ja jb jc fe jd es et paragraph-image"><div role="button" tabindex="0" class="je jf di jg bf jh"><div class="es et nf"><img src="../Images/47be8574484858ee54e9e6268e0627a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c5mXcOUfddHwVVfgF6hSfQ.png"/></div></div><figcaption class="jk jl eu es et jm jn bd b be z dy translated"><strong class="bd kn">你好世界！</strong>从控制台运行应用程序</figcaption></figure><p id="25dd" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">现在使用控制台中的<code class="dv nc nd ne ms b">ctrl+c</code>停止它。</p><p id="725c" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">如果一切按预期运行，您就可以配置一个<em class="li"> Docker映像</em>。在主目录中，有一个名为<code class="dv nc nd ne ms b">Dockerfile</code>的文件。</p><figure class="iz ja jb jc fe jd es et paragraph-image"><div role="button" tabindex="0" class="je jf di jg bf jh"><div class="es et ng"><img src="../Images/4b986c94b4adc1db0f436cf844f4f7a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*olLLa1OhvuyhGAwXMIYgmQ.png"/></div></div><figcaption class="jk jl eu es et jm jn bd b be z dy translated"><a class="ae jo" href="https://github.com/Escoto/KotlinSpringSample/blob/main/Dockerfile" rel="noopener ugc nofollow" target="_blank">来自<a class="ae jo" href="https://github.com/Escoto" rel="noopener ugc nofollow" target="_blank"> Escoto </a> (me)的样本代码</a></figcaption></figure><p id="ba85" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">这个脚本将</p><ol class=""><li id="02df" class="lp lq hj jr b js jt jv jw jy lr kc ls kg lt kk nh lv lw lx bi translated">使用来自<a class="ae jo" href="https://hub.docker.com/_/openjdk" rel="noopener ugc nofollow" target="_blank"> OpenJDK </a>的docker图像；它已经为我们的应用程序配置了所需的环境。</li><li id="0284" class="lp lq hj jr b js ly jv lz jy ma kc mb kg mc kk nh lv lw lx bi translated">暴露端口<code class="dv nc nd ne ms b">8080</code>；因为我们的应用程序是一个Web-API，所以端口<code class="dv nc nd ne ms b">8080</code>是最常见的端口之一，也是我们的应用程序中配置的默认端口<em class="li">。</em></li><li id="9f3d" class="lp lq hj jr b js ly jv lz jy ma kc mb kg mc kk nh lv lw lx bi translated">将您用<code class="dv nc nd ne ms b">mvn package</code>命令生成的<code class="dv nc nd ne ms b">restapi-1.0.jar</code>复制到这个docker的映像中。</li><li id="147d" class="lp lq hj jr b js ly jv lz jy ma kc mb kg mc kk nh lv lw lx bi translated">配置一个<code class="dv nc nd ne ms b">entrypoint</code>；这基本上告诉了docker如何启动我们的应用程序。</li></ol><p id="a6f8" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">现在让我们构建Docker映像</p><pre class="iz ja jb jc fe mr ms mt mu aw mv bi"><span id="6214" class="md km hj ms b fj mw mx l my mz">$&gt; docker build -t kotlinapihello .</span></pre><p id="0483" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">列出您的Docker图像，以确保它已成功创建</p><pre class="iz ja jb jc fe mr ms mt mu aw mv bi"><span id="5135" class="md km hj ms b fj mw mx l my mz">$&gt; docker images<br/>REPOSITORY       TAG     IMAGE ID       CREATED         SIZE<br/>kotlinapihello   latest  a7d5841c86b9   2 minutes ago   427MB</span></pre><p id="e920" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">现在，让我们开始我们刚刚创建的图像的实例。它将被称为<code class="dv nc nd ne ms b">workinginstance</code>，我们将把计算机的端口<code class="dv nc nd ne ms b">8080</code>映射到你在<code class="dv nc nd ne ms b">Dockerfile</code>中的图像所显示的端口</p><pre class="iz ja jb jc fe mr ms mt mu aw mv bi"><span id="593d" class="md km hj ms b fj mw mx l my mz">$&gt; docker run -d -p 8080:8080 --name workinginstance kotlinapihello</span></pre><ul class=""><li id="9572" class="lp lq hj jr b js jt jv jw jy lr kc ls kg lt kk lu lv lw lx bi translated"><code class="dv nc nd ne ms b">-p</code>配置端口</li><li id="db3d" class="lp lq hj jr b js ly jv lz jy ma kc mb kg mc kk lu lv lw lx bi translated"><code class="dv nc nd ne ms b">--name</code>给实例命名</li><li id="e0b3" class="lp lq hj jr b js ly jv lz jy ma kc mb kg mc kk lu lv lw lx bi translated"><code class="dv nc nd ne ms b">-d</code>到<em class="li">从您的控制台分离</em>正在运行的实例</li></ul><p id="b304" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">不带<code class="dv nc nd ne ms b">-d</code>运行意味着您的映像将<em class="li">附加到</em>您的控制台或任何启动该实例的进程。在这种情况下，这将意味着你不能继续使用这个控制台，直到你<strong class="jr hk">停止</strong>你刚刚<strong class="jr hk">启动</strong>的实例。</p><p id="d525" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">现在！又来了！检查API是否按预期工作</p><pre class="iz ja jb jc fe mr ms mt mu aw mv bi"><span id="b2c8" class="md km hj ms b fj mw mx l my mz"><a class="ae jo" href="http://localhost:8080/" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/</a><br/><a class="ae jo" href="http://localhost:8080/hello/name" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/hello/hame</a></span></pre><p id="3210" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">这是现在运行从你的码头形象！</p><figure class="iz ja jb jc fe jd es et paragraph-image"><div role="button" tabindex="0" class="je jf di jg bf jh"><div class="es et nf"><img src="../Images/47be8574484858ee54e9e6268e0627a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c5mXcOUfddHwVVfgF6hSfQ.png"/></div></div><figcaption class="jk jl eu es et jm jn bd b be z dy translated">你好，世界！从Docker容器中运行的应用程序</figcaption></figure><p id="f9fd" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">现在，让我们来清理一下环境，这样你就不会到处乱放容器了</p><pre class="iz ja jb jc fe mr ms mt mu aw mv bi"><span id="65d1" class="md km hj ms b fj mw mx l my mz">$&gt; docker stop <!-- -->workinginstance<br/>$&gt; docker rm workinginstance</span></pre><p id="296e" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">这只会停止并删除<em class="li">实例</em> <code class="dv nc nd ne ms b">workinginstance</code>，但您的<code class="dv nc nd ne ms b">kotlinghelloapi</code> <em class="li">图像</em>仍会保留在那里。如果您想完成清洗，请同时删除图像:</p><pre class="iz ja jb jc fe mr ms mt mu aw mv bi"><span id="bb43" class="md km hj ms b fj mw mx l my mz">$&gt; docker image rm kotlinapihello</span></pre><h1 id="45a9" class="kl km hj bd kn ko kp kq kr ks kt ku kv ip kw iq kx is ky it kz iv la iw lb lc bi translated">结论</h1><p id="ba68" class="pw-post-body-paragraph jp jq hj jr b js ld ik ju jv le in jx jy lf ka kb kc lg ke kf kg lh ki kj kk hc bi translated">正如我在开头提到的，容器只是包装和应用的另一种方式。</p><p id="68c3" class="pw-post-body-paragraph jp jq hj jr b js jt ik ju jv jw in jx jy jz ka kb kc kd ke kf kg kh ki kj kk hc bi translated">最大的好处是让这种配置<em class="li">准备好发货</em>。这意味着您拥有极大的可移植性，允许您毫不费力地在您的开发/测试/生产环境中复制完全相同的行为。</p></div></div>    
</body>
</html>