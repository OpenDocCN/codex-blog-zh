<html>
<head>
<title>Flutter User Authentication Part 2: Storing Users With The Cubit</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Flutter用户认证第2部分:用Cubit存储用户</h1>
<blockquote>原文：<a href="https://medium.com/codex/flutter-user-authentication-part-2-storing-users-with-the-cubit-6d60c537ce82?source=collection_archive---------1-----------------------#2021-05-28">https://medium.com/codex/flutter-user-authentication-part-2-storing-users-with-the-cubit-6d60c537ce82?source=collection_archive---------1-----------------------#2021-05-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/85a2cbef9fee8d6738aa7e7c115d0ea9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*sWRRJ7-7gXs4wPvE"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">迈克尔·泽兹奇在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="7b84" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在上一篇教程中，我教了你如何构建一个<a class="ae iu" rel="noopener" href="/codex/flutter-user-authentication-part-1-models-and-api-acf33cf42f83">客户模型和认证API</a>。为了让我们的客户对象在我们的小部件中可用，我们将使用<a class="ae iu" href="https://pub.dev/packages/flutter_bloc" rel="noopener ugc nofollow" target="_blank"> flutter_bloc </a>包中的Cubit(在继续之前，请确保安装这个包)。我们开始吧！</p><p id="efab" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">播客:<a class="ae iu" href="https://podcasts.apple.com/us/podcast/coreys-corner/id1479097455" rel="noopener ugc nofollow" target="_blank">https://podcast . apple . com/us/podcast/coreys-corner/id 1479097455</a></p><p id="b70f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">学习编码:<a class="ae iu" href="https://www.youtube.com/channel/UCfd8A1xfzqk7veapUhe8hLQ" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/channel/UCfd8A1xfzqk7veapUhe8hLQ</a></p><h2 id="5008" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">一肘是什么？</h2><p id="8a14" class="pw-post-body-paragraph iv iw hi ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">肘是集团架构的一个子集。<strong class="ix hj">我认为Cubits是贯穿整个应用程序的一种状态形式</strong>。Cubits比Blocs更容易使用，因为它们依靠方法而不是流来处理状态变化，最终这意味着编写更少的代码。</p><h2 id="1f7e" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">创造我们的腕尺</h2><p id="7baa" class="pw-post-body-paragraph iv iw hi ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">关于身份验证，我们需要让用户登录和退出。在我们的cubit类中，我们将创建处理这些事件的方法，并最终改变我们的Cubit的状态。</p><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="28f9" class="jt ju hi ky b fi lc ld l le lf">class CustomerCubit extends Cubit&lt;Customer&gt;{ <br/> CustomerCubit(Customer state) : super(state); <br/><br/>  void login(Customer customer) =&gt; emit(customer);<br/>  <br/>  void logout() =&gt;  emit(null);<br/>  <br/>}</span></pre><p id="9015" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在第一行中，我们创建了自己的cubit对象，状态类型为Customer。第二行基本上是说，如果我们的Cubit没有存储用户，它将继承其父代的状态，也就是null。</p><p id="cf27" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们创建两个方法登录和注销。在每个方法中，我们通过调用emit来设置我们的cubit的状态，这个<strong class="ix hj">本质上是Cubit类的setState()的一个版本。任何从Cubit继承(扩展)的类都可以访问emit。要让客户登录，我们传递一个客户实例，要让用户退出，我们传递null。</strong></p><p id="bd02" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">在不到5行代码中，我们已经为在应用程序中存储客户对象打下了基础。</strong></p><h2 id="bf23" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">使用腕尺</h2><p id="b48f" class="pw-post-body-paragraph iv iw hi ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">为了使我们的Cubit在我们的应用程序中可用，我们必须将我们的Material应用程序小部件包装在BlocProvider中:</p><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="b3ad" class="jt ju hi ky b fi lc ld l le lf">void main() {<br/>  runApp(MyApp());<br/>}<br/><br/>class MyApp extends StatelessWidget {<br/>  @override<br/>  Widget build(BuildContext context) {<br/>    return MultiBlocProvider(<br/>      providers:  [<br/>        BlocProvider&lt;CustomerCubit&gt;(<br/>        create: (BuildContext context) =&gt; CustomerCubit(null)<br/>        ),<br/>      ],<br/>      child: MaterialApp(<br/>        title: 'Corey's Corner',<br/>        theme: ThemeData(<br/>          splashColor: Colors.orange,<br/>          primarySwatch: Colors.orange,<br/>          appBarTheme: AppBarTheme(elevation: 16.0),<br/>        ),<br/>        home: MyHomePage(),<br/>      ),<br/>    );<br/>  }<br/>}</span></pre><p id="03cb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我喜欢从MultiBlocProvider开始，以防以后需要添加更多的Blocs或Cubits。</p><p id="d91b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们基本上只是告诉我们的提供者它将寻找什么类型的类，并告诉它初始状态应该是什么，在这种情况下应该是null，因为没有用户初始登录。</p><h2 id="8357" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">在我们的API调用之后使用Cubit</h2><p id="7a36" class="pw-post-body-paragraph iv iw hi ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">在我们的API请求之后，我们将需要调用我们之前构建的登录方法，查看下面的代码:</p><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="ba5f" class="jt ju hi ky b fi lc ld l le lf">if(req.statusCode == 202){<br/>    var customer = Customer.fromReqBody(req.body);<br/>    BlocProvider.of&lt;CustomerCubit&gt;(context).login(customer); <br/>// a lot more stuff<br/>}</span></pre><p id="d1b8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">假设我们从后端请求中获得了正确的响应代码，我们将访问我们想要使用的cubit的提供者，并使用我们从解码的JSON响应中创建的客户作为参数调用login方法。恭喜你刚刚成功地使用了腕尺！</p><h2 id="0901" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn bi translated">使用BlocBuilder小部件</h2><p id="710c" class="pw-post-body-paragraph iv iw hi ix b iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo ks jq jr js hb bi translated">我们将根据Cubit发出的状态来构建小部件。例如，假设我们有一个带有按钮的导航条。最终，我们的应用程序布局将取决于cubit的状态。</p><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="8eba" class="jt ju hi ky b fi lc ld l le lf">class MyHomePage extends StatelessWidget {<br/>  const MyHomePage({Key key}) : super(key: key);<br/><br/>  @override<br/>  Widget build(BuildContext context) {<br/>    AuthAPI _authAPI = AuthAPI();<br/>    return BlocBuilder&lt;CustomerCubit, User&gt;(<br/>      buildWhen: (previous, current) =&gt; previous != current,<br/>        builder: (BuildContext context, Customer state){<br/>            return Scaffold(<br/>                   appBar: AppBar(<br/>                    title: Text("Corey\'s Corner"),<br/>            leading: state == null ?<br/>            IconButton(icon: Icon(Icons.login),<br/>              onPressed: () {<br/>                Navigator.push(context,<br/>                    MaterialPageRoute(builder: (context) =&gt;     Auth()));<br/>              },<br/>            ) : null, <br/>//more stuff</span></pre><p id="ff03" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在我们的widgets build方法中，我们返回了一个bloc builder，每当我们的状态改变时，它总是会重新构建。builder参数被传递给一个函数，该函数将当前的BuildContext和我们的cubit的状态作为参数。</p><p id="6a64" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在我们可以调用状态函数变量来访问cubit中的数据。在上面的代码中，我们使用三元运算符来构建一个IconButton，如果我们的状态为null(没有客户登录)，它将路由到登录页面。如果我们的状态不是null(登录用户),我们显然不构建任何东西。</p><p id="5005" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">本教程到此为止！请继续关注下一个版本，因为我们将使用<a class="ae iu" href="https://pub.dev/packages/shared_preferences" rel="noopener ugc nofollow" target="_blank">共享首选项包</a>来保持用户登录，即使我们的应用程序关闭。感谢您的阅读，请务必查看<a class="ae iu" href="https://c0reygardner63.medium.com/flutter-user-authentication-part-3-persistent-login-with-shared-preferences-d0ffb64e1745" rel="noopener">第三部分。</a></p><p id="d13c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">播客:<a class="ae iu" href="https://podcasts.apple.com/us/podcast/coreys-corner/id1479097455" rel="noopener ugc nofollow" target="_blank">https://podcast . apple . com/us/podcast/coreys-corner/id 1479097455</a></p><p id="d724" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">学习编码:<a class="ae iu" href="https://www.youtube.com/channel/UCfd8A1xfzqk7veapUhe8hLQ" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/channel/UCfd8A1xfzqk7veapUhe8hLQ</a></p></div></div>    
</body>
</html>