<html>
<head>
<title>Introduction to Kotlin for Java developers — Part 3: Generics</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向Java开发人员的Kotlin介绍—第3部分:泛型</h1>
<blockquote>原文：<a href="https://medium.com/codex/introduction-to-kotlin-for-java-developers-part-3-generics-21e1646ec2ae?source=collection_archive---------12-----------------------#2021-06-26">https://medium.com/codex/introduction-to-kotlin-for-java-developers-part-3-generics-21e1646ec2ae?source=collection_archive---------12-----------------------#2021-06-26</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es im"><img src="../Images/aa0852893e691143c84e1b1cd82266dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*cTOSWA1rjzyQlvW4.png"/></div></div></figure></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><p id="a031" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">在本系列的第三部分中，我将带您游览Kotlin中的泛型。我将概述它们在哪些方面与Java不同。我希望你喜欢读这篇文章，就像我喜欢写它一样！如果你做到了，别忘了鼓掌:-)</p><p id="2f29" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">本系列的其他部分:</p><ul class=""><li id="64f9" class="jw jx hi ja b jb jc jf jg jj jy jn jz jr ka jv kb kc kd ke bi translated">面向Java开发人员的Kotlin简介—第1部分:函数和操作符</li><li id="5799" class="jw jx hi ja b jb kg jf kh jj ki jn kj jr kk jv kb kc kd ke bi translated"><a class="ae kf" rel="noopener" href="/codex/introduction-to-kotlin-for-java-developers-part-2-classes-and-objects-dbafe7cb177d">面向Java开发人员的Kotlin介绍—第2部分:类和对象</a></li></ul></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><p id="cdb9" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">泛型在Kotlin中的工作方式与它们在Java中的工作方式非常相似，只有一个主要区别:Kotlin没有通配符(<code class="du kl km kn ko b">?</code>)。相反，科特林添加了<code class="du kl km kn ko b">in</code>和<code class="du kl km kn ko b">out</code>关键字。这是怎么回事？</p><h1 id="f1b3" class="kp kq hi bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">1.申报地点差异</h1><p id="acd9" class="pw-post-body-paragraph iy iz hi ja b jb ln jd je jf lo jh ji jj lp jl jm jn lq jp jq jr lr jt ju jv hb bi translated">当你在Kotlin中声明一个有通用参数<code class="du kl km kn ko b">T</code>的类<code class="du kl km kn ko b">C</code>时，你可以用这些关键字来注释这个通用参数:</p><ul class=""><li id="a25c" class="jw jx hi ja b jb jc jf jg jj jy jn jz jr ka jv kb kc kd ke bi translated"><code class="du kl km kn ko b">in</code>:如果这样做，编译器会确保<code class="du kl km kn ko b">T</code>在<code class="du kl km kn ko b">C</code>中只作为方法参数类型出现，否则会产生错误。</li><li id="c269" class="jw jx hi ja b jb kg jf kh jj ki jn kj jr kk jv kb kc kd ke bi translated"><code class="du kl km kn ko b">out</code>:如果你这样做，编译器会确保<code class="du kl km kn ko b">T</code>只作为方法返回类型出现在<code class="du kl km kn ko b">C</code>中，否则会产生一个错误。</li></ul><p id="bddf" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">因此，当Kotlin编译器遇到具有泛型参数<code class="du kl km kn ko b">T</code>的类的用法时，它会比Java编译器更聪明，因为它有关于<code class="du kl km kn ko b">T</code>的附加信息。让我们看看这在实践中是如何工作的。</p><p id="d958" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated"><a class="ae kf" href="https://kotlinlang.org/docs/generics.html#declaration-site-variance" rel="noopener ugc nofollow" target="_blank">科特林文档</a></p><h2 id="4d75" class="ls kq hi bd kr lt lu lv kv lw lx ly kz jj lz ma ld jn mb mc lh jr md me ll mf bi translated">1.1生产商</h2><p id="8945" class="pw-post-body-paragraph iy iz hi ja b jb ln jd je jf lo jh ji jj lp jl jm jn lq jp jq jr lr jt ju jv hb bi translated">考虑下面这个只产生<code class="du kl km kn ko b">T</code>实例的接口:</p><figure class="in io ip iq fd ir"><div class="bz dy l di"><div class="mg mh l"/></div></figure><p id="59cc" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">注意，这里没有用关键字<code class="du kl km kn ko b">out</code>声明泛型参数<code class="du kl km kn ko b">T</code>(它应该已经声明了)，所以就编译器而言，<code class="du kl km kn ko b">T</code>可能作为方法参数类型出现，也可能作为方法返回类型出现在接口<code class="du kl km kn ko b">Source</code>中:</p><figure class="in io ip iq fd ir er es paragraph-image"><div class="er es mi"><img src="../Images/c883bc251c070497d910ee012fce97a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:922/format:webp/1*53iotUkTk_4gOu3hr-Rfjw.png"/></div></figure><p id="10bd" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">现在考虑下面的代码，它试图将一个<code class="du kl km kn ko b">Source&lt;String&gt;</code>包装在一个<code class="du kl km kn ko b">Source&lt;Any&gt;</code>变量中:</p><figure class="in io ip iq fd ir"><div class="bz dy l di"><div class="mg mh l"/></div></figure><p id="942f" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">在编译器看来，情况是这样的:</p><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es mj"><img src="../Images/8f2bb6d4179d0ab642382c10c76a043b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-0mCFqKMqgJIUSjlPFCZww.png"/></div></div></figure><p id="9d79" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">由于编译器没有关于<code class="du kl km kn ko b">Source</code>使用参数<code class="du kl km kn ko b">T</code>的方式的信息，它将产生一个错误，因为这种设置可能导致<code class="du kl km kn ko b">Objects</code>潜入只允许<code class="du kl km kn ko b">Strings</code>的地方。</p><p id="651c" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">要在Kotlin中解决这个问题，只需在<code class="du kl km kn ko b">T</code>之前添加<code class="du kl km kn ko b">out</code>关键字，让编译器更智能地处理<code class="du kl km kn ko b">Source </code>接口:</p><figure class="in io ip iq fd ir"><div class="bz dy l di"><div class="mg mh l"/></div></figure><p id="d9a8" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">错误将会消失，因为现在编译器可以确定代码确实是类型安全的:</p><figure class="in io ip iq fd ir er es paragraph-image"><div class="er es mk"><img src="../Images/309897ce2e8270a63027f3d2c21ebd0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1176/format:webp/1*FUQRgrctYJS3OtJTJjoXxw.png"/></div></figure><h2 id="c1c7" class="ls kq hi bd kr lt lu lv kv lw lx ly kz jj lz ma ld jn mb mc lh jr md me ll mf bi translated">1.2消费者</h2><p id="5f18" class="pw-post-body-paragraph iy iz hi ja b jb ln jd je jf lo jh ji jj lp jl jm jn lq jp jq jr lr jt ju jv hb bi translated">同样的道理反过来也适用。考虑下面这个只使用<code class="du kl km kn ko b">T</code>实例的接口:</p><figure class="in io ip iq fd ir"><div class="bz dy l di"><div class="mg mh l"/></div></figure><p id="2629" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">注意，这里没有用关键字<code class="du kl km kn ko b">in</code>声明泛型参数<code class="du kl km kn ko b">T</code>(它应该已经声明了)，所以就编译器而言，<code class="du kl km kn ko b">T</code>可能作为方法参数类型出现，也可能作为方法返回类型出现在接口<code class="du kl km kn ko b">Receiver</code>中:</p><figure class="in io ip iq fd ir er es paragraph-image"><div class="er es ml"><img src="../Images/4244044875efcd327b7d18e9b30d0e6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:926/format:webp/1*sJNYAPIdfuysSPJRZCvdJw.png"/></div></figure><p id="7a46" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">现在考虑下面的代码，它试图将一个<code class="du kl km kn ko b">Receiver&lt;Any&gt;</code>包装在一个<code class="du kl km kn ko b">Receiver&lt;String&gt;</code>变量中:</p><figure class="in io ip iq fd ir"><div class="bz dy l di"><div class="mg mh l"/></div></figure><p id="2e71" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">在编译器看来，情况是这样的:</p><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es mm"><img src="../Images/0366de723c258ca4b3291675d0e9bb72.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Cqd_KeIYVAZjjQiHz1PR1w.png"/></div></div></figure><p id="2b96" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">由于编译器没有关于<code class="du kl km kn ko b">Receiver</code>使用参数<code class="du kl km kn ko b">T</code>的方式的信息，它将产生en错误，因为这种设置可能导致<code class="du kl km kn ko b">Objects</code>偷偷溜到只允许<code class="du kl km kn ko b">Strings</code>的地方。</p><p id="a367" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">要在Kotlin中解决这个问题，只需在<code class="du kl km kn ko b">T</code>之前添加<code class="du kl km kn ko b">in</code>关键字，让编译器更智能地处理<code class="du kl km kn ko b">Receiver </code>接口:</p><figure class="in io ip iq fd ir"><div class="bz dy l di"><div class="mg mh l"/></div></figure><p id="8f5d" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">错误将会消失，因为现在编译器可以确定代码确实是类型安全的:</p><figure class="in io ip iq fd ir er es paragraph-image"><div class="er es mn"><img src="../Images/132898309cd73eb1f32fd3263cb58b52.png" data-original-src="https://miro.medium.com/v2/resize:fit:1138/format:webp/1*S11ChRNmqM0VNS9dXc0mFg.png"/></div></figure><h1 id="a1ff" class="kp kq hi bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">2.使用站点差异</h1><p id="d404" class="pw-post-body-paragraph iy iz hi ja b jb ln jd je jf lo jh ji jj lp jl jm jn lq jp jq jr lr jt ju jv hb bi translated">声明站点差异是好的，但是一些通用参数不能仅仅局限于<code class="du kl km kn ko b">in</code>或<code class="du kl km kn ko b">out</code>。</p><p id="9060" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">以<code class="du kl km kn ko b">Array</code>类为例:</p><figure class="in io ip iq fd ir"><div class="bz dy l di"><div class="mg mh l"/></div></figure><p id="204e" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">假设<code class="du kl km kn ko b">MutableCollection</code>上的<code class="du kl km kn ko b">addAll</code>方法签名简单地声明如下:</p><figure class="in io ip iq fd ir"><div class="bz dy l di"><div class="mg mh l"/></div></figure><p id="cdb5" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">如果我们试图将<code class="du kl km kn ko b">Strings</code>的<code class="du kl km kn ko b">Array</code>添加到<code class="du kl km kn ko b">MutableCollection&lt;Any&gt;</code>中，尽管代码是完全安全的，但这将导致编译器错误，因为据编译器所知，<code class="du kl km kn ko b">addAll</code>方法可能会调用数组中的<code class="du kl km kn ko b">set(index: Int, value: Any)</code>方法，并将任何内容放入我们的<code class="du kl km kn ko b">Strings</code>数组中。</p><p id="de28" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">要解决这个问题，只需让编译器变得更聪明，告诉它如何使用<code class="du kl km kn ko b">addAll</code>方法中的数组。通过将签名更改为以下内容，告诉它您将正常工作并且只从数组中读取数据:</p><figure class="in io ip iq fd ir"><div class="bz dy l di"><div class="mg mh l"/></div></figure><p id="3e58" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">错误将会消失，因为编译器现在可以确保代码是类型安全的。</p><p id="7f01" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">同样的推理也适用于<code class="du kl km kn ko b">in</code>关键字。</p><p id="9ff5" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">这种对<code class="du kl km kn ko b">in</code>和<code class="du kl km kn ko b">out</code>的使用被称为使用位置差异，因为它仅适用于通用参数的一种特定用法。</p><p id="e001" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated"><a class="ae kf" href="https://kotlinlang.org/docs/generics.html#use-site-variance-type-projections" rel="noopener ugc nofollow" target="_blank">科特林文档</a></p><h1 id="d8fe" class="kp kq hi bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">3.恒星投影</h1><p id="744e" class="pw-post-body-paragraph iy iz hi ja b jb ln jd je jf lo jh ji jj lp jl jm jn lq jp jq jr lr jt ju jv hb bi translated">假设您声明了一个带有泛型参数<code class="du kl km kn ko b">T</code>的<code class="du kl km kn ko b">Foo</code>类，该参数有一个上限<code class="du kl km kn ko b">Upper</code>。</p><p id="4505" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">现在假设您想以这样一种方式键入一个<code class="du kl km kn ko b">Foo</code>变量，编译器允许您将任何类型的<code class="du kl km kn ko b">Foo</code>赋给该变量，例如<code class="du kl km kn ko b">Foo&lt;A&gt;</code>、<code class="du kl km kn ko b">Foo&lt;B&gt;</code>、<code class="du kl km kn ko b">Foo&lt;C&gt;</code>等等(只要<code class="du kl km kn ko b">Upper</code>是<code class="du kl km kn ko b">A</code>、<code class="du kl km kn ko b">B</code>和<code class="du kl km kn ko b">C</code>的超类型)。为了在Kotlin中表达变量的类型，您使用了星形投影:您将变量声明为类型<code class="du kl km kn ko b">Foo&lt;*&gt;</code>。</p><p id="8f0a" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">就类型而言，这样的变量是如何表现的呢？返回<code class="du kl km kn ko b">T</code>的<code class="du kl km kn ko b">Foo</code>方法可以返回从类型<code class="du kl km kn ko b">Upper</code>派生的任何东西，因此它们的返回类型变成了<code class="du kl km kn ko b">Upper</code>。对于接受<code class="du kl km kn ko b">T</code>的方法，如果不知道<code class="du kl km kn ko b">T</code> ( <code class="du kl km kn ko b">A</code>、<code class="du kl km kn ko b">B</code>、<code class="du kl km kn ko b">C</code>、…)的确切值，就不可能保证类型安全。所以不能调用这样的方法。</p><p id="967d" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated"><a class="ae kf" href="https://kotlinlang.org/docs/generics.html#star-projections" rel="noopener ugc nofollow" target="_blank">科特林文档</a></p><h1 id="ba18" class="kp kq hi bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">4.一般上限</h1><p id="9448" class="pw-post-body-paragraph iy iz hi ja b jb ln jd je jf lo jh ji jj lp jl jm jn lq jp jq jr lr jt ju jv hb bi translated">可以替换给定类型参数的所有可能类型的集合可以通过使用冒号的上限来限制:</p><figure class="in io ip iq fd ir"><div class="bz dy l di"><div class="mg mh l"/></div></figure><p id="8f8a" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated">如果需要一个以上的上限，可以使用<code class="du kl km kn ko b">where</code>关键字:</p><figure class="in io ip iq fd ir"><div class="bz dy l di"><div class="mg mh l"/></div></figure><p id="ae9b" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated"><a class="ae kf" href="https://kotlinlang.org/docs/generics.html#upper-bounds" rel="noopener ugc nofollow" target="_blank">科特林文档</a></p><h1 id="03b0" class="kp kq hi bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">资源</h1><p id="07f7" class="pw-post-body-paragraph iy iz hi ja b jb ln jd je jf lo jh ji jj lp jl jm jn lq jp jq jr lr jt ju jv hb bi translated"><a class="ae kf" href="https://kotlinlang.org/docs/home.html" rel="noopener ugc nofollow" target="_blank">科特林文档</a></p><p id="8eb3" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated"><a class="ae kf" href="https://play.kotlinlang.org/" rel="noopener ugc nofollow" target="_blank">科特林游乐场</a></p><p id="cb7e" class="pw-post-body-paragraph iy iz hi ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hb bi translated"><a class="ae kf" href="https://play.kotlinlang.org/koans/overview" rel="noopener ugc nofollow" target="_blank">科特林公案</a></p></div></div>    
</body>
</html>