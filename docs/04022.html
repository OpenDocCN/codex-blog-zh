<html>
<head>
<title>The Two-Pointer Technique</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">两点技术</h1>
<blockquote>原文：<a href="https://medium.com/codex/the-two-pointer-technique-8c44b0b3890?source=collection_archive---------2-----------------------#2021-10-18">https://medium.com/codex/the-two-pointer-technique-8c44b0b3890?source=collection_archive---------2-----------------------#2021-10-18</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/165e81d025c2e97fc8736e05d1fde82e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y8PDcO3e8S0sWYCuFOe1tw.jpeg"/></div></div></figure><p id="d915" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在我的算法和数据结构系列的第二部分中，我将解释一种在搜索算法中非常常用的技术:双指针技术。第一部分，JavaScript 中的<em class="jo">滑动窗口问题，不是理解本文内容的先决条件，但它涵盖了另一种对软件工程面试问题有用的常见编码模式，可以在这里阅读<a class="ae jp" href="https://hanreitz.medium.com/sliding-window-problems-27d599c6cc13" rel="noopener">。</a></em></p><h1 id="1f65" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">为什么是两个指针？</h1><p id="aea7" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">许多涉及存储在数组或链表中的数据的问题要求我们找到符合特定条件或标准的数据集。输入两个指针:我们可以使用单个迭代器通过蛮力来解决这些问题，但是这通常涉及到嵌套循环，这成倍地增加了解决方案的时间复杂度。相反，我们可以使用两个指针或迭代器变量来跟踪数据中子集的开始和结束，然后检查条件或标准。</p><h1 id="6d9f" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">认识两点问题</h1><p id="631a" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">由于我目前正在加强我的数据结构和算法知识，我发现最困难的事情之一是识别何时需要使用双指针技术，如果我需要，是哪种类型。这对于其他人来说可能是显而易见的，但既然对我来说是/不是，我将在这里详细解释一下。</p><p id="0757" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">可能需要两点方法的第一个线索</strong>是该问题要求在排序数组或链表中找到一组符合特定模式或约束的元素。与未排序的数组相比，在排序的数组中有关于端点的附加信息。例如，如果一个整数数组按升序排序，我们知道数组的起始位置是最小或最负的整数，结束位置是最大或最正的整数。因此，如果一个问题出现在一个排序的数组中，那么很有可能使用双指针技术来解决这个问题，其中指针最初被赋予数组的第一个和最后一个成员的值。下面举例说明，以便进一步澄清。相比之下，在链表中，最有可能的解决方案是指针前后移动来“寻找”问题的约束或条件。</p><p id="4f73" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">第二个线索可能需要一个双指针方法，这个问题要求在一个链表中找到、插入或删除一些东西。知道链表的确切位置或长度意味着遍历该位置之前的每个节点(如果需要长度，则遍历所有节点)。我们知道列表中的每个节点都连接到列表中的下一个节点，直到列表的末尾。在这种情况下，串联指针或快慢指针方法可能有助于解决问题。下面举例说明了快速指针和慢速指针方法。</p><h1 id="ac5a" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">示例:带有排序输入数组的两个求和问题</h1><p id="48d2" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">问题:给定一个按升序排序的数组，找出两个数字，使它们相加得到一个特定的目标。返回两个数的索引。</p><p id="866f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">约束:输入数组按升序排序，并且只包含一个解。<strong class="is hj">数组是1索引的</strong>。</p><p id="9df5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">伪代码:</p><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="360b" class="lc jr hi ky b fi ld le l lf lg">function(array, target){<br/>  set a left pointer to the first element of the array<br/>  set a right pointer to the last element of the array<br/>  loop through the array; check if left and right add to target<br/>  sum is less than the target, increase left pointer<br/>  sum is greater than the target, decrease right pointer<br/>  once their sum equals the target, return their indices<br/>}</span></pre><p id="5563" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">伪代码说明了两个指针问题的最经典的情况，其中指针从一个排序数组的末端开始。在这种情况下，我们寻找一个数组的两个成员来添加到一个特定的目标值。下面是真正的代码，伪代码留在注释中:</p><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="1c73" class="lc jr hi ky b fi ld le l lf lg">var twoSum = function(numbers, target) { <br/>  // set a left pointer to the first element of the array<br/>  let left = 1; <br/>  // set a right pointer to the last element of the array<br/>  let right = numbers.length<br/>    <br/>  // loop through the array; check if left and right add to target<br/>  while(numbers[left - 1] + numbers[right - 1] !== target){ <br/>    // sum is less than the target, increase left pointer<br/>    if(numbers[left - 1] + numbers[right - 1] &lt; target){<br/>      left++ <br/>    // sum is greater than the target, decrease right pointer<br/>    } else {<br/>      right--<br/>    }<br/>  }<br/>  // once their sum equals the target, return their indices <br/>  return[left, right]<br/>};</span></pre><p id="e9f0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了练习这个问题或尝试不同的解决方案，<a class="ae jp" href="https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/" rel="noopener ugc nofollow" target="_blank">在LeetCode上查看</a>。</p><h1 id="35d6" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">示例:从链接列表的末尾移除第n个元素</h1><p id="71c1" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">问题:写一个函数，接受一个链表的头节点和一个数字n，然后从链表的末尾去掉第n个元素。</p><p id="f54e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">约束:n将小于链表的长度。</p><p id="32fb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">伪代码:</p><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="41b5" class="lc jr hi ky b fi ld le l lf lg">function(head, n) {<br/>  set up two pointers<br/>  initially, both should be equal to the head<br/>  check if the head is the only node + remove it<br/>  iterate the second pointer n places ahead of the first<br/>  if the second pointer is null, remove the head (because the head is the nth from the end if this is the case)<br/>  iterate both pointers until the second pointer is the tail<br/>  if there is a node two ahead of the first pointer, set it as the next node of the first pointer ('dropping' the nth node)<br/>  if there is no node two ahead of the first pointer, the first pointer is now the tail and its next should be set to null<br/>  return head<br/>}</span></pre><p id="4cda" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">伪代码说明了这是一个两个指针的问题，迭代器一前一后地移动。一旦两个指针在链表中相距n，它们以相同的速度移动，直到第二个指针到达尾部。以下是实际代码，带注释的伪代码:</p><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="f972" class="lc jr hi ky b fi ld le l lf lg">var removeNthFromEnd = function(head, n) {<br/>  // set up two pointers<br/>  // initially, both should be equal to the head<br/>  let left = head;<br/>  let right = head;  </span><span id="56ff" class="lc jr hi ky b fi lh le l lf lg">  // check if the head is the only node + remove it<br/>  if(!head.next) return null</span><span id="2c37" class="lc jr hi ky b fi lh le l lf lg">  // iterate the second pointer n places ahead of the first<br/>  let i = 0;<br/>  while(i++ &lt; n){<br/>      right = right.next<br/>  }</span><span id="43f9" class="lc jr hi ky b fi lh le l lf lg">  // if the second pointer is null, remove the head<br/>  // (because the head is the nth from the end if this is the case)<br/>  if(right === null){<br/>      return head = head.next<br/>  }</span><span id="dc1d" class="lc jr hi ky b fi lh le l lf lg">  // iterate both pointers until the second pointer is the tail<br/>  while(right &amp;&amp; right.next){<br/>      right = right.next<br/>      left = left.next<br/>  }<br/>  <br/>  // if there is a node two ahead of the first pointer, <br/>  // set it as the next node of the first pointer <br/>  // ('dropping' the nth node)<br/>  // if there is no node two ahead of the first pointer, <br/>  // the first pointer is now the tail and its next should <br/>  // be set to null<br/>  left.next = left.next.next ? left.next.next : null</span><span id="00b4" class="lc jr hi ky b fi lh le l lf lg">  // return head<br/>  return head<br/>};</span></pre><p id="b85a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">要练习这个问题或尝试不同的解决方案，<a class="ae jp" href="https://leetcode.com/problems/remove-nth-node-from-end-of-list/" rel="noopener ugc nofollow" target="_blank">在LeetCode上查看</a>。</p><h1 id="757a" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">示例:查找链表的中间</h1><p id="7cdc" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb kq jd je jf kr jh ji jj ks jl jm jn hb bi translated">问题:给定一个单链表的头，找到并返回链表的中间节点。如果有两个中间节点，则返回第二个。</p><p id="57b1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">约束:节点的数量范围从1到100，包括1和100。</p><p id="b83a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">伪代码:</p><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="16a5" class="lc jr hi ky b fi ld le l lf lg">function(head){<br/>  set a slow and a fast pointer to the head<br/>  iterate the pointers through the list<br/>  fast should move twice the speed of slow<br/>  once fast reaches the tail, slow will be at the middle <br/>  if there are two middles, slow will be at the second middle<br/>  return slow<br/>}</span></pre><p id="137a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是一个从数学上考虑链表的简单问题。中点是到端点距离的一半，因此，如果我们有一个慢速指针以快速指针一半的速度移动，当快速指针位于尾部时，它将位于中间节点。请记住，我们可以通过下一个节点为空来定义尾节点。以下是实际代码，带注释的伪代码:</p><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="5bae" class="lc jr hi ky b fi ld le l lf lg">var middleNode = function(head) {<br/>  // set a slow and a fast pointer to the head  <br/>  let slow = head;<br/>  let fast = head;</span><span id="7ed1" class="lc jr hi ky b fi lh le l lf lg">  // iterate the pointers through the list<br/>  while(fast !== null &amp;&amp; fast.next !== null){<br/>    // fast should move twice the speed of slow<br/>    slow = slow.next<br/>    fast = fast.next.next<br/>  } </span><span id="e8ca" class="lc jr hi ky b fi lh le l lf lg">  // once fast reaches the tail, slow will be at the middle <br/>  // if there are two middles, slow will be at the second middle<br/>  // return slow  <br/>  return slow<br/>};</span></pre><p id="fed3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">要练习这个问题或尝试不同的解决方案，<a class="ae jp" href="https://leetcode.com/problems/middle-of-the-linked-list/" rel="noopener ugc nofollow" target="_blank">请在LeetCode上查看</a>。</p></div><div class="ab cl li lj gp lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="hb hc hd he hf"><p id="d9ad" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这篇文章中，作为我自己知识建设的一部分，我试图解释一种特定类型的搜索算法是如何使用双指针方法编写的。无论指针是一起开始并前后移动，采用快速和慢速方法，还是从数组的两端开始，这些方法都通过减少代码中所需的循环次数来节省时间。更多练习问题，查看LeetCode对该技术的简要说明和问题列表<a class="ae jp" href="https://leetcode.com/articles/two-pointer-technique/" rel="noopener ugc nofollow" target="_blank">这里</a>。对于另一个不是我的深入解释，请查看这篇<a class="ae jp" href="https://algodaily.com/lessons/using-the-two-pointer-technique" rel="noopener ugc nofollow" target="_blank">文章</a>。</p></div></div>    
</body>
</html>