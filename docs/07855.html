<html>
<head>
<title>SQL Server 2022 Parameter Sensitive Plan (PSP) Optimization</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SQL Server 2022参数敏感计划(PSP)优化</h1>
<blockquote>原文：<a href="https://medium.com/codex/sql-server-2022-parameter-sensitive-plan-psp-optimization-a5e8a319fa0b?source=collection_archive---------3-----------------------#2022-07-01">https://medium.com/codex/sql-server-2022-parameter-sensitive-plan-psp-optimization-a5e8a319fa0b?source=collection_archive---------3-----------------------#2022-07-01</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="7e39" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">下一代智能查询处理的杀手锏！</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/9efff2ee385a9bb584573a406a577407.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Jo-p9zcdy4GGwbXH"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">卡斯帕·卡米尔·鲁宾在<a class="ae jn" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><h2 id="5ca1" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated"><strong class="ak">简介</strong></h2><p id="fd3a" class="pw-post-body-paragraph km kn hi ko b kp kq ij kr ks kt im ku jz kv kw kx kd ky kz la kh lb lc ld le hb bi translated">对参数敏感的计划优化是SQL Server 2022的新特性之一，它是名为<a class="ae jn" href="https://docs.microsoft.com/en-us/sql/relational-databases/performance/intelligent-query-processing?WT.mc_id=DP-MVP-4029181" rel="noopener ugc nofollow" target="_blank">智能查询处理</a>的系列特性的一部分，可在不更改应用程序代码的情况下提高现有工作负载的性能。</p><h2 id="7447" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated"><strong class="ak">参数敏感方案优化</strong></h2><p id="c54b" class="pw-post-body-paragraph km kn hi ko b kp kq ij kr ks kt im ku jz kv kw kx kd ky kz la kh lb lc ld le hb bi translated">SQL Server 2022中的参数敏感计划优化进一步增强了智能查询处理，解决了参数化查询的单个缓存执行计划对于这些参数可能采用的所有值都不是最佳的情况。此问题与SQL Server实现的<a class="ae jn" href="https://docs.microsoft.com/en-gb/sql/relational-databases/query-processing-architecture-guide?WT.mc_id=DP-MVP-4029181#parameters-and-execution-plan-reuse" rel="noopener ugc nofollow" target="_blank">执行计划保存和重用</a>机制有关。执行计划保存和重用机制旨在增加查询的响应时间，因为SQL Server将缓存以前保存和参数化的计划，因此不必在每次运行相同的查询时编译新的计划。这种技术优化了查询的编译时间，但是在存在非均匀数据分布的情况下，它可能会降低性能，这种现象称为<a class="ae jn" href="https://docs.microsoft.com/en-gb/sql/relational-databases/query-processing-architecture-guide?WT.mc_id=DP-MVP-4029181#parameter-sensitivity" rel="noopener ugc nofollow" target="_blank">参数嗅探</a>。更多信息可在文章<a class="ae jn" href="https://docs.microsoft.com/en-gb/azure/azure-sql/identify-query-performance-issues?WT.mc_id=DP-MVP-4029181#ParamSniffing" rel="noopener ugc nofollow" target="_blank">有参数敏感计划(PSP)问题的查询</a>中找到。</p><p id="978e" class="pw-post-body-paragraph km kn hi ko b kp lf ij kr ks lg im ku jz lh kw kx kd li kz la kh lj lc ld le hb bi translated">参数敏感计划将允许您在计划缓存中保存多个活动的执行计划。对于单个参数化查询，每个执行计划都将进行优化，并将根据参数假定的值托管不同的数据大小。每当SQL Server检测到需要使用未保存在参数化查询的计划缓存中的执行计划时，它将为当前参数值计算最佳执行计划。</p><h2 id="39e5" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">测试环境设置</h2><p id="bda9" class="pw-post-body-paragraph km kn hi ko b kp kq ij kr ks kt im ku jz kv kw kx kd ky kz la kh lb lc ld le hb bi translated">为了演示参数敏感计划如何工作，我们将使用PSP数据库，该数据库可以在SQL Server 2022实例中使用以下脚本创建。</p><pre class="iy iz ja jb fd lk ll lm ln aw lo bi"><span id="0336" class="jo jp hi ll b fi lp lq l lr ls">USE [master];<br/>GO</span><span id="2b08" class="jo jp hi ll b fi lt lq l lr ls">-- Drop database PSP if exists<br/>IF (DB_ID('PSP') IS NOT NULL)<br/>BEGIN<br/>  ALTER DATABASE [PSP]<br/>    SET SINGLE_USER WITH ROLLBACK IMMEDIATE;</span><span id="395a" class="jo jp hi ll b fi lt lq l lr ls">  DROP DATABASE [PSP];<br/>END;<br/>GO</span><span id="08aa" class="jo jp hi ll b fi lt lq l lr ls">-- Create database PSP<br/>CREATE DATABASE [PSP]<br/>  ON PRIMARY <br/>  (<br/>    NAME = N'PSPData'<br/>    ,FILENAME = N'C:\SQL\DBs\PSPData.mdf'<br/>  )<br/>  LOG ON <br/>  (<br/>    NAME = N'PSPLog'<br/>    ,FILENAME = N'C:\SQL\DBs\PSPLog.ldf'<br/>  );<br/>GO</span><span id="1e88" class="jo jp hi ll b fi lt lq l lr ls">-- Set recovery model to SIMPLE<br/>ALTER DATABASE [PSP] SET RECOVERY SIMPLE;<br/>GO</span></pre><p id="d586" class="pw-post-body-paragraph km kn hi ko b kp lf ij kr ks lg im ku jz lh kw kx kd li kz la kh lj lc ld le hb bi translated">让我们添加dbo。新创建的PSP数据库的表。以下脚本创建该表并插入一些示例数据。</p><pre class="iy iz ja jb fd lk ll lm ln aw lo bi"><span id="7ba1" class="jo jp hi ll b fi lp lq l lr ls">USE [PSP];<br/>GO</span><span id="0c87" class="jo jp hi ll b fi lt lq l lr ls">DROP TABLE IF EXISTS dbo.Tab_A;<br/>GO</span><span id="8553" class="jo jp hi ll b fi lt lq l lr ls">CREATE TABLE dbo.Tab_A<br/>(<br/>  Col1 INTEGER<br/>  ,Col2 INTEGER<br/>  ,Col3 BINARY(2000)<br/>);<br/>GO</span><span id="99e1" class="jo jp hi ll b fi lt lq l lr ls">-- Insert some data into the sample table<br/>SET NOCOUNT ON;</span><span id="3539" class="jo jp hi ll b fi lt lq l lr ls">BEGIN<br/>  BEGIN TRANSACTION;</span><span id="54af" class="jo jp hi ll b fi lt lq l lr ls">DECLARE @i INTEGER = 0;</span><span id="5e1b" class="jo jp hi ll b fi lt lq l lr ls">WHILE (@i &lt; 10000)<br/>  BEGIN<br/>    INSERT INTO dbo.Tab_A (Col1, Col2) VALUES (@i, @i);<br/>    SET @i+=1;<br/>  END;</span><span id="db87" class="jo jp hi ll b fi lt lq l lr ls">COMMIT TRANSACTION;<br/>END;<br/>GO</span><span id="28a4" class="jo jp hi ll b fi lt lq l lr ls">-- There are much more rows with value 1 than rows with other values<br/>INSERT INTO dbo.Tab_A (Col1, Col2) VALUES (1, 1)<br/>GO 500000</span><span id="498b" class="jo jp hi ll b fi lt lq l lr ls">SET NOCOUNT OFF;<br/>GO</span><span id="7c29" class="jo jp hi ll b fi lt lq l lr ls">-- Create indexes<br/>CREATE INDEX IDX_Tab_A_Col1 ON dbo.Tab_A<br/>(<br/>  [Col1]<br/>);<br/>GO</span><span id="640b" class="jo jp hi ll b fi lt lq l lr ls">CREATE INDEX IDX_Tab_A_Col2 ON dbo.Tab_A<br/>(<br/>  [Col2]<br/>);<br/>GO</span></pre><p id="7b29" class="pw-post-body-paragraph km kn hi ko b kp lf ij kr ks lg im ku jz lh kw kx kd li kz la kh lj lc ld le hb bi translated">dbo中的数据分布。Tab_A表是不一致的，在列Col1和Col2中具有值1的行(510，000行中的500，001行)多于具有其他值的行。</p><p id="2a63" class="pw-post-body-paragraph km kn hi ko b kp lf ij kr ks lg im ku jz lh kw kx kd li kz la kh lj lc ld le hb bi translated">让我们考虑下面的存储过程，它在dbo上执行简单的搜索。Tab _列Col1和Col2的表。</p><pre class="iy iz ja jb fd lk ll lm ln aw lo bi"><span id="d2cf" class="jo jp hi ll b fi lp lq l lr ls">CREATE OR ALTER PROCEDURE dbo.Tab_A_Search<br/>(<br/>  @ACol1 INTEGER<br/>  ,@ACol2 INTEGER<br/>)<br/>AS BEGIN<br/>  SELECT * FROM dbo.Tab_A WHERE (Col1 = @ACol1) AND (Col2 = @ACol2);<br/>END</span></pre><p id="d438" class="pw-post-body-paragraph km kn hi ko b kp lf ij kr ks lg im ku jz lh kw kx kd li kz la kh lj lc ld le hb bi translated">在存储过程的初始编译期间，WHERE子句中列的可用统计信息用于识别非均匀分布，并评估最“有风险”的参数化谓词，最多三个可用谓词。存储过程中使用的谓词影响列Col1和Col2，在这些列上创建的非聚集索引导致了相关统计信息的创建。</p><p id="a261" class="pw-post-body-paragraph km kn hi ko b kp lf ij kr ks lg im ku jz lh kw kx kd li kz la kh lj lc ld le hb bi translated">以下查询显示了描绘Col1列上的数据分布的直方图步骤，其中range_high_key显示了现有的Col1输入值。</p><pre class="iy iz ja jb fd lk ll lm ln aw lo bi"><span id="b44e" class="jo jp hi ll b fi lp lq l lr ls">SELECT<br/>  sh.* <br/>FROM<br/>  sys.stats AS s<br/>CROSS APPLY<br/>  sys.dm_db_stats_histogram(s.object_id, s.stats_id) AS sh<br/>WHERE<br/>  (name = 'IDX_Tab_A_Col1') AND (s.object_id = OBJECT_ID('dbo.Tab_A'));<br/>GO</span></pre><p id="b763" class="pw-post-body-paragraph km kn hi ko b kp lf ij kr ks lg im ku jz lh kw kx kd li kz la kh lj lc ld le hb bi translated">输出如下图所示，您可以看到值为1的range_high_key有500，001条记录，而大多数其他值只有几条记录。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lu"><img src="../Images/7b6110be331a52dbb7513a4f421e97eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Lonqls2R26RlFmOP9IDgaQ.png"/></div></div></figure><p id="d29b" class="pw-post-body-paragraph km kn hi ko b kp lf ij kr ks lg im ku jz lh kw kx kd li kz la kh lj lc ld le hb bi translated">IDX_Tab_A_Col2指数也是类似情况。</p><p id="f819" class="pw-post-body-paragraph km kn hi ko b kp lf ij kr ks lg im ku jz lh kw kx kd li kz la kh lj lc ld le hb bi translated">存储过程dbo的首次执行。Tab_A_Search将参数@ACol1和@ACol2设置为1，这对应于500K记录数据集。</p><pre class="iy iz ja jb fd lk ll lm ln aw lo bi"><span id="8db9" class="jo jp hi ll b fi lp lq l lr ls">EXEC dbo.Tab_A_Search @ACol1 = 1, @ACol2 = 1;</span></pre><p id="4496" class="pw-post-body-paragraph km kn hi ko b kp lf ij kr ks lg im ku jz lh kw kx kd li kz la kh lj lc ld le hb bi translated">下图显示了SQL Server为此输入参数选择的执行计划。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es lv"><img src="../Images/129429b3471a342b3d47ceeb54f4f861.png" data-original-src="https://miro.medium.com/v2/resize:fit:1034/format:webp/1*Jy_vD5rNH2H45KZGmALwcQ.png"/></div></figure><p id="b01a" class="pw-post-body-paragraph km kn hi ko b kp lf ij kr ks lg im ku jz lh kw kx kd li kz la kh lj lc ld le hb bi translated">执行计划显示已经选择了表扫描作为数据访问方法，这对于返回大量行的场景非常有效。在SQL Server和Azure SQL数据库的任何早期版本中，计划缓存和重用此执行计划是参数化查询的默认行为。如果使用这个执行计划来检索几行，效率会很低。</p><p id="11bd" class="pw-post-body-paragraph km kn hi ko b kp lf ij kr ks lg im ku jz lh kw kx kd li kz la kh lj lc ld le hb bi translated">使用SQL Server 2022中兼容级别设置为160的数据库，Parameter Sensitive Plan可以检测这些等式谓词的情况，就像本例中使用的一样(其中Col1 = @ ACol1 ),它将允许您为同一个查询在计划缓存中保留多个活动计划。每个计划将仅用于返回的行数与第一次执行存储过程返回的行数相似的执行。因此，在返回很少几行的执行过程中，我们将有一个更有效的执行计划，使用不同的数据访问方法和不同的计划操作符。将使用索引上的直接指向操作(查找)而不是全扫描(扫描)。</p><pre class="iy iz ja jb fd lk ll lm ln aw lo bi"><span id="d28c" class="jo jp hi ll b fi lp lq l lr ls">EXEC dbo.Tab_A_Search @ACol1 = 33, @ACol2 = 33;<br/>GO</span><span id="500c" class="jo jp hi ll b fi lt lq l lr ls">EXEC dbo.Tab_A_Search @ACol1 = 33, @ACol2 = 25;<br/>GO</span></pre><p id="5590" class="pw-post-body-paragraph km kn hi ko b kp lf ij kr ks lg im ku jz lh kw kx kd li kz la kh lj lc ld le hb bi translated">下面的执行计划显示了一种更有效的索引查找方法，在这种执行中只返回几行。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lw"><img src="../Images/16e79a58623491a64bc1e448fa535cf2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1h5xqm26bLA-85cwfu-8rQ.png"/></div></div></figure><p id="96e8" class="pw-post-body-paragraph km kn hi ko b kp lf ij kr ks lg im ku jz lh kw kx kd li kz la kh lj lc ld le hb bi translated">对于适合使用参数敏感计划进行优化的执行计划，初始编译会生成包含优化逻辑(调度程序表达式)的调度程序计划。调度程序计划基于谓词基数范围边界值映射到查询变量。每个变量都链接到一个执行计划，在该计划中，您将找到最合适的操作符来处理预计由该特定查询变量返回的数据集。</p><p id="ad91" class="pw-post-body-paragraph km kn hi ko b kp lf ij kr ks lg im ku jz lh kw kx kd li kz la kh lj lc ld le hb bi translated">如果数据分布发生重大变化，调度程序计划会自动更新。链接到查询变量的执行计划会根据需要独立地重新编译。</p><p id="28eb" class="pw-post-body-paragraph km kn hi ko b kp lf ij kr ks lg im ku jz lh kw kx kd li kz la kh lj lc ld le hb bi translated">未记录的跟踪标志12619允许您获取有关参数敏感计划在查询存储中执行的优化的详细信息。</p><p id="21ab" class="pw-post-body-paragraph km kn hi ko b kp lf ij kr ks lg im ku jz lh kw kx kd li kz la kh lj lc ld le hb bi translated">sys.query_store_query_variant系统视图允许您监视查询及其变体之间的关系，并允许创建与带有参数的查询相关联的所有查询变体的报告，它代表了通过query_hash进行数据聚合的替代方法。</p><p id="b58a" class="pw-post-body-paragraph km kn hi ko b kp lf ij kr ks lg im ku jz lh kw kx kd li kz la kh lj lc ld le hb bi translated">以下查询从计划缓存中检索数据，并显示同一查询存在两个活动的执行计划，第一个最适合提取大量行，第二个最适合提取少量行。</p><pre class="iy iz ja jb fd lk ll lm ln aw lo bi"><span id="1061" class="jo jp hi ll b fi lp lq l lr ls">SELECT<br/>  usecounts<br/>  ,plan_handle<br/>  ,objtype<br/>  ,text<br/>FROM<br/>  sys.dm_exec_cached_plans <br/>CROSS APPLY<br/>  sys.dm_exec_sql_text (plan_handle)<br/>WHERE<br/>  (text LIKE '%Tab_A%')<br/>AND<br/>  (objtype = 'Prepared');<br/>GO</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lx"><img src="../Images/73d82af242998a7cc04730bf09455c0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rtYItTzc5PyR7Gg3u3WASw.png"/></div></div></figure><h2 id="eab0" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">摘要</h2><p id="3944" class="pw-post-body-paragraph km kn hi ko b kp kq ij kr ks kt im ku jz kv kw kx kd ky kz la kh lb lc ld le hb bi translated">SQL Server 2022中默认启用的查询存储与新一代智能查询处理相结合，允许在一些常见情况下提高性能，而无需更改T-SQL代码。参数敏感计划(PSP)优化代表了这些改进之一，因为它允许在计划缓存中为单个参数化查询保留多个活动执行计划，以解决著名的参数嗅探问题。</p><p id="fd2f" class="pw-post-body-paragraph km kn hi ko b kp lf ij kr ks lg im ku jz lh kw kx kd li kz la kh lj lc ld le hb bi translated">享受SQL Server 2022！</p></div></div>    
</body>
</html>