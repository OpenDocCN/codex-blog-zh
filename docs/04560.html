<html>
<head>
<title>Is swiftUI suitable for production?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">swiftUI适合生产吗？</h1>
<blockquote>原文：<a href="https://medium.com/codex/is-swiftui-suitable-for-production-4a92eb55751b?source=collection_archive---------3-----------------------#2021-12-13">https://medium.com/codex/is-swiftui-suitable-for-production-4a92eb55751b?source=collection_archive---------3-----------------------#2021-12-13</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="f67f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我好几次面对这个问题<em class="jd">我们可以使用swiftUI来构建我们的视图吗？。</em>作为一名iOS开发人员，我想使用SwiftUI、Combine甚至新的并发API等最新工具。但是当我们开发一个面向成百上千甚至上百万用户的应用程序时，我们必须优先考虑客户，而不是我们的需求。</p><p id="51c3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这就是为什么这个问题的答案总是:<em class="jd">是的，我们可以引进它，但是你为什么认为我们必须采用它？</em>在本文中，我将尝试解释使用swiftUI构建基本流程的好处，并解释其优缺点。</p><h1 id="df29" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">我们的要求</h1><p id="28b8" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">在开始之前，我们必须现实一点，我们希望只使用swiftUI将我们的应用程序部署到iOS 13+,我们不能使用任何其他UI框架，如UIKit或AppKit。由于swiftUI的主要优势之一是其跨平台支持，我们希望在macOS上部署我们的应用程序(不使用catalyst)</p><p id="f938" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦我们定义了我们的需求，让我们检查我们想要构建的流:</p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es kh"><img src="../Images/3671b4946b49cc9661c4804083e68e34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ICWYZ_5PZBzXZyAjO3jvag.png"/></div></div></figure><p id="7e09" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如您所见，第一个屏幕将推送登录表单，登录将呈现一个模式化的屏幕。</p><h1 id="d56e" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">优势</h1><p id="8b8b" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">SwiftUI是如此强大，它所具有的提高生产力的最好的特性之一是预览，它允许你非常快速地创建你的界面。它增加了在你的界面中使用像<a class="ae kt" href="https://atomicdesign.bradfrost.com/chapter-2/" rel="noopener ugc nofollow" target="_blank">原子设计</a> n这样的设计模式的好处。</p><p id="e1e1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你将能够忘记破坏约束的错误，因为你将把时间花在填充等编码时更安全使用的东西上。</p><p id="228e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">学习曲线很难，因为swiftUI依赖于泛型、关联类型等概念，这对于新手来说尤其困难，但实时可视化您的更改的可能性允许您实时测试和理解您正在做的事情(如果您需要，可以使用UIKit实现相同的功能)。</p><p id="4d2d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">完全是反应式的。如果你将swiftUI与Combine(我个人推荐)一起使用，你将会看到两个框架之间的完全兼容性，允许你使用两者的所有优势。</p><p id="5003" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">内存管理非常简单，因为您的视图将用结构而不是类来建模，从而减少了获得保留周期的可能性。当您与团队中的初级开发人员打交道时，这一点非常重要。</p><p id="fb45" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是最主要的是跨平台支持。你现在不需要对你的接口编码两次(如果你想完全重用你的接口),因为你现在可以编码一次，然后把代码共享给macOS和iOS。</p><h1 id="9f7a" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">不足之处</h1><p id="c66b" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">如果你真的想使用swiftUI，你会发现它有几个缺点。</p><p id="d1cb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">在建</strong></p><p id="b31f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们都知道UIKit或AppKit有多老，swiftUI有多新。在我看来，我们还不能放弃swiftUI，因为我们必须假设我们不能用一个2-3年前的框架获得UIKit给我们的所有可能性。每一次迭代都会增加越来越多的可能性。但是，我们的客户不能提供更差的体验，因为迫使我们使用swiftUI，我将向您展示一些示例。</p><p id="1d91" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您将面临的第一个问题是缺乏API。是的，如果你支持最新的iOS，这可能不会成为你代码中的问题，但是正如我们所说的，我们必须支持3个不同的iOS版本。</p><p id="277c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在swiftUI中，响应者管理等非常基本的交互并不简单，在iOS 13或14中，如果不依赖于旧的框架，几乎不可能实现。从iOS 15开始，focus API为我们打开了一堆管理响应器的可能性，但如果你只是想在iOS 13上使用响应器，你将不得不依赖于<em class="jd">uiviewreclarable</em>来实现这一行为</p><pre class="ki kj kk kl fd ku kv kw kx aw ky bi"><span id="6f5b" class="kz jf hi kv b fi la lb l lc ld">struct LegacyTextField: UIViewRepresentable {<br/>    @Binding public var isFirstResponder: Bool<br/>    @Binding public var text: String<br/><br/>    public var configuration = { (view: UITextField) in }<br/><br/>    public init(text: Binding&lt;String&gt;, isFirstResponder: Binding&lt;Bool&gt;, configuration: @escaping (UITextField) -&gt; () = { _ in }) {<br/>        self.configuration = configuration<br/>        self._text = text<br/>        self._isFirstResponder = isFirstResponder<br/>    }<br/><br/>    public func makeUIView(context: Context) -&gt; UITextField {<br/>        let view = UITextField()<br/>        view.setContentCompressionResistancePriority(.defaultLow, for: .horizontal)<br/>        view.addTarget(context.coordinator, action: #selector(Coordinator.textViewDidChange), for: .editingChanged)<br/>        view.delegate = context.coordinator<br/>        return view<br/>    }<br/><br/>    public func updateUIView(_ uiView: UITextField, context: Context) {<br/>        uiView.text = text<br/>        configuration(uiView)<br/>        switch isFirstResponder {<br/>        case true: uiView.becomeFirstResponder()<br/>        case false: uiView.resignFirstResponder()<br/>        }<br/>    }<br/><br/>    public func makeCoordinator() -&gt; Coordinator {<br/>        Coordinator($text, isFirstResponder: $isFirstResponder)<br/>    }<br/><br/>    public class Coordinator: NSObject, UITextFieldDelegate {<br/>        var text: Binding&lt;String&gt;<br/>        var isFirstResponder: Binding&lt;Bool&gt;<br/><br/>        init(_ text: Binding&lt;String&gt;, isFirstResponder: Binding&lt;Bool&gt;) {<br/>            self.text = text<br/>            self.isFirstResponder = isFirstResponder<br/>        }<br/><br/>        @objc public func textViewDidChange(_ textField: UITextField) {<br/>            self.text.wrappedValue = textField.text ?? ""<br/>        }<br/><br/>        public func textFieldDidBeginEditing(_ textField: UITextField) {<br/>            self.isFirstResponder.wrappedValue = true<br/>        }<br/><br/>        public func textFieldDidEndEditing(_ textField: UITextField) {<br/>            self.isFirstResponder.wrappedValue = false<br/>        }<br/>    }<br/>}<!-- --> </span></pre><p id="9c34" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是当我们要求用相同的源代码支持macOS时，我们将不得不开始使用编译标志来支持两个平台，所有的优势都消失了。</p><p id="3c24" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">导航也是如此。由于iOS 13中缺乏API，像模态这样非常基本的导航可能会变得很困难。迫使您使用自定义的viewModifiers来实现相同的用户体验。</p><p id="cff8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">视图是状态的函数</strong></p><p id="1130" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">SwiftUI提出了一个新的接口范例。视图是状态的函数，是一种将状态数据转换成渲染图的算法。这解释了为什么从SwiftUI视图中提取路由是一个相当大的挑战:<strong class="ih hj">路由是这个绘制算法不可或缺的一部分。</strong></p><p id="5f68" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这就是我认为swiftUI无法与UIKit或AppKit等框架竞争的地方。构建动态导航树是相当困难的，你至少要在某一点上声明你的导航层次，强迫你到一个特定的导航树。</p><h1 id="e182" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">结论</h1><p id="3344" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">这都在你的要求中，如果你必须处理你的应用程序，这个应用程序被数百万用户使用，我可能会说不，就像你在swift的第一个版本中拒绝采用swift作为你的语言代码而不是objective-c一样。但是，事情可能会在未来发生变化，swiftUI是一个我们都必须开始使用并学习如何处理的框架，因为它是未来的发展方向。</p><p id="6e28" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我目前正在使用swiftUI从头开始重建我的应用程序<a class="ae kt" href="https://nalu.gitlab.io/#/" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">路娜</strong> </a> <strong class="ih hj"> </strong>。所以我会在这篇文章中不断更新我发现的新问题或优势。</p><p id="46fa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你想知道发布编译代码而不是源代码的好处，可以看看我的帖子:</p><div class="le lf ez fb lg lh"><a rel="noopener follow" target="_blank" href="/@alb.garciam/reduce-build-times-on-your-ios-app-86a964e0f3bf"><div class="li ab dw"><div class="lj ab lk cl cj ll"><h2 class="bd hj fi z dy lm ea eb ln ed ef hh bi translated">减少iOS应用程序的构建时间</h2><div class="lo l"><h3 class="bd b fi z dy lm ea eb ln ed ef dx translated">如果你是一名开发人员，你可能会面临这样的情况，你的应用程序需要太多的时间来编译。</h3></div><div class="lp l"><p class="bd b fp z dy lm ea eb ln ed ef dx translated">medium.com</p></div></div><div class="lq l"><div class="lr l ls lt lu lq lv kr lh"/></div></div></a></div><p id="b0d9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你喜欢这些帖子，请别忘了给我鼓掌，如果你想让我写另一个话题，别忘了添加到评论中。</p></div></div>    
</body>
</html>