<html>
<head>
<title>Why you should stop using retrying in python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么应该停止在python中使用重试</h1>
<blockquote>原文：<a href="https://medium.com/codex/why-you-should-stop-using-retrying-in-python-fb33d43412ab?source=collection_archive---------8-----------------------#2022-06-29">https://medium.com/codex/why-you-should-stop-using-retrying-in-python-fb33d43412ab?source=collection_archive---------8-----------------------#2022-06-29</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="78b2" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">不再维护重试。用韧性代替。</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/5323427dd99d457d2c9a58b90ca4d8ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3rUg6qeLSYKMFymr"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">照片由<a class="ae jn" href="https://unsplash.com/@hngstrm?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">亨利&amp;公司</a>在<a class="ae jn" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><h1 id="67e1" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">简介:</h1><p id="1bbb" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">如果你是一个web开发人员，你应该知道服务器错误有多烦人，或者任何与此相关的错误。想象一下，有一大块下载/上传文件的代码，最后在第n分钟抛出了一个<code class="du lc ld le lf b">exception</code>。不幸的是，这种事经常发生。相信我，伙计，我也经历过。</p><p id="c0d1" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp li kr ks kt lj kv kw kx lk kz la lb hb bi translated">作为一名开发人员，我们不仅应该提供没有错误的代码(让我把它改写成错误最少的代码😉)，但也是一个优雅的失败，一个信息性的错误消息，也许还有一个重试机制。</p><p id="3d85" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp li kr ks kt lj kv kw kx lk kz la lb hb bi translated">python中有多个重试库，我们现在用它们来实现指数回退。有几个是，</p><p id="ff6d" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp li kr ks kt lj kv kw kx lk kz la lb hb bi translated">很遗憾，不再支持重试。我们从重试中派生出另一个库，叫做<a class="ae jn" href="https://pypi.org/project/tenacity/" rel="noopener ugc nofollow" target="_blank"> tenacity </a>。今天，我们来讨论一下<code class="du lc ld le lf b">tenacity</code>为我们提供了哪些功能。</p><h1 id="c75e" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">韧性:</h1><p id="99ed" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">Tenacity是一个Apache 2.0许可的通用重试库，用Python编写，用于简化向任何东西添加重试行为的任务。它源于<a class="ae jn" href="https://github.com/rholder/retrying/issues/65" rel="noopener ugc nofollow" target="_blank">重试</a>的一个分支，遗憾的是不再被<a class="ae jn" href="https://julien.danjou.info/python-tenacity/" rel="noopener ugc nofollow" target="_blank">维护</a>。Tenacity与重试不兼容，但增加了重要的新功能，并修复了一些长期存在的错误。</p><h2 id="79c0" class="ll jp hi bd jq lm ln lo ju lp lq lr jy kp ls lt ka kt lu lv kc kx lw lx ke ly bi translated">安装:</h2><pre class="iy iz ja jb fd lz lf ma mb aw mc bi"><span id="baa1" class="ll jp hi lf b fi md me l mf mg">$pip install tenacity</span></pre><h1 id="43c5" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">无条件简单重试:</h1><p id="0a3f" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">下面的代码，<code class="du lc ld le lf b">retries</code>永远不带任何条件。这是一个基本的重试修饰器，可以应用于任何引发异常的函数。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mh mi l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">简单重试</figcaption></figure><h2 id="a364" class="ll jp hi bd jq lm ln lo ju lp lq lr jy kp ls lt ka kt lu lv kc kx lw lx ke ly bi translated">输出:</h2><pre class="iy iz ja jb fd lz lf ma mb aw mc bi"><span id="0ccf" class="ll jp hi lf b fi md me l mf mg"> Example for simple retry. Retrying forever...<br/> Example for simple retry. Retrying forever...<br/> Example for simple retry. Retrying forever...<br/> Example for simple retry. Retrying forever...<br/> Example for simple retry. Retrying forever...<br/> Example for simple retry. Retrying forever...<br/> Example for simple retry. Retrying forever...<br/> Example for simple retry. Retrying forever...<br/> Example for simple retry. Retrying forever...<br/> Example for simple retry. Retrying forever...<br/> Example for simple retry. Retrying forever...<br/> Example for simple retry. Retrying forever...<br/> Example for simple retry. Retrying forever...<br/> Example for simple retry. Retrying forever...<br/> Example for simple retry. Retrying forever...<br/> Example for simple retry. Retrying forever...<br/> Example for simple retry. Retrying forever...<br/> Example for simple retry. Retrying forever...<br/> Example for simple retry. Retrying forever...<br/> Example for simple retry. Retrying forever...<br/> Example for simple retry. Retrying forever...<br/> Example for simple retry. Retrying forever...<br/> Example for simple retry. Retrying forever...<br/> Example for simple retry. Retrying forever...<br/> Example for simple retry. Retrying forever...<br/> Example for simple retry. Retrying forever...<br/> Example for simple retry. Retrying forever...</span></pre><p id="4da7" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp li kr ks kt lj kv kw kx lk kz la lb hb bi translated">如果没有出现异常，就不会有重试，并且<code class="du lc ld le lf b">print</code>语句将只执行一次，你应该明白了。</p><h1 id="41b9" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">有条件重试:</h1><h2 id="2af0" class="ll jp hi bd jq lm ln lo ju lp lq lr jy kp ls lt ka kt lu lv kc kx lw lx ke ly bi translated">尝试后停止:</h2><p id="9386" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">现在我们已经看到了基本的重试，让我们尝试施加条件。在某些情况下，我们可能需要停止尝试某些条件。让我们尝试实现一个这样的条件。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mh mi l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">带停止的简单重试</figcaption></figure><h2 id="459e" class="ll jp hi bd jq lm ln lo ju lp lq lr jy kp ls lt ka kt lu lv kc kx lw lx ke ly bi translated">输出:</h2><pre class="iy iz ja jb fd lz lf ma mb aw mc bi"><span id="e104" class="ll jp hi lf b fi md me l mf mg"> Example for simple retry. Retrying forever...<br/> Example for simple retry. Retrying forever...<br/> Example for simple retry. Retrying forever...<br/> Example for simple retry. Retrying forever...<br/> Example for simple retry. Retrying forever...<br/>Traceback (most recent call last):<br/>  File "/Users/dkb/VirtualEnvs/practo-env/lib/python3.9/site-packages/tenacity/__init__.py", line 407, in __call__<br/>    result = fn(*args, **kwargs)<br/>  File "/Users/dkb/Code/practice/my_tenacity.py", line 7, in simple_retry<br/>    raise Exception('Raising exception after 5 retries...')<br/>Exception: Raising exception after 5 retries...<br/><br/>The above exception was the direct cause of the following exception:<br/><br/>Traceback (most recent call last):<br/>  File "/Users/dkb/Code/practice/my_tenacity.py", line 10, in &lt;module&gt;<br/>    simple_retry()<br/>  File "/Users/dkb/VirtualEnvs/practo-env/lib/python3.9/site-packages/tenacity/__init__.py", line 324, in wrapped_f<br/>    return self(f, *args, **kw)<br/>  File "/Users/dkb/VirtualEnvs/practo-env/lib/python3.9/site-packages/tenacity/__init__.py", line 404, in __call__<br/>    do = self.iter(retry_state=retry_state)<br/>  File "/Users/dkb/VirtualEnvs/practo-env/lib/python3.9/site-packages/tenacity/__init__.py", line 361, in iter<br/>    raise retry_exc from fut.exception()<br/>tenacity.RetryError: RetryError[&lt;Future at 0x100d64c40 state=finished raised Exception&gt;]</span></pre><h2 id="0a10" class="ll jp hi bd jq lm ln lo ju lp lq lr jy kp ls lt ka kt lu lv kc kx lw lx ke ly bi translated">延迟后停止:</h2><p id="0ea7" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">这将尝试，直到我们提供的时间。例如，如果你想尝试10秒钟，然后停止，这是你应该选择的方法。</p><p id="2a94" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp li kr ks kt lj kv kw kx lk kz la lb hb bi translated">在下面的代码中，<a class="ae jn" href="http://httpbin.org/" rel="noopener ugc nofollow" target="_blank">httpbin.org</a>是一个测试HTTP服务器。您可以选择任何其他HTTP服务器进行测试，或者托管您自己的服务器。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mh mi l"/></div></figure><h2 id="0fa8" class="ll jp hi bd jq lm ln lo ju lp lq lr jy kp ls lt ka kt lu lv kc kx lw lx ke ly bi translated">输出:</h2><pre class="iy iz ja jb fd lz lf ma mb aw mc bi"><span id="dbbe" class="ll jp hi lf b fi md me l mf mg">401<br/>401<br/>401<br/>401<br/>401<br/>401<br/>401<br/>401<br/>401<br/>401<br/>401<br/>401<br/>401<br/>401<br/>401<br/>401<br/>Traceback (most recent call last):<br/>  File "/Users/dkb/VirtualEnvs/practo-env/lib/python3.9/site-packages/tenacity/__init__.py", line 407, in __call__<br/>    result = fn(*args, **kwargs)<br/>  File "/Users/dkb/Code/practice/my_tenacity.py", line 21, in authenticate_user<br/>    response.raise_for_status()<br/>  File "/Users/dkb/VirtualEnvs/practo-env/lib/python3.9/site-packages/requests/models.py", line 953, in raise_for_status<br/>    raise HTTPError(http_error_msg, response=self)<br/>requests.exceptions.HTTPError: 401 Client Error: UNAUTHORIZED for url: http://httpbin.org/basic-auth/user/password</span></pre><p id="4e8c" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp li kr ks kt lj kv kw kx lk kz la lb hb bi translated">在上面的代码中，我们重试auth机制十秒钟，然后出错。您总是可以通过封装在一个<code class="du lc ld le lf b">try/except</code>块中来捕捉这些异常，以增加更多的优雅。</p><h2 id="ec8b" class="ll jp hi bd jq lm ln lo ju lp lq lr jy kp ls lt ka kt lu lv kc kx lw lx ke ly bi translated">组合停止条件:</h2><p id="1f57" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">偶尔，服务器需要一段时间来响应，而大多数时候他们可能会很快响应。在某些情况下，您可能还必须量化重试的次数。在这些场景中，你可以结合<code class="du lc ld le lf b">stop_after_delay</code>和<code class="du lc ld le lf b">stop_after_attempt</code>两个条件。</p><p id="45e4" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp li kr ks kt lj kv kw kx lk kz la lb hb bi translated">这里，无论哪个条件首先满足，重试都会停止。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mh mi l"/></div></figure><h2 id="3c45" class="ll jp hi bd jq lm ln lo ju lp lq lr jy kp ls lt ka kt lu lv kc kx lw lx ke ly bi translated">输出:</h2><pre class="iy iz ja jb fd lz lf ma mb aw mc bi"><span id="11ae" class="ll jp hi lf b fi md me l mf mg">401<br/>401<br/>401<br/>401<br/>401<br/>RetryError[&lt;Future at 0x110914c40 state=finished raised HTTPError&gt;]</span></pre><h1 id="20f9" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">实施指数回退:</h1><p id="a400" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">大多数后端服务器限制每秒向服务发出的请求数。在这些情况下，您可能会遇到限制异常或超过最大请求数错误。在这些场景中，我们可能需要抑制我们的请求，以降低对服务器的请求率。</p><blockquote class="mj mk ml"><p id="fc81" class="kg kh mm ki b kj lg ij kl km lh im ko mn li kr ks mo lj kv kw mp lk kz la lb hb bi translated">如果你有兴趣了解如何解决<code class="du lc ld le lf b">aws</code>中的节流异常，请阅读<a class="ae jn" href="https://dock2learn.com/tech/throttling-exceptions-in-aws-and-ways-to-resolve-them/" rel="noopener ugc nofollow" target="_blank">这篇</a>帖子。</p></blockquote><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mh mi l"/></div></figure><h2 id="1daa" class="ll jp hi bd jq lm ln lo ju lp lq lr jy kp ls lt ka kt lu lv kc kx lw lx ke ly bi translated">输出:</h2><pre class="iy iz ja jb fd lz lf ma mb aw mc bi"><span id="e94f" class="ll jp hi lf b fi md me l mf mg">401 2022-06-28 11:54:40.414397<br/>401 2022-06-28 11:54:43.054521<br/>401 2022-06-28 11:54:45.614282<br/>401 2022-06-28 11:54:48.176247<br/>401 2022-06-28 11:54:50.648000<br/>RetryError[&lt;Future at 0x110f7fd30 state=finished raised HTTPError&gt;]</span></pre><p id="d372" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp li kr ks kt lj kv kw kx lk kz la lb hb bi translated">这里，我们在尝试重试之前等待2秒钟，然后重试5次。重试的次数可以改变，如果你想重试，直到你成功。这样，您可以在<code class="du lc ld le lf b">retry</code>装饰器中混合匹配<code class="du lc ld le lf b">stop</code>和<code class="du lc ld le lf b">wait</code>参数。</p><h1 id="b023" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">针对特定异常重试:</h1><p id="3473" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">顾名思义，我们可以重试特定的错误消息，如<code class="du lc ld le lf b">HTTP errors</code>、<code class="du lc ld le lf b">ValueError</code>、<code class="du lc ld le lf b">TypeError</code>或任何自定义异常。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mh mi l"/></div></figure><p id="23a7" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp li kr ks kt lj kv kw kx lk kz la lb hb bi translated">此代码将仅在HTTPErrors的情况下重试。如此优雅。不是吗？类似地，如果异常不是特定的类型，我们也可以使用<code class="du lc ld le lf b">retry_if_not_exception_type()</code>。</p><h1 id="0d4b" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">基于返回值的重试和显式重试:</h1><p id="a916" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">可以将函数编程为基于返回值重试。例如，当一个函数返回<code class="du lc ld le lf b">None</code>时。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mh mi l"/></div></figure><h2 id="06e5" class="ll jp hi bd jq lm ln lo ju lp lq lr jy kp ls lt ka kt lu lv kc kx lw lx ke ly bi translated">输出:</h2><pre class="iy iz ja jb fd lz lf ma mb aw mc bi"><span id="fbd7" class="ll jp hi lf b fi md me l mf mg"> Retrying . . .: None<br/> Retrying . . .: None<br/> Retrying . . .: None<br/> Retrying . . .: None<br/> Retrying . . .: None<br/> Retrying . . .: None<br/> Retrying . . .: None<br/> Retrying . . .: None<br/> Retrying . . .: None</span></pre><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mh mi l"/></div></figure><p id="67c2" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp li kr ks kt lj kv kw kx lk kz la lb hb bi translated">当您使用<code class="du lc ld le lf b">TryAgain</code>异常得到401错误时，上面的代码会重试。我没有为此提供输出，因为到现在为止，您已经掌握了它的窍门。</p><h1 id="56c0" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">统计数据:</h1><p id="d413" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">使用<code class="du lc ld le lf b">statistics</code>属性可以获得用<code class="du lc ld le lf b">retry</code>修饰的函数的统计数据。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mh mi l"/></div></figure><h2 id="0e8e" class="ll jp hi bd jq lm ln lo ju lp lq lr jy kp ls lt ka kt lu lv kc kx lw lx ke ly bi translated">输出:</h2><pre class="iy iz ja jb fd lz lf ma mb aw mc bi"><span id="fbb1" class="ll jp hi lf b fi md me l mf mg"> Retrying using explicit retry . . .<br/> Retrying using explicit retry . . .<br/> Retrying using explicit retry . . .<br/> Retrying using explicit retry . . .<br/> Retrying using explicit retry . . .<br/>{'start_time': 0.227001672, 'attempt_number': 5, 'idle_for': 0, 'delay_since_first_attempt': 2.319967352}</span></pre><p id="9af9" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp li kr ks kt lj kv kw kx lk kz la lb hb bi translated">统计数据以字典的形式打印出来，包括开始时间、尝试次数等。</p><h1 id="f54e" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">自定义回调:</h1><p id="304f" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">这个选项是我个人最喜欢的。这正是让<code class="du lc ld le lf b">tenacity</code>成为开发者的乐趣所在。您可以添加一个回调机制，在我们用完重试次数后调用，或者更准确地说，在执行完<code class="du lc ld le lf b">retry</code>装饰器后调用。</p><p id="7544" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp li kr ks kt lj kv kw kx lk kz la lb hb bi translated">这将避免引发异常。如果您想要引发自定义异常而不是<code class="du lc ld le lf b">RetryError</code>，这可能会派上用场。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mh mi l"/></div></figure><h2 id="bc68" class="ll jp hi bd jq lm ln lo ju lp lq lr jy kp ls lt ka kt lu lv kc kx lw lx ke ly bi translated">输出:</h2><pre class="iy iz ja jb fd lz lf ma mb aw mc bi"><span id="35d8" class="ll jp hi lf b fi md me l mf mg"> Retrying using explicit retry . . .<br/> Retrying using explicit retry . . .<br/> Retrying using explicit retry . . .<br/> Retrying using explicit retry . . .<br/> Retrying using explicit retry . . .<br/> Maximum number of retries exceeded. &lt;RetryCallState 4340277104: attempt #5; slept for 0.0; last result: failed (HTTPError 401 Client Error: UNAUTHORIZED for url: http://httpbin.org/basic-auth/user/password)&gt; <br/>{'start_time': 0.196902178, 'attempt_number': 5, 'idle_for': 0, 'delay_since_first_attempt': 3.0087615750000003}</span></pre><p id="44b9" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp li kr ks kt lj kv kw kx lk kz la lb hb bi translated">整洁吗？。这里的<code class="du lc ld le lf b">get_response()</code>是一个回调函数，它接受一个具有当前<code class="du lc ld le lf b">retry</code>所有属性的<code class="du lc ld le lf b">retry_state</code>参数。</p><h1 id="f6d6" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">总结:</h1><p id="4cb9" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">在我看来，tenacity将很快成为重试的同义词库，因为重试不再被维护。话虽如此，我们也将<code class="du lc ld le lf b">retry</code>作为python标准库的一部分。然而，我不确定我们是否有像<code class="du lc ld le lf b">tenacity</code>中那样多的参数。除了上面提到的功能，<code class="du lc ld le lf b">tenacity</code>还提供</p><p id="b320" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp li kr ks kt lj kv kw kx lk kz la lb hb bi translated">欲了解更多信息，请参考参考文献部分提供的文档。</p><p id="da0b" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp li kr ks kt lj kv kw kx lk kz la lb hb bi translated">下次如果你正在为你的代码实现一个<code class="du lc ld le lf b">retry</code>,我建议你试试tenacity。</p><h1 id="d24c" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">参考资料:</h1><ul class=""><li id="186d" class="mq mr hi ki b kj kk km kn kp ms kt mt kx mu lb mv mw mx my bi translated"><a class="ae jn" href="https://tenacity.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank">https://tenacity.readthedocs.io/en/latest/</a></li><li id="872e" class="mq mr hi ki b kj mz km na kp nb kt nc kx nd lb mv mw mx my bi translated"><a class="ae jn" href="https://pypi.org/project/tenacity/" rel="noopener ugc nofollow" target="_blank">https://pypi.org/project/tenacity/</a></li></ul></div><div class="ab cl ne nf gp ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="hb hc hd he hf"><p id="4e57" class="pw-post-body-paragraph kg kh hi ki b kj lg ij kl km lh im ko kp li kr ks kt lj kv kw kx lk kz la lb hb bi translated"><em class="mm">原载于2022年6月29日https://dock2learn.com</em><a class="ae jn" href="https://dock2learn.com/tech/implement-retries-using-tenacity-in-python/" rel="noopener ugc nofollow" target="_blank"><em class="mm"/></a><em class="mm">。</em></p></div></div>    
</body>
</html>